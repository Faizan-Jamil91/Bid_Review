"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/chart.js";
exports.ids = ["vendor-chunks/chart.js"];
exports.modules = {

/***/ "(ssr)/./node_modules/chart.js/dist/chart.js":
/*!*********************************************!*\
  !*** ./node_modules/chart.js/dist/chart.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Animation: () => (/* binding */ Animation),\n/* harmony export */   Animations: () => (/* binding */ Animations),\n/* harmony export */   ArcElement: () => (/* binding */ ArcElement),\n/* harmony export */   BarController: () => (/* binding */ BarController),\n/* harmony export */   BarElement: () => (/* binding */ BarElement),\n/* harmony export */   BasePlatform: () => (/* binding */ BasePlatform),\n/* harmony export */   BasicPlatform: () => (/* binding */ BasicPlatform),\n/* harmony export */   BubbleController: () => (/* binding */ BubbleController),\n/* harmony export */   CategoryScale: () => (/* binding */ CategoryScale),\n/* harmony export */   Chart: () => (/* binding */ Chart),\n/* harmony export */   Colors: () => (/* binding */ plugin_colors),\n/* harmony export */   DatasetController: () => (/* binding */ DatasetController),\n/* harmony export */   Decimation: () => (/* binding */ plugin_decimation),\n/* harmony export */   DomPlatform: () => (/* binding */ DomPlatform),\n/* harmony export */   DoughnutController: () => (/* binding */ DoughnutController),\n/* harmony export */   Element: () => (/* binding */ Element),\n/* harmony export */   Filler: () => (/* binding */ index),\n/* harmony export */   Interaction: () => (/* binding */ Interaction),\n/* harmony export */   Legend: () => (/* binding */ plugin_legend),\n/* harmony export */   LineController: () => (/* binding */ LineController),\n/* harmony export */   LineElement: () => (/* binding */ LineElement),\n/* harmony export */   LinearScale: () => (/* binding */ LinearScale),\n/* harmony export */   LogarithmicScale: () => (/* binding */ LogarithmicScale),\n/* harmony export */   PieController: () => (/* binding */ PieController),\n/* harmony export */   PointElement: () => (/* binding */ PointElement),\n/* harmony export */   PolarAreaController: () => (/* binding */ PolarAreaController),\n/* harmony export */   RadarController: () => (/* binding */ RadarController),\n/* harmony export */   RadialLinearScale: () => (/* binding */ RadialLinearScale),\n/* harmony export */   Scale: () => (/* binding */ Scale),\n/* harmony export */   ScatterController: () => (/* binding */ ScatterController),\n/* harmony export */   SubTitle: () => (/* binding */ plugin_subtitle),\n/* harmony export */   Ticks: () => (/* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aM),\n/* harmony export */   TimeScale: () => (/* binding */ TimeScale),\n/* harmony export */   TimeSeriesScale: () => (/* binding */ TimeSeriesScale),\n/* harmony export */   Title: () => (/* binding */ plugin_title),\n/* harmony export */   Tooltip: () => (/* binding */ plugin_tooltip),\n/* harmony export */   _adapters: () => (/* binding */ adapters),\n/* harmony export */   _detectPlatform: () => (/* binding */ _detectPlatform),\n/* harmony export */   animator: () => (/* binding */ animator),\n/* harmony export */   controllers: () => (/* binding */ controllers),\n/* harmony export */   defaults: () => (/* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d),\n/* harmony export */   elements: () => (/* binding */ elements),\n/* harmony export */   layouts: () => (/* binding */ layouts),\n/* harmony export */   plugins: () => (/* binding */ plugins),\n/* harmony export */   registerables: () => (/* binding */ registerables),\n/* harmony export */   registry: () => (/* binding */ registry),\n/* harmony export */   scales: () => (/* binding */ scales)\n/* harmony export */ });\n/* harmony import */ var _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunks/helpers.dataset.js */ \"(ssr)/./node_modules/chart.js/dist/chunks/helpers.dataset.js\");\n/*!\n * Chart.js v4.5.1\n * https://www.chartjs.org\n * (c) 2025 Chart.js Contributors\n * Released under the MIT License\n */ \n\nclass Animator {\n    constructor(){\n        this._request = null;\n        this._charts = new Map();\n        this._running = false;\n        this._lastDate = undefined;\n    }\n    _notify(chart, anims, date, type) {\n        const callbacks = anims.listeners[type];\n        const numSteps = anims.duration;\n        callbacks.forEach((fn)=>fn({\n                chart,\n                initial: anims.initial,\n                numSteps,\n                currentStep: Math.min(date - anims.start, numSteps)\n            }));\n    }\n    _refresh() {\n        if (this._request) {\n            return;\n        }\n        this._running = true;\n        this._request = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.r.call(window, ()=>{\n            this._update();\n            this._request = null;\n            if (this._running) {\n                this._refresh();\n            }\n        });\n    }\n    _update(date = Date.now()) {\n        let remaining = 0;\n        this._charts.forEach((anims, chart)=>{\n            if (!anims.running || !anims.items.length) {\n                return;\n            }\n            const items = anims.items;\n            let i = items.length - 1;\n            let draw = false;\n            let item;\n            for(; i >= 0; --i){\n                item = items[i];\n                if (item._active) {\n                    if (item._total > anims.duration) {\n                        anims.duration = item._total;\n                    }\n                    item.tick(date);\n                    draw = true;\n                } else {\n                    items[i] = items[items.length - 1];\n                    items.pop();\n                }\n            }\n            if (draw) {\n                chart.draw();\n                this._notify(chart, anims, date, 'progress');\n            }\n            if (!items.length) {\n                anims.running = false;\n                this._notify(chart, anims, date, 'complete');\n                anims.initial = false;\n            }\n            remaining += items.length;\n        });\n        this._lastDate = date;\n        if (remaining === 0) {\n            this._running = false;\n        }\n    }\n    _getAnims(chart) {\n        const charts = this._charts;\n        let anims = charts.get(chart);\n        if (!anims) {\n            anims = {\n                running: false,\n                initial: true,\n                items: [],\n                listeners: {\n                    complete: [],\n                    progress: []\n                }\n            };\n            charts.set(chart, anims);\n        }\n        return anims;\n    }\n    listen(chart, event, cb) {\n        this._getAnims(chart).listeners[event].push(cb);\n    }\n    add(chart, items) {\n        if (!items || !items.length) {\n            return;\n        }\n        this._getAnims(chart).items.push(...items);\n    }\n    has(chart) {\n        return this._getAnims(chart).items.length > 0;\n    }\n    start(chart) {\n        const anims = this._charts.get(chart);\n        if (!anims) {\n            return;\n        }\n        anims.running = true;\n        anims.start = Date.now();\n        anims.duration = anims.items.reduce((acc, cur)=>Math.max(acc, cur._duration), 0);\n        this._refresh();\n    }\n    running(chart) {\n        if (!this._running) {\n            return false;\n        }\n        const anims = this._charts.get(chart);\n        if (!anims || !anims.running || !anims.items.length) {\n            return false;\n        }\n        return true;\n    }\n    stop(chart) {\n        const anims = this._charts.get(chart);\n        if (!anims || !anims.items.length) {\n            return;\n        }\n        const items = anims.items;\n        let i = items.length - 1;\n        for(; i >= 0; --i){\n            items[i].cancel();\n        }\n        anims.items = [];\n        this._notify(chart, anims, Date.now(), 'complete');\n    }\n    remove(chart) {\n        return this._charts.delete(chart);\n    }\n}\nvar animator = /* #__PURE__ */ new Animator();\nconst transparent = 'transparent';\nconst interpolators = {\n    boolean (from, to, factor) {\n        return factor > 0.5 ? to : from;\n    },\n    color (from, to, factor) {\n        const c0 = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.c)(from || transparent);\n        const c1 = c0.valid && (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.c)(to || transparent);\n        return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to;\n    },\n    number (from, to, factor) {\n        return from + (to - from) * factor;\n    }\n};\nclass Animation {\n    constructor(cfg, target, prop, to){\n        const currentValue = target[prop];\n        to = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a)([\n            cfg.to,\n            to,\n            currentValue,\n            cfg.from\n        ]);\n        const from = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a)([\n            cfg.from,\n            currentValue,\n            to\n        ]);\n        this._active = true;\n        this._fn = cfg.fn || interpolators[cfg.type || typeof from];\n        this._easing = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.e[cfg.easing] || _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.e.linear;\n        this._start = Math.floor(Date.now() + (cfg.delay || 0));\n        this._duration = this._total = Math.floor(cfg.duration);\n        this._loop = !!cfg.loop;\n        this._target = target;\n        this._prop = prop;\n        this._from = from;\n        this._to = to;\n        this._promises = undefined;\n    }\n    active() {\n        return this._active;\n    }\n    update(cfg, to, date) {\n        if (this._active) {\n            this._notify(false);\n            const currentValue = this._target[this._prop];\n            const elapsed = date - this._start;\n            const remain = this._duration - elapsed;\n            this._start = date;\n            this._duration = Math.floor(Math.max(remain, cfg.duration));\n            this._total += elapsed;\n            this._loop = !!cfg.loop;\n            this._to = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a)([\n                cfg.to,\n                to,\n                currentValue,\n                cfg.from\n            ]);\n            this._from = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a)([\n                cfg.from,\n                currentValue,\n                to\n            ]);\n        }\n    }\n    cancel() {\n        if (this._active) {\n            this.tick(Date.now());\n            this._active = false;\n            this._notify(false);\n        }\n    }\n    tick(date) {\n        const elapsed = date - this._start;\n        const duration = this._duration;\n        const prop = this._prop;\n        const from = this._from;\n        const loop = this._loop;\n        const to = this._to;\n        let factor;\n        this._active = from !== to && (loop || elapsed < duration);\n        if (!this._active) {\n            this._target[prop] = to;\n            this._notify(true);\n            return;\n        }\n        if (elapsed < 0) {\n            this._target[prop] = from;\n            return;\n        }\n        factor = elapsed / duration % 2;\n        factor = loop && factor > 1 ? 2 - factor : factor;\n        factor = this._easing(Math.min(1, Math.max(0, factor)));\n        this._target[prop] = this._fn(from, to, factor);\n    }\n    wait() {\n        const promises = this._promises || (this._promises = []);\n        return new Promise((res, rej)=>{\n            promises.push({\n                res,\n                rej\n            });\n        });\n    }\n    _notify(resolved) {\n        const method = resolved ? 'res' : 'rej';\n        const promises = this._promises || [];\n        for(let i = 0; i < promises.length; i++){\n            promises[i][method]();\n        }\n    }\n}\nclass Animations {\n    constructor(chart, config){\n        this._chart = chart;\n        this._properties = new Map();\n        this.configure(config);\n    }\n    configure(config) {\n        if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(config)) {\n            return;\n        }\n        const animationOptions = Object.keys(_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.animation);\n        const animatedProps = this._properties;\n        Object.getOwnPropertyNames(config).forEach((key)=>{\n            const cfg = config[key];\n            if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(cfg)) {\n                return;\n            }\n            const resolved = {};\n            for (const option of animationOptions){\n                resolved[option] = cfg[option];\n            }\n            ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(cfg.properties) && cfg.properties || [\n                key\n            ]).forEach((prop)=>{\n                if (prop === key || !animatedProps.has(prop)) {\n                    animatedProps.set(prop, resolved);\n                }\n            });\n        });\n    }\n    _animateOptions(target, values) {\n        const newOptions = values.options;\n        const options = resolveTargetOptions(target, newOptions);\n        if (!options) {\n            return [];\n        }\n        const animations = this._createAnimations(options, newOptions);\n        if (newOptions.$shared) {\n            awaitAll(target.options.$animations, newOptions).then(()=>{\n                target.options = newOptions;\n            }, ()=>{});\n        }\n        return animations;\n    }\n    _createAnimations(target, values) {\n        const animatedProps = this._properties;\n        const animations = [];\n        const running = target.$animations || (target.$animations = {});\n        const props = Object.keys(values);\n        const date = Date.now();\n        let i;\n        for(i = props.length - 1; i >= 0; --i){\n            const prop = props[i];\n            if (prop.charAt(0) === '$') {\n                continue;\n            }\n            if (prop === 'options') {\n                animations.push(...this._animateOptions(target, values));\n                continue;\n            }\n            const value = values[prop];\n            let animation = running[prop];\n            const cfg = animatedProps.get(prop);\n            if (animation) {\n                if (cfg && animation.active()) {\n                    animation.update(cfg, value, date);\n                    continue;\n                } else {\n                    animation.cancel();\n                }\n            }\n            if (!cfg || !cfg.duration) {\n                target[prop] = value;\n                continue;\n            }\n            running[prop] = animation = new Animation(cfg, target, prop, value);\n            animations.push(animation);\n        }\n        return animations;\n    }\n    update(target, values) {\n        if (this._properties.size === 0) {\n            Object.assign(target, values);\n            return;\n        }\n        const animations = this._createAnimations(target, values);\n        if (animations.length) {\n            animator.add(this._chart, animations);\n            return true;\n        }\n    }\n}\nfunction awaitAll(animations, properties) {\n    const running = [];\n    const keys = Object.keys(properties);\n    for(let i = 0; i < keys.length; i++){\n        const anim = animations[keys[i]];\n        if (anim && anim.active()) {\n            running.push(anim.wait());\n        }\n    }\n    return Promise.all(running);\n}\nfunction resolveTargetOptions(target, newOptions) {\n    if (!newOptions) {\n        return;\n    }\n    let options = target.options;\n    if (!options) {\n        target.options = newOptions;\n        return;\n    }\n    if (options.$shared) {\n        target.options = options = Object.assign({}, options, {\n            $shared: false,\n            $animations: {}\n        });\n    }\n    return options;\n}\nfunction scaleClip(scale, allowedOverflow) {\n    const opts = scale && scale.options || {};\n    const reverse = opts.reverse;\n    const min = opts.min === undefined ? allowedOverflow : 0;\n    const max = opts.max === undefined ? allowedOverflow : 0;\n    return {\n        start: reverse ? max : min,\n        end: reverse ? min : max\n    };\n}\nfunction defaultClip(xScale, yScale, allowedOverflow) {\n    if (allowedOverflow === false) {\n        return false;\n    }\n    const x = scaleClip(xScale, allowedOverflow);\n    const y = scaleClip(yScale, allowedOverflow);\n    return {\n        top: y.end,\n        right: x.end,\n        bottom: y.start,\n        left: x.start\n    };\n}\nfunction toClip(value) {\n    let t, r, b, l;\n    if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(value)) {\n        t = value.top;\n        r = value.right;\n        b = value.bottom;\n        l = value.left;\n    } else {\n        t = r = b = l = value;\n    }\n    return {\n        top: t,\n        right: r,\n        bottom: b,\n        left: l,\n        disabled: value === false\n    };\n}\nfunction getSortedDatasetIndices(chart, filterVisible) {\n    const keys = [];\n    const metasets = chart._getSortedDatasetMetas(filterVisible);\n    let i, ilen;\n    for(i = 0, ilen = metasets.length; i < ilen; ++i){\n        keys.push(metasets[i].index);\n    }\n    return keys;\n}\nfunction applyStack(stack, value, dsIndex, options = {}) {\n    const keys = stack.keys;\n    const singleMode = options.mode === 'single';\n    let i, ilen, datasetIndex, otherValue;\n    if (value === null) {\n        return;\n    }\n    let found = false;\n    for(i = 0, ilen = keys.length; i < ilen; ++i){\n        datasetIndex = +keys[i];\n        if (datasetIndex === dsIndex) {\n            found = true;\n            if (options.all) {\n                continue;\n            }\n            break;\n        }\n        otherValue = stack.values[datasetIndex];\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(otherValue) && (singleMode || value === 0 || (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.s)(value) === (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.s)(otherValue))) {\n            value += otherValue;\n        }\n    }\n    if (!found && !options.all) {\n        return 0;\n    }\n    return value;\n}\nfunction convertObjectDataToArray(data, meta) {\n    const { iScale, vScale } = meta;\n    const iAxisKey = iScale.axis === 'x' ? 'x' : 'y';\n    const vAxisKey = vScale.axis === 'x' ? 'x' : 'y';\n    const keys = Object.keys(data);\n    const adata = new Array(keys.length);\n    let i, ilen, key;\n    for(i = 0, ilen = keys.length; i < ilen; ++i){\n        key = keys[i];\n        adata[i] = {\n            [iAxisKey]: key,\n            [vAxisKey]: data[key]\n        };\n    }\n    return adata;\n}\nfunction isStacked(scale, meta) {\n    const stacked = scale && scale.options.stacked;\n    return stacked || stacked === undefined && meta.stack !== undefined;\n}\nfunction getStackKey(indexScale, valueScale, meta) {\n    return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;\n}\nfunction getUserBounds(scale) {\n    const { min, max, minDefined, maxDefined } = scale.getUserBounds();\n    return {\n        min: minDefined ? min : Number.NEGATIVE_INFINITY,\n        max: maxDefined ? max : Number.POSITIVE_INFINITY\n    };\n}\nfunction getOrCreateStack(stacks, stackKey, indexValue) {\n    const subStack = stacks[stackKey] || (stacks[stackKey] = {});\n    return subStack[indexValue] || (subStack[indexValue] = {});\n}\nfunction getLastIndexInStack(stack, vScale, positive, type) {\n    for (const meta of vScale.getMatchingVisibleMetas(type).reverse()){\n        const value = stack[meta.index];\n        if (positive && value > 0 || !positive && value < 0) {\n            return meta.index;\n        }\n    }\n    return null;\n}\nfunction updateStacks(controller, parsed) {\n    const { chart, _cachedMeta: meta } = controller;\n    const stacks = chart._stacks || (chart._stacks = {});\n    const { iScale, vScale, index: datasetIndex } = meta;\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const key = getStackKey(iScale, vScale, meta);\n    const ilen = parsed.length;\n    let stack;\n    for(let i = 0; i < ilen; ++i){\n        const item = parsed[i];\n        const { [iAxis]: index, [vAxis]: value } = item;\n        const itemStacks = item._stacks || (item._stacks = {});\n        stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);\n        stack[datasetIndex] = value;\n        stack._top = getLastIndexInStack(stack, vScale, true, meta.type);\n        stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);\n        const visualValues = stack._visualValues || (stack._visualValues = {});\n        visualValues[datasetIndex] = value;\n    }\n}\nfunction getFirstScaleId(chart, axis) {\n    const scales = chart.scales;\n    return Object.keys(scales).filter((key)=>scales[key].axis === axis).shift();\n}\nfunction createDatasetContext(parent, index) {\n    return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.j)(parent, {\n        active: false,\n        dataset: undefined,\n        datasetIndex: index,\n        index,\n        mode: 'default',\n        type: 'dataset'\n    });\n}\nfunction createDataContext(parent, index, element) {\n    return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.j)(parent, {\n        active: false,\n        dataIndex: index,\n        parsed: undefined,\n        raw: undefined,\n        element,\n        index,\n        mode: 'default',\n        type: 'data'\n    });\n}\nfunction clearStacks(meta, items) {\n    const datasetIndex = meta.controller.index;\n    const axis = meta.vScale && meta.vScale.axis;\n    if (!axis) {\n        return;\n    }\n    items = items || meta._parsed;\n    for (const parsed of items){\n        const stacks = parsed._stacks;\n        if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {\n            return;\n        }\n        delete stacks[axis][datasetIndex];\n        if (stacks[axis]._visualValues !== undefined && stacks[axis]._visualValues[datasetIndex] !== undefined) {\n            delete stacks[axis]._visualValues[datasetIndex];\n        }\n    }\n}\nconst isDirectUpdateMode = (mode)=>mode === 'reset' || mode === 'none';\nconst cloneIfNotShared = (cached, shared)=>shared ? cached : Object.assign({}, cached);\nconst createStack = (canStack, meta, chart)=>canStack && !meta.hidden && meta._stacked && {\n        keys: getSortedDatasetIndices(chart, true),\n        values: null\n    };\nclass DatasetController {\n    static{\n        this.defaults = {};\n    }\n    static{\n        this.datasetElementType = null;\n    }\n    static{\n        this.dataElementType = null;\n    }\n    constructor(chart, datasetIndex){\n        this.chart = chart;\n        this._ctx = chart.ctx;\n        this.index = datasetIndex;\n        this._cachedDataOpts = {};\n        this._cachedMeta = this.getMeta();\n        this._type = this._cachedMeta.type;\n        this.options = undefined;\n        this._parsing = false;\n        this._data = undefined;\n        this._objectData = undefined;\n        this._sharedOptions = undefined;\n        this._drawStart = undefined;\n        this._drawCount = undefined;\n        this.enableOptionSharing = false;\n        this.supportsDecimation = false;\n        this.$context = undefined;\n        this._syncList = [];\n        this.datasetElementType = new.target.datasetElementType;\n        this.dataElementType = new.target.dataElementType;\n        this.initialize();\n    }\n    initialize() {\n        const meta = this._cachedMeta;\n        this.configure();\n        this.linkScales();\n        meta._stacked = isStacked(meta.vScale, meta);\n        this.addElements();\n        if (this.options.fill && !this.chart.isPluginEnabled('filler')) {\n            console.warn(\"Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options\");\n        }\n    }\n    updateIndex(datasetIndex) {\n        if (this.index !== datasetIndex) {\n            clearStacks(this._cachedMeta);\n        }\n        this.index = datasetIndex;\n    }\n    linkScales() {\n        const chart = this.chart;\n        const meta = this._cachedMeta;\n        const dataset = this.getDataset();\n        const chooseId = (axis, x, y, r)=>axis === 'x' ? x : axis === 'r' ? r : y;\n        const xid = meta.xAxisID = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(dataset.xAxisID, getFirstScaleId(chart, 'x'));\n        const yid = meta.yAxisID = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(dataset.yAxisID, getFirstScaleId(chart, 'y'));\n        const rid = meta.rAxisID = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(dataset.rAxisID, getFirstScaleId(chart, 'r'));\n        const indexAxis = meta.indexAxis;\n        const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);\n        const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);\n        meta.xScale = this.getScaleForId(xid);\n        meta.yScale = this.getScaleForId(yid);\n        meta.rScale = this.getScaleForId(rid);\n        meta.iScale = this.getScaleForId(iid);\n        meta.vScale = this.getScaleForId(vid);\n    }\n    getDataset() {\n        return this.chart.data.datasets[this.index];\n    }\n    getMeta() {\n        return this.chart.getDatasetMeta(this.index);\n    }\n    getScaleForId(scaleID) {\n        return this.chart.scales[scaleID];\n    }\n    _getOtherScale(scale) {\n        const meta = this._cachedMeta;\n        return scale === meta.iScale ? meta.vScale : meta.iScale;\n    }\n    reset() {\n        this._update('reset');\n    }\n    _destroy() {\n        const meta = this._cachedMeta;\n        if (this._data) {\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.u)(this._data, this);\n        }\n        if (meta._stacked) {\n            clearStacks(meta);\n        }\n    }\n    _dataCheck() {\n        const dataset = this.getDataset();\n        const data = dataset.data || (dataset.data = []);\n        const _data = this._data;\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(data)) {\n            const meta = this._cachedMeta;\n            this._data = convertObjectDataToArray(data, meta);\n        } else if (_data !== data) {\n            if (_data) {\n                (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.u)(_data, this);\n                const meta = this._cachedMeta;\n                clearStacks(meta);\n                meta._parsed = [];\n            }\n            if (data && Object.isExtensible(data)) {\n                (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.l)(data, this);\n            }\n            this._syncList = [];\n            this._data = data;\n        }\n    }\n    addElements() {\n        const meta = this._cachedMeta;\n        this._dataCheck();\n        if (this.datasetElementType) {\n            meta.dataset = new this.datasetElementType();\n        }\n    }\n    buildOrUpdateElements(resetNewElements) {\n        const meta = this._cachedMeta;\n        const dataset = this.getDataset();\n        let stackChanged = false;\n        this._dataCheck();\n        const oldStacked = meta._stacked;\n        meta._stacked = isStacked(meta.vScale, meta);\n        if (meta.stack !== dataset.stack) {\n            stackChanged = true;\n            clearStacks(meta);\n            meta.stack = dataset.stack;\n        }\n        this._resyncElements(resetNewElements);\n        if (stackChanged || oldStacked !== meta._stacked) {\n            updateStacks(this, meta._parsed);\n            meta._stacked = isStacked(meta.vScale, meta);\n        }\n    }\n    configure() {\n        const config = this.chart.config;\n        const scopeKeys = config.datasetScopeKeys(this._type);\n        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);\n        this.options = config.createResolver(scopes, this.getContext());\n        this._parsing = this.options.parsing;\n        this._cachedDataOpts = {};\n    }\n    parse(start, count) {\n        const { _cachedMeta: meta, _data: data } = this;\n        const { iScale, _stacked } = meta;\n        const iAxis = iScale.axis;\n        let sorted = start === 0 && count === data.length ? true : meta._sorted;\n        let prev = start > 0 && meta._parsed[start - 1];\n        let i, cur, parsed;\n        if (this._parsing === false) {\n            meta._parsed = data;\n            meta._sorted = true;\n            parsed = data;\n        } else {\n            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(data[start])) {\n                parsed = this.parseArrayData(meta, data, start, count);\n            } else if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(data[start])) {\n                parsed = this.parseObjectData(meta, data, start, count);\n            } else {\n                parsed = this.parsePrimitiveData(meta, data, start, count);\n            }\n            const isNotInOrderComparedToPrev = ()=>cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];\n            for(i = 0; i < count; ++i){\n                meta._parsed[i + start] = cur = parsed[i];\n                if (sorted) {\n                    if (isNotInOrderComparedToPrev()) {\n                        sorted = false;\n                    }\n                    prev = cur;\n                }\n            }\n            meta._sorted = sorted;\n        }\n        if (_stacked) {\n            updateStacks(this, parsed);\n        }\n    }\n    parsePrimitiveData(meta, data, start, count) {\n        const { iScale, vScale } = meta;\n        const iAxis = iScale.axis;\n        const vAxis = vScale.axis;\n        const labels = iScale.getLabels();\n        const singleScale = iScale === vScale;\n        const parsed = new Array(count);\n        let i, ilen, index;\n        for(i = 0, ilen = count; i < ilen; ++i){\n            index = i + start;\n            parsed[i] = {\n                [iAxis]: singleScale || iScale.parse(labels[index], index),\n                [vAxis]: vScale.parse(data[index], index)\n            };\n        }\n        return parsed;\n    }\n    parseArrayData(meta, data, start, count) {\n        const { xScale, yScale } = meta;\n        const parsed = new Array(count);\n        let i, ilen, index, item;\n        for(i = 0, ilen = count; i < ilen; ++i){\n            index = i + start;\n            item = data[index];\n            parsed[i] = {\n                x: xScale.parse(item[0], index),\n                y: yScale.parse(item[1], index)\n            };\n        }\n        return parsed;\n    }\n    parseObjectData(meta, data, start, count) {\n        const { xScale, yScale } = meta;\n        const { xAxisKey = 'x', yAxisKey = 'y' } = this._parsing;\n        const parsed = new Array(count);\n        let i, ilen, index, item;\n        for(i = 0, ilen = count; i < ilen; ++i){\n            index = i + start;\n            item = data[index];\n            parsed[i] = {\n                x: xScale.parse((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.f)(item, xAxisKey), index),\n                y: yScale.parse((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.f)(item, yAxisKey), index)\n            };\n        }\n        return parsed;\n    }\n    getParsed(index) {\n        return this._cachedMeta._parsed[index];\n    }\n    getDataElement(index) {\n        return this._cachedMeta.data[index];\n    }\n    applyStack(scale, parsed, mode) {\n        const chart = this.chart;\n        const meta = this._cachedMeta;\n        const value = parsed[scale.axis];\n        const stack = {\n            keys: getSortedDatasetIndices(chart, true),\n            values: parsed._stacks[scale.axis]._visualValues\n        };\n        return applyStack(stack, value, meta.index, {\n            mode\n        });\n    }\n    updateRangeFromParsed(range, scale, parsed, stack) {\n        const parsedValue = parsed[scale.axis];\n        let value = parsedValue === null ? NaN : parsedValue;\n        const values = stack && parsed._stacks[scale.axis];\n        if (stack && values) {\n            stack.values = values;\n            value = applyStack(stack, parsedValue, this._cachedMeta.index);\n        }\n        range.min = Math.min(range.min, value);\n        range.max = Math.max(range.max, value);\n    }\n    getMinMax(scale, canStack) {\n        const meta = this._cachedMeta;\n        const _parsed = meta._parsed;\n        const sorted = meta._sorted && scale === meta.iScale;\n        const ilen = _parsed.length;\n        const otherScale = this._getOtherScale(scale);\n        const stack = createStack(canStack, meta, this.chart);\n        const range = {\n            min: Number.POSITIVE_INFINITY,\n            max: Number.NEGATIVE_INFINITY\n        };\n        const { min: otherMin, max: otherMax } = getUserBounds(otherScale);\n        let i, parsed;\n        function _skip() {\n            parsed = _parsed[i];\n            const otherValue = parsed[otherScale.axis];\n            return !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;\n        }\n        for(i = 0; i < ilen; ++i){\n            if (_skip()) {\n                continue;\n            }\n            this.updateRangeFromParsed(range, scale, parsed, stack);\n            if (sorted) {\n                break;\n            }\n        }\n        if (sorted) {\n            for(i = ilen - 1; i >= 0; --i){\n                if (_skip()) {\n                    continue;\n                }\n                this.updateRangeFromParsed(range, scale, parsed, stack);\n                break;\n            }\n        }\n        return range;\n    }\n    getAllParsedValues(scale) {\n        const parsed = this._cachedMeta._parsed;\n        const values = [];\n        let i, ilen, value;\n        for(i = 0, ilen = parsed.length; i < ilen; ++i){\n            value = parsed[i][scale.axis];\n            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(value)) {\n                values.push(value);\n            }\n        }\n        return values;\n    }\n    getMaxOverflow() {\n        return false;\n    }\n    getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const iScale = meta.iScale;\n        const vScale = meta.vScale;\n        const parsed = this.getParsed(index);\n        return {\n            label: iScale ? '' + iScale.getLabelForValue(parsed[iScale.axis]) : '',\n            value: vScale ? '' + vScale.getLabelForValue(parsed[vScale.axis]) : ''\n        };\n    }\n    _update(mode) {\n        const meta = this._cachedMeta;\n        this.update(mode || 'default');\n        meta._clip = toClip((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));\n    }\n    update(mode) {}\n    draw() {\n        const ctx = this._ctx;\n        const chart = this.chart;\n        const meta = this._cachedMeta;\n        const elements = meta.data || [];\n        const area = chart.chartArea;\n        const active = [];\n        const start = this._drawStart || 0;\n        const count = this._drawCount || elements.length - start;\n        const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;\n        let i;\n        if (meta.dataset) {\n            meta.dataset.draw(ctx, area, start, count);\n        }\n        for(i = start; i < start + count; ++i){\n            const element = elements[i];\n            if (element.hidden) {\n                continue;\n            }\n            if (element.active && drawActiveElementsOnTop) {\n                active.push(element);\n            } else {\n                element.draw(ctx, area);\n            }\n        }\n        for(i = 0; i < active.length; ++i){\n            active[i].draw(ctx, area);\n        }\n    }\n    getStyle(index, active) {\n        const mode = active ? 'active' : 'default';\n        return index === undefined && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index || 0, mode);\n    }\n    getContext(index, active, mode) {\n        const dataset = this.getDataset();\n        let context;\n        if (index >= 0 && index < this._cachedMeta.data.length) {\n            const element = this._cachedMeta.data[index];\n            context = element.$context || (element.$context = createDataContext(this.getContext(), index, element));\n            context.parsed = this.getParsed(index);\n            context.raw = dataset.data[index];\n            context.index = context.dataIndex = index;\n        } else {\n            context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));\n            context.dataset = dataset;\n            context.index = context.datasetIndex = this.index;\n        }\n        context.active = !!active;\n        context.mode = mode;\n        return context;\n    }\n    resolveDatasetElementOptions(mode) {\n        return this._resolveElementOptions(this.datasetElementType.id, mode);\n    }\n    resolveDataElementOptions(index, mode) {\n        return this._resolveElementOptions(this.dataElementType.id, mode, index);\n    }\n    _resolveElementOptions(elementType, mode = 'default', index) {\n        const active = mode === 'active';\n        const cache = this._cachedDataOpts;\n        const cacheKey = elementType + '-' + mode;\n        const cached = cache[cacheKey];\n        const sharing = this.enableOptionSharing && (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.h)(index);\n        if (cached) {\n            return cloneIfNotShared(cached, sharing);\n        }\n        const config = this.chart.config;\n        const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);\n        const prefixes = active ? [\n            `${elementType}Hover`,\n            'hover',\n            elementType,\n            ''\n        ] : [\n            elementType,\n            ''\n        ];\n        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n        const names = Object.keys(_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.elements[elementType]);\n        const context = ()=>this.getContext(index, active, mode);\n        const values = config.resolveNamedOptions(scopes, names, context, prefixes);\n        if (values.$shared) {\n            values.$shared = sharing;\n            cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));\n        }\n        return values;\n    }\n    _resolveAnimations(index, transition, active) {\n        const chart = this.chart;\n        const cache = this._cachedDataOpts;\n        const cacheKey = `animation-${transition}`;\n        const cached = cache[cacheKey];\n        if (cached) {\n            return cached;\n        }\n        let options;\n        if (chart.options.animation !== false) {\n            const config = this.chart.config;\n            const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);\n            const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n            options = config.createResolver(scopes, this.getContext(index, active, transition));\n        }\n        const animations = new Animations(chart, options && options.animations);\n        if (options && options._cacheable) {\n            cache[cacheKey] = Object.freeze(animations);\n        }\n        return animations;\n    }\n    getSharedOptions(options) {\n        if (!options.$shared) {\n            return;\n        }\n        return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));\n    }\n    includeOptions(mode, sharedOptions) {\n        return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;\n    }\n    _getSharedOptions(start, mode) {\n        const firstOpts = this.resolveDataElementOptions(start, mode);\n        const previouslySharedOptions = this._sharedOptions;\n        const sharedOptions = this.getSharedOptions(firstOpts);\n        const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;\n        this.updateSharedOptions(sharedOptions, mode, firstOpts);\n        return {\n            sharedOptions,\n            includeOptions\n        };\n    }\n    updateElement(element, index, properties, mode) {\n        if (isDirectUpdateMode(mode)) {\n            Object.assign(element, properties);\n        } else {\n            this._resolveAnimations(index, mode).update(element, properties);\n        }\n    }\n    updateSharedOptions(sharedOptions, mode, newOptions) {\n        if (sharedOptions && !isDirectUpdateMode(mode)) {\n            this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);\n        }\n    }\n    _setStyle(element, index, mode, active) {\n        element.active = active;\n        const options = this.getStyle(index, active);\n        this._resolveAnimations(index, mode, active).update(element, {\n            options: !active && this.getSharedOptions(options) || options\n        });\n    }\n    removeHoverStyle(element, datasetIndex, index) {\n        this._setStyle(element, index, 'active', false);\n    }\n    setHoverStyle(element, datasetIndex, index) {\n        this._setStyle(element, index, 'active', true);\n    }\n    _removeDatasetHoverStyle() {\n        const element = this._cachedMeta.dataset;\n        if (element) {\n            this._setStyle(element, undefined, 'active', false);\n        }\n    }\n    _setDatasetHoverStyle() {\n        const element = this._cachedMeta.dataset;\n        if (element) {\n            this._setStyle(element, undefined, 'active', true);\n        }\n    }\n    _resyncElements(resetNewElements) {\n        const data = this._data;\n        const elements = this._cachedMeta.data;\n        for (const [method, arg1, arg2] of this._syncList){\n            this[method](arg1, arg2);\n        }\n        this._syncList = [];\n        const numMeta = elements.length;\n        const numData = data.length;\n        const count = Math.min(numData, numMeta);\n        if (count) {\n            this.parse(0, count);\n        }\n        if (numData > numMeta) {\n            this._insertElements(numMeta, numData - numMeta, resetNewElements);\n        } else if (numData < numMeta) {\n            this._removeElements(numData, numMeta - numData);\n        }\n    }\n    _insertElements(start, count, resetNewElements = true) {\n        const meta = this._cachedMeta;\n        const data = meta.data;\n        const end = start + count;\n        let i;\n        const move = (arr)=>{\n            arr.length += count;\n            for(i = arr.length - 1; i >= end; i--){\n                arr[i] = arr[i - count];\n            }\n        };\n        move(data);\n        for(i = start; i < end; ++i){\n            data[i] = new this.dataElementType();\n        }\n        if (this._parsing) {\n            move(meta._parsed);\n        }\n        this.parse(start, count);\n        if (resetNewElements) {\n            this.updateElements(data, start, count, 'reset');\n        }\n    }\n    updateElements(element, start, count, mode) {}\n    _removeElements(start, count) {\n        const meta = this._cachedMeta;\n        if (this._parsing) {\n            const removed = meta._parsed.splice(start, count);\n            if (meta._stacked) {\n                clearStacks(meta, removed);\n            }\n        }\n        meta.data.splice(start, count);\n    }\n    _sync(args) {\n        if (this._parsing) {\n            this._syncList.push(args);\n        } else {\n            const [method, arg1, arg2] = args;\n            this[method](arg1, arg2);\n        }\n        this.chart._dataChanges.push([\n            this.index,\n            ...args\n        ]);\n    }\n    _onDataPush() {\n        const count = arguments.length;\n        this._sync([\n            '_insertElements',\n            this.getDataset().data.length - count,\n            count\n        ]);\n    }\n    _onDataPop() {\n        this._sync([\n            '_removeElements',\n            this._cachedMeta.data.length - 1,\n            1\n        ]);\n    }\n    _onDataShift() {\n        this._sync([\n            '_removeElements',\n            0,\n            1\n        ]);\n    }\n    _onDataSplice(start, count) {\n        if (count) {\n            this._sync([\n                '_removeElements',\n                start,\n                count\n            ]);\n        }\n        const newCount = arguments.length - 2;\n        if (newCount) {\n            this._sync([\n                '_insertElements',\n                start,\n                newCount\n            ]);\n        }\n    }\n    _onDataUnshift() {\n        this._sync([\n            '_insertElements',\n            0,\n            arguments.length\n        ]);\n    }\n}\nfunction getAllScaleValues(scale, type) {\n    if (!scale._cache.$bar) {\n        const visibleMetas = scale.getMatchingVisibleMetas(type);\n        let values = [];\n        for(let i = 0, ilen = visibleMetas.length; i < ilen; i++){\n            values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));\n        }\n        scale._cache.$bar = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__._)(values.sort((a, b)=>a - b));\n    }\n    return scale._cache.$bar;\n}\nfunction computeMinSampleSize(meta) {\n    const scale = meta.iScale;\n    const values = getAllScaleValues(scale, meta.type);\n    let min = scale._length;\n    let i, ilen, curr, prev;\n    const updateMinAndPrev = ()=>{\n        if (curr === 32767 || curr === -32768) {\n            return;\n        }\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.h)(prev)) {\n            min = Math.min(min, Math.abs(curr - prev) || min);\n        }\n        prev = curr;\n    };\n    for(i = 0, ilen = values.length; i < ilen; ++i){\n        curr = scale.getPixelForValue(values[i]);\n        updateMinAndPrev();\n    }\n    prev = undefined;\n    for(i = 0, ilen = scale.ticks.length; i < ilen; ++i){\n        curr = scale.getPixelForTick(i);\n        updateMinAndPrev();\n    }\n    return min;\n}\nfunction computeFitCategoryTraits(index, ruler, options, stackCount) {\n    const thickness = options.barThickness;\n    let size, ratio;\n    if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(thickness)) {\n        size = ruler.min * options.categoryPercentage;\n        ratio = options.barPercentage;\n    } else {\n        size = thickness * stackCount;\n        ratio = 1;\n    }\n    return {\n        chunk: size / stackCount,\n        ratio,\n        start: ruler.pixels[index] - size / 2\n    };\n}\nfunction computeFlexCategoryTraits(index, ruler, options, stackCount) {\n    const pixels = ruler.pixels;\n    const curr = pixels[index];\n    let prev = index > 0 ? pixels[index - 1] : null;\n    let next = index < pixels.length - 1 ? pixels[index + 1] : null;\n    const percent = options.categoryPercentage;\n    if (prev === null) {\n        prev = curr - (next === null ? ruler.end - ruler.start : next - curr);\n    }\n    if (next === null) {\n        next = curr + curr - prev;\n    }\n    const start = curr - (curr - Math.min(prev, next)) / 2 * percent;\n    const size = Math.abs(next - prev) / 2 * percent;\n    return {\n        chunk: size / stackCount,\n        ratio: options.barPercentage,\n        start\n    };\n}\nfunction parseFloatBar(entry, item, vScale, i) {\n    const startValue = vScale.parse(entry[0], i);\n    const endValue = vScale.parse(entry[1], i);\n    const min = Math.min(startValue, endValue);\n    const max = Math.max(startValue, endValue);\n    let barStart = min;\n    let barEnd = max;\n    if (Math.abs(min) > Math.abs(max)) {\n        barStart = max;\n        barEnd = min;\n    }\n    item[vScale.axis] = barEnd;\n    item._custom = {\n        barStart,\n        barEnd,\n        start: startValue,\n        end: endValue,\n        min,\n        max\n    };\n}\nfunction parseValue(entry, item, vScale, i) {\n    if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(entry)) {\n        parseFloatBar(entry, item, vScale, i);\n    } else {\n        item[vScale.axis] = vScale.parse(entry, i);\n    }\n    return item;\n}\nfunction parseArrayOrPrimitive(meta, data, start, count) {\n    const iScale = meta.iScale;\n    const vScale = meta.vScale;\n    const labels = iScale.getLabels();\n    const singleScale = iScale === vScale;\n    const parsed = [];\n    let i, ilen, item, entry;\n    for(i = start, ilen = start + count; i < ilen; ++i){\n        entry = data[i];\n        item = {};\n        item[iScale.axis] = singleScale || iScale.parse(labels[i], i);\n        parsed.push(parseValue(entry, item, vScale, i));\n    }\n    return parsed;\n}\nfunction isFloatBar(custom) {\n    return custom && custom.barStart !== undefined && custom.barEnd !== undefined;\n}\nfunction barSign(size, vScale, actualBase) {\n    if (size !== 0) {\n        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.s)(size);\n    }\n    return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);\n}\nfunction borderProps(properties) {\n    let reverse, start, end, top, bottom;\n    if (properties.horizontal) {\n        reverse = properties.base > properties.x;\n        start = 'left';\n        end = 'right';\n    } else {\n        reverse = properties.base < properties.y;\n        start = 'bottom';\n        end = 'top';\n    }\n    if (reverse) {\n        top = 'end';\n        bottom = 'start';\n    } else {\n        top = 'start';\n        bottom = 'end';\n    }\n    return {\n        start,\n        end,\n        reverse,\n        top,\n        bottom\n    };\n}\nfunction setBorderSkipped(properties, options, stack, index) {\n    let edge = options.borderSkipped;\n    const res = {};\n    if (!edge) {\n        properties.borderSkipped = res;\n        return;\n    }\n    if (edge === true) {\n        properties.borderSkipped = {\n            top: true,\n            right: true,\n            bottom: true,\n            left: true\n        };\n        return;\n    }\n    const { start, end, reverse, top, bottom } = borderProps(properties);\n    if (edge === 'middle' && stack) {\n        properties.enableBorderRadius = true;\n        if ((stack._top || 0) === index) {\n            edge = top;\n        } else if ((stack._bottom || 0) === index) {\n            edge = bottom;\n        } else {\n            res[parseEdge(bottom, start, end, reverse)] = true;\n            edge = top;\n        }\n    }\n    res[parseEdge(edge, start, end, reverse)] = true;\n    properties.borderSkipped = res;\n}\nfunction parseEdge(edge, a, b, reverse) {\n    if (reverse) {\n        edge = swap(edge, a, b);\n        edge = startEnd(edge, b, a);\n    } else {\n        edge = startEnd(edge, a, b);\n    }\n    return edge;\n}\nfunction swap(orig, v1, v2) {\n    return orig === v1 ? v2 : orig === v2 ? v1 : orig;\n}\nfunction startEnd(v, start, end) {\n    return v === 'start' ? start : v === 'end' ? end : v;\n}\nfunction setInflateAmount(properties, { inflateAmount }, ratio) {\n    properties.inflateAmount = inflateAmount === 'auto' ? ratio === 1 ? 0.33 : 0 : inflateAmount;\n}\nclass BarController extends DatasetController {\n    static{\n        this.id = 'bar';\n    }\n    static{\n        this.defaults = {\n            datasetElementType: false,\n            dataElementType: 'bar',\n            categoryPercentage: 0.8,\n            barPercentage: 0.9,\n            grouped: true,\n            animations: {\n                numbers: {\n                    type: 'number',\n                    properties: [\n                        'x',\n                        'y',\n                        'base',\n                        'width',\n                        'height'\n                    ]\n                }\n            }\n        };\n    }\n    static{\n        this.overrides = {\n            scales: {\n                _index_: {\n                    type: 'category',\n                    offset: true,\n                    grid: {\n                        offset: true\n                    }\n                },\n                _value_: {\n                    type: 'linear',\n                    beginAtZero: true\n                }\n            }\n        };\n    }\n    parsePrimitiveData(meta, data, start, count) {\n        return parseArrayOrPrimitive(meta, data, start, count);\n    }\n    parseArrayData(meta, data, start, count) {\n        return parseArrayOrPrimitive(meta, data, start, count);\n    }\n    parseObjectData(meta, data, start, count) {\n        const { iScale, vScale } = meta;\n        const { xAxisKey = 'x', yAxisKey = 'y' } = this._parsing;\n        const iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;\n        const vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;\n        const parsed = [];\n        let i, ilen, item, obj;\n        for(i = start, ilen = start + count; i < ilen; ++i){\n            obj = data[i];\n            item = {};\n            item[iScale.axis] = iScale.parse((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.f)(obj, iAxisKey), i);\n            parsed.push(parseValue((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.f)(obj, vAxisKey), item, vScale, i));\n        }\n        return parsed;\n    }\n    updateRangeFromParsed(range, scale, parsed, stack) {\n        super.updateRangeFromParsed(range, scale, parsed, stack);\n        const custom = parsed._custom;\n        if (custom && scale === this._cachedMeta.vScale) {\n            range.min = Math.min(range.min, custom.min);\n            range.max = Math.max(range.max, custom.max);\n        }\n    }\n    getMaxOverflow() {\n        return 0;\n    }\n    getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const { iScale, vScale } = meta;\n        const parsed = this.getParsed(index);\n        const custom = parsed._custom;\n        const value = isFloatBar(custom) ? '[' + custom.start + ', ' + custom.end + ']' : '' + vScale.getLabelForValue(parsed[vScale.axis]);\n        return {\n            label: '' + iScale.getLabelForValue(parsed[iScale.axis]),\n            value\n        };\n    }\n    initialize() {\n        this.enableOptionSharing = true;\n        super.initialize();\n        const meta = this._cachedMeta;\n        meta.stack = this.getDataset().stack;\n    }\n    update(mode) {\n        const meta = this._cachedMeta;\n        this.updateElements(meta.data, 0, meta.data.length, mode);\n    }\n    updateElements(bars, start, count, mode) {\n        const reset = mode === 'reset';\n        const { index, _cachedMeta: { vScale } } = this;\n        const base = vScale.getBasePixel();\n        const horizontal = vScale.isHorizontal();\n        const ruler = this._getRuler();\n        const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);\n        for(let i = start; i < start + count; i++){\n            const parsed = this.getParsed(i);\n            const vpixels = reset || (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(parsed[vScale.axis]) ? {\n                base,\n                head: base\n            } : this._calculateBarValuePixels(i);\n            const ipixels = this._calculateBarIndexPixels(i, ruler);\n            const stack = (parsed._stacks || {})[vScale.axis];\n            const properties = {\n                horizontal,\n                base: vpixels.base,\n                enableBorderRadius: !stack || isFloatBar(parsed._custom) || index === stack._top || index === stack._bottom,\n                x: horizontal ? vpixels.head : ipixels.center,\n                y: horizontal ? ipixels.center : vpixels.head,\n                height: horizontal ? ipixels.size : Math.abs(vpixels.size),\n                width: horizontal ? Math.abs(vpixels.size) : ipixels.size\n            };\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? 'active' : mode);\n            }\n            const options = properties.options || bars[i].options;\n            setBorderSkipped(properties, options, stack, index);\n            setInflateAmount(properties, options, ruler.ratio);\n            this.updateElement(bars[i], i, properties, mode);\n        }\n    }\n    _getStacks(last, dataIndex) {\n        const { iScale } = this._cachedMeta;\n        const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta)=>meta.controller.options.grouped);\n        const stacked = iScale.options.stacked;\n        const stacks = [];\n        const currentParsed = this._cachedMeta.controller.getParsed(dataIndex);\n        const iScaleValue = currentParsed && currentParsed[iScale.axis];\n        const skipNull = (meta)=>{\n            const parsed = meta._parsed.find((item)=>item[iScale.axis] === iScaleValue);\n            const val = parsed && parsed[meta.vScale.axis];\n            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(val) || isNaN(val)) {\n                return true;\n            }\n        };\n        for (const meta of metasets){\n            if (dataIndex !== undefined && skipNull(meta)) {\n                continue;\n            }\n            if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === undefined && meta.stack === undefined) {\n                stacks.push(meta.stack);\n            }\n            if (meta.index === last) {\n                break;\n            }\n        }\n        if (!stacks.length) {\n            stacks.push(undefined);\n        }\n        return stacks;\n    }\n    _getStackCount(index) {\n        return this._getStacks(undefined, index).length;\n    }\n    _getAxisCount() {\n        return this._getAxis().length;\n    }\n    getFirstScaleIdForIndexAxis() {\n        const scales = this.chart.scales;\n        const indexScaleId = this.chart.options.indexAxis;\n        return Object.keys(scales).filter((key)=>scales[key].axis === indexScaleId).shift();\n    }\n    _getAxis() {\n        const axis = {};\n        const firstScaleAxisId = this.getFirstScaleIdForIndexAxis();\n        for (const dataset of this.chart.data.datasets){\n            axis[(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(this.chart.options.indexAxis === 'x' ? dataset.xAxisID : dataset.yAxisID, firstScaleAxisId)] = true;\n        }\n        return Object.keys(axis);\n    }\n    _getStackIndex(datasetIndex, name, dataIndex) {\n        const stacks = this._getStacks(datasetIndex, dataIndex);\n        const index = name !== undefined ? stacks.indexOf(name) : -1;\n        return index === -1 ? stacks.length - 1 : index;\n    }\n    _getRuler() {\n        const opts = this.options;\n        const meta = this._cachedMeta;\n        const iScale = meta.iScale;\n        const pixels = [];\n        let i, ilen;\n        for(i = 0, ilen = meta.data.length; i < ilen; ++i){\n            pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));\n        }\n        const barThickness = opts.barThickness;\n        const min = barThickness || computeMinSampleSize(meta);\n        return {\n            min,\n            pixels,\n            start: iScale._startPixel,\n            end: iScale._endPixel,\n            stackCount: this._getStackCount(),\n            scale: iScale,\n            grouped: opts.grouped,\n            ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage\n        };\n    }\n    _calculateBarValuePixels(index) {\n        const { _cachedMeta: { vScale, _stacked, index: datasetIndex }, options: { base: baseValue, minBarLength } } = this;\n        const actualBase = baseValue || 0;\n        const parsed = this.getParsed(index);\n        const custom = parsed._custom;\n        const floating = isFloatBar(custom);\n        let value = parsed[vScale.axis];\n        let start = 0;\n        let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;\n        let head, size;\n        if (length !== value) {\n            start = length - value;\n            length = value;\n        }\n        if (floating) {\n            value = custom.barStart;\n            length = custom.barEnd - custom.barStart;\n            if (value !== 0 && (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.s)(value) !== (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.s)(custom.barEnd)) {\n                start = 0;\n            }\n            start += value;\n        }\n        const startValue = !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(baseValue) && !floating ? baseValue : start;\n        let base = vScale.getPixelForValue(startValue);\n        if (this.chart.getDataVisibility(index)) {\n            head = vScale.getPixelForValue(start + length);\n        } else {\n            head = base;\n        }\n        size = head - base;\n        if (Math.abs(size) < minBarLength) {\n            size = barSign(size, vScale, actualBase) * minBarLength;\n            if (value === actualBase) {\n                base -= size / 2;\n            }\n            const startPixel = vScale.getPixelForDecimal(0);\n            const endPixel = vScale.getPixelForDecimal(1);\n            const min = Math.min(startPixel, endPixel);\n            const max = Math.max(startPixel, endPixel);\n            base = Math.max(Math.min(base, max), min);\n            head = base + size;\n            if (_stacked && !floating) {\n                parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);\n            }\n        }\n        if (base === vScale.getPixelForValue(actualBase)) {\n            const halfGrid = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.s)(size) * vScale.getLineWidthForValue(actualBase) / 2;\n            base += halfGrid;\n            size -= halfGrid;\n        }\n        return {\n            size,\n            base,\n            head,\n            center: head + size / 2\n        };\n    }\n    _calculateBarIndexPixels(index, ruler) {\n        const scale = ruler.scale;\n        const options = this.options;\n        const skipNull = options.skipNull;\n        const maxBarThickness = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(options.maxBarThickness, Infinity);\n        let center, size;\n        const axisCount = this._getAxisCount();\n        if (ruler.grouped) {\n            const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;\n            const range = options.barThickness === 'flex' ? computeFlexCategoryTraits(index, ruler, options, stackCount * axisCount) : computeFitCategoryTraits(index, ruler, options, stackCount * axisCount);\n            const axisID = this.chart.options.indexAxis === 'x' ? this.getDataset().xAxisID : this.getDataset().yAxisID;\n            const axisNumber = this._getAxis().indexOf((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(axisID, this.getFirstScaleIdForIndexAxis()));\n            const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined) + axisNumber;\n            center = range.start + range.chunk * stackIndex + range.chunk / 2;\n            size = Math.min(maxBarThickness, range.chunk * range.ratio);\n        } else {\n            center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);\n            size = Math.min(maxBarThickness, ruler.min * ruler.ratio);\n        }\n        return {\n            base: center - size / 2,\n            head: center + size / 2,\n            center,\n            size\n        };\n    }\n    draw() {\n        const meta = this._cachedMeta;\n        const vScale = meta.vScale;\n        const rects = meta.data;\n        const ilen = rects.length;\n        let i = 0;\n        for(; i < ilen; ++i){\n            if (this.getParsed(i)[vScale.axis] !== null && !rects[i].hidden) {\n                rects[i].draw(this._ctx);\n            }\n        }\n    }\n}\nclass BubbleController extends DatasetController {\n    static{\n        this.id = 'bubble';\n    }\n    static{\n        this.defaults = {\n            datasetElementType: false,\n            dataElementType: 'point',\n            animations: {\n                numbers: {\n                    type: 'number',\n                    properties: [\n                        'x',\n                        'y',\n                        'borderWidth',\n                        'radius'\n                    ]\n                }\n            }\n        };\n    }\n    static{\n        this.overrides = {\n            scales: {\n                x: {\n                    type: 'linear'\n                },\n                y: {\n                    type: 'linear'\n                }\n            }\n        };\n    }\n    initialize() {\n        this.enableOptionSharing = true;\n        super.initialize();\n    }\n    parsePrimitiveData(meta, data, start, count) {\n        const parsed = super.parsePrimitiveData(meta, data, start, count);\n        for(let i = 0; i < parsed.length; i++){\n            parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;\n        }\n        return parsed;\n    }\n    parseArrayData(meta, data, start, count) {\n        const parsed = super.parseArrayData(meta, data, start, count);\n        for(let i = 0; i < parsed.length; i++){\n            const item = data[start + i];\n            parsed[i]._custom = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(item[2], this.resolveDataElementOptions(i + start).radius);\n        }\n        return parsed;\n    }\n    parseObjectData(meta, data, start, count) {\n        const parsed = super.parseObjectData(meta, data, start, count);\n        for(let i = 0; i < parsed.length; i++){\n            const item = data[start + i];\n            parsed[i]._custom = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);\n        }\n        return parsed;\n    }\n    getMaxOverflow() {\n        const data = this._cachedMeta.data;\n        let max = 0;\n        for(let i = data.length - 1; i >= 0; --i){\n            max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n        }\n        return max > 0 && max;\n    }\n    getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const labels = this.chart.data.labels || [];\n        const { xScale, yScale } = meta;\n        const parsed = this.getParsed(index);\n        const x = xScale.getLabelForValue(parsed.x);\n        const y = yScale.getLabelForValue(parsed.y);\n        const r = parsed._custom;\n        return {\n            label: labels[index] || '',\n            value: '(' + x + ', ' + y + (r ? ', ' + r : '') + ')'\n        };\n    }\n    update(mode) {\n        const points = this._cachedMeta.data;\n        this.updateElements(points, 0, points.length, mode);\n    }\n    updateElements(points, start, count, mode) {\n        const reset = mode === 'reset';\n        const { iScale, vScale } = this._cachedMeta;\n        const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);\n        const iAxis = iScale.axis;\n        const vAxis = vScale.axis;\n        for(let i = start; i < start + count; i++){\n            const point = points[i];\n            const parsed = !reset && this.getParsed(i);\n            const properties = {};\n            const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);\n            const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);\n            properties.skip = isNaN(iPixel) || isNaN(vPixel);\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n                if (reset) {\n                    properties.options.radius = 0;\n                }\n            }\n            this.updateElement(point, i, properties, mode);\n        }\n    }\n    resolveDataElementOptions(index, mode) {\n        const parsed = this.getParsed(index);\n        let values = super.resolveDataElementOptions(index, mode);\n        if (values.$shared) {\n            values = Object.assign({}, values, {\n                $shared: false\n            });\n        }\n        const radius = values.radius;\n        if (mode !== 'active') {\n            values.radius = 0;\n        }\n        values.radius += (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(parsed && parsed._custom, radius);\n        return values;\n    }\n}\nfunction getRatioAndOffset(rotation, circumference, cutout) {\n    let ratioX = 1;\n    let ratioY = 1;\n    let offsetX = 0;\n    let offsetY = 0;\n    if (circumference < _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T) {\n        const startAngle = rotation;\n        const endAngle = startAngle + circumference;\n        const startX = Math.cos(startAngle);\n        const startY = Math.sin(startAngle);\n        const endX = Math.cos(endAngle);\n        const endY = Math.sin(endAngle);\n        const calcMax = (angle, a, b)=>(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.p)(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);\n        const calcMin = (angle, a, b)=>(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.p)(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);\n        const maxX = calcMax(0, startX, endX);\n        const maxY = calcMax(_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H, startY, endY);\n        const minX = calcMin(_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P, startX, endX);\n        const minY = calcMin(_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P + _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H, startY, endY);\n        ratioX = (maxX - minX) / 2;\n        ratioY = (maxY - minY) / 2;\n        offsetX = -(maxX + minX) / 2;\n        offsetY = -(maxY + minY) / 2;\n    }\n    return {\n        ratioX,\n        ratioY,\n        offsetX,\n        offsetY\n    };\n}\nclass DoughnutController extends DatasetController {\n    static{\n        this.id = 'doughnut';\n    }\n    static{\n        this.defaults = {\n            datasetElementType: false,\n            dataElementType: 'arc',\n            animation: {\n                animateRotate: true,\n                animateScale: false\n            },\n            animations: {\n                numbers: {\n                    type: 'number',\n                    properties: [\n                        'circumference',\n                        'endAngle',\n                        'innerRadius',\n                        'outerRadius',\n                        'startAngle',\n                        'x',\n                        'y',\n                        'offset',\n                        'borderWidth',\n                        'spacing'\n                    ]\n                }\n            },\n            cutout: '50%',\n            rotation: 0,\n            circumference: 360,\n            radius: '100%',\n            spacing: 0,\n            indexAxis: 'r'\n        };\n    }\n    static{\n        this.descriptors = {\n            _scriptable: (name)=>name !== 'spacing',\n            _indexable: (name)=>name !== 'spacing' && !name.startsWith('borderDash') && !name.startsWith('hoverBorderDash')\n        };\n    }\n    static{\n        this.overrides = {\n            aspectRatio: 1,\n            plugins: {\n                legend: {\n                    labels: {\n                        generateLabels (chart) {\n                            const data = chart.data;\n                            const { labels: { pointStyle, textAlign, color, useBorderRadius, borderRadius } } = chart.legend.options;\n                            if (data.labels.length && data.datasets.length) {\n                                return data.labels.map((label, i)=>{\n                                    const meta = chart.getDatasetMeta(0);\n                                    const style = meta.controller.getStyle(i);\n                                    return {\n                                        text: label,\n                                        fillStyle: style.backgroundColor,\n                                        fontColor: color,\n                                        hidden: !chart.getDataVisibility(i),\n                                        lineDash: style.borderDash,\n                                        lineDashOffset: style.borderDashOffset,\n                                        lineJoin: style.borderJoinStyle,\n                                        lineWidth: style.borderWidth,\n                                        strokeStyle: style.borderColor,\n                                        textAlign: textAlign,\n                                        pointStyle: pointStyle,\n                                        borderRadius: useBorderRadius && (borderRadius || style.borderRadius),\n                                        index: i\n                                    };\n                                });\n                            }\n                            return [];\n                        }\n                    },\n                    onClick (e, legendItem, legend) {\n                        legend.chart.toggleDataVisibility(legendItem.index);\n                        legend.chart.update();\n                    }\n                }\n            }\n        };\n    }\n    constructor(chart, datasetIndex){\n        super(chart, datasetIndex);\n        this.enableOptionSharing = true;\n        this.innerRadius = undefined;\n        this.outerRadius = undefined;\n        this.offsetX = undefined;\n        this.offsetY = undefined;\n    }\n    linkScales() {}\n    parse(start, count) {\n        const data = this.getDataset().data;\n        const meta = this._cachedMeta;\n        if (this._parsing === false) {\n            meta._parsed = data;\n        } else {\n            let getter = (i)=>+data[i];\n            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(data[start])) {\n                const { key = 'value' } = this._parsing;\n                getter = (i)=>+(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.f)(data[i], key);\n            }\n            let i, ilen;\n            for(i = start, ilen = start + count; i < ilen; ++i){\n                meta._parsed[i] = getter(i);\n            }\n        }\n    }\n    _getRotation() {\n        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.options.rotation - 90);\n    }\n    _getCircumference() {\n        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.options.circumference);\n    }\n    _getRotationExtents() {\n        let min = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T;\n        let max = -_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T;\n        for(let i = 0; i < this.chart.data.datasets.length; ++i){\n            if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {\n                const controller = this.chart.getDatasetMeta(i).controller;\n                const rotation = controller._getRotation();\n                const circumference = controller._getCircumference();\n                min = Math.min(min, rotation);\n                max = Math.max(max, rotation + circumference);\n            }\n        }\n        return {\n            rotation: min,\n            circumference: max - min\n        };\n    }\n    update(mode) {\n        const chart = this.chart;\n        const { chartArea } = chart;\n        const meta = this._cachedMeta;\n        const arcs = meta.data;\n        const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;\n        const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);\n        const cutout = Math.min((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.m)(this.options.cutout, maxSize), 1);\n        const chartWeight = this._getRingWeight(this.index);\n        const { circumference, rotation } = this._getRotationExtents();\n        const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);\n        const maxWidth = (chartArea.width - spacing) / ratioX;\n        const maxHeight = (chartArea.height - spacing) / ratioY;\n        const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);\n        const outerRadius = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.n)(this.options.radius, maxRadius);\n        const innerRadius = Math.max(outerRadius * cutout, 0);\n        const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();\n        this.offsetX = offsetX * outerRadius;\n        this.offsetY = offsetY * outerRadius;\n        meta.total = this.calculateTotal();\n        this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);\n        this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);\n        this.updateElements(arcs, 0, arcs.length, mode);\n    }\n    _circumference(i, reset) {\n        const opts = this.options;\n        const meta = this._cachedMeta;\n        const circumference = this._getCircumference();\n        if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {\n            return 0;\n        }\n        return this.calculateCircumference(meta._parsed[i] * circumference / _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T);\n    }\n    updateElements(arcs, start, count, mode) {\n        const reset = mode === 'reset';\n        const chart = this.chart;\n        const chartArea = chart.chartArea;\n        const opts = chart.options;\n        const animationOpts = opts.animation;\n        const centerX = (chartArea.left + chartArea.right) / 2;\n        const centerY = (chartArea.top + chartArea.bottom) / 2;\n        const animateScale = reset && animationOpts.animateScale;\n        const innerRadius = animateScale ? 0 : this.innerRadius;\n        const outerRadius = animateScale ? 0 : this.outerRadius;\n        const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);\n        let startAngle = this._getRotation();\n        let i;\n        for(i = 0; i < start; ++i){\n            startAngle += this._circumference(i, reset);\n        }\n        for(i = start; i < start + count; ++i){\n            const circumference = this._circumference(i, reset);\n            const arc = arcs[i];\n            const properties = {\n                x: centerX + this.offsetX,\n                y: centerY + this.offsetY,\n                startAngle,\n                endAngle: startAngle + circumference,\n                circumference,\n                outerRadius,\n                innerRadius\n            };\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? 'active' : mode);\n            }\n            startAngle += circumference;\n            this.updateElement(arc, i, properties, mode);\n        }\n    }\n    calculateTotal() {\n        const meta = this._cachedMeta;\n        const metaData = meta.data;\n        let total = 0;\n        let i;\n        for(i = 0; i < metaData.length; i++){\n            const value = meta._parsed[i];\n            if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {\n                total += Math.abs(value);\n            }\n        }\n        return total;\n    }\n    calculateCircumference(value) {\n        const total = this._cachedMeta.total;\n        if (total > 0 && !isNaN(value)) {\n            return _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T * (Math.abs(value) / total);\n        }\n        return 0;\n    }\n    getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const chart = this.chart;\n        const labels = chart.data.labels || [];\n        const value = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.o)(meta._parsed[index], chart.options.locale);\n        return {\n            label: labels[index] || '',\n            value\n        };\n    }\n    getMaxBorderWidth(arcs) {\n        let max = 0;\n        const chart = this.chart;\n        let i, ilen, meta, controller, options;\n        if (!arcs) {\n            for(i = 0, ilen = chart.data.datasets.length; i < ilen; ++i){\n                if (chart.isDatasetVisible(i)) {\n                    meta = chart.getDatasetMeta(i);\n                    arcs = meta.data;\n                    controller = meta.controller;\n                    break;\n                }\n            }\n        }\n        if (!arcs) {\n            return 0;\n        }\n        for(i = 0, ilen = arcs.length; i < ilen; ++i){\n            options = controller.resolveDataElementOptions(i);\n            if (options.borderAlign !== 'inner') {\n                max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);\n            }\n        }\n        return max;\n    }\n    getMaxOffset(arcs) {\n        let max = 0;\n        for(let i = 0, ilen = arcs.length; i < ilen; ++i){\n            const options = this.resolveDataElementOptions(i);\n            max = Math.max(max, options.offset || 0, options.hoverOffset || 0);\n        }\n        return max;\n    }\n    _getRingWeightOffset(datasetIndex) {\n        let ringWeightOffset = 0;\n        for(let i = 0; i < datasetIndex; ++i){\n            if (this.chart.isDatasetVisible(i)) {\n                ringWeightOffset += this._getRingWeight(i);\n            }\n        }\n        return ringWeightOffset;\n    }\n    _getRingWeight(datasetIndex) {\n        return Math.max((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(this.chart.data.datasets[datasetIndex].weight, 1), 0);\n    }\n    _getVisibleDatasetWeightTotal() {\n        return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\n    }\n}\nclass LineController extends DatasetController {\n    static{\n        this.id = 'line';\n    }\n    static{\n        this.defaults = {\n            datasetElementType: 'line',\n            dataElementType: 'point',\n            showLine: true,\n            spanGaps: false\n        };\n    }\n    static{\n        this.overrides = {\n            scales: {\n                _index_: {\n                    type: 'category'\n                },\n                _value_: {\n                    type: 'linear'\n                }\n            }\n        };\n    }\n    initialize() {\n        this.enableOptionSharing = true;\n        this.supportsDecimation = true;\n        super.initialize();\n    }\n    update(mode) {\n        const meta = this._cachedMeta;\n        const { dataset: line, data: points = [], _dataset } = meta;\n        const animationsDisabled = this.chart._animationsDisabled;\n        let { start, count } = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.q)(meta, points, animationsDisabled);\n        this._drawStart = start;\n        this._drawCount = count;\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.w)(meta)) {\n            start = 0;\n            count = points.length;\n        }\n        line._chart = this.chart;\n        line._datasetIndex = this.index;\n        line._decimated = !!_dataset._decimated;\n        line.points = points;\n        const options = this.resolveDatasetElementOptions(mode);\n        if (!this.options.showLine) {\n            options.borderWidth = 0;\n        }\n        options.segment = this.options.segment;\n        this.updateElement(line, undefined, {\n            animated: !animationsDisabled,\n            options\n        }, mode);\n        this.updateElements(points, start, count, mode);\n    }\n    updateElements(points, start, count, mode) {\n        const reset = mode === 'reset';\n        const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;\n        const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);\n        const iAxis = iScale.axis;\n        const vAxis = vScale.axis;\n        const { spanGaps, segment } = this.options;\n        const maxGapLength = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.x)(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n        const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\n        const end = start + count;\n        const pointsCount = points.length;\n        let prevParsed = start > 0 && this.getParsed(start - 1);\n        for(let i = 0; i < pointsCount; ++i){\n            const point = points[i];\n            const properties = directUpdate ? point : {};\n            if (i < start || i >= end) {\n                properties.skip = true;\n                continue;\n            }\n            const parsed = this.getParsed(i);\n            const nullData = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(parsed[vAxis]);\n            const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n            const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n            properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n            properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;\n            if (segment) {\n                properties.parsed = parsed;\n                properties.raw = _dataset.data[i];\n            }\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n            }\n            if (!directUpdate) {\n                this.updateElement(point, i, properties, mode);\n            }\n            prevParsed = parsed;\n        }\n    }\n    getMaxOverflow() {\n        const meta = this._cachedMeta;\n        const dataset = meta.dataset;\n        const border = dataset.options && dataset.options.borderWidth || 0;\n        const data = meta.data || [];\n        if (!data.length) {\n            return border;\n        }\n        const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n        const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n        return Math.max(border, firstPoint, lastPoint) / 2;\n    }\n    draw() {\n        const meta = this._cachedMeta;\n        meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);\n        super.draw();\n    }\n}\nclass PolarAreaController extends DatasetController {\n    static{\n        this.id = 'polarArea';\n    }\n    static{\n        this.defaults = {\n            dataElementType: 'arc',\n            animation: {\n                animateRotate: true,\n                animateScale: true\n            },\n            animations: {\n                numbers: {\n                    type: 'number',\n                    properties: [\n                        'x',\n                        'y',\n                        'startAngle',\n                        'endAngle',\n                        'innerRadius',\n                        'outerRadius'\n                    ]\n                }\n            },\n            indexAxis: 'r',\n            startAngle: 0\n        };\n    }\n    static{\n        this.overrides = {\n            aspectRatio: 1,\n            plugins: {\n                legend: {\n                    labels: {\n                        generateLabels (chart) {\n                            const data = chart.data;\n                            if (data.labels.length && data.datasets.length) {\n                                const { labels: { pointStyle, color } } = chart.legend.options;\n                                return data.labels.map((label, i)=>{\n                                    const meta = chart.getDatasetMeta(0);\n                                    const style = meta.controller.getStyle(i);\n                                    return {\n                                        text: label,\n                                        fillStyle: style.backgroundColor,\n                                        strokeStyle: style.borderColor,\n                                        fontColor: color,\n                                        lineWidth: style.borderWidth,\n                                        pointStyle: pointStyle,\n                                        hidden: !chart.getDataVisibility(i),\n                                        index: i\n                                    };\n                                });\n                            }\n                            return [];\n                        }\n                    },\n                    onClick (e, legendItem, legend) {\n                        legend.chart.toggleDataVisibility(legendItem.index);\n                        legend.chart.update();\n                    }\n                }\n            },\n            scales: {\n                r: {\n                    type: 'radialLinear',\n                    angleLines: {\n                        display: false\n                    },\n                    beginAtZero: true,\n                    grid: {\n                        circular: true\n                    },\n                    pointLabels: {\n                        display: false\n                    },\n                    startAngle: 0\n                }\n            }\n        };\n    }\n    constructor(chart, datasetIndex){\n        super(chart, datasetIndex);\n        this.innerRadius = undefined;\n        this.outerRadius = undefined;\n    }\n    getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const chart = this.chart;\n        const labels = chart.data.labels || [];\n        const value = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.o)(meta._parsed[index].r, chart.options.locale);\n        return {\n            label: labels[index] || '',\n            value\n        };\n    }\n    parseObjectData(meta, data, start, count) {\n        return _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.y.bind(this)(meta, data, start, count);\n    }\n    update(mode) {\n        const arcs = this._cachedMeta.data;\n        this._updateRadius();\n        this.updateElements(arcs, 0, arcs.length, mode);\n    }\n    getMinMax() {\n        const meta = this._cachedMeta;\n        const range = {\n            min: Number.POSITIVE_INFINITY,\n            max: Number.NEGATIVE_INFINITY\n        };\n        meta.data.forEach((element, index)=>{\n            const parsed = this.getParsed(index).r;\n            if (!isNaN(parsed) && this.chart.getDataVisibility(index)) {\n                if (parsed < range.min) {\n                    range.min = parsed;\n                }\n                if (parsed > range.max) {\n                    range.max = parsed;\n                }\n            }\n        });\n        return range;\n    }\n    _updateRadius() {\n        const chart = this.chart;\n        const chartArea = chart.chartArea;\n        const opts = chart.options;\n        const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n        const outerRadius = Math.max(minSize / 2, 0);\n        const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);\n        const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();\n        this.outerRadius = outerRadius - radiusLength * this.index;\n        this.innerRadius = this.outerRadius - radiusLength;\n    }\n    updateElements(arcs, start, count, mode) {\n        const reset = mode === 'reset';\n        const chart = this.chart;\n        const opts = chart.options;\n        const animationOpts = opts.animation;\n        const scale = this._cachedMeta.rScale;\n        const centerX = scale.xCenter;\n        const centerY = scale.yCenter;\n        const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P;\n        let angle = datasetStartAngle;\n        let i;\n        const defaultAngle = 360 / this.countVisibleElements();\n        for(i = 0; i < start; ++i){\n            angle += this._computeAngle(i, mode, defaultAngle);\n        }\n        for(i = start; i < start + count; i++){\n            const arc = arcs[i];\n            let startAngle = angle;\n            let endAngle = angle + this._computeAngle(i, mode, defaultAngle);\n            let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;\n            angle = endAngle;\n            if (reset) {\n                if (animationOpts.animateScale) {\n                    outerRadius = 0;\n                }\n                if (animationOpts.animateRotate) {\n                    startAngle = endAngle = datasetStartAngle;\n                }\n            }\n            const properties = {\n                x: centerX,\n                y: centerY,\n                innerRadius: 0,\n                outerRadius,\n                startAngle,\n                endAngle,\n                options: this.resolveDataElementOptions(i, arc.active ? 'active' : mode)\n            };\n            this.updateElement(arc, i, properties, mode);\n        }\n    }\n    countVisibleElements() {\n        const meta = this._cachedMeta;\n        let count = 0;\n        meta.data.forEach((element, index)=>{\n            if (!isNaN(this.getParsed(index).r) && this.chart.getDataVisibility(index)) {\n                count++;\n            }\n        });\n        return count;\n    }\n    _computeAngle(index, mode, defaultAngle) {\n        return this.chart.getDataVisibility(index) ? (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.resolveDataElementOptions(index, mode).angle || defaultAngle) : 0;\n    }\n}\nclass PieController extends DoughnutController {\n    static{\n        this.id = 'pie';\n    }\n    static{\n        this.defaults = {\n            cutout: 0,\n            rotation: 0,\n            circumference: 360,\n            radius: '100%'\n        };\n    }\n}\nclass RadarController extends DatasetController {\n    static{\n        this.id = 'radar';\n    }\n    static{\n        this.defaults = {\n            datasetElementType: 'line',\n            dataElementType: 'point',\n            indexAxis: 'r',\n            showLine: true,\n            elements: {\n                line: {\n                    fill: 'start'\n                }\n            }\n        };\n    }\n    static{\n        this.overrides = {\n            aspectRatio: 1,\n            scales: {\n                r: {\n                    type: 'radialLinear'\n                }\n            }\n        };\n    }\n    getLabelAndValue(index) {\n        const vScale = this._cachedMeta.vScale;\n        const parsed = this.getParsed(index);\n        return {\n            label: vScale.getLabels()[index],\n            value: '' + vScale.getLabelForValue(parsed[vScale.axis])\n        };\n    }\n    parseObjectData(meta, data, start, count) {\n        return _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.y.bind(this)(meta, data, start, count);\n    }\n    update(mode) {\n        const meta = this._cachedMeta;\n        const line = meta.dataset;\n        const points = meta.data || [];\n        const labels = meta.iScale.getLabels();\n        line.points = points;\n        if (mode !== 'resize') {\n            const options = this.resolveDatasetElementOptions(mode);\n            if (!this.options.showLine) {\n                options.borderWidth = 0;\n            }\n            const properties = {\n                _loop: true,\n                _fullLoop: labels.length === points.length,\n                options\n            };\n            this.updateElement(line, undefined, properties, mode);\n        }\n        this.updateElements(points, 0, points.length, mode);\n    }\n    updateElements(points, start, count, mode) {\n        const scale = this._cachedMeta.rScale;\n        const reset = mode === 'reset';\n        for(let i = start; i < start + count; i++){\n            const point = points[i];\n            const options = this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n            const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);\n            const x = reset ? scale.xCenter : pointPosition.x;\n            const y = reset ? scale.yCenter : pointPosition.y;\n            const properties = {\n                x,\n                y,\n                angle: pointPosition.angle,\n                skip: isNaN(x) || isNaN(y),\n                options\n            };\n            this.updateElement(point, i, properties, mode);\n        }\n    }\n}\nclass ScatterController extends DatasetController {\n    static{\n        this.id = 'scatter';\n    }\n    static{\n        this.defaults = {\n            datasetElementType: false,\n            dataElementType: 'point',\n            showLine: false,\n            fill: false\n        };\n    }\n    static{\n        this.overrides = {\n            interaction: {\n                mode: 'point'\n            },\n            scales: {\n                x: {\n                    type: 'linear'\n                },\n                y: {\n                    type: 'linear'\n                }\n            }\n        };\n    }\n    getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const labels = this.chart.data.labels || [];\n        const { xScale, yScale } = meta;\n        const parsed = this.getParsed(index);\n        const x = xScale.getLabelForValue(parsed.x);\n        const y = yScale.getLabelForValue(parsed.y);\n        return {\n            label: labels[index] || '',\n            value: '(' + x + ', ' + y + ')'\n        };\n    }\n    update(mode) {\n        const meta = this._cachedMeta;\n        const { data: points = [] } = meta;\n        const animationsDisabled = this.chart._animationsDisabled;\n        let { start, count } = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.q)(meta, points, animationsDisabled);\n        this._drawStart = start;\n        this._drawCount = count;\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.w)(meta)) {\n            start = 0;\n            count = points.length;\n        }\n        if (this.options.showLine) {\n            if (!this.datasetElementType) {\n                this.addElements();\n            }\n            const { dataset: line, _dataset } = meta;\n            line._chart = this.chart;\n            line._datasetIndex = this.index;\n            line._decimated = !!_dataset._decimated;\n            line.points = points;\n            const options = this.resolveDatasetElementOptions(mode);\n            options.segment = this.options.segment;\n            this.updateElement(line, undefined, {\n                animated: !animationsDisabled,\n                options\n            }, mode);\n        } else if (this.datasetElementType) {\n            delete meta.dataset;\n            this.datasetElementType = false;\n        }\n        this.updateElements(points, start, count, mode);\n    }\n    addElements() {\n        const { showLine } = this.options;\n        if (!this.datasetElementType && showLine) {\n            this.datasetElementType = this.chart.registry.getElement('line');\n        }\n        super.addElements();\n    }\n    updateElements(points, start, count, mode) {\n        const reset = mode === 'reset';\n        const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;\n        const firstOpts = this.resolveDataElementOptions(start, mode);\n        const sharedOptions = this.getSharedOptions(firstOpts);\n        const includeOptions = this.includeOptions(mode, sharedOptions);\n        const iAxis = iScale.axis;\n        const vAxis = vScale.axis;\n        const { spanGaps, segment } = this.options;\n        const maxGapLength = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.x)(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n        const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\n        let prevParsed = start > 0 && this.getParsed(start - 1);\n        for(let i = start; i < start + count; ++i){\n            const point = points[i];\n            const parsed = this.getParsed(i);\n            const properties = directUpdate ? point : {};\n            const nullData = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(parsed[vAxis]);\n            const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n            const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n            properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n            properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;\n            if (segment) {\n                properties.parsed = parsed;\n                properties.raw = _dataset.data[i];\n            }\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n            }\n            if (!directUpdate) {\n                this.updateElement(point, i, properties, mode);\n            }\n            prevParsed = parsed;\n        }\n        this.updateSharedOptions(sharedOptions, mode, firstOpts);\n    }\n    getMaxOverflow() {\n        const meta = this._cachedMeta;\n        const data = meta.data || [];\n        if (!this.options.showLine) {\n            let max = 0;\n            for(let i = data.length - 1; i >= 0; --i){\n                max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n            }\n            return max > 0 && max;\n        }\n        const dataset = meta.dataset;\n        const border = dataset.options && dataset.options.borderWidth || 0;\n        if (!data.length) {\n            return border;\n        }\n        const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n        const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n        return Math.max(border, firstPoint, lastPoint) / 2;\n    }\n}\nvar controllers = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    BarController: BarController,\n    BubbleController: BubbleController,\n    DoughnutController: DoughnutController,\n    LineController: LineController,\n    PieController: PieController,\n    PolarAreaController: PolarAreaController,\n    RadarController: RadarController,\n    ScatterController: ScatterController\n});\n/**\n * @namespace Chart._adapters\n * @since 2.8.0\n * @private\n */ function abstract() {\n    throw new Error('This method is not implemented: Check that a complete date adapter is provided.');\n}\n/**\n * Date adapter (current used by the time scale)\n * @namespace Chart._adapters._date\n * @memberof Chart._adapters\n * @private\n */ class DateAdapterBase {\n    /**\n   * Override default date adapter methods.\n   * Accepts type parameter to define options type.\n   * @example\n   * Chart._adapters._date.override<{myAdapterOption: string}>({\n   *   init() {\n   *     console.log(this.options.myAdapterOption);\n   *   }\n   * })\n   */ static override(members) {\n        Object.assign(DateAdapterBase.prototype, members);\n    }\n    constructor(options){\n        this.options = options || {};\n    }\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    init() {}\n    formats() {\n        return abstract();\n    }\n    parse() {\n        return abstract();\n    }\n    format() {\n        return abstract();\n    }\n    add() {\n        return abstract();\n    }\n    diff() {\n        return abstract();\n    }\n    startOf() {\n        return abstract();\n    }\n    endOf() {\n        return abstract();\n    }\n}\nvar adapters = {\n    _date: DateAdapterBase\n};\nfunction binarySearch(metaset, axis, value, intersect) {\n    const { controller, data, _sorted } = metaset;\n    const iScale = controller._cachedMeta.iScale;\n    const spanGaps = metaset.dataset ? metaset.dataset.options ? metaset.dataset.options.spanGaps : null : null;\n    if (iScale && axis === iScale.axis && axis !== 'r' && _sorted && data.length) {\n        const lookupMethod = iScale._reversePixels ? _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.A : _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.B;\n        if (!intersect) {\n            const result = lookupMethod(data, axis, value);\n            if (spanGaps) {\n                const { vScale } = controller._cachedMeta;\n                const { _parsed } = metaset;\n                const distanceToDefinedLo = _parsed.slice(0, result.lo + 1).reverse().findIndex((point)=>!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(point[vScale.axis]));\n                result.lo -= Math.max(0, distanceToDefinedLo);\n                const distanceToDefinedHi = _parsed.slice(result.hi).findIndex((point)=>!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(point[vScale.axis]));\n                result.hi += Math.max(0, distanceToDefinedHi);\n            }\n            return result;\n        } else if (controller._sharedOptions) {\n            const el = data[0];\n            const range = typeof el.getRange === 'function' && el.getRange(axis);\n            if (range) {\n                const start = lookupMethod(data, axis, value - range);\n                const end = lookupMethod(data, axis, value + range);\n                return {\n                    lo: start.lo,\n                    hi: end.hi\n                };\n            }\n        }\n    }\n    return {\n        lo: 0,\n        hi: data.length - 1\n    };\n}\nfunction evaluateInteractionItems(chart, axis, position, handler, intersect) {\n    const metasets = chart.getSortedVisibleDatasetMetas();\n    const value = position[axis];\n    for(let i = 0, ilen = metasets.length; i < ilen; ++i){\n        const { index, data } = metasets[i];\n        const { lo, hi } = binarySearch(metasets[i], axis, value, intersect);\n        for(let j = lo; j <= hi; ++j){\n            const element = data[j];\n            if (!element.skip) {\n                handler(element, index, j);\n            }\n        }\n    }\n}\nfunction getDistanceMetricForAxis(axis) {\n    const useX = axis.indexOf('x') !== -1;\n    const useY = axis.indexOf('y') !== -1;\n    return function(pt1, pt2) {\n        const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\n        const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\n        return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n    };\n}\nfunction getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {\n    const items = [];\n    if (!includeInvisible && !chart.isPointInArea(position)) {\n        return items;\n    }\n    const evaluationFunc = function(element, datasetIndex, index) {\n        if (!includeInvisible && !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.C)(element, chart.chartArea, 0)) {\n            return;\n        }\n        if (element.inRange(position.x, position.y, useFinalPosition)) {\n            items.push({\n                element,\n                datasetIndex,\n                index\n            });\n        }\n    };\n    evaluateInteractionItems(chart, axis, position, evaluationFunc, true);\n    return items;\n}\nfunction getNearestRadialItems(chart, position, axis, useFinalPosition) {\n    let items = [];\n    function evaluationFunc(element, datasetIndex, index) {\n        const { startAngle, endAngle } = element.getProps([\n            'startAngle',\n            'endAngle'\n        ], useFinalPosition);\n        const { angle } = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.D)(element, {\n            x: position.x,\n            y: position.y\n        });\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.p)(angle, startAngle, endAngle)) {\n            items.push({\n                element,\n                datasetIndex,\n                index\n            });\n        }\n    }\n    evaluateInteractionItems(chart, axis, position, evaluationFunc);\n    return items;\n}\nfunction getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n    let items = [];\n    const distanceMetric = getDistanceMetricForAxis(axis);\n    let minDistance = Number.POSITIVE_INFINITY;\n    function evaluationFunc(element, datasetIndex, index) {\n        const inRange = element.inRange(position.x, position.y, useFinalPosition);\n        if (intersect && !inRange) {\n            return;\n        }\n        const center = element.getCenterPoint(useFinalPosition);\n        const pointInArea = !!includeInvisible || chart.isPointInArea(center);\n        if (!pointInArea && !inRange) {\n            return;\n        }\n        const distance = distanceMetric(position, center);\n        if (distance < minDistance) {\n            items = [\n                {\n                    element,\n                    datasetIndex,\n                    index\n                }\n            ];\n            minDistance = distance;\n        } else if (distance === minDistance) {\n            items.push({\n                element,\n                datasetIndex,\n                index\n            });\n        }\n    }\n    evaluateInteractionItems(chart, axis, position, evaluationFunc);\n    return items;\n}\nfunction getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n    if (!includeInvisible && !chart.isPointInArea(position)) {\n        return [];\n    }\n    return axis === 'r' && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);\n}\nfunction getAxisItems(chart, position, axis, intersect, useFinalPosition) {\n    const items = [];\n    const rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';\n    let intersectsItem = false;\n    evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index)=>{\n        if (element[rangeMethod] && element[rangeMethod](position[axis], useFinalPosition)) {\n            items.push({\n                element,\n                datasetIndex,\n                index\n            });\n            intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);\n        }\n    });\n    if (intersect && !intersectsItem) {\n        return [];\n    }\n    return items;\n}\nvar Interaction = {\n    evaluateInteractionItems,\n    modes: {\n        index (chart, e, options, useFinalPosition) {\n            const position = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.z)(e, chart);\n            const axis = options.axis || 'x';\n            const includeInvisible = options.includeInvisible || false;\n            const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n            const elements = [];\n            if (!items.length) {\n                return [];\n            }\n            chart.getSortedVisibleDatasetMetas().forEach((meta)=>{\n                const index = items[0].index;\n                const element = meta.data[index];\n                if (element && !element.skip) {\n                    elements.push({\n                        element,\n                        datasetIndex: meta.index,\n                        index\n                    });\n                }\n            });\n            return elements;\n        },\n        dataset (chart, e, options, useFinalPosition) {\n            const position = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.z)(e, chart);\n            const axis = options.axis || 'xy';\n            const includeInvisible = options.includeInvisible || false;\n            let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n            if (items.length > 0) {\n                const datasetIndex = items[0].datasetIndex;\n                const data = chart.getDatasetMeta(datasetIndex).data;\n                items = [];\n                for(let i = 0; i < data.length; ++i){\n                    items.push({\n                        element: data[i],\n                        datasetIndex,\n                        index: i\n                    });\n                }\n            }\n            return items;\n        },\n        point (chart, e, options, useFinalPosition) {\n            const position = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.z)(e, chart);\n            const axis = options.axis || 'xy';\n            const includeInvisible = options.includeInvisible || false;\n            return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);\n        },\n        nearest (chart, e, options, useFinalPosition) {\n            const position = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.z)(e, chart);\n            const axis = options.axis || 'xy';\n            const includeInvisible = options.includeInvisible || false;\n            return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);\n        },\n        x (chart, e, options, useFinalPosition) {\n            const position = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.z)(e, chart);\n            return getAxisItems(chart, position, 'x', options.intersect, useFinalPosition);\n        },\n        y (chart, e, options, useFinalPosition) {\n            const position = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.z)(e, chart);\n            return getAxisItems(chart, position, 'y', options.intersect, useFinalPosition);\n        }\n    }\n};\nconst STATIC_POSITIONS = [\n    'left',\n    'top',\n    'right',\n    'bottom'\n];\nfunction filterByPosition(array, position) {\n    return array.filter((v)=>v.pos === position);\n}\nfunction filterDynamicPositionByAxis(array, axis) {\n    return array.filter((v)=>STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);\n}\nfunction sortByWeight(array, reverse) {\n    return array.sort((a, b)=>{\n        const v0 = reverse ? b : a;\n        const v1 = reverse ? a : b;\n        return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;\n    });\n}\nfunction wrapBoxes(boxes) {\n    const layoutBoxes = [];\n    let i, ilen, box, pos, stack, stackWeight;\n    for(i = 0, ilen = (boxes || []).length; i < ilen; ++i){\n        box = boxes[i];\n        ({ position: pos, options: { stack, stackWeight = 1 } } = box);\n        layoutBoxes.push({\n            index: i,\n            box,\n            pos,\n            horizontal: box.isHorizontal(),\n            weight: box.weight,\n            stack: stack && pos + stack,\n            stackWeight\n        });\n    }\n    return layoutBoxes;\n}\nfunction buildStacks(layouts) {\n    const stacks = {};\n    for (const wrap of layouts){\n        const { stack, pos, stackWeight } = wrap;\n        if (!stack || !STATIC_POSITIONS.includes(pos)) {\n            continue;\n        }\n        const _stack = stacks[stack] || (stacks[stack] = {\n            count: 0,\n            placed: 0,\n            weight: 0,\n            size: 0\n        });\n        _stack.count++;\n        _stack.weight += stackWeight;\n    }\n    return stacks;\n}\nfunction setLayoutDims(layouts, params) {\n    const stacks = buildStacks(layouts);\n    const { vBoxMaxWidth, hBoxMaxHeight } = params;\n    let i, ilen, layout;\n    for(i = 0, ilen = layouts.length; i < ilen; ++i){\n        layout = layouts[i];\n        const { fullSize } = layout.box;\n        const stack = stacks[layout.stack];\n        const factor = stack && layout.stackWeight / stack.weight;\n        if (layout.horizontal) {\n            layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;\n            layout.height = hBoxMaxHeight;\n        } else {\n            layout.width = vBoxMaxWidth;\n            layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;\n        }\n    }\n    return stacks;\n}\nfunction buildLayoutBoxes(boxes) {\n    const layoutBoxes = wrapBoxes(boxes);\n    const fullSize = sortByWeight(layoutBoxes.filter((wrap)=>wrap.box.fullSize), true);\n    const left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);\n    const right = sortByWeight(filterByPosition(layoutBoxes, 'right'));\n    const top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);\n    const bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));\n    const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, 'x');\n    const centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');\n    return {\n        fullSize,\n        leftAndTop: left.concat(top),\n        rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),\n        chartArea: filterByPosition(layoutBoxes, 'chartArea'),\n        vertical: left.concat(right).concat(centerVertical),\n        horizontal: top.concat(bottom).concat(centerHorizontal)\n    };\n}\nfunction getCombinedMax(maxPadding, chartArea, a, b) {\n    return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);\n}\nfunction updateMaxPadding(maxPadding, boxPadding) {\n    maxPadding.top = Math.max(maxPadding.top, boxPadding.top);\n    maxPadding.left = Math.max(maxPadding.left, boxPadding.left);\n    maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);\n    maxPadding.right = Math.max(maxPadding.right, boxPadding.right);\n}\nfunction updateDims(chartArea, params, layout, stacks) {\n    const { pos, box } = layout;\n    const maxPadding = chartArea.maxPadding;\n    if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(pos)) {\n        if (layout.size) {\n            chartArea[pos] -= layout.size;\n        }\n        const stack = stacks[layout.stack] || {\n            size: 0,\n            count: 1\n        };\n        stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);\n        layout.size = stack.size / stack.count;\n        chartArea[pos] += layout.size;\n    }\n    if (box.getPadding) {\n        updateMaxPadding(maxPadding, box.getPadding());\n    }\n    const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right'));\n    const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom'));\n    const widthChanged = newWidth !== chartArea.w;\n    const heightChanged = newHeight !== chartArea.h;\n    chartArea.w = newWidth;\n    chartArea.h = newHeight;\n    return layout.horizontal ? {\n        same: widthChanged,\n        other: heightChanged\n    } : {\n        same: heightChanged,\n        other: widthChanged\n    };\n}\nfunction handleMaxPadding(chartArea) {\n    const maxPadding = chartArea.maxPadding;\n    function updatePos(pos) {\n        const change = Math.max(maxPadding[pos] - chartArea[pos], 0);\n        chartArea[pos] += change;\n        return change;\n    }\n    chartArea.y += updatePos('top');\n    chartArea.x += updatePos('left');\n    updatePos('right');\n    updatePos('bottom');\n}\nfunction getMargins(horizontal, chartArea) {\n    const maxPadding = chartArea.maxPadding;\n    function marginForPositions(positions) {\n        const margin = {\n            left: 0,\n            top: 0,\n            right: 0,\n            bottom: 0\n        };\n        positions.forEach((pos)=>{\n            margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);\n        });\n        return margin;\n    }\n    return horizontal ? marginForPositions([\n        'left',\n        'right'\n    ]) : marginForPositions([\n        'top',\n        'bottom'\n    ]);\n}\nfunction fitBoxes(boxes, chartArea, params, stacks) {\n    const refitBoxes = [];\n    let i, ilen, layout, box, refit, changed;\n    for(i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i){\n        layout = boxes[i];\n        box = layout.box;\n        box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));\n        const { same, other } = updateDims(chartArea, params, layout, stacks);\n        refit |= same && refitBoxes.length;\n        changed = changed || other;\n        if (!box.fullSize) {\n            refitBoxes.push(layout);\n        }\n    }\n    return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;\n}\nfunction setBoxDims(box, left, top, width, height) {\n    box.top = top;\n    box.left = left;\n    box.right = left + width;\n    box.bottom = top + height;\n    box.width = width;\n    box.height = height;\n}\nfunction placeBoxes(boxes, chartArea, params, stacks) {\n    const userPadding = params.padding;\n    let { x, y } = chartArea;\n    for (const layout of boxes){\n        const box = layout.box;\n        const stack = stacks[layout.stack] || {\n            count: 1,\n            placed: 0,\n            weight: 1\n        };\n        const weight = layout.stackWeight / stack.weight || 1;\n        if (layout.horizontal) {\n            const width = chartArea.w * weight;\n            const height = stack.size || box.height;\n            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.h)(stack.start)) {\n                y = stack.start;\n            }\n            if (box.fullSize) {\n                setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);\n            } else {\n                setBoxDims(box, chartArea.left + stack.placed, y, width, height);\n            }\n            stack.start = y;\n            stack.placed += width;\n            y = box.bottom;\n        } else {\n            const height = chartArea.h * weight;\n            const width = stack.size || box.width;\n            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.h)(stack.start)) {\n                x = stack.start;\n            }\n            if (box.fullSize) {\n                setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);\n            } else {\n                setBoxDims(box, x, chartArea.top + stack.placed, width, height);\n            }\n            stack.start = x;\n            stack.placed += height;\n            x = box.right;\n        }\n    }\n    chartArea.x = x;\n    chartArea.y = y;\n}\nvar layouts = {\n    addBox (chart, item) {\n        if (!chart.boxes) {\n            chart.boxes = [];\n        }\n        item.fullSize = item.fullSize || false;\n        item.position = item.position || 'top';\n        item.weight = item.weight || 0;\n        item._layers = item._layers || function() {\n            return [\n                {\n                    z: 0,\n                    draw (chartArea) {\n                        item.draw(chartArea);\n                    }\n                }\n            ];\n        };\n        chart.boxes.push(item);\n    },\n    removeBox (chart, layoutItem) {\n        const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\n        if (index !== -1) {\n            chart.boxes.splice(index, 1);\n        }\n    },\n    configure (chart, item, options) {\n        item.fullSize = options.fullSize;\n        item.position = options.position;\n        item.weight = options.weight;\n    },\n    update (chart, width, height, minPadding) {\n        if (!chart) {\n            return;\n        }\n        const padding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(chart.options.layout.padding);\n        const availableWidth = Math.max(width - padding.width, 0);\n        const availableHeight = Math.max(height - padding.height, 0);\n        const boxes = buildLayoutBoxes(chart.boxes);\n        const verticalBoxes = boxes.vertical;\n        const horizontalBoxes = boxes.horizontal;\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(chart.boxes, (box)=>{\n            if (typeof box.beforeLayout === 'function') {\n                box.beforeLayout();\n            }\n        });\n        const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap)=>wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;\n        const params = Object.freeze({\n            outerWidth: width,\n            outerHeight: height,\n            padding,\n            availableWidth,\n            availableHeight,\n            vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,\n            hBoxMaxHeight: availableHeight / 2\n        });\n        const maxPadding = Object.assign({}, padding);\n        updateMaxPadding(maxPadding, (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(minPadding));\n        const chartArea = Object.assign({\n            maxPadding,\n            w: availableWidth,\n            h: availableHeight,\n            x: padding.left,\n            y: padding.top\n        }, padding);\n        const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);\n        fitBoxes(boxes.fullSize, chartArea, params, stacks);\n        fitBoxes(verticalBoxes, chartArea, params, stacks);\n        if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {\n            fitBoxes(verticalBoxes, chartArea, params, stacks);\n        }\n        handleMaxPadding(chartArea);\n        placeBoxes(boxes.leftAndTop, chartArea, params, stacks);\n        chartArea.x += chartArea.w;\n        chartArea.y += chartArea.h;\n        placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);\n        chart.chartArea = {\n            left: chartArea.left,\n            top: chartArea.top,\n            right: chartArea.left + chartArea.w,\n            bottom: chartArea.top + chartArea.h,\n            height: chartArea.h,\n            width: chartArea.w\n        };\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(boxes.chartArea, (layout)=>{\n            const box = layout.box;\n            Object.assign(box, chart.chartArea);\n            box.update(chartArea.w, chartArea.h, {\n                left: 0,\n                top: 0,\n                right: 0,\n                bottom: 0\n            });\n        });\n    }\n};\nclass BasePlatform {\n    acquireContext(canvas, aspectRatio) {}\n    releaseContext(context) {\n        return false;\n    }\n    addEventListener(chart, type, listener) {}\n    removeEventListener(chart, type, listener) {}\n    getDevicePixelRatio() {\n        return 1;\n    }\n    getMaximumSize(element, width, height, aspectRatio) {\n        width = Math.max(0, width || element.width);\n        height = height || element.height;\n        return {\n            width,\n            height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)\n        };\n    }\n    isAttached(canvas) {\n        return true;\n    }\n    updateConfig(config) {}\n}\nclass BasicPlatform extends BasePlatform {\n    acquireContext(item) {\n        return item && item.getContext && item.getContext('2d') || null;\n    }\n    updateConfig(config) {\n        config.options.animation = false;\n    }\n}\nconst EXPANDO_KEY = '$chartjs';\nconst EVENT_TYPES = {\n    touchstart: 'mousedown',\n    touchmove: 'mousemove',\n    touchend: 'mouseup',\n    pointerenter: 'mouseenter',\n    pointerdown: 'mousedown',\n    pointermove: 'mousemove',\n    pointerup: 'mouseup',\n    pointerleave: 'mouseout',\n    pointerout: 'mouseout'\n};\nconst isNullOrEmpty = (value)=>value === null || value === '';\nfunction initCanvas(canvas, aspectRatio) {\n    const style = canvas.style;\n    const renderHeight = canvas.getAttribute('height');\n    const renderWidth = canvas.getAttribute('width');\n    canvas[EXPANDO_KEY] = {\n        initial: {\n            height: renderHeight,\n            width: renderWidth,\n            style: {\n                display: style.display,\n                height: style.height,\n                width: style.width\n            }\n        }\n    };\n    style.display = style.display || 'block';\n    style.boxSizing = style.boxSizing || 'border-box';\n    if (isNullOrEmpty(renderWidth)) {\n        const displayWidth = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.J)(canvas, 'width');\n        if (displayWidth !== undefined) {\n            canvas.width = displayWidth;\n        }\n    }\n    if (isNullOrEmpty(renderHeight)) {\n        if (canvas.style.height === '') {\n            canvas.height = canvas.width / (aspectRatio || 2);\n        } else {\n            const displayHeight = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.J)(canvas, 'height');\n            if (displayHeight !== undefined) {\n                canvas.height = displayHeight;\n            }\n        }\n    }\n    return canvas;\n}\nconst eventListenerOptions = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.K ? {\n    passive: true\n} : false;\nfunction addListener(node, type, listener) {\n    if (node) {\n        node.addEventListener(type, listener, eventListenerOptions);\n    }\n}\nfunction removeListener(chart, type, listener) {\n    if (chart && chart.canvas) {\n        chart.canvas.removeEventListener(type, listener, eventListenerOptions);\n    }\n}\nfunction fromNativeEvent(event, chart) {\n    const type = EVENT_TYPES[event.type] || event.type;\n    const { x, y } = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.z)(event, chart);\n    return {\n        type,\n        chart,\n        native: event,\n        x: x !== undefined ? x : null,\n        y: y !== undefined ? y : null\n    };\n}\nfunction nodeListContains(nodeList, canvas) {\n    for (const node of nodeList){\n        if (node === canvas || node.contains(canvas)) {\n            return true;\n        }\n    }\n}\nfunction createAttachObserver(chart, type, listener) {\n    const canvas = chart.canvas;\n    const observer = new MutationObserver((entries)=>{\n        let trigger = false;\n        for (const entry of entries){\n            trigger = trigger || nodeListContains(entry.addedNodes, canvas);\n            trigger = trigger && !nodeListContains(entry.removedNodes, canvas);\n        }\n        if (trigger) {\n            listener();\n        }\n    });\n    observer.observe(document, {\n        childList: true,\n        subtree: true\n    });\n    return observer;\n}\nfunction createDetachObserver(chart, type, listener) {\n    const canvas = chart.canvas;\n    const observer = new MutationObserver((entries)=>{\n        let trigger = false;\n        for (const entry of entries){\n            trigger = trigger || nodeListContains(entry.removedNodes, canvas);\n            trigger = trigger && !nodeListContains(entry.addedNodes, canvas);\n        }\n        if (trigger) {\n            listener();\n        }\n    });\n    observer.observe(document, {\n        childList: true,\n        subtree: true\n    });\n    return observer;\n}\nconst drpListeningCharts = new Map();\nlet oldDevicePixelRatio = 0;\nfunction onWindowResize() {\n    const dpr = window.devicePixelRatio;\n    if (dpr === oldDevicePixelRatio) {\n        return;\n    }\n    oldDevicePixelRatio = dpr;\n    drpListeningCharts.forEach((resize, chart)=>{\n        if (chart.currentDevicePixelRatio !== dpr) {\n            resize();\n        }\n    });\n}\nfunction listenDevicePixelRatioChanges(chart, resize) {\n    if (!drpListeningCharts.size) {\n        window.addEventListener('resize', onWindowResize);\n    }\n    drpListeningCharts.set(chart, resize);\n}\nfunction unlistenDevicePixelRatioChanges(chart) {\n    drpListeningCharts.delete(chart);\n    if (!drpListeningCharts.size) {\n        window.removeEventListener('resize', onWindowResize);\n    }\n}\nfunction createResizeObserver(chart, type, listener) {\n    const canvas = chart.canvas;\n    const container = canvas && (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.I)(canvas);\n    if (!container) {\n        return;\n    }\n    const resize = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.L)((width, height)=>{\n        const w = container.clientWidth;\n        listener(width, height);\n        if (w < container.clientWidth) {\n            listener();\n        }\n    }, window);\n    const observer = new ResizeObserver((entries)=>{\n        const entry = entries[0];\n        const width = entry.contentRect.width;\n        const height = entry.contentRect.height;\n        if (width === 0 && height === 0) {\n            return;\n        }\n        resize(width, height);\n    });\n    observer.observe(container);\n    listenDevicePixelRatioChanges(chart, resize);\n    return observer;\n}\nfunction releaseObserver(chart, type, observer) {\n    if (observer) {\n        observer.disconnect();\n    }\n    if (type === 'resize') {\n        unlistenDevicePixelRatioChanges(chart);\n    }\n}\nfunction createProxyAndListen(chart, type, listener) {\n    const canvas = chart.canvas;\n    const proxy = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.L)((event)=>{\n        if (chart.ctx !== null) {\n            listener(fromNativeEvent(event, chart));\n        }\n    }, chart);\n    addListener(canvas, type, proxy);\n    return proxy;\n}\nclass DomPlatform extends BasePlatform {\n    acquireContext(canvas, aspectRatio) {\n        const context = canvas && canvas.getContext && canvas.getContext('2d');\n        if (context && context.canvas === canvas) {\n            initCanvas(canvas, aspectRatio);\n            return context;\n        }\n        return null;\n    }\n    releaseContext(context) {\n        const canvas = context.canvas;\n        if (!canvas[EXPANDO_KEY]) {\n            return false;\n        }\n        const initial = canvas[EXPANDO_KEY].initial;\n        [\n            'height',\n            'width'\n        ].forEach((prop)=>{\n            const value = initial[prop];\n            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(value)) {\n                canvas.removeAttribute(prop);\n            } else {\n                canvas.setAttribute(prop, value);\n            }\n        });\n        const style = initial.style || {};\n        Object.keys(style).forEach((key)=>{\n            canvas.style[key] = style[key];\n        });\n        canvas.width = canvas.width;\n        delete canvas[EXPANDO_KEY];\n        return true;\n    }\n    addEventListener(chart, type, listener) {\n        this.removeEventListener(chart, type);\n        const proxies = chart.$proxies || (chart.$proxies = {});\n        const handlers = {\n            attach: createAttachObserver,\n            detach: createDetachObserver,\n            resize: createResizeObserver\n        };\n        const handler = handlers[type] || createProxyAndListen;\n        proxies[type] = handler(chart, type, listener);\n    }\n    removeEventListener(chart, type) {\n        const proxies = chart.$proxies || (chart.$proxies = {});\n        const proxy = proxies[type];\n        if (!proxy) {\n            return;\n        }\n        const handlers = {\n            attach: releaseObserver,\n            detach: releaseObserver,\n            resize: releaseObserver\n        };\n        const handler = handlers[type] || removeListener;\n        handler(chart, type, proxy);\n        proxies[type] = undefined;\n    }\n    getDevicePixelRatio() {\n        return window.devicePixelRatio;\n    }\n    getMaximumSize(canvas, width, height, aspectRatio) {\n        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.G)(canvas, width, height, aspectRatio);\n    }\n    isAttached(canvas) {\n        const container = canvas && (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.I)(canvas);\n        return !!(container && container.isConnected);\n    }\n}\nfunction _detectPlatform(canvas) {\n    if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.M)() || typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas) {\n        return BasicPlatform;\n    }\n    return DomPlatform;\n}\nclass Element {\n    static{\n        this.defaults = {};\n    }\n    static{\n        this.defaultRoutes = undefined;\n    }\n    tooltipPosition(useFinalPosition) {\n        const { x, y } = this.getProps([\n            'x',\n            'y'\n        ], useFinalPosition);\n        return {\n            x,\n            y\n        };\n    }\n    hasValue() {\n        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.x)(this.x) && (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.x)(this.y);\n    }\n    getProps(props, final) {\n        const anims = this.$animations;\n        if (!final || !anims) {\n            // let's not create an object, if not needed\n            return this;\n        }\n        const ret = {};\n        props.forEach((prop)=>{\n            ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];\n        });\n        return ret;\n    }\n    constructor(){\n        this.active = false;\n    }\n}\nfunction autoSkip(scale, ticks) {\n    const tickOpts = scale.options.ticks;\n    const determinedMaxTicks = determineMaxTicks(scale);\n    const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);\n    const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];\n    const numMajorIndices = majorIndices.length;\n    const first = majorIndices[0];\n    const last = majorIndices[numMajorIndices - 1];\n    const newTicks = [];\n    if (numMajorIndices > ticksLimit) {\n        skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);\n        return newTicks;\n    }\n    const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);\n    if (numMajorIndices > 0) {\n        let i, ilen;\n        const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;\n        skip(ticks, newTicks, spacing, (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);\n        for(i = 0, ilen = numMajorIndices - 1; i < ilen; i++){\n            skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);\n        }\n        skip(ticks, newTicks, spacing, last, (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);\n        return newTicks;\n    }\n    skip(ticks, newTicks, spacing);\n    return newTicks;\n}\nfunction determineMaxTicks(scale) {\n    const offset = scale.options.offset;\n    const tickLength = scale._tickSize();\n    const maxScale = scale._length / tickLength + (offset ? 0 : 1);\n    const maxChart = scale._maxLength / tickLength;\n    return Math.floor(Math.min(maxScale, maxChart));\n}\nfunction calculateSpacing(majorIndices, ticks, ticksLimit) {\n    const evenMajorSpacing = getEvenSpacing(majorIndices);\n    const spacing = ticks.length / ticksLimit;\n    if (!evenMajorSpacing) {\n        return Math.max(spacing, 1);\n    }\n    const factors = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.N)(evenMajorSpacing);\n    for(let i = 0, ilen = factors.length - 1; i < ilen; i++){\n        const factor = factors[i];\n        if (factor > spacing) {\n            return factor;\n        }\n    }\n    return Math.max(spacing, 1);\n}\nfunction getMajorIndices(ticks) {\n    const result = [];\n    let i, ilen;\n    for(i = 0, ilen = ticks.length; i < ilen; i++){\n        if (ticks[i].major) {\n            result.push(i);\n        }\n    }\n    return result;\n}\nfunction skipMajors(ticks, newTicks, majorIndices, spacing) {\n    let count = 0;\n    let next = majorIndices[0];\n    let i;\n    spacing = Math.ceil(spacing);\n    for(i = 0; i < ticks.length; i++){\n        if (i === next) {\n            newTicks.push(ticks[i]);\n            count++;\n            next = majorIndices[count * spacing];\n        }\n    }\n}\nfunction skip(ticks, newTicks, spacing, majorStart, majorEnd) {\n    const start = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(majorStart, 0);\n    const end = Math.min((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(majorEnd, ticks.length), ticks.length);\n    let count = 0;\n    let length, i, next;\n    spacing = Math.ceil(spacing);\n    if (majorEnd) {\n        length = majorEnd - majorStart;\n        spacing = length / Math.floor(length / spacing);\n    }\n    next = start;\n    while(next < 0){\n        count++;\n        next = Math.round(start + count * spacing);\n    }\n    for(i = Math.max(start, 0); i < end; i++){\n        if (i === next) {\n            newTicks.push(ticks[i]);\n            count++;\n            next = Math.round(start + count * spacing);\n        }\n    }\n}\nfunction getEvenSpacing(arr) {\n    const len = arr.length;\n    let i, diff;\n    if (len < 2) {\n        return false;\n    }\n    for(diff = arr[0], i = 1; i < len; ++i){\n        if (arr[i] - arr[i - 1] !== diff) {\n            return false;\n        }\n    }\n    return diff;\n}\nconst reverseAlign = (align)=>align === 'left' ? 'right' : align === 'right' ? 'left' : align;\nconst offsetFromEdge = (scale, edge, offset)=>edge === 'top' || edge === 'left' ? scale[edge] + offset : scale[edge] - offset;\nconst getTicksLimit = (ticksLength, maxTicksLimit)=>Math.min(maxTicksLimit || ticksLength, ticksLength);\nfunction sample(arr, numItems) {\n    const result = [];\n    const increment = arr.length / numItems;\n    const len = arr.length;\n    let i = 0;\n    for(; i < len; i += increment){\n        result.push(arr[Math.floor(i)]);\n    }\n    return result;\n}\nfunction getPixelForGridLine(scale, index, offsetGridLines) {\n    const length = scale.ticks.length;\n    const validIndex = Math.min(index, length - 1);\n    const start = scale._startPixel;\n    const end = scale._endPixel;\n    const epsilon = 1e-6;\n    let lineValue = scale.getPixelForTick(validIndex);\n    let offset;\n    if (offsetGridLines) {\n        if (length === 1) {\n            offset = Math.max(lineValue - start, end - lineValue);\n        } else if (index === 0) {\n            offset = (scale.getPixelForTick(1) - lineValue) / 2;\n        } else {\n            offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;\n        }\n        lineValue += validIndex < index ? offset : -offset;\n        if (lineValue < start - epsilon || lineValue > end + epsilon) {\n            return;\n        }\n    }\n    return lineValue;\n}\nfunction garbageCollect(caches, length) {\n    (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(caches, (cache)=>{\n        const gc = cache.gc;\n        const gcLen = gc.length / 2;\n        let i;\n        if (gcLen > length) {\n            for(i = 0; i < gcLen; ++i){\n                delete cache.data[gc[i]];\n            }\n            gc.splice(0, gcLen);\n        }\n    });\n}\nfunction getTickMarkLength(options) {\n    return options.drawTicks ? options.tickLength : 0;\n}\nfunction getTitleHeight(options, fallback) {\n    if (!options.display) {\n        return 0;\n    }\n    const font = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(options.font, fallback);\n    const padding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(options.padding);\n    const lines = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(options.text) ? options.text.length : 1;\n    return lines * font.lineHeight + padding.height;\n}\nfunction createScaleContext(parent, scale) {\n    return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.j)(parent, {\n        scale,\n        type: 'scale'\n    });\n}\nfunction createTickContext(parent, index, tick) {\n    return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.j)(parent, {\n        tick,\n        index,\n        type: 'tick'\n    });\n}\nfunction titleAlign(align, position, reverse) {\n    let ret = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a1)(align);\n    if (reverse && position !== 'right' || !reverse && position === 'right') {\n        ret = reverseAlign(ret);\n    }\n    return ret;\n}\nfunction titleArgs(scale, offset, position, align) {\n    const { top, left, bottom, right, chart } = scale;\n    const { chartArea, scales } = chart;\n    let rotation = 0;\n    let maxWidth, titleX, titleY;\n    const height = bottom - top;\n    const width = right - left;\n    if (scale.isHorizontal()) {\n        titleX = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, left, right);\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n            const positionAxisID = Object.keys(position)[0];\n            const value = position[positionAxisID];\n            titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;\n        } else if (position === 'center') {\n            titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;\n        } else {\n            titleY = offsetFromEdge(scale, position, offset);\n        }\n        maxWidth = right - left;\n    } else {\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n            const positionAxisID = Object.keys(position)[0];\n            const value = position[positionAxisID];\n            titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;\n        } else if (position === 'center') {\n            titleX = (chartArea.left + chartArea.right) / 2 - width + offset;\n        } else {\n            titleX = offsetFromEdge(scale, position, offset);\n        }\n        titleY = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, bottom, top);\n        rotation = position === 'left' ? -_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H : _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H;\n    }\n    return {\n        titleX,\n        titleY,\n        maxWidth,\n        rotation\n    };\n}\nclass Scale extends Element {\n    constructor(cfg){\n        super();\n        this.id = cfg.id;\n        this.type = cfg.type;\n        this.options = undefined;\n        this.ctx = cfg.ctx;\n        this.chart = cfg.chart;\n        this.top = undefined;\n        this.bottom = undefined;\n        this.left = undefined;\n        this.right = undefined;\n        this.width = undefined;\n        this.height = undefined;\n        this._margins = {\n            left: 0,\n            right: 0,\n            top: 0,\n            bottom: 0\n        };\n        this.maxWidth = undefined;\n        this.maxHeight = undefined;\n        this.paddingTop = undefined;\n        this.paddingBottom = undefined;\n        this.paddingLeft = undefined;\n        this.paddingRight = undefined;\n        this.axis = undefined;\n        this.labelRotation = undefined;\n        this.min = undefined;\n        this.max = undefined;\n        this._range = undefined;\n        this.ticks = [];\n        this._gridLineItems = null;\n        this._labelItems = null;\n        this._labelSizes = null;\n        this._length = 0;\n        this._maxLength = 0;\n        this._longestTextCache = {};\n        this._startPixel = undefined;\n        this._endPixel = undefined;\n        this._reversePixels = false;\n        this._userMax = undefined;\n        this._userMin = undefined;\n        this._suggestedMax = undefined;\n        this._suggestedMin = undefined;\n        this._ticksLength = 0;\n        this._borderValue = 0;\n        this._cache = {};\n        this._dataLimitsCached = false;\n        this.$context = undefined;\n    }\n    init(options) {\n        this.options = options.setContext(this.getContext());\n        this.axis = options.axis;\n        this._userMin = this.parse(options.min);\n        this._userMax = this.parse(options.max);\n        this._suggestedMin = this.parse(options.suggestedMin);\n        this._suggestedMax = this.parse(options.suggestedMax);\n    }\n    parse(raw, index) {\n        return raw;\n    }\n    getUserBounds() {\n        let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;\n        _userMin = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(_userMin, Number.POSITIVE_INFINITY);\n        _userMax = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(_userMax, Number.NEGATIVE_INFINITY);\n        _suggestedMin = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(_suggestedMin, Number.POSITIVE_INFINITY);\n        _suggestedMax = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(_suggestedMax, Number.NEGATIVE_INFINITY);\n        return {\n            min: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(_userMin, _suggestedMin),\n            max: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(_userMax, _suggestedMax),\n            minDefined: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(_userMin),\n            maxDefined: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(_userMax)\n        };\n    }\n    getMinMax(canStack) {\n        let { min, max, minDefined, maxDefined } = this.getUserBounds();\n        let range;\n        if (minDefined && maxDefined) {\n            return {\n                min,\n                max\n            };\n        }\n        const metas = this.getMatchingVisibleMetas();\n        for(let i = 0, ilen = metas.length; i < ilen; ++i){\n            range = metas[i].controller.getMinMax(this, canStack);\n            if (!minDefined) {\n                min = Math.min(min, range.min);\n            }\n            if (!maxDefined) {\n                max = Math.max(max, range.max);\n            }\n        }\n        min = maxDefined && min > max ? max : min;\n        max = minDefined && min > max ? min : max;\n        return {\n            min: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(min, (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(max, min)),\n            max: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(max, (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(min, max))\n        };\n    }\n    getPadding() {\n        return {\n            left: this.paddingLeft || 0,\n            top: this.paddingTop || 0,\n            right: this.paddingRight || 0,\n            bottom: this.paddingBottom || 0\n        };\n    }\n    getTicks() {\n        return this.ticks;\n    }\n    getLabels() {\n        const data = this.chart.data;\n        return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];\n    }\n    getLabelItems(chartArea = this.chart.chartArea) {\n        const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));\n        return items;\n    }\n    beforeLayout() {\n        this._cache = {};\n        this._dataLimitsCached = false;\n    }\n    beforeUpdate() {\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options.beforeUpdate, [\n            this\n        ]);\n    }\n    update(maxWidth, maxHeight, margins) {\n        const { beginAtZero, grace, ticks: tickOpts } = this.options;\n        const sampleSize = tickOpts.sampleSize;\n        this.beforeUpdate();\n        this.maxWidth = maxWidth;\n        this.maxHeight = maxHeight;\n        this._margins = margins = Object.assign({\n            left: 0,\n            right: 0,\n            top: 0,\n            bottom: 0\n        }, margins);\n        this.ticks = null;\n        this._labelSizes = null;\n        this._gridLineItems = null;\n        this._labelItems = null;\n        this.beforeSetDimensions();\n        this.setDimensions();\n        this.afterSetDimensions();\n        this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;\n        if (!this._dataLimitsCached) {\n            this.beforeDataLimits();\n            this.determineDataLimits();\n            this.afterDataLimits();\n            this._range = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.R)(this, grace, beginAtZero);\n            this._dataLimitsCached = true;\n        }\n        this.beforeBuildTicks();\n        this.ticks = this.buildTicks() || [];\n        this.afterBuildTicks();\n        const samplingEnabled = sampleSize < this.ticks.length;\n        this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);\n        this.configure();\n        this.beforeCalculateLabelRotation();\n        this.calculateLabelRotation();\n        this.afterCalculateLabelRotation();\n        if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto')) {\n            this.ticks = autoSkip(this, this.ticks);\n            this._labelSizes = null;\n            this.afterAutoSkip();\n        }\n        if (samplingEnabled) {\n            this._convertTicksToLabels(this.ticks);\n        }\n        this.beforeFit();\n        this.fit();\n        this.afterFit();\n        this.afterUpdate();\n    }\n    configure() {\n        let reversePixels = this.options.reverse;\n        let startPixel, endPixel;\n        if (this.isHorizontal()) {\n            startPixel = this.left;\n            endPixel = this.right;\n        } else {\n            startPixel = this.top;\n            endPixel = this.bottom;\n            reversePixels = !reversePixels;\n        }\n        this._startPixel = startPixel;\n        this._endPixel = endPixel;\n        this._reversePixels = reversePixels;\n        this._length = endPixel - startPixel;\n        this._alignToPixels = this.options.alignToPixels;\n    }\n    afterUpdate() {\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options.afterUpdate, [\n            this\n        ]);\n    }\n    beforeSetDimensions() {\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options.beforeSetDimensions, [\n            this\n        ]);\n    }\n    setDimensions() {\n        if (this.isHorizontal()) {\n            this.width = this.maxWidth;\n            this.left = 0;\n            this.right = this.width;\n        } else {\n            this.height = this.maxHeight;\n            this.top = 0;\n            this.bottom = this.height;\n        }\n        this.paddingLeft = 0;\n        this.paddingTop = 0;\n        this.paddingRight = 0;\n        this.paddingBottom = 0;\n    }\n    afterSetDimensions() {\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options.afterSetDimensions, [\n            this\n        ]);\n    }\n    _callHooks(name) {\n        this.chart.notifyPlugins(name, this.getContext());\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options[name], [\n            this\n        ]);\n    }\n    beforeDataLimits() {\n        this._callHooks('beforeDataLimits');\n    }\n    determineDataLimits() {}\n    afterDataLimits() {\n        this._callHooks('afterDataLimits');\n    }\n    beforeBuildTicks() {\n        this._callHooks('beforeBuildTicks');\n    }\n    buildTicks() {\n        return [];\n    }\n    afterBuildTicks() {\n        this._callHooks('afterBuildTicks');\n    }\n    beforeTickToLabelConversion() {\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options.beforeTickToLabelConversion, [\n            this\n        ]);\n    }\n    generateTickLabels(ticks) {\n        const tickOpts = this.options.ticks;\n        let i, ilen, tick;\n        for(i = 0, ilen = ticks.length; i < ilen; i++){\n            tick = ticks[i];\n            tick.label = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(tickOpts.callback, [\n                tick.value,\n                i,\n                ticks\n            ], this);\n        }\n    }\n    afterTickToLabelConversion() {\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options.afterTickToLabelConversion, [\n            this\n        ]);\n    }\n    beforeCalculateLabelRotation() {\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options.beforeCalculateLabelRotation, [\n            this\n        ]);\n    }\n    calculateLabelRotation() {\n        const options = this.options;\n        const tickOpts = options.ticks;\n        const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);\n        const minRotation = tickOpts.minRotation || 0;\n        const maxRotation = tickOpts.maxRotation;\n        let labelRotation = minRotation;\n        let tickWidth, maxHeight, maxLabelDiagonal;\n        if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {\n            this.labelRotation = minRotation;\n            return;\n        }\n        const labelSizes = this._getLabelSizes();\n        const maxLabelWidth = labelSizes.widest.width;\n        const maxLabelHeight = labelSizes.highest.height;\n        const maxWidth = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(this.chart.width - maxLabelWidth, 0, this.maxWidth);\n        tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);\n        if (maxLabelWidth + 6 > tickWidth) {\n            tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));\n            maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);\n            maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);\n            labelRotation = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.U)(Math.min(Math.asin((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(maxLabelHeight / maxLabelDiagonal, -1, 1))));\n            labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));\n        }\n        this.labelRotation = labelRotation;\n    }\n    afterCalculateLabelRotation() {\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options.afterCalculateLabelRotation, [\n            this\n        ]);\n    }\n    afterAutoSkip() {}\n    beforeFit() {\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options.beforeFit, [\n            this\n        ]);\n    }\n    fit() {\n        const minSize = {\n            width: 0,\n            height: 0\n        };\n        const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;\n        const display = this._isVisible();\n        const isHorizontal = this.isHorizontal();\n        if (display) {\n            const titleHeight = getTitleHeight(titleOpts, chart.options.font);\n            if (isHorizontal) {\n                minSize.width = this.maxWidth;\n                minSize.height = getTickMarkLength(gridOpts) + titleHeight;\n            } else {\n                minSize.height = this.maxHeight;\n                minSize.width = getTickMarkLength(gridOpts) + titleHeight;\n            }\n            if (tickOpts.display && this.ticks.length) {\n                const { first, last, widest, highest } = this._getLabelSizes();\n                const tickPadding = tickOpts.padding * 2;\n                const angleRadians = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.labelRotation);\n                const cos = Math.cos(angleRadians);\n                const sin = Math.sin(angleRadians);\n                if (isHorizontal) {\n                    const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;\n                    minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);\n                } else {\n                    const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;\n                    minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);\n                }\n                this._calculatePadding(first, last, sin, cos);\n            }\n        }\n        this._handleMargins();\n        if (isHorizontal) {\n            this.width = this._length = chart.width - this._margins.left - this._margins.right;\n            this.height = minSize.height;\n        } else {\n            this.width = minSize.width;\n            this.height = this._length = chart.height - this._margins.top - this._margins.bottom;\n        }\n    }\n    _calculatePadding(first, last, sin, cos) {\n        const { ticks: { align, padding }, position } = this.options;\n        const isRotated = this.labelRotation !== 0;\n        const labelsBelowTicks = position !== 'top' && this.axis === 'x';\n        if (this.isHorizontal()) {\n            const offsetLeft = this.getPixelForTick(0) - this.left;\n            const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);\n            let paddingLeft = 0;\n            let paddingRight = 0;\n            if (isRotated) {\n                if (labelsBelowTicks) {\n                    paddingLeft = cos * first.width;\n                    paddingRight = sin * last.height;\n                } else {\n                    paddingLeft = sin * first.height;\n                    paddingRight = cos * last.width;\n                }\n            } else if (align === 'start') {\n                paddingRight = last.width;\n            } else if (align === 'end') {\n                paddingLeft = first.width;\n            } else if (align !== 'inner') {\n                paddingLeft = first.width / 2;\n                paddingRight = last.width / 2;\n            }\n            this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);\n            this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);\n        } else {\n            let paddingTop = last.height / 2;\n            let paddingBottom = first.height / 2;\n            if (align === 'start') {\n                paddingTop = 0;\n                paddingBottom = first.height;\n            } else if (align === 'end') {\n                paddingTop = last.height;\n                paddingBottom = 0;\n            }\n            this.paddingTop = paddingTop + padding;\n            this.paddingBottom = paddingBottom + padding;\n        }\n    }\n    _handleMargins() {\n        if (this._margins) {\n            this._margins.left = Math.max(this.paddingLeft, this._margins.left);\n            this._margins.top = Math.max(this.paddingTop, this._margins.top);\n            this._margins.right = Math.max(this.paddingRight, this._margins.right);\n            this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);\n        }\n    }\n    afterFit() {\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options.afterFit, [\n            this\n        ]);\n    }\n    isHorizontal() {\n        const { axis, position } = this.options;\n        return position === 'top' || position === 'bottom' || axis === 'x';\n    }\n    isFullSize() {\n        return this.options.fullSize;\n    }\n    _convertTicksToLabels(ticks) {\n        this.beforeTickToLabelConversion();\n        this.generateTickLabels(ticks);\n        let i, ilen;\n        for(i = 0, ilen = ticks.length; i < ilen; i++){\n            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(ticks[i].label)) {\n                ticks.splice(i, 1);\n                ilen--;\n                i--;\n            }\n        }\n        this.afterTickToLabelConversion();\n    }\n    _getLabelSizes() {\n        let labelSizes = this._labelSizes;\n        if (!labelSizes) {\n            const sampleSize = this.options.ticks.sampleSize;\n            let ticks = this.ticks;\n            if (sampleSize < ticks.length) {\n                ticks = sample(ticks, sampleSize);\n            }\n            this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);\n        }\n        return labelSizes;\n    }\n    _computeLabelSizes(ticks, length, maxTicksLimit) {\n        const { ctx, _longestTextCache: caches } = this;\n        const widths = [];\n        const heights = [];\n        const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));\n        let widestLabelSize = 0;\n        let highestLabelSize = 0;\n        let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;\n        for(i = 0; i < length; i += increment){\n            label = ticks[i].label;\n            tickFont = this._resolveTickFontOptions(i);\n            ctx.font = fontString = tickFont.string;\n            cache = caches[fontString] = caches[fontString] || {\n                data: {},\n                gc: []\n            };\n            lineHeight = tickFont.lineHeight;\n            width = height = 0;\n            if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(label) && !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(label)) {\n                width = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.V)(ctx, cache.data, cache.gc, width, label);\n                height = lineHeight;\n            } else if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(label)) {\n                for(j = 0, jlen = label.length; j < jlen; ++j){\n                    nestedLabel = label[j];\n                    if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(nestedLabel) && !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(nestedLabel)) {\n                        width = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.V)(ctx, cache.data, cache.gc, width, nestedLabel);\n                        height += lineHeight;\n                    }\n                }\n            }\n            widths.push(width);\n            heights.push(height);\n            widestLabelSize = Math.max(width, widestLabelSize);\n            highestLabelSize = Math.max(height, highestLabelSize);\n        }\n        garbageCollect(caches, length);\n        const widest = widths.indexOf(widestLabelSize);\n        const highest = heights.indexOf(highestLabelSize);\n        const valueAt = (idx)=>({\n                width: widths[idx] || 0,\n                height: heights[idx] || 0\n            });\n        return {\n            first: valueAt(0),\n            last: valueAt(length - 1),\n            widest: valueAt(widest),\n            highest: valueAt(highest),\n            widths,\n            heights\n        };\n    }\n    getLabelForValue(value) {\n        return value;\n    }\n    getPixelForValue(value, index) {\n        return NaN;\n    }\n    getValueForPixel(pixel) {}\n    getPixelForTick(index) {\n        const ticks = this.ticks;\n        if (index < 0 || index > ticks.length - 1) {\n            return null;\n        }\n        return this.getPixelForValue(ticks[index].value);\n    }\n    getPixelForDecimal(decimal) {\n        if (this._reversePixels) {\n            decimal = 1 - decimal;\n        }\n        const pixel = this._startPixel + decimal * this._length;\n        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.W)(this._alignToPixels ? (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.X)(this.chart, pixel, 0) : pixel);\n    }\n    getDecimalForPixel(pixel) {\n        const decimal = (pixel - this._startPixel) / this._length;\n        return this._reversePixels ? 1 - decimal : decimal;\n    }\n    getBasePixel() {\n        return this.getPixelForValue(this.getBaseValue());\n    }\n    getBaseValue() {\n        const { min, max } = this;\n        return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;\n    }\n    getContext(index) {\n        const ticks = this.ticks || [];\n        if (index >= 0 && index < ticks.length) {\n            const tick = ticks[index];\n            return tick.$context || (tick.$context = createTickContext(this.getContext(), index, tick));\n        }\n        return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));\n    }\n    _tickSize() {\n        const optionTicks = this.options.ticks;\n        const rot = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.labelRotation);\n        const cos = Math.abs(Math.cos(rot));\n        const sin = Math.abs(Math.sin(rot));\n        const labelSizes = this._getLabelSizes();\n        const padding = optionTicks.autoSkipPadding || 0;\n        const w = labelSizes ? labelSizes.widest.width + padding : 0;\n        const h = labelSizes ? labelSizes.highest.height + padding : 0;\n        return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;\n    }\n    _isVisible() {\n        const display = this.options.display;\n        if (display !== 'auto') {\n            return !!display;\n        }\n        return this.getMatchingVisibleMetas().length > 0;\n    }\n    _computeGridLineItems(chartArea) {\n        const axis = this.axis;\n        const chart = this.chart;\n        const options = this.options;\n        const { grid, position, border } = options;\n        const offset = grid.offset;\n        const isHorizontal = this.isHorizontal();\n        const ticks = this.ticks;\n        const ticksLength = ticks.length + (offset ? 1 : 0);\n        const tl = getTickMarkLength(grid);\n        const items = [];\n        const borderOpts = border.setContext(this.getContext());\n        const axisWidth = borderOpts.display ? borderOpts.width : 0;\n        const axisHalfWidth = axisWidth / 2;\n        const alignBorderValue = function(pixel) {\n            return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.X)(chart, pixel, axisWidth);\n        };\n        let borderValue, i, lineValue, alignedLineValue;\n        let tx1, ty1, tx2, ty2, x1, y1, x2, y2;\n        if (position === 'top') {\n            borderValue = alignBorderValue(this.bottom);\n            ty1 = this.bottom - tl;\n            ty2 = borderValue - axisHalfWidth;\n            y1 = alignBorderValue(chartArea.top) + axisHalfWidth;\n            y2 = chartArea.bottom;\n        } else if (position === 'bottom') {\n            borderValue = alignBorderValue(this.top);\n            y1 = chartArea.top;\n            y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;\n            ty1 = borderValue + axisHalfWidth;\n            ty2 = this.top + tl;\n        } else if (position === 'left') {\n            borderValue = alignBorderValue(this.right);\n            tx1 = this.right - tl;\n            tx2 = borderValue - axisHalfWidth;\n            x1 = alignBorderValue(chartArea.left) + axisHalfWidth;\n            x2 = chartArea.right;\n        } else if (position === 'right') {\n            borderValue = alignBorderValue(this.left);\n            x1 = chartArea.left;\n            x2 = alignBorderValue(chartArea.right) - axisHalfWidth;\n            tx1 = borderValue + axisHalfWidth;\n            tx2 = this.left + tl;\n        } else if (axis === 'x') {\n            if (position === 'center') {\n                borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);\n            } else if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n                const positionAxisID = Object.keys(position)[0];\n                const value = position[positionAxisID];\n                borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n            }\n            y1 = chartArea.top;\n            y2 = chartArea.bottom;\n            ty1 = borderValue + axisHalfWidth;\n            ty2 = ty1 + tl;\n        } else if (axis === 'y') {\n            if (position === 'center') {\n                borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);\n            } else if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n                const positionAxisID = Object.keys(position)[0];\n                const value = position[positionAxisID];\n                borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n            }\n            tx1 = borderValue - axisHalfWidth;\n            tx2 = tx1 - tl;\n            x1 = chartArea.left;\n            x2 = chartArea.right;\n        }\n        const limit = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(options.ticks.maxTicksLimit, ticksLength);\n        const step = Math.max(1, Math.ceil(ticksLength / limit));\n        for(i = 0; i < ticksLength; i += step){\n            const context = this.getContext(i);\n            const optsAtIndex = grid.setContext(context);\n            const optsAtIndexBorder = border.setContext(context);\n            const lineWidth = optsAtIndex.lineWidth;\n            const lineColor = optsAtIndex.color;\n            const borderDash = optsAtIndexBorder.dash || [];\n            const borderDashOffset = optsAtIndexBorder.dashOffset;\n            const tickWidth = optsAtIndex.tickWidth;\n            const tickColor = optsAtIndex.tickColor;\n            const tickBorderDash = optsAtIndex.tickBorderDash || [];\n            const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;\n            lineValue = getPixelForGridLine(this, i, offset);\n            if (lineValue === undefined) {\n                continue;\n            }\n            alignedLineValue = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.X)(chart, lineValue, lineWidth);\n            if (isHorizontal) {\n                tx1 = tx2 = x1 = x2 = alignedLineValue;\n            } else {\n                ty1 = ty2 = y1 = y2 = alignedLineValue;\n            }\n            items.push({\n                tx1,\n                ty1,\n                tx2,\n                ty2,\n                x1,\n                y1,\n                x2,\n                y2,\n                width: lineWidth,\n                color: lineColor,\n                borderDash,\n                borderDashOffset,\n                tickWidth,\n                tickColor,\n                tickBorderDash,\n                tickBorderDashOffset\n            });\n        }\n        this._ticksLength = ticksLength;\n        this._borderValue = borderValue;\n        return items;\n    }\n    _computeLabelItems(chartArea) {\n        const axis = this.axis;\n        const options = this.options;\n        const { position, ticks: optionTicks } = options;\n        const isHorizontal = this.isHorizontal();\n        const ticks = this.ticks;\n        const { align, crossAlign, padding, mirror } = optionTicks;\n        const tl = getTickMarkLength(options.grid);\n        const tickAndPadding = tl + padding;\n        const hTickAndPadding = mirror ? -padding : tickAndPadding;\n        const rotation = -(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.labelRotation);\n        const items = [];\n        let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;\n        let textBaseline = 'middle';\n        if (position === 'top') {\n            y = this.bottom - hTickAndPadding;\n            textAlign = this._getXAxisLabelAlignment();\n        } else if (position === 'bottom') {\n            y = this.top + hTickAndPadding;\n            textAlign = this._getXAxisLabelAlignment();\n        } else if (position === 'left') {\n            const ret = this._getYAxisLabelAlignment(tl);\n            textAlign = ret.textAlign;\n            x = ret.x;\n        } else if (position === 'right') {\n            const ret = this._getYAxisLabelAlignment(tl);\n            textAlign = ret.textAlign;\n            x = ret.x;\n        } else if (axis === 'x') {\n            if (position === 'center') {\n                y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;\n            } else if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n                const positionAxisID = Object.keys(position)[0];\n                const value = position[positionAxisID];\n                y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;\n            }\n            textAlign = this._getXAxisLabelAlignment();\n        } else if (axis === 'y') {\n            if (position === 'center') {\n                x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;\n            } else if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n                const positionAxisID = Object.keys(position)[0];\n                const value = position[positionAxisID];\n                x = this.chart.scales[positionAxisID].getPixelForValue(value);\n            }\n            textAlign = this._getYAxisLabelAlignment(tl).textAlign;\n        }\n        if (axis === 'y') {\n            if (align === 'start') {\n                textBaseline = 'top';\n            } else if (align === 'end') {\n                textBaseline = 'bottom';\n            }\n        }\n        const labelSizes = this._getLabelSizes();\n        for(i = 0, ilen = ticks.length; i < ilen; ++i){\n            tick = ticks[i];\n            label = tick.label;\n            const optsAtIndex = optionTicks.setContext(this.getContext(i));\n            pixel = this.getPixelForTick(i) + optionTicks.labelOffset;\n            font = this._resolveTickFontOptions(i);\n            lineHeight = font.lineHeight;\n            lineCount = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(label) ? label.length : 1;\n            const halfCount = lineCount / 2;\n            const color = optsAtIndex.color;\n            const strokeColor = optsAtIndex.textStrokeColor;\n            const strokeWidth = optsAtIndex.textStrokeWidth;\n            let tickTextAlign = textAlign;\n            if (isHorizontal) {\n                x = pixel;\n                if (textAlign === 'inner') {\n                    if (i === ilen - 1) {\n                        tickTextAlign = !this.options.reverse ? 'right' : 'left';\n                    } else if (i === 0) {\n                        tickTextAlign = !this.options.reverse ? 'left' : 'right';\n                    } else {\n                        tickTextAlign = 'center';\n                    }\n                }\n                if (position === 'top') {\n                    if (crossAlign === 'near' || rotation !== 0) {\n                        textOffset = -lineCount * lineHeight + lineHeight / 2;\n                    } else if (crossAlign === 'center') {\n                        textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;\n                    } else {\n                        textOffset = -labelSizes.highest.height + lineHeight / 2;\n                    }\n                } else {\n                    if (crossAlign === 'near' || rotation !== 0) {\n                        textOffset = lineHeight / 2;\n                    } else if (crossAlign === 'center') {\n                        textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;\n                    } else {\n                        textOffset = labelSizes.highest.height - lineCount * lineHeight;\n                    }\n                }\n                if (mirror) {\n                    textOffset *= -1;\n                }\n                if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {\n                    x += lineHeight / 2 * Math.sin(rotation);\n                }\n            } else {\n                y = pixel;\n                textOffset = (1 - lineCount) * lineHeight / 2;\n            }\n            let backdrop;\n            if (optsAtIndex.showLabelBackdrop) {\n                const labelPadding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(optsAtIndex.backdropPadding);\n                const height = labelSizes.heights[i];\n                const width = labelSizes.widths[i];\n                let top = textOffset - labelPadding.top;\n                let left = 0 - labelPadding.left;\n                switch(textBaseline){\n                    case 'middle':\n                        top -= height / 2;\n                        break;\n                    case 'bottom':\n                        top -= height;\n                        break;\n                }\n                switch(textAlign){\n                    case 'center':\n                        left -= width / 2;\n                        break;\n                    case 'right':\n                        left -= width;\n                        break;\n                    case 'inner':\n                        if (i === ilen - 1) {\n                            left -= width;\n                        } else if (i > 0) {\n                            left -= width / 2;\n                        }\n                        break;\n                }\n                backdrop = {\n                    left,\n                    top,\n                    width: width + labelPadding.width,\n                    height: height + labelPadding.height,\n                    color: optsAtIndex.backdropColor\n                };\n            }\n            items.push({\n                label,\n                font,\n                textOffset,\n                options: {\n                    rotation,\n                    color,\n                    strokeColor,\n                    strokeWidth,\n                    textAlign: tickTextAlign,\n                    textBaseline,\n                    translation: [\n                        x,\n                        y\n                    ],\n                    backdrop\n                }\n            });\n        }\n        return items;\n    }\n    _getXAxisLabelAlignment() {\n        const { position, ticks } = this.options;\n        const rotation = -(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.labelRotation);\n        if (rotation) {\n            return position === 'top' ? 'left' : 'right';\n        }\n        let align = 'center';\n        if (ticks.align === 'start') {\n            align = 'left';\n        } else if (ticks.align === 'end') {\n            align = 'right';\n        } else if (ticks.align === 'inner') {\n            align = 'inner';\n        }\n        return align;\n    }\n    _getYAxisLabelAlignment(tl) {\n        const { position, ticks: { crossAlign, mirror, padding } } = this.options;\n        const labelSizes = this._getLabelSizes();\n        const tickAndPadding = tl + padding;\n        const widest = labelSizes.widest.width;\n        let textAlign;\n        let x;\n        if (position === 'left') {\n            if (mirror) {\n                x = this.right + padding;\n                if (crossAlign === 'near') {\n                    textAlign = 'left';\n                } else if (crossAlign === 'center') {\n                    textAlign = 'center';\n                    x += widest / 2;\n                } else {\n                    textAlign = 'right';\n                    x += widest;\n                }\n            } else {\n                x = this.right - tickAndPadding;\n                if (crossAlign === 'near') {\n                    textAlign = 'right';\n                } else if (crossAlign === 'center') {\n                    textAlign = 'center';\n                    x -= widest / 2;\n                } else {\n                    textAlign = 'left';\n                    x = this.left;\n                }\n            }\n        } else if (position === 'right') {\n            if (mirror) {\n                x = this.left + padding;\n                if (crossAlign === 'near') {\n                    textAlign = 'right';\n                } else if (crossAlign === 'center') {\n                    textAlign = 'center';\n                    x -= widest / 2;\n                } else {\n                    textAlign = 'left';\n                    x -= widest;\n                }\n            } else {\n                x = this.left + tickAndPadding;\n                if (crossAlign === 'near') {\n                    textAlign = 'left';\n                } else if (crossAlign === 'center') {\n                    textAlign = 'center';\n                    x += widest / 2;\n                } else {\n                    textAlign = 'right';\n                    x = this.right;\n                }\n            }\n        } else {\n            textAlign = 'right';\n        }\n        return {\n            textAlign,\n            x\n        };\n    }\n    _computeLabelArea() {\n        if (this.options.ticks.mirror) {\n            return;\n        }\n        const chart = this.chart;\n        const position = this.options.position;\n        if (position === 'left' || position === 'right') {\n            return {\n                top: 0,\n                left: this.left,\n                bottom: chart.height,\n                right: this.right\n            };\n        }\n        if (position === 'top' || position === 'bottom') {\n            return {\n                top: this.top,\n                left: 0,\n                bottom: this.bottom,\n                right: chart.width\n            };\n        }\n    }\n    drawBackground() {\n        const { ctx, options: { backgroundColor }, left, top, width, height } = this;\n        if (backgroundColor) {\n            ctx.save();\n            ctx.fillStyle = backgroundColor;\n            ctx.fillRect(left, top, width, height);\n            ctx.restore();\n        }\n    }\n    getLineWidthForValue(value) {\n        const grid = this.options.grid;\n        if (!this._isVisible() || !grid.display) {\n            return 0;\n        }\n        const ticks = this.ticks;\n        const index = ticks.findIndex((t)=>t.value === value);\n        if (index >= 0) {\n            const opts = grid.setContext(this.getContext(index));\n            return opts.lineWidth;\n        }\n        return 0;\n    }\n    drawGrid(chartArea) {\n        const grid = this.options.grid;\n        const ctx = this.ctx;\n        const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));\n        let i, ilen;\n        const drawLine = (p1, p2, style)=>{\n            if (!style.width || !style.color) {\n                return;\n            }\n            ctx.save();\n            ctx.lineWidth = style.width;\n            ctx.strokeStyle = style.color;\n            ctx.setLineDash(style.borderDash || []);\n            ctx.lineDashOffset = style.borderDashOffset;\n            ctx.beginPath();\n            ctx.moveTo(p1.x, p1.y);\n            ctx.lineTo(p2.x, p2.y);\n            ctx.stroke();\n            ctx.restore();\n        };\n        if (grid.display) {\n            for(i = 0, ilen = items.length; i < ilen; ++i){\n                const item = items[i];\n                if (grid.drawOnChartArea) {\n                    drawLine({\n                        x: item.x1,\n                        y: item.y1\n                    }, {\n                        x: item.x2,\n                        y: item.y2\n                    }, item);\n                }\n                if (grid.drawTicks) {\n                    drawLine({\n                        x: item.tx1,\n                        y: item.ty1\n                    }, {\n                        x: item.tx2,\n                        y: item.ty2\n                    }, {\n                        color: item.tickColor,\n                        width: item.tickWidth,\n                        borderDash: item.tickBorderDash,\n                        borderDashOffset: item.tickBorderDashOffset\n                    });\n                }\n            }\n        }\n    }\n    drawBorder() {\n        const { chart, ctx, options: { border, grid } } = this;\n        const borderOpts = border.setContext(this.getContext());\n        const axisWidth = border.display ? borderOpts.width : 0;\n        if (!axisWidth) {\n            return;\n        }\n        const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;\n        const borderValue = this._borderValue;\n        let x1, x2, y1, y2;\n        if (this.isHorizontal()) {\n            x1 = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.X)(chart, this.left, axisWidth) - axisWidth / 2;\n            x2 = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.X)(chart, this.right, lastLineWidth) + lastLineWidth / 2;\n            y1 = y2 = borderValue;\n        } else {\n            y1 = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.X)(chart, this.top, axisWidth) - axisWidth / 2;\n            y2 = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.X)(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;\n            x1 = x2 = borderValue;\n        }\n        ctx.save();\n        ctx.lineWidth = borderOpts.width;\n        ctx.strokeStyle = borderOpts.color;\n        ctx.beginPath();\n        ctx.moveTo(x1, y1);\n        ctx.lineTo(x2, y2);\n        ctx.stroke();\n        ctx.restore();\n    }\n    drawLabels(chartArea) {\n        const optionTicks = this.options.ticks;\n        if (!optionTicks.display) {\n            return;\n        }\n        const ctx = this.ctx;\n        const area = this._computeLabelArea();\n        if (area) {\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Y)(ctx, area);\n        }\n        const items = this.getLabelItems(chartArea);\n        for (const item of items){\n            const renderTextOptions = item.options;\n            const tickFont = item.font;\n            const label = item.label;\n            const y = item.textOffset;\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Z)(ctx, label, 0, y, tickFont, renderTextOptions);\n        }\n        if (area) {\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.$)(ctx);\n        }\n    }\n    drawTitle() {\n        const { ctx, options: { position, title, reverse } } = this;\n        if (!title.display) {\n            return;\n        }\n        const font = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(title.font);\n        const padding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(title.padding);\n        const align = title.align;\n        let offset = font.lineHeight / 2;\n        if (position === 'bottom' || position === 'center' || (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n            offset += padding.bottom;\n            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(title.text)) {\n                offset += font.lineHeight * (title.text.length - 1);\n            }\n        } else {\n            offset += padding.top;\n        }\n        const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset, position, align);\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Z)(ctx, title.text, 0, 0, font, {\n            color: title.color,\n            maxWidth,\n            rotation,\n            textAlign: titleAlign(align, position, reverse),\n            textBaseline: 'middle',\n            translation: [\n                titleX,\n                titleY\n            ]\n        });\n    }\n    draw(chartArea) {\n        if (!this._isVisible()) {\n            return;\n        }\n        this.drawBackground();\n        this.drawGrid(chartArea);\n        this.drawBorder();\n        this.drawTitle();\n        this.drawLabels(chartArea);\n    }\n    _layers() {\n        const opts = this.options;\n        const tz = opts.ticks && opts.ticks.z || 0;\n        const gz = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(opts.grid && opts.grid.z, -1);\n        const bz = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(opts.border && opts.border.z, 0);\n        if (!this._isVisible() || this.draw !== Scale.prototype.draw) {\n            return [\n                {\n                    z: tz,\n                    draw: (chartArea)=>{\n                        this.draw(chartArea);\n                    }\n                }\n            ];\n        }\n        return [\n            {\n                z: gz,\n                draw: (chartArea)=>{\n                    this.drawBackground();\n                    this.drawGrid(chartArea);\n                    this.drawTitle();\n                }\n            },\n            {\n                z: bz,\n                draw: ()=>{\n                    this.drawBorder();\n                }\n            },\n            {\n                z: tz,\n                draw: (chartArea)=>{\n                    this.drawLabels(chartArea);\n                }\n            }\n        ];\n    }\n    getMatchingVisibleMetas(type) {\n        const metas = this.chart.getSortedVisibleDatasetMetas();\n        const axisID = this.axis + 'AxisID';\n        const result = [];\n        let i, ilen;\n        for(i = 0, ilen = metas.length; i < ilen; ++i){\n            const meta = metas[i];\n            if (meta[axisID] === this.id && (!type || meta.type === type)) {\n                result.push(meta);\n            }\n        }\n        return result;\n    }\n    _resolveTickFontOptions(index) {\n        const opts = this.options.ticks.setContext(this.getContext(index));\n        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(opts.font);\n    }\n    _maxDigits() {\n        const fontSize = this._resolveTickFontOptions(0).lineHeight;\n        return (this.isHorizontal() ? this.width : this.height) / fontSize;\n    }\n}\nclass TypedRegistry {\n    constructor(type, scope, override){\n        this.type = type;\n        this.scope = scope;\n        this.override = override;\n        this.items = Object.create(null);\n    }\n    isForType(type) {\n        return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);\n    }\n    register(item) {\n        const proto = Object.getPrototypeOf(item);\n        let parentScope;\n        if (isIChartComponent(proto)) {\n            parentScope = this.register(proto);\n        }\n        const items = this.items;\n        const id = item.id;\n        const scope = this.scope + '.' + id;\n        if (!id) {\n            throw new Error('class does not have id: ' + item);\n        }\n        if (id in items) {\n            return scope;\n        }\n        items[id] = item;\n        registerDefaults(item, scope, parentScope);\n        if (this.override) {\n            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.override(item.id, item.overrides);\n        }\n        return scope;\n    }\n    get(id) {\n        return this.items[id];\n    }\n    unregister(item) {\n        const items = this.items;\n        const id = item.id;\n        const scope = this.scope;\n        if (id in items) {\n            delete items[id];\n        }\n        if (scope && id in _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d[scope]) {\n            delete _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d[scope][id];\n            if (this.override) {\n                delete _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a3[id];\n            }\n        }\n    }\n}\nfunction registerDefaults(item, scope, parentScope) {\n    const itemDefaults = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a4)(Object.create(null), [\n        parentScope ? _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.get(parentScope) : {},\n        _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.get(scope),\n        item.defaults\n    ]);\n    _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.set(scope, itemDefaults);\n    if (item.defaultRoutes) {\n        routeDefaults(scope, item.defaultRoutes);\n    }\n    if (item.descriptors) {\n        _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.describe(scope, item.descriptors);\n    }\n}\nfunction routeDefaults(scope, routes) {\n    Object.keys(routes).forEach((property)=>{\n        const propertyParts = property.split('.');\n        const sourceName = propertyParts.pop();\n        const sourceScope = [\n            scope\n        ].concat(propertyParts).join('.');\n        const parts = routes[property].split('.');\n        const targetName = parts.pop();\n        const targetScope = parts.join('.');\n        _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.route(sourceScope, sourceName, targetScope, targetName);\n    });\n}\nfunction isIChartComponent(proto) {\n    return 'id' in proto && 'defaults' in proto;\n}\nclass Registry {\n    constructor(){\n        this.controllers = new TypedRegistry(DatasetController, 'datasets', true);\n        this.elements = new TypedRegistry(Element, 'elements');\n        this.plugins = new TypedRegistry(Object, 'plugins');\n        this.scales = new TypedRegistry(Scale, 'scales');\n        this._typedRegistries = [\n            this.controllers,\n            this.scales,\n            this.elements\n        ];\n    }\n    add(...args) {\n        this._each('register', args);\n    }\n    remove(...args) {\n        this._each('unregister', args);\n    }\n    addControllers(...args) {\n        this._each('register', args, this.controllers);\n    }\n    addElements(...args) {\n        this._each('register', args, this.elements);\n    }\n    addPlugins(...args) {\n        this._each('register', args, this.plugins);\n    }\n    addScales(...args) {\n        this._each('register', args, this.scales);\n    }\n    getController(id) {\n        return this._get(id, this.controllers, 'controller');\n    }\n    getElement(id) {\n        return this._get(id, this.elements, 'element');\n    }\n    getPlugin(id) {\n        return this._get(id, this.plugins, 'plugin');\n    }\n    getScale(id) {\n        return this._get(id, this.scales, 'scale');\n    }\n    removeControllers(...args) {\n        this._each('unregister', args, this.controllers);\n    }\n    removeElements(...args) {\n        this._each('unregister', args, this.elements);\n    }\n    removePlugins(...args) {\n        this._each('unregister', args, this.plugins);\n    }\n    removeScales(...args) {\n        this._each('unregister', args, this.scales);\n    }\n    _each(method, args, typedRegistry) {\n        [\n            ...args\n        ].forEach((arg)=>{\n            const reg = typedRegistry || this._getRegistryForType(arg);\n            if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {\n                this._exec(method, reg, arg);\n            } else {\n                (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(arg, (item)=>{\n                    const itemReg = typedRegistry || this._getRegistryForType(item);\n                    this._exec(method, itemReg, item);\n                });\n            }\n        });\n    }\n    _exec(method, registry, component) {\n        const camelMethod = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a5)(method);\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(component['before' + camelMethod], [], component);\n        registry[method](component);\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(component['after' + camelMethod], [], component);\n    }\n    _getRegistryForType(type) {\n        for(let i = 0; i < this._typedRegistries.length; i++){\n            const reg = this._typedRegistries[i];\n            if (reg.isForType(type)) {\n                return reg;\n            }\n        }\n        return this.plugins;\n    }\n    _get(id, typedRegistry, type) {\n        const item = typedRegistry.get(id);\n        if (item === undefined) {\n            throw new Error('\"' + id + '\" is not a registered ' + type + '.');\n        }\n        return item;\n    }\n}\nvar registry = /* #__PURE__ */ new Registry();\nclass PluginService {\n    constructor(){\n        this._init = undefined;\n    }\n    notify(chart, hook, args, filter) {\n        if (hook === 'beforeInit') {\n            this._init = this._createDescriptors(chart, true);\n            this._notify(this._init, chart, 'install');\n        }\n        if (this._init === undefined) {\n            return;\n        }\n        const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);\n        const result = this._notify(descriptors, chart, hook, args);\n        if (hook === 'afterDestroy') {\n            this._notify(descriptors, chart, 'stop');\n            this._notify(this._init, chart, 'uninstall');\n            this._init = undefined;\n        }\n        return result;\n    }\n    _notify(descriptors, chart, hook, args) {\n        args = args || {};\n        for (const descriptor of descriptors){\n            const plugin = descriptor.plugin;\n            const method = plugin[hook];\n            const params = [\n                chart,\n                args,\n                descriptor.options\n            ];\n            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(method, params, plugin) === false && args.cancelable) {\n                return false;\n            }\n        }\n        return true;\n    }\n    invalidate() {\n        if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(this._cache)) {\n            this._oldCache = this._cache;\n            this._cache = undefined;\n        }\n    }\n    _descriptors(chart) {\n        if (this._cache) {\n            return this._cache;\n        }\n        const descriptors = this._cache = this._createDescriptors(chart);\n        this._notifyStateChanges(chart);\n        return descriptors;\n    }\n    _createDescriptors(chart, all) {\n        const config = chart && chart.config;\n        const options = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(config.options && config.options.plugins, {});\n        const plugins = allPlugins(config);\n        return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);\n    }\n    _notifyStateChanges(chart) {\n        const previousDescriptors = this._oldCache || [];\n        const descriptors = this._cache;\n        const diff = (a, b)=>a.filter((x)=>!b.some((y)=>x.plugin.id === y.plugin.id));\n        this._notify(diff(previousDescriptors, descriptors), chart, 'stop');\n        this._notify(diff(descriptors, previousDescriptors), chart, 'start');\n    }\n}\nfunction allPlugins(config) {\n    const localIds = {};\n    const plugins = [];\n    const keys = Object.keys(registry.plugins.items);\n    for(let i = 0; i < keys.length; i++){\n        plugins.push(registry.getPlugin(keys[i]));\n    }\n    const local = config.plugins || [];\n    for(let i = 0; i < local.length; i++){\n        const plugin = local[i];\n        if (plugins.indexOf(plugin) === -1) {\n            plugins.push(plugin);\n            localIds[plugin.id] = true;\n        }\n    }\n    return {\n        plugins,\n        localIds\n    };\n}\nfunction getOpts(options, all) {\n    if (!all && options === false) {\n        return null;\n    }\n    if (options === true) {\n        return {};\n    }\n    return options;\n}\nfunction createDescriptors(chart, { plugins, localIds }, options, all) {\n    const result = [];\n    const context = chart.getContext();\n    for (const plugin of plugins){\n        const id = plugin.id;\n        const opts = getOpts(options[id], all);\n        if (opts === null) {\n            continue;\n        }\n        result.push({\n            plugin,\n            options: pluginOpts(chart.config, {\n                plugin,\n                local: localIds[id]\n            }, opts, context)\n        });\n    }\n    return result;\n}\nfunction pluginOpts(config, { plugin, local }, opts, context) {\n    const keys = config.pluginScopeKeys(plugin);\n    const scopes = config.getOptionScopes(opts, keys);\n    if (local && plugin.defaults) {\n        scopes.push(plugin.defaults);\n    }\n    return config.createResolver(scopes, context, [\n        ''\n    ], {\n        scriptable: false,\n        indexable: false,\n        allKeys: true\n    });\n}\nfunction getIndexAxis(type, options) {\n    const datasetDefaults = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.datasets[type] || {};\n    const datasetOptions = (options.datasets || {})[type] || {};\n    return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || 'x';\n}\nfunction getAxisFromDefaultScaleID(id, indexAxis) {\n    let axis = id;\n    if (id === '_index_') {\n        axis = indexAxis;\n    } else if (id === '_value_') {\n        axis = indexAxis === 'x' ? 'y' : 'x';\n    }\n    return axis;\n}\nfunction getDefaultScaleIDFromAxis(axis, indexAxis) {\n    return axis === indexAxis ? '_index_' : '_value_';\n}\nfunction idMatchesAxis(id) {\n    if (id === 'x' || id === 'y' || id === 'r') {\n        return id;\n    }\n}\nfunction axisFromPosition(position) {\n    if (position === 'top' || position === 'bottom') {\n        return 'x';\n    }\n    if (position === 'left' || position === 'right') {\n        return 'y';\n    }\n}\nfunction determineAxis(id, ...scaleOptions) {\n    if (idMatchesAxis(id)) {\n        return id;\n    }\n    for (const opts of scaleOptions){\n        const axis = opts.axis || axisFromPosition(opts.position) || id.length > 1 && idMatchesAxis(id[0].toLowerCase());\n        if (axis) {\n            return axis;\n        }\n    }\n    throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);\n}\nfunction getAxisFromDataset(id, axis, dataset) {\n    if (dataset[axis + 'AxisID'] === id) {\n        return {\n            axis\n        };\n    }\n}\nfunction retrieveAxisFromDatasets(id, config) {\n    if (config.data && config.data.datasets) {\n        const boundDs = config.data.datasets.filter((d)=>d.xAxisID === id || d.yAxisID === id);\n        if (boundDs.length) {\n            return getAxisFromDataset(id, 'x', boundDs[0]) || getAxisFromDataset(id, 'y', boundDs[0]);\n        }\n    }\n    return {};\n}\nfunction mergeScaleConfig(config, options) {\n    const chartDefaults = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a3[config.type] || {\n        scales: {}\n    };\n    const configScales = options.scales || {};\n    const chartIndexAxis = getIndexAxis(config.type, options);\n    const scales = Object.create(null);\n    Object.keys(configScales).forEach((id)=>{\n        const scaleConf = configScales[id];\n        if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(scaleConf)) {\n            return console.error(`Invalid scale configuration for scale: ${id}`);\n        }\n        if (scaleConf._proxy) {\n            return console.warn(`Ignoring resolver passed as options for scale: ${id}`);\n        }\n        const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.scales[scaleConf.type]);\n        const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);\n        const defaultScaleOptions = chartDefaults.scales || {};\n        scales[id] = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ab)(Object.create(null), [\n            {\n                axis\n            },\n            scaleConf,\n            defaultScaleOptions[axis],\n            defaultScaleOptions[defaultId]\n        ]);\n    });\n    config.data.datasets.forEach((dataset)=>{\n        const type = dataset.type || config.type;\n        const indexAxis = dataset.indexAxis || getIndexAxis(type, options);\n        const datasetDefaults = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a3[type] || {};\n        const defaultScaleOptions = datasetDefaults.scales || {};\n        Object.keys(defaultScaleOptions).forEach((defaultID)=>{\n            const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);\n            const id = dataset[axis + 'AxisID'] || axis;\n            scales[id] = scales[id] || Object.create(null);\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ab)(scales[id], [\n                {\n                    axis\n                },\n                configScales[id],\n                defaultScaleOptions[defaultID]\n            ]);\n        });\n    });\n    Object.keys(scales).forEach((key)=>{\n        const scale = scales[key];\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ab)(scale, [\n            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.scales[scale.type],\n            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.scale\n        ]);\n    });\n    return scales;\n}\nfunction initOptions(config) {\n    const options = config.options || (config.options = {});\n    options.plugins = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(options.plugins, {});\n    options.scales = mergeScaleConfig(config, options);\n}\nfunction initData(data) {\n    data = data || {};\n    data.datasets = data.datasets || [];\n    data.labels = data.labels || [];\n    return data;\n}\nfunction initConfig(config) {\n    config = config || {};\n    config.data = initData(config.data);\n    initOptions(config);\n    return config;\n}\nconst keyCache = new Map();\nconst keysCached = new Set();\nfunction cachedKeys(cacheKey, generate) {\n    let keys = keyCache.get(cacheKey);\n    if (!keys) {\n        keys = generate();\n        keyCache.set(cacheKey, keys);\n        keysCached.add(keys);\n    }\n    return keys;\n}\nconst addIfFound = (set, obj, key)=>{\n    const opts = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.f)(obj, key);\n    if (opts !== undefined) {\n        set.add(opts);\n    }\n};\nclass Config {\n    constructor(config){\n        this._config = initConfig(config);\n        this._scopeCache = new Map();\n        this._resolverCache = new Map();\n    }\n    get platform() {\n        return this._config.platform;\n    }\n    get type() {\n        return this._config.type;\n    }\n    set type(type) {\n        this._config.type = type;\n    }\n    get data() {\n        return this._config.data;\n    }\n    set data(data) {\n        this._config.data = initData(data);\n    }\n    get options() {\n        return this._config.options;\n    }\n    set options(options) {\n        this._config.options = options;\n    }\n    get plugins() {\n        return this._config.plugins;\n    }\n    update() {\n        const config = this._config;\n        this.clearCache();\n        initOptions(config);\n    }\n    clearCache() {\n        this._scopeCache.clear();\n        this._resolverCache.clear();\n    }\n    datasetScopeKeys(datasetType) {\n        return cachedKeys(datasetType, ()=>[\n                [\n                    `datasets.${datasetType}`,\n                    ''\n                ]\n            ]);\n    }\n    datasetAnimationScopeKeys(datasetType, transition) {\n        return cachedKeys(`${datasetType}.transition.${transition}`, ()=>[\n                [\n                    `datasets.${datasetType}.transitions.${transition}`,\n                    `transitions.${transition}`\n                ],\n                [\n                    `datasets.${datasetType}`,\n                    ''\n                ]\n            ]);\n    }\n    datasetElementScopeKeys(datasetType, elementType) {\n        return cachedKeys(`${datasetType}-${elementType}`, ()=>[\n                [\n                    `datasets.${datasetType}.elements.${elementType}`,\n                    `datasets.${datasetType}`,\n                    `elements.${elementType}`,\n                    ''\n                ]\n            ]);\n    }\n    pluginScopeKeys(plugin) {\n        const id = plugin.id;\n        const type = this.type;\n        return cachedKeys(`${type}-plugin-${id}`, ()=>[\n                [\n                    `plugins.${id}`,\n                    ...plugin.additionalOptionScopes || []\n                ]\n            ]);\n    }\n    _cachedScopes(mainScope, resetCache) {\n        const _scopeCache = this._scopeCache;\n        let cache = _scopeCache.get(mainScope);\n        if (!cache || resetCache) {\n            cache = new Map();\n            _scopeCache.set(mainScope, cache);\n        }\n        return cache;\n    }\n    getOptionScopes(mainScope, keyLists, resetCache) {\n        const { options, type } = this;\n        const cache = this._cachedScopes(mainScope, resetCache);\n        const cached = cache.get(keyLists);\n        if (cached) {\n            return cached;\n        }\n        const scopes = new Set();\n        keyLists.forEach((keys)=>{\n            if (mainScope) {\n                scopes.add(mainScope);\n                keys.forEach((key)=>addIfFound(scopes, mainScope, key));\n            }\n            keys.forEach((key)=>addIfFound(scopes, options, key));\n            keys.forEach((key)=>addIfFound(scopes, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a3[type] || {}, key));\n            keys.forEach((key)=>addIfFound(scopes, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d, key));\n            keys.forEach((key)=>addIfFound(scopes, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a6, key));\n        });\n        const array = Array.from(scopes);\n        if (array.length === 0) {\n            array.push(Object.create(null));\n        }\n        if (keysCached.has(keyLists)) {\n            cache.set(keyLists, array);\n        }\n        return array;\n    }\n    chartOptionScopes() {\n        const { options, type } = this;\n        return [\n            options,\n            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a3[type] || {},\n            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.datasets[type] || {},\n            {\n                type\n            },\n            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d,\n            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a6\n        ];\n    }\n    resolveNamedOptions(scopes, names, context, prefixes = [\n        ''\n    ]) {\n        const result = {\n            $shared: true\n        };\n        const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);\n        let options = resolver;\n        if (needContext(resolver, names)) {\n            result.$shared = false;\n            context = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a7)(context) ? context() : context;\n            const subResolver = this.createResolver(scopes, context, subPrefixes);\n            options = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a8)(resolver, context, subResolver);\n        }\n        for (const prop of names){\n            result[prop] = options[prop];\n        }\n        return result;\n    }\n    createResolver(scopes, context, prefixes = [\n        ''\n    ], descriptorDefaults) {\n        const { resolver } = getResolver(this._resolverCache, scopes, prefixes);\n        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(context) ? (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a8)(resolver, context, undefined, descriptorDefaults) : resolver;\n    }\n}\nfunction getResolver(resolverCache, scopes, prefixes) {\n    let cache = resolverCache.get(scopes);\n    if (!cache) {\n        cache = new Map();\n        resolverCache.set(scopes, cache);\n    }\n    const cacheKey = prefixes.join();\n    let cached = cache.get(cacheKey);\n    if (!cached) {\n        const resolver = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a9)(scopes, prefixes);\n        cached = {\n            resolver,\n            subPrefixes: prefixes.filter((p)=>!p.toLowerCase().includes('hover'))\n        };\n        cache.set(cacheKey, cached);\n    }\n    return cached;\n}\nconst hasFunction = (value)=>(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(value) && Object.getOwnPropertyNames(value).some((key)=>(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a7)(value[key]));\nfunction needContext(proxy, names) {\n    const { isScriptable, isIndexable } = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aa)(proxy);\n    for (const prop of names){\n        const scriptable = isScriptable(prop);\n        const indexable = isIndexable(prop);\n        const value = (indexable || scriptable) && proxy[prop];\n        if (scriptable && ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a7)(value) || hasFunction(value)) || indexable && (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(value)) {\n            return true;\n        }\n    }\n    return false;\n}\nvar version = \"4.5.1\";\nconst KNOWN_POSITIONS = [\n    'top',\n    'bottom',\n    'left',\n    'right',\n    'chartArea'\n];\nfunction positionIsHorizontal(position, axis) {\n    return position === 'top' || position === 'bottom' || KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x';\n}\nfunction compare2Level(l1, l2) {\n    return function(a, b) {\n        return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];\n    };\n}\nfunction onAnimationsComplete(context) {\n    const chart = context.chart;\n    const animationOptions = chart.options.animation;\n    chart.notifyPlugins('afterRender');\n    (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(animationOptions && animationOptions.onComplete, [\n        context\n    ], chart);\n}\nfunction onAnimationProgress(context) {\n    const chart = context.chart;\n    const animationOptions = chart.options.animation;\n    (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(animationOptions && animationOptions.onProgress, [\n        context\n    ], chart);\n}\nfunction getCanvas(item) {\n    if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.M)() && typeof item === 'string') {\n        item = document.getElementById(item);\n    } else if (item && item.length) {\n        item = item[0];\n    }\n    if (item && item.canvas) {\n        item = item.canvas;\n    }\n    return item;\n}\nconst instances = {};\nconst getChart = (key)=>{\n    const canvas = getCanvas(key);\n    return Object.values(instances).filter((c)=>c.canvas === canvas).pop();\n};\nfunction moveNumericKeys(obj, start, move) {\n    const keys = Object.keys(obj);\n    for (const key of keys){\n        const intKey = +key;\n        if (intKey >= start) {\n            const value = obj[key];\n            delete obj[key];\n            if (move > 0 || intKey > start) {\n                obj[intKey + move] = value;\n            }\n        }\n    }\n}\nfunction determineLastEvent(e, lastEvent, inChartArea, isClick) {\n    if (!inChartArea || e.type === 'mouseout') {\n        return null;\n    }\n    if (isClick) {\n        return lastEvent;\n    }\n    return e;\n}\nclass Chart {\n    static{\n        this.defaults = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d;\n    }\n    static{\n        this.instances = instances;\n    }\n    static{\n        this.overrides = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a3;\n    }\n    static{\n        this.registry = registry;\n    }\n    static{\n        this.version = version;\n    }\n    static{\n        this.getChart = getChart;\n    }\n    static register(...items) {\n        registry.add(...items);\n        invalidatePlugins();\n    }\n    static unregister(...items) {\n        registry.remove(...items);\n        invalidatePlugins();\n    }\n    constructor(item, userConfig){\n        const config = this.config = new Config(userConfig);\n        const initialCanvas = getCanvas(item);\n        const existingChart = getChart(initialCanvas);\n        if (existingChart) {\n            throw new Error('Canvas is already in use. Chart with ID \\'' + existingChart.id + '\\'' + ' must be destroyed before the canvas with ID \\'' + existingChart.canvas.id + '\\' can be reused.');\n        }\n        const options = config.createResolver(config.chartOptionScopes(), this.getContext());\n        this.platform = new (config.platform || _detectPlatform(initialCanvas))();\n        this.platform.updateConfig(config);\n        const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);\n        const canvas = context && context.canvas;\n        const height = canvas && canvas.height;\n        const width = canvas && canvas.width;\n        this.id = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ac)();\n        this.ctx = context;\n        this.canvas = canvas;\n        this.width = width;\n        this.height = height;\n        this._options = options;\n        this._aspectRatio = this.aspectRatio;\n        this._layers = [];\n        this._metasets = [];\n        this._stacks = undefined;\n        this.boxes = [];\n        this.currentDevicePixelRatio = undefined;\n        this.chartArea = undefined;\n        this._active = [];\n        this._lastEvent = undefined;\n        this._listeners = {};\n        this._responsiveListeners = undefined;\n        this._sortedMetasets = [];\n        this.scales = {};\n        this._plugins = new PluginService();\n        this.$proxies = {};\n        this._hiddenIndices = {};\n        this.attached = false;\n        this._animationsDisabled = undefined;\n        this.$context = undefined;\n        this._doResize = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ad)((mode)=>this.update(mode), options.resizeDelay || 0);\n        this._dataChanges = [];\n        instances[this.id] = this;\n        if (!context || !canvas) {\n            console.error(\"Failed to create chart: can't acquire context from the given item\");\n            return;\n        }\n        animator.listen(this, 'complete', onAnimationsComplete);\n        animator.listen(this, 'progress', onAnimationProgress);\n        this._initialize();\n        if (this.attached) {\n            this.update();\n        }\n    }\n    get aspectRatio() {\n        const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;\n        if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(aspectRatio)) {\n            return aspectRatio;\n        }\n        if (maintainAspectRatio && _aspectRatio) {\n            return _aspectRatio;\n        }\n        return height ? width / height : null;\n    }\n    get data() {\n        return this.config.data;\n    }\n    set data(data) {\n        this.config.data = data;\n    }\n    get options() {\n        return this._options;\n    }\n    set options(options) {\n        this.config.options = options;\n    }\n    get registry() {\n        return registry;\n    }\n    _initialize() {\n        this.notifyPlugins('beforeInit');\n        if (this.options.responsive) {\n            this.resize();\n        } else {\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ae)(this, this.options.devicePixelRatio);\n        }\n        this.bindEvents();\n        this.notifyPlugins('afterInit');\n        return this;\n    }\n    clear() {\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.af)(this.canvas, this.ctx);\n        return this;\n    }\n    stop() {\n        animator.stop(this);\n        return this;\n    }\n    resize(width, height) {\n        if (!animator.running(this)) {\n            this._resize(width, height);\n        } else {\n            this._resizeBeforeDraw = {\n                width,\n                height\n            };\n        }\n    }\n    _resize(width, height) {\n        const options = this.options;\n        const canvas = this.canvas;\n        const aspectRatio = options.maintainAspectRatio && this.aspectRatio;\n        const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);\n        const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();\n        const mode = this.width ? 'resize' : 'attach';\n        this.width = newSize.width;\n        this.height = newSize.height;\n        this._aspectRatio = this.aspectRatio;\n        if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ae)(this, newRatio, true)) {\n            return;\n        }\n        this.notifyPlugins('resize', {\n            size: newSize\n        });\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(options.onResize, [\n            this,\n            newSize\n        ], this);\n        if (this.attached) {\n            if (this._doResize(mode)) {\n                this.render();\n            }\n        }\n    }\n    ensureScalesHaveIDs() {\n        const options = this.options;\n        const scalesOptions = options.scales || {};\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(scalesOptions, (axisOptions, axisID)=>{\n            axisOptions.id = axisID;\n        });\n    }\n    buildOrUpdateScales() {\n        const options = this.options;\n        const scaleOpts = options.scales;\n        const scales = this.scales;\n        const updated = Object.keys(scales).reduce((obj, id)=>{\n            obj[id] = false;\n            return obj;\n        }, {});\n        let items = [];\n        if (scaleOpts) {\n            items = items.concat(Object.keys(scaleOpts).map((id)=>{\n                const scaleOptions = scaleOpts[id];\n                const axis = determineAxis(id, scaleOptions);\n                const isRadial = axis === 'r';\n                const isHorizontal = axis === 'x';\n                return {\n                    options: scaleOptions,\n                    dposition: isRadial ? 'chartArea' : isHorizontal ? 'bottom' : 'left',\n                    dtype: isRadial ? 'radialLinear' : isHorizontal ? 'category' : 'linear'\n                };\n            }));\n        }\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(items, (item)=>{\n            const scaleOptions = item.options;\n            const id = scaleOptions.id;\n            const axis = determineAxis(id, scaleOptions);\n            const scaleType = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(scaleOptions.type, item.dtype);\n            if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {\n                scaleOptions.position = item.dposition;\n            }\n            updated[id] = true;\n            let scale = null;\n            if (id in scales && scales[id].type === scaleType) {\n                scale = scales[id];\n            } else {\n                const scaleClass = registry.getScale(scaleType);\n                scale = new scaleClass({\n                    id,\n                    type: scaleType,\n                    ctx: this.ctx,\n                    chart: this\n                });\n                scales[scale.id] = scale;\n            }\n            scale.init(scaleOptions, options);\n        });\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(updated, (hasUpdated, id)=>{\n            if (!hasUpdated) {\n                delete scales[id];\n            }\n        });\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(scales, (scale)=>{\n            layouts.configure(this, scale, scale.options);\n            layouts.addBox(this, scale);\n        });\n    }\n    _updateMetasets() {\n        const metasets = this._metasets;\n        const numData = this.data.datasets.length;\n        const numMeta = metasets.length;\n        metasets.sort((a, b)=>a.index - b.index);\n        if (numMeta > numData) {\n            for(let i = numData; i < numMeta; ++i){\n                this._destroyDatasetMeta(i);\n            }\n            metasets.splice(numData, numMeta - numData);\n        }\n        this._sortedMetasets = metasets.slice(0).sort(compare2Level('order', 'index'));\n    }\n    _removeUnreferencedMetasets() {\n        const { _metasets: metasets, data: { datasets } } = this;\n        if (metasets.length > datasets.length) {\n            delete this._stacks;\n        }\n        metasets.forEach((meta, index)=>{\n            if (datasets.filter((x)=>x === meta._dataset).length === 0) {\n                this._destroyDatasetMeta(index);\n            }\n        });\n    }\n    buildOrUpdateControllers() {\n        const newControllers = [];\n        const datasets = this.data.datasets;\n        let i, ilen;\n        this._removeUnreferencedMetasets();\n        for(i = 0, ilen = datasets.length; i < ilen; i++){\n            const dataset = datasets[i];\n            let meta = this.getDatasetMeta(i);\n            const type = dataset.type || this.config.type;\n            if (meta.type && meta.type !== type) {\n                this._destroyDatasetMeta(i);\n                meta = this.getDatasetMeta(i);\n            }\n            meta.type = type;\n            meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);\n            meta.order = dataset.order || 0;\n            meta.index = i;\n            meta.label = '' + dataset.label;\n            meta.visible = this.isDatasetVisible(i);\n            if (meta.controller) {\n                meta.controller.updateIndex(i);\n                meta.controller.linkScales();\n            } else {\n                const ControllerClass = registry.getController(type);\n                const { datasetElementType, dataElementType } = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.datasets[type];\n                Object.assign(ControllerClass, {\n                    dataElementType: registry.getElement(dataElementType),\n                    datasetElementType: datasetElementType && registry.getElement(datasetElementType)\n                });\n                meta.controller = new ControllerClass(this, i);\n                newControllers.push(meta.controller);\n            }\n        }\n        this._updateMetasets();\n        return newControllers;\n    }\n    _resetElements() {\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(this.data.datasets, (dataset, datasetIndex)=>{\n            this.getDatasetMeta(datasetIndex).controller.reset();\n        }, this);\n    }\n    reset() {\n        this._resetElements();\n        this.notifyPlugins('reset');\n    }\n    update(mode) {\n        const config = this.config;\n        config.update();\n        const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());\n        const animsDisabled = this._animationsDisabled = !options.animation;\n        this._updateScales();\n        this._checkEventBindings();\n        this._updateHiddenIndices();\n        this._plugins.invalidate();\n        if (this.notifyPlugins('beforeUpdate', {\n            mode,\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        const newControllers = this.buildOrUpdateControllers();\n        this.notifyPlugins('beforeElementsUpdate');\n        let minPadding = 0;\n        for(let i = 0, ilen = this.data.datasets.length; i < ilen; i++){\n            const { controller } = this.getDatasetMeta(i);\n            const reset = !animsDisabled && newControllers.indexOf(controller) === -1;\n            controller.buildOrUpdateElements(reset);\n            minPadding = Math.max(+controller.getMaxOverflow(), minPadding);\n        }\n        minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;\n        this._updateLayout(minPadding);\n        if (!animsDisabled) {\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(newControllers, (controller)=>{\n                controller.reset();\n            });\n        }\n        this._updateDatasets(mode);\n        this.notifyPlugins('afterUpdate', {\n            mode\n        });\n        this._layers.sort(compare2Level('z', '_idx'));\n        const { _active, _lastEvent } = this;\n        if (_lastEvent) {\n            this._eventHandler(_lastEvent, true);\n        } else if (_active.length) {\n            this._updateHoverStyles(_active, _active, true);\n        }\n        this.render();\n    }\n    _updateScales() {\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(this.scales, (scale)=>{\n            layouts.removeBox(this, scale);\n        });\n        this.ensureScalesHaveIDs();\n        this.buildOrUpdateScales();\n    }\n    _checkEventBindings() {\n        const options = this.options;\n        const existingEvents = new Set(Object.keys(this._listeners));\n        const newEvents = new Set(options.events);\n        if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ag)(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {\n            this.unbindEvents();\n            this.bindEvents();\n        }\n    }\n    _updateHiddenIndices() {\n        const { _hiddenIndices } = this;\n        const changes = this._getUniformDataChanges() || [];\n        for (const { method, start, count } of changes){\n            const move = method === '_removeElements' ? -count : count;\n            moveNumericKeys(_hiddenIndices, start, move);\n        }\n    }\n    _getUniformDataChanges() {\n        const _dataChanges = this._dataChanges;\n        if (!_dataChanges || !_dataChanges.length) {\n            return;\n        }\n        this._dataChanges = [];\n        const datasetCount = this.data.datasets.length;\n        const makeSet = (idx)=>new Set(_dataChanges.filter((c)=>c[0] === idx).map((c, i)=>i + ',' + c.splice(1).join(',')));\n        const changeSet = makeSet(0);\n        for(let i = 1; i < datasetCount; i++){\n            if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ag)(changeSet, makeSet(i))) {\n                return;\n            }\n        }\n        return Array.from(changeSet).map((c)=>c.split(',')).map((a)=>({\n                method: a[1],\n                start: +a[2],\n                count: +a[3]\n            }));\n    }\n    _updateLayout(minPadding) {\n        if (this.notifyPlugins('beforeLayout', {\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        layouts.update(this, this.width, this.height, minPadding);\n        const area = this.chartArea;\n        const noArea = area.width <= 0 || area.height <= 0;\n        this._layers = [];\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(this.boxes, (box)=>{\n            if (noArea && box.position === 'chartArea') {\n                return;\n            }\n            if (box.configure) {\n                box.configure();\n            }\n            this._layers.push(...box._layers());\n        }, this);\n        this._layers.forEach((item, index)=>{\n            item._idx = index;\n        });\n        this.notifyPlugins('afterLayout');\n    }\n    _updateDatasets(mode) {\n        if (this.notifyPlugins('beforeDatasetsUpdate', {\n            mode,\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        for(let i = 0, ilen = this.data.datasets.length; i < ilen; ++i){\n            this.getDatasetMeta(i).controller.configure();\n        }\n        for(let i = 0, ilen = this.data.datasets.length; i < ilen; ++i){\n            this._updateDataset(i, (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a7)(mode) ? mode({\n                datasetIndex: i\n            }) : mode);\n        }\n        this.notifyPlugins('afterDatasetsUpdate', {\n            mode\n        });\n    }\n    _updateDataset(index, mode) {\n        const meta = this.getDatasetMeta(index);\n        const args = {\n            meta,\n            index,\n            mode,\n            cancelable: true\n        };\n        if (this.notifyPlugins('beforeDatasetUpdate', args) === false) {\n            return;\n        }\n        meta.controller._update(mode);\n        args.cancelable = false;\n        this.notifyPlugins('afterDatasetUpdate', args);\n    }\n    render() {\n        if (this.notifyPlugins('beforeRender', {\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        if (animator.has(this)) {\n            if (this.attached && !animator.running(this)) {\n                animator.start(this);\n            }\n        } else {\n            this.draw();\n            onAnimationsComplete({\n                chart: this\n            });\n        }\n    }\n    draw() {\n        let i;\n        if (this._resizeBeforeDraw) {\n            const { width, height } = this._resizeBeforeDraw;\n            this._resizeBeforeDraw = null;\n            this._resize(width, height);\n        }\n        this.clear();\n        if (this.width <= 0 || this.height <= 0) {\n            return;\n        }\n        if (this.notifyPlugins('beforeDraw', {\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        const layers = this._layers;\n        for(i = 0; i < layers.length && layers[i].z <= 0; ++i){\n            layers[i].draw(this.chartArea);\n        }\n        this._drawDatasets();\n        for(; i < layers.length; ++i){\n            layers[i].draw(this.chartArea);\n        }\n        this.notifyPlugins('afterDraw');\n    }\n    _getSortedDatasetMetas(filterVisible) {\n        const metasets = this._sortedMetasets;\n        const result = [];\n        let i, ilen;\n        for(i = 0, ilen = metasets.length; i < ilen; ++i){\n            const meta = metasets[i];\n            if (!filterVisible || meta.visible) {\n                result.push(meta);\n            }\n        }\n        return result;\n    }\n    getSortedVisibleDatasetMetas() {\n        return this._getSortedDatasetMetas(true);\n    }\n    _drawDatasets() {\n        if (this.notifyPlugins('beforeDatasetsDraw', {\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        const metasets = this.getSortedVisibleDatasetMetas();\n        for(let i = metasets.length - 1; i >= 0; --i){\n            this._drawDataset(metasets[i]);\n        }\n        this.notifyPlugins('afterDatasetsDraw');\n    }\n    _drawDataset(meta) {\n        const ctx = this.ctx;\n        const args = {\n            meta,\n            index: meta.index,\n            cancelable: true\n        };\n        const clip = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ah)(this, meta);\n        if (this.notifyPlugins('beforeDatasetDraw', args) === false) {\n            return;\n        }\n        if (clip) {\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Y)(ctx, clip);\n        }\n        meta.controller.draw();\n        if (clip) {\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.$)(ctx);\n        }\n        args.cancelable = false;\n        this.notifyPlugins('afterDatasetDraw', args);\n    }\n    isPointInArea(point) {\n        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.C)(point, this.chartArea, this._minPadding);\n    }\n    getElementsAtEventForMode(e, mode, options, useFinalPosition) {\n        const method = Interaction.modes[mode];\n        if (typeof method === 'function') {\n            return method(this, e, options, useFinalPosition);\n        }\n        return [];\n    }\n    getDatasetMeta(datasetIndex) {\n        const dataset = this.data.datasets[datasetIndex];\n        const metasets = this._metasets;\n        let meta = metasets.filter((x)=>x && x._dataset === dataset).pop();\n        if (!meta) {\n            meta = {\n                type: null,\n                data: [],\n                dataset: null,\n                controller: null,\n                hidden: null,\n                xAxisID: null,\n                yAxisID: null,\n                order: dataset && dataset.order || 0,\n                index: datasetIndex,\n                _dataset: dataset,\n                _parsed: [],\n                _sorted: false\n            };\n            metasets.push(meta);\n        }\n        return meta;\n    }\n    getContext() {\n        return this.$context || (this.$context = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.j)(null, {\n            chart: this,\n            type: 'chart'\n        }));\n    }\n    getVisibleDatasetCount() {\n        return this.getSortedVisibleDatasetMetas().length;\n    }\n    isDatasetVisible(datasetIndex) {\n        const dataset = this.data.datasets[datasetIndex];\n        if (!dataset) {\n            return false;\n        }\n        const meta = this.getDatasetMeta(datasetIndex);\n        return typeof meta.hidden === 'boolean' ? !meta.hidden : !dataset.hidden;\n    }\n    setDatasetVisibility(datasetIndex, visible) {\n        const meta = this.getDatasetMeta(datasetIndex);\n        meta.hidden = !visible;\n    }\n    toggleDataVisibility(index) {\n        this._hiddenIndices[index] = !this._hiddenIndices[index];\n    }\n    getDataVisibility(index) {\n        return !this._hiddenIndices[index];\n    }\n    _updateVisibility(datasetIndex, dataIndex, visible) {\n        const mode = visible ? 'show' : 'hide';\n        const meta = this.getDatasetMeta(datasetIndex);\n        const anims = meta.controller._resolveAnimations(undefined, mode);\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.h)(dataIndex)) {\n            meta.data[dataIndex].hidden = !visible;\n            this.update();\n        } else {\n            this.setDatasetVisibility(datasetIndex, visible);\n            anims.update(meta, {\n                visible\n            });\n            this.update((ctx)=>ctx.datasetIndex === datasetIndex ? mode : undefined);\n        }\n    }\n    hide(datasetIndex, dataIndex) {\n        this._updateVisibility(datasetIndex, dataIndex, false);\n    }\n    show(datasetIndex, dataIndex) {\n        this._updateVisibility(datasetIndex, dataIndex, true);\n    }\n    _destroyDatasetMeta(datasetIndex) {\n        const meta = this._metasets[datasetIndex];\n        if (meta && meta.controller) {\n            meta.controller._destroy();\n        }\n        delete this._metasets[datasetIndex];\n    }\n    _stop() {\n        let i, ilen;\n        this.stop();\n        animator.remove(this);\n        for(i = 0, ilen = this.data.datasets.length; i < ilen; ++i){\n            this._destroyDatasetMeta(i);\n        }\n    }\n    destroy() {\n        this.notifyPlugins('beforeDestroy');\n        const { canvas, ctx } = this;\n        this._stop();\n        this.config.clearCache();\n        if (canvas) {\n            this.unbindEvents();\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.af)(canvas, ctx);\n            this.platform.releaseContext(ctx);\n            this.canvas = null;\n            this.ctx = null;\n        }\n        delete instances[this.id];\n        this.notifyPlugins('afterDestroy');\n    }\n    toBase64Image(...args) {\n        return this.canvas.toDataURL(...args);\n    }\n    bindEvents() {\n        this.bindUserEvents();\n        if (this.options.responsive) {\n            this.bindResponsiveEvents();\n        } else {\n            this.attached = true;\n        }\n    }\n    bindUserEvents() {\n        const listeners = this._listeners;\n        const platform = this.platform;\n        const _add = (type, listener)=>{\n            platform.addEventListener(this, type, listener);\n            listeners[type] = listener;\n        };\n        const listener = (e, x, y)=>{\n            e.offsetX = x;\n            e.offsetY = y;\n            this._eventHandler(e);\n        };\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(this.options.events, (type)=>_add(type, listener));\n    }\n    bindResponsiveEvents() {\n        if (!this._responsiveListeners) {\n            this._responsiveListeners = {};\n        }\n        const listeners = this._responsiveListeners;\n        const platform = this.platform;\n        const _add = (type, listener)=>{\n            platform.addEventListener(this, type, listener);\n            listeners[type] = listener;\n        };\n        const _remove = (type, listener)=>{\n            if (listeners[type]) {\n                platform.removeEventListener(this, type, listener);\n                delete listeners[type];\n            }\n        };\n        const listener = (width, height)=>{\n            if (this.canvas) {\n                this.resize(width, height);\n            }\n        };\n        let detached;\n        const attached = ()=>{\n            _remove('attach', attached);\n            this.attached = true;\n            this.resize();\n            _add('resize', listener);\n            _add('detach', detached);\n        };\n        detached = ()=>{\n            this.attached = false;\n            _remove('resize', listener);\n            this._stop();\n            this._resize(0, 0);\n            _add('attach', attached);\n        };\n        if (platform.isAttached(this.canvas)) {\n            attached();\n        } else {\n            detached();\n        }\n    }\n    unbindEvents() {\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(this._listeners, (listener, type)=>{\n            this.platform.removeEventListener(this, type, listener);\n        });\n        this._listeners = {};\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(this._responsiveListeners, (listener, type)=>{\n            this.platform.removeEventListener(this, type, listener);\n        });\n        this._responsiveListeners = undefined;\n    }\n    updateHoverStyle(items, mode, enabled) {\n        const prefix = enabled ? 'set' : 'remove';\n        let meta, item, i, ilen;\n        if (mode === 'dataset') {\n            meta = this.getDatasetMeta(items[0].datasetIndex);\n            meta.controller['_' + prefix + 'DatasetHoverStyle']();\n        }\n        for(i = 0, ilen = items.length; i < ilen; ++i){\n            item = items[i];\n            const controller = item && this.getDatasetMeta(item.datasetIndex).controller;\n            if (controller) {\n                controller[prefix + 'HoverStyle'](item.element, item.datasetIndex, item.index);\n            }\n        }\n    }\n    getActiveElements() {\n        return this._active || [];\n    }\n    setActiveElements(activeElements) {\n        const lastActive = this._active || [];\n        const active = activeElements.map(({ datasetIndex, index })=>{\n            const meta = this.getDatasetMeta(datasetIndex);\n            if (!meta) {\n                throw new Error('No dataset found at index ' + datasetIndex);\n            }\n            return {\n                datasetIndex,\n                element: meta.data[index],\n                index\n            };\n        });\n        const changed = !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ai)(active, lastActive);\n        if (changed) {\n            this._active = active;\n            this._lastEvent = null;\n            this._updateHoverStyles(active, lastActive);\n        }\n    }\n    notifyPlugins(hook, args, filter) {\n        return this._plugins.notify(this, hook, args, filter);\n    }\n    isPluginEnabled(pluginId) {\n        return this._plugins._cache.filter((p)=>p.plugin.id === pluginId).length === 1;\n    }\n    _updateHoverStyles(active, lastActive, replay) {\n        const hoverOptions = this.options.hover;\n        const diff = (a, b)=>a.filter((x)=>!b.some((y)=>x.datasetIndex === y.datasetIndex && x.index === y.index));\n        const deactivated = diff(lastActive, active);\n        const activated = replay ? active : diff(active, lastActive);\n        if (deactivated.length) {\n            this.updateHoverStyle(deactivated, hoverOptions.mode, false);\n        }\n        if (activated.length && hoverOptions.mode) {\n            this.updateHoverStyle(activated, hoverOptions.mode, true);\n        }\n    }\n    _eventHandler(e, replay) {\n        const args = {\n            event: e,\n            replay,\n            cancelable: true,\n            inChartArea: this.isPointInArea(e)\n        };\n        const eventFilter = (plugin)=>(plugin.options.events || this.options.events).includes(e.native.type);\n        if (this.notifyPlugins('beforeEvent', args, eventFilter) === false) {\n            return;\n        }\n        const changed = this._handleEvent(e, replay, args.inChartArea);\n        args.cancelable = false;\n        this.notifyPlugins('afterEvent', args, eventFilter);\n        if (changed || args.changed) {\n            this.render();\n        }\n        return this;\n    }\n    _handleEvent(e, replay, inChartArea) {\n        const { _active: lastActive = [], options } = this;\n        const useFinalPosition = replay;\n        const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);\n        const isClick = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aj)(e);\n        const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);\n        if (inChartArea) {\n            this._lastEvent = null;\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(options.onHover, [\n                e,\n                active,\n                this\n            ], this);\n            if (isClick) {\n                (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(options.onClick, [\n                    e,\n                    active,\n                    this\n                ], this);\n            }\n        }\n        const changed = !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ai)(active, lastActive);\n        if (changed || replay) {\n            this._active = active;\n            this._updateHoverStyles(active, lastActive, replay);\n        }\n        this._lastEvent = lastEvent;\n        return changed;\n    }\n    _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {\n        if (e.type === 'mouseout') {\n            return [];\n        }\n        if (!inChartArea) {\n            return lastActive;\n        }\n        const hoverOptions = this.options.hover;\n        return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);\n    }\n}\nfunction invalidatePlugins() {\n    return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(Chart.instances, (chart)=>chart._plugins.invalidate());\n}\nfunction clipSelf(ctx, element, endAngle) {\n    const { startAngle, x, y, outerRadius, innerRadius, options } = element;\n    const { borderWidth, borderJoinStyle } = options;\n    const outerAngleClip = Math.min(borderWidth / outerRadius, (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.al)(startAngle - endAngle));\n    ctx.beginPath();\n    ctx.arc(x, y, outerRadius - borderWidth / 2, startAngle + outerAngleClip / 2, endAngle - outerAngleClip / 2);\n    if (innerRadius > 0) {\n        const innerAngleClip = Math.min(borderWidth / innerRadius, (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.al)(startAngle - endAngle));\n        ctx.arc(x, y, innerRadius + borderWidth / 2, endAngle - innerAngleClip / 2, startAngle + innerAngleClip / 2, true);\n    } else {\n        const clipWidth = Math.min(borderWidth / 2, outerRadius * (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.al)(startAngle - endAngle));\n        if (borderJoinStyle === 'round') {\n            ctx.arc(x, y, clipWidth, endAngle - _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P / 2, startAngle + _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P / 2, true);\n        } else if (borderJoinStyle === 'bevel') {\n            const r = 2 * clipWidth * clipWidth;\n            const endX = -r * Math.cos(endAngle + _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P / 2) + x;\n            const endY = -r * Math.sin(endAngle + _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P / 2) + y;\n            const startX = r * Math.cos(startAngle + _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P / 2) + x;\n            const startY = r * Math.sin(startAngle + _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P / 2) + y;\n            ctx.lineTo(endX, endY);\n            ctx.lineTo(startX, startY);\n        }\n    }\n    ctx.closePath();\n    ctx.moveTo(0, 0);\n    ctx.rect(0, 0, ctx.canvas.width, ctx.canvas.height);\n    ctx.clip('evenodd');\n}\nfunction clipArc(ctx, element, endAngle) {\n    const { startAngle, pixelMargin, x, y, outerRadius, innerRadius } = element;\n    let angleMargin = pixelMargin / outerRadius;\n    // Draw an inner border by clipping the arc and drawing a double-width border\n    // Enlarge the clipping arc by 0.33 pixels to eliminate glitches between borders\n    ctx.beginPath();\n    ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);\n    if (innerRadius > pixelMargin) {\n        angleMargin = pixelMargin / innerRadius;\n        ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);\n    } else {\n        ctx.arc(x, y, pixelMargin, endAngle + _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H, startAngle - _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H);\n    }\n    ctx.closePath();\n    ctx.clip();\n}\nfunction toRadiusCorners(value) {\n    return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.am)(value, [\n        'outerStart',\n        'outerEnd',\n        'innerStart',\n        'innerEnd'\n    ]);\n}\n/**\n * Parse border radius from the provided options\n */ function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {\n    const o = toRadiusCorners(arc.options.borderRadius);\n    const halfThickness = (outerRadius - innerRadius) / 2;\n    const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);\n    // Outer limits are complicated. We want to compute the available angular distance at\n    // a radius of outerRadius - borderRadius because for small angular distances, this term limits.\n    // We compute at r = outerRadius - borderRadius because this circle defines the center of the border corners.\n    //\n    // If the borderRadius is large, that value can become negative.\n    // This causes the outer borders to lose their radius entirely, which is rather unexpected. To solve that, if borderRadius > outerRadius\n    // we know that the thickness term will dominate and compute the limits at that point\n    const computeOuterLimit = (val)=>{\n        const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;\n        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(val, 0, Math.min(halfThickness, outerArcLimit));\n    };\n    return {\n        outerStart: computeOuterLimit(o.outerStart),\n        outerEnd: computeOuterLimit(o.outerEnd),\n        innerStart: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(o.innerStart, 0, innerLimit),\n        innerEnd: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(o.innerEnd, 0, innerLimit)\n    };\n}\n/**\n * Convert (r, ) to (x, y)\n */ function rThetaToXY(r, theta, x, y) {\n    return {\n        x: x + r * Math.cos(theta),\n        y: y + r * Math.sin(theta)\n    };\n}\n/**\n * Path the arc, respecting border radius by separating into left and right halves.\n *\n *   Start      End\n *\n *    1--->a--->2    Outer\n *   /           \\\n *   8           3\n *   |           |\n *   |           |\n *   7           4\n *   \\           /\n *    6<---b<---5    Inner\n */ function pathArc(ctx, element, offset, spacing, end, circular) {\n    const { x, y, startAngle: start, pixelMargin, innerRadius: innerR } = element;\n    const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);\n    const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;\n    let spacingOffset = 0;\n    const alpha = end - start;\n    if (spacing) {\n        // When spacing is present, it is the same for all items\n        // So we adjust the start and end angle of the arc such that\n        // the distance is the same as it would be without the spacing\n        const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;\n        const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;\n        const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;\n        const adjustedAngle = avNogSpacingRadius !== 0 ? alpha * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha;\n        spacingOffset = (alpha - adjustedAngle) / 2;\n    }\n    const beta = Math.max(0.001, alpha * outerRadius - offset / _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P) / outerRadius;\n    const angleOffset = (alpha - beta) / 2;\n    const startAngle = start + angleOffset + spacingOffset;\n    const endAngle = end - angleOffset - spacingOffset;\n    const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);\n    const outerStartAdjustedRadius = outerRadius - outerStart;\n    const outerEndAdjustedRadius = outerRadius - outerEnd;\n    const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;\n    const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;\n    const innerStartAdjustedRadius = innerRadius + innerStart;\n    const innerEndAdjustedRadius = innerRadius + innerEnd;\n    const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;\n    const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;\n    ctx.beginPath();\n    if (circular) {\n        // The first arc segments from point 1 to point a to point 2\n        const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;\n        ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);\n        ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);\n        // The corner segment from point 2 to point 3\n        if (outerEnd > 0) {\n            const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);\n            ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H);\n        }\n        // The line from point 3 to point 4\n        const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);\n        ctx.lineTo(p4.x, p4.y);\n        // The corner segment from point 4 to point 5\n        if (innerEnd > 0) {\n            const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);\n            ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H, innerEndAdjustedAngle + Math.PI);\n        }\n        // The inner arc from point 5 to point b to point 6\n        const innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;\n        ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);\n        ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true);\n        // The corner segment from point 6 to point 7\n        if (innerStart > 0) {\n            const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);\n            ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H);\n        }\n        // The line from point 7 to point 8\n        const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);\n        ctx.lineTo(p8.x, p8.y);\n        // The corner segment from point 8 to point 1\n        if (outerStart > 0) {\n            const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);\n            ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H, outerStartAdjustedAngle);\n        }\n    } else {\n        ctx.moveTo(x, y);\n        const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;\n        const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;\n        ctx.lineTo(outerStartX, outerStartY);\n        const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;\n        const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;\n        ctx.lineTo(outerEndX, outerEndY);\n    }\n    ctx.closePath();\n}\nfunction drawArc(ctx, element, offset, spacing, circular) {\n    const { fullCircles, startAngle, circumference } = element;\n    let endAngle = element.endAngle;\n    if (fullCircles) {\n        pathArc(ctx, element, offset, spacing, endAngle, circular);\n        for(let i = 0; i < fullCircles; ++i){\n            ctx.fill();\n        }\n        if (!isNaN(circumference)) {\n            endAngle = startAngle + (circumference % _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T || _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T);\n        }\n    }\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\n    ctx.fill();\n    return endAngle;\n}\nfunction drawBorder(ctx, element, offset, spacing, circular) {\n    const { fullCircles, startAngle, circumference, options } = element;\n    const { borderWidth, borderJoinStyle, borderDash, borderDashOffset, borderRadius } = options;\n    const inner = options.borderAlign === 'inner';\n    if (!borderWidth) {\n        return;\n    }\n    ctx.setLineDash(borderDash || []);\n    ctx.lineDashOffset = borderDashOffset;\n    if (inner) {\n        ctx.lineWidth = borderWidth * 2;\n        ctx.lineJoin = borderJoinStyle || 'round';\n    } else {\n        ctx.lineWidth = borderWidth;\n        ctx.lineJoin = borderJoinStyle || 'bevel';\n    }\n    let endAngle = element.endAngle;\n    if (fullCircles) {\n        pathArc(ctx, element, offset, spacing, endAngle, circular);\n        for(let i = 0; i < fullCircles; ++i){\n            ctx.stroke();\n        }\n        if (!isNaN(circumference)) {\n            endAngle = startAngle + (circumference % _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T || _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T);\n        }\n    }\n    if (inner) {\n        clipArc(ctx, element, endAngle);\n    }\n    if (options.selfJoin && endAngle - startAngle >= _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P && borderRadius === 0 && borderJoinStyle !== 'miter') {\n        clipSelf(ctx, element, endAngle);\n    }\n    if (!fullCircles) {\n        pathArc(ctx, element, offset, spacing, endAngle, circular);\n        ctx.stroke();\n    }\n}\nclass ArcElement extends Element {\n    static{\n        this.id = 'arc';\n    }\n    static{\n        this.defaults = {\n            borderAlign: 'center',\n            borderColor: '#fff',\n            borderDash: [],\n            borderDashOffset: 0,\n            borderJoinStyle: undefined,\n            borderRadius: 0,\n            borderWidth: 2,\n            offset: 0,\n            spacing: 0,\n            angle: undefined,\n            circular: true,\n            selfJoin: false\n        };\n    }\n    static{\n        this.defaultRoutes = {\n            backgroundColor: 'backgroundColor'\n        };\n    }\n    static{\n        this.descriptors = {\n            _scriptable: true,\n            _indexable: (name)=>name !== 'borderDash'\n        };\n    }\n    constructor(cfg){\n        super();\n        this.options = undefined;\n        this.circumference = undefined;\n        this.startAngle = undefined;\n        this.endAngle = undefined;\n        this.innerRadius = undefined;\n        this.outerRadius = undefined;\n        this.pixelMargin = 0;\n        this.fullCircles = 0;\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n    inRange(chartX, chartY, useFinalPosition) {\n        const point = this.getProps([\n            'x',\n            'y'\n        ], useFinalPosition);\n        const { angle, distance } = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.D)(point, {\n            x: chartX,\n            y: chartY\n        });\n        const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([\n            'startAngle',\n            'endAngle',\n            'innerRadius',\n            'outerRadius',\n            'circumference'\n        ], useFinalPosition);\n        const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;\n        const _circumference = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(circumference, endAngle - startAngle);\n        const nonZeroBetween = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.p)(angle, startAngle, endAngle) && startAngle !== endAngle;\n        const betweenAngles = _circumference >= _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T || nonZeroBetween;\n        const withinRadius = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ak)(distance, innerRadius + rAdjust, outerRadius + rAdjust);\n        return betweenAngles && withinRadius;\n    }\n    getCenterPoint(useFinalPosition) {\n        const { x, y, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([\n            'x',\n            'y',\n            'startAngle',\n            'endAngle',\n            'innerRadius',\n            'outerRadius'\n        ], useFinalPosition);\n        const { offset, spacing } = this.options;\n        const halfAngle = (startAngle + endAngle) / 2;\n        const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;\n        return {\n            x: x + Math.cos(halfAngle) * halfRadius,\n            y: y + Math.sin(halfAngle) * halfRadius\n        };\n    }\n    tooltipPosition(useFinalPosition) {\n        return this.getCenterPoint(useFinalPosition);\n    }\n    draw(ctx) {\n        const { options, circumference } = this;\n        const offset = (options.offset || 0) / 4;\n        const spacing = (options.spacing || 0) / 2;\n        const circular = options.circular;\n        this.pixelMargin = options.borderAlign === 'inner' ? 0.33 : 0;\n        this.fullCircles = circumference > _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T ? Math.floor(circumference / _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T) : 0;\n        if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {\n            return;\n        }\n        ctx.save();\n        const halfAngle = (this.startAngle + this.endAngle) / 2;\n        ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);\n        const fix = 1 - Math.sin(Math.min(_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P, circumference || 0));\n        const radiusOffset = offset * fix;\n        ctx.fillStyle = options.backgroundColor;\n        ctx.strokeStyle = options.borderColor;\n        drawArc(ctx, this, radiusOffset, spacing, circular);\n        drawBorder(ctx, this, radiusOffset, spacing, circular);\n        ctx.restore();\n    }\n}\nfunction setStyle(ctx, options, style = options) {\n    ctx.lineCap = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderCapStyle, options.borderCapStyle);\n    ctx.setLineDash((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderDash, options.borderDash));\n    ctx.lineDashOffset = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderDashOffset, options.borderDashOffset);\n    ctx.lineJoin = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderJoinStyle, options.borderJoinStyle);\n    ctx.lineWidth = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderWidth, options.borderWidth);\n    ctx.strokeStyle = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderColor, options.borderColor);\n}\nfunction lineTo(ctx, previous, target) {\n    ctx.lineTo(target.x, target.y);\n}\nfunction getLineMethod(options) {\n    if (options.stepped) {\n        return _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.at;\n    }\n    if (options.tension || options.cubicInterpolationMode === 'monotone') {\n        return _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.au;\n    }\n    return lineTo;\n}\nfunction pathVars(points, segment, params = {}) {\n    const count = points.length;\n    const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;\n    const { start: segmentStart, end: segmentEnd } = segment;\n    const start = Math.max(paramsStart, segmentStart);\n    const end = Math.min(paramsEnd, segmentEnd);\n    const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;\n    return {\n        count,\n        start,\n        loop: segment.loop,\n        ilen: end < start && !outside ? count + end - start : end - start\n    };\n}\nfunction pathSegment(ctx, line, segment, params) {\n    const { points, options } = line;\n    const { count, start, loop, ilen } = pathVars(points, segment, params);\n    const lineMethod = getLineMethod(options);\n    let { move = true, reverse } = params || {};\n    let i, point, prev;\n    for(i = 0; i <= ilen; ++i){\n        point = points[(start + (reverse ? ilen - i : i)) % count];\n        if (point.skip) {\n            continue;\n        } else if (move) {\n            ctx.moveTo(point.x, point.y);\n            move = false;\n        } else {\n            lineMethod(ctx, prev, point, reverse, options.stepped);\n        }\n        prev = point;\n    }\n    if (loop) {\n        point = points[(start + (reverse ? ilen : 0)) % count];\n        lineMethod(ctx, prev, point, reverse, options.stepped);\n    }\n    return !!loop;\n}\nfunction fastPathSegment(ctx, line, segment, params) {\n    const points = line.points;\n    const { count, start, ilen } = pathVars(points, segment, params);\n    const { move = true, reverse } = params || {};\n    let avgX = 0;\n    let countX = 0;\n    let i, point, prevX, minY, maxY, lastY;\n    const pointIndex = (index)=>(start + (reverse ? ilen - index : index)) % count;\n    const drawX = ()=>{\n        if (minY !== maxY) {\n            ctx.lineTo(avgX, maxY);\n            ctx.lineTo(avgX, minY);\n            ctx.lineTo(avgX, lastY);\n        }\n    };\n    if (move) {\n        point = points[pointIndex(0)];\n        ctx.moveTo(point.x, point.y);\n    }\n    for(i = 0; i <= ilen; ++i){\n        point = points[pointIndex(i)];\n        if (point.skip) {\n            continue;\n        }\n        const x = point.x;\n        const y = point.y;\n        const truncX = x | 0;\n        if (truncX === prevX) {\n            if (y < minY) {\n                minY = y;\n            } else if (y > maxY) {\n                maxY = y;\n            }\n            avgX = (countX * avgX + x) / ++countX;\n        } else {\n            drawX();\n            ctx.lineTo(x, y);\n            prevX = truncX;\n            countX = 0;\n            minY = maxY = y;\n        }\n        lastY = y;\n    }\n    drawX();\n}\nfunction _getSegmentMethod(line) {\n    const opts = line.options;\n    const borderDash = opts.borderDash && opts.borderDash.length;\n    const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== 'monotone' && !opts.stepped && !borderDash;\n    return useFastPath ? fastPathSegment : pathSegment;\n}\nfunction _getInterpolationMethod(options) {\n    if (options.stepped) {\n        return _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aq;\n    }\n    if (options.tension || options.cubicInterpolationMode === 'monotone') {\n        return _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ar;\n    }\n    return _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.as;\n}\nfunction strokePathWithCache(ctx, line, start, count) {\n    let path = line._path;\n    if (!path) {\n        path = line._path = new Path2D();\n        if (line.path(path, start, count)) {\n            path.closePath();\n        }\n    }\n    setStyle(ctx, line.options);\n    ctx.stroke(path);\n}\nfunction strokePathDirect(ctx, line, start, count) {\n    const { segments, options } = line;\n    const segmentMethod = _getSegmentMethod(line);\n    for (const segment of segments){\n        setStyle(ctx, options, segment.style);\n        ctx.beginPath();\n        if (segmentMethod(ctx, line, segment, {\n            start,\n            end: start + count - 1\n        })) {\n            ctx.closePath();\n        }\n        ctx.stroke();\n    }\n}\nconst usePath2D = typeof Path2D === 'function';\nfunction draw(ctx, line, start, count) {\n    if (usePath2D && !line.options.segment) {\n        strokePathWithCache(ctx, line, start, count);\n    } else {\n        strokePathDirect(ctx, line, start, count);\n    }\n}\nclass LineElement extends Element {\n    static{\n        this.id = 'line';\n    }\n    static{\n        this.defaults = {\n            borderCapStyle: 'butt',\n            borderDash: [],\n            borderDashOffset: 0,\n            borderJoinStyle: 'miter',\n            borderWidth: 3,\n            capBezierPoints: true,\n            cubicInterpolationMode: 'default',\n            fill: false,\n            spanGaps: false,\n            stepped: false,\n            tension: 0\n        };\n    }\n    static{\n        this.defaultRoutes = {\n            backgroundColor: 'backgroundColor',\n            borderColor: 'borderColor'\n        };\n    }\n    static{\n        this.descriptors = {\n            _scriptable: true,\n            _indexable: (name)=>name !== 'borderDash' && name !== 'fill'\n        };\n    }\n    constructor(cfg){\n        super();\n        this.animated = true;\n        this.options = undefined;\n        this._chart = undefined;\n        this._loop = undefined;\n        this._fullLoop = undefined;\n        this._path = undefined;\n        this._points = undefined;\n        this._segments = undefined;\n        this._decimated = false;\n        this._pointsUpdated = false;\n        this._datasetIndex = undefined;\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n    updateControlPoints(chartArea, indexAxis) {\n        const options = this.options;\n        if ((options.tension || options.cubicInterpolationMode === 'monotone') && !options.stepped && !this._pointsUpdated) {\n            const loop = options.spanGaps ? this._loop : this._fullLoop;\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.an)(this._points, options, chartArea, loop, indexAxis);\n            this._pointsUpdated = true;\n        }\n    }\n    set points(points) {\n        this._points = points;\n        delete this._segments;\n        delete this._path;\n        this._pointsUpdated = false;\n    }\n    get points() {\n        return this._points;\n    }\n    get segments() {\n        return this._segments || (this._segments = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ao)(this, this.options.segment));\n    }\n    first() {\n        const segments = this.segments;\n        const points = this.points;\n        return segments.length && points[segments[0].start];\n    }\n    last() {\n        const segments = this.segments;\n        const points = this.points;\n        const count = segments.length;\n        return count && points[segments[count - 1].end];\n    }\n    interpolate(point, property) {\n        const options = this.options;\n        const value = point[property];\n        const points = this.points;\n        const segments = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ap)(this, {\n            property,\n            start: value,\n            end: value\n        });\n        if (!segments.length) {\n            return;\n        }\n        const result = [];\n        const _interpolate = _getInterpolationMethod(options);\n        let i, ilen;\n        for(i = 0, ilen = segments.length; i < ilen; ++i){\n            const { start, end } = segments[i];\n            const p1 = points[start];\n            const p2 = points[end];\n            if (p1 === p2) {\n                result.push(p1);\n                continue;\n            }\n            const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));\n            const interpolated = _interpolate(p1, p2, t, options.stepped);\n            interpolated[property] = point[property];\n            result.push(interpolated);\n        }\n        return result.length === 1 ? result[0] : result;\n    }\n    pathSegment(ctx, segment, params) {\n        const segmentMethod = _getSegmentMethod(this);\n        return segmentMethod(ctx, this, segment, params);\n    }\n    path(ctx, start, count) {\n        const segments = this.segments;\n        const segmentMethod = _getSegmentMethod(this);\n        let loop = this._loop;\n        start = start || 0;\n        count = count || this.points.length - start;\n        for (const segment of segments){\n            loop &= segmentMethod(ctx, this, segment, {\n                start,\n                end: start + count - 1\n            });\n        }\n        return !!loop;\n    }\n    draw(ctx, chartArea, start, count) {\n        const options = this.options || {};\n        const points = this.points || [];\n        if (points.length && options.borderWidth) {\n            ctx.save();\n            draw(ctx, this, start, count);\n            ctx.restore();\n        }\n        if (this.animated) {\n            this._pointsUpdated = false;\n            this._path = undefined;\n        }\n    }\n}\nfunction inRange$1(el, pos, axis, useFinalPosition) {\n    const options = el.options;\n    const { [axis]: value } = el.getProps([\n        axis\n    ], useFinalPosition);\n    return Math.abs(pos - value) < options.radius + options.hitRadius;\n}\nclass PointElement extends Element {\n    static{\n        this.id = 'point';\n    }\n    static{\n        /**\n   * @type {any}\n   */ this.defaults = {\n            borderWidth: 1,\n            hitRadius: 1,\n            hoverBorderWidth: 1,\n            hoverRadius: 4,\n            pointStyle: 'circle',\n            radius: 3,\n            rotation: 0\n        };\n    }\n    static{\n        /**\n   * @type {any}\n   */ this.defaultRoutes = {\n            backgroundColor: 'backgroundColor',\n            borderColor: 'borderColor'\n        };\n    }\n    constructor(cfg){\n        super();\n        this.options = undefined;\n        this.parsed = undefined;\n        this.skip = undefined;\n        this.stop = undefined;\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n    inRange(mouseX, mouseY, useFinalPosition) {\n        const options = this.options;\n        const { x, y } = this.getProps([\n            'x',\n            'y'\n        ], useFinalPosition);\n        return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);\n    }\n    inXRange(mouseX, useFinalPosition) {\n        return inRange$1(this, mouseX, 'x', useFinalPosition);\n    }\n    inYRange(mouseY, useFinalPosition) {\n        return inRange$1(this, mouseY, 'y', useFinalPosition);\n    }\n    getCenterPoint(useFinalPosition) {\n        const { x, y } = this.getProps([\n            'x',\n            'y'\n        ], useFinalPosition);\n        return {\n            x,\n            y\n        };\n    }\n    size(options) {\n        options = options || this.options || {};\n        let radius = options.radius || 0;\n        radius = Math.max(radius, radius && options.hoverRadius || 0);\n        const borderWidth = radius && options.borderWidth || 0;\n        return (radius + borderWidth) * 2;\n    }\n    draw(ctx, area) {\n        const options = this.options;\n        if (this.skip || options.radius < 0.1 || !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.C)(this, area, this.size(options) / 2)) {\n            return;\n        }\n        ctx.strokeStyle = options.borderColor;\n        ctx.lineWidth = options.borderWidth;\n        ctx.fillStyle = options.backgroundColor;\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.av)(ctx, options, this.x, this.y);\n    }\n    getRange() {\n        const options = this.options || {};\n        // @ts-expect-error Fallbacks should never be hit in practice\n        return options.radius + options.hitRadius;\n    }\n}\nfunction getBarBounds(bar, useFinalPosition) {\n    const { x, y, base, width, height } = bar.getProps([\n        'x',\n        'y',\n        'base',\n        'width',\n        'height'\n    ], useFinalPosition);\n    let left, right, top, bottom, half;\n    if (bar.horizontal) {\n        half = height / 2;\n        left = Math.min(x, base);\n        right = Math.max(x, base);\n        top = y - half;\n        bottom = y + half;\n    } else {\n        half = width / 2;\n        left = x - half;\n        right = x + half;\n        top = Math.min(y, base);\n        bottom = Math.max(y, base);\n    }\n    return {\n        left,\n        top,\n        right,\n        bottom\n    };\n}\nfunction skipOrLimit(skip, value, min, max) {\n    return skip ? 0 : (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(value, min, max);\n}\nfunction parseBorderWidth(bar, maxW, maxH) {\n    const value = bar.options.borderWidth;\n    const skip = bar.borderSkipped;\n    const o = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ax)(value);\n    return {\n        t: skipOrLimit(skip.top, o.top, 0, maxH),\n        r: skipOrLimit(skip.right, o.right, 0, maxW),\n        b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),\n        l: skipOrLimit(skip.left, o.left, 0, maxW)\n    };\n}\nfunction parseBorderRadius(bar, maxW, maxH) {\n    const { enableBorderRadius } = bar.getProps([\n        'enableBorderRadius'\n    ]);\n    const value = bar.options.borderRadius;\n    const o = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ay)(value);\n    const maxR = Math.min(maxW, maxH);\n    const skip = bar.borderSkipped;\n    const enableBorder = enableBorderRadius || (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(value);\n    return {\n        topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),\n        topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),\n        bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),\n        bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)\n    };\n}\nfunction boundingRects(bar) {\n    const bounds = getBarBounds(bar);\n    const width = bounds.right - bounds.left;\n    const height = bounds.bottom - bounds.top;\n    const border = parseBorderWidth(bar, width / 2, height / 2);\n    const radius = parseBorderRadius(bar, width / 2, height / 2);\n    return {\n        outer: {\n            x: bounds.left,\n            y: bounds.top,\n            w: width,\n            h: height,\n            radius\n        },\n        inner: {\n            x: bounds.left + border.l,\n            y: bounds.top + border.t,\n            w: width - border.l - border.r,\n            h: height - border.t - border.b,\n            radius: {\n                topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),\n                topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),\n                bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),\n                bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))\n            }\n        }\n    };\n}\nfunction inRange(bar, x, y, useFinalPosition) {\n    const skipX = x === null;\n    const skipY = y === null;\n    const skipBoth = skipX && skipY;\n    const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);\n    return bounds && (skipX || (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ak)(x, bounds.left, bounds.right)) && (skipY || (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ak)(y, bounds.top, bounds.bottom));\n}\nfunction hasRadius(radius) {\n    return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;\n}\nfunction addNormalRectPath(ctx, rect) {\n    ctx.rect(rect.x, rect.y, rect.w, rect.h);\n}\nfunction inflateRect(rect, amount, refRect = {}) {\n    const x = rect.x !== refRect.x ? -amount : 0;\n    const y = rect.y !== refRect.y ? -amount : 0;\n    const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;\n    const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;\n    return {\n        x: rect.x + x,\n        y: rect.y + y,\n        w: rect.w + w,\n        h: rect.h + h,\n        radius: rect.radius\n    };\n}\nclass BarElement extends Element {\n    static{\n        this.id = 'bar';\n    }\n    static{\n        this.defaults = {\n            borderSkipped: 'start',\n            borderWidth: 0,\n            borderRadius: 0,\n            inflateAmount: 'auto',\n            pointStyle: undefined\n        };\n    }\n    static{\n        this.defaultRoutes = {\n            backgroundColor: 'backgroundColor',\n            borderColor: 'borderColor'\n        };\n    }\n    constructor(cfg){\n        super();\n        this.options = undefined;\n        this.horizontal = undefined;\n        this.base = undefined;\n        this.width = undefined;\n        this.height = undefined;\n        this.inflateAmount = undefined;\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n    draw(ctx) {\n        const { inflateAmount, options: { borderColor, backgroundColor } } = this;\n        const { inner, outer } = boundingRects(this);\n        const addRectPath = hasRadius(outer.radius) ? _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aw : addNormalRectPath;\n        ctx.save();\n        if (outer.w !== inner.w || outer.h !== inner.h) {\n            ctx.beginPath();\n            addRectPath(ctx, inflateRect(outer, inflateAmount, inner));\n            ctx.clip();\n            addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));\n            ctx.fillStyle = borderColor;\n            ctx.fill('evenodd');\n        }\n        ctx.beginPath();\n        addRectPath(ctx, inflateRect(inner, inflateAmount));\n        ctx.fillStyle = backgroundColor;\n        ctx.fill();\n        ctx.restore();\n    }\n    inRange(mouseX, mouseY, useFinalPosition) {\n        return inRange(this, mouseX, mouseY, useFinalPosition);\n    }\n    inXRange(mouseX, useFinalPosition) {\n        return inRange(this, mouseX, null, useFinalPosition);\n    }\n    inYRange(mouseY, useFinalPosition) {\n        return inRange(this, null, mouseY, useFinalPosition);\n    }\n    getCenterPoint(useFinalPosition) {\n        const { x, y, base, horizontal } = this.getProps([\n            'x',\n            'y',\n            'base',\n            'horizontal'\n        ], useFinalPosition);\n        return {\n            x: horizontal ? (x + base) / 2 : x,\n            y: horizontal ? y : (y + base) / 2\n        };\n    }\n    getRange(axis) {\n        return axis === 'x' ? this.width / 2 : this.height / 2;\n    }\n}\nvar elements = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    ArcElement: ArcElement,\n    BarElement: BarElement,\n    LineElement: LineElement,\n    PointElement: PointElement\n});\nconst BORDER_COLORS = [\n    'rgb(54, 162, 235)',\n    'rgb(255, 99, 132)',\n    'rgb(255, 159, 64)',\n    'rgb(255, 205, 86)',\n    'rgb(75, 192, 192)',\n    'rgb(153, 102, 255)',\n    'rgb(201, 203, 207)' // grey\n];\n// Border colors with 50% transparency\nconst BACKGROUND_COLORS = /* #__PURE__ */ BORDER_COLORS.map((color)=>color.replace('rgb(', 'rgba(').replace(')', ', 0.5)'));\nfunction getBorderColor(i) {\n    return BORDER_COLORS[i % BORDER_COLORS.length];\n}\nfunction getBackgroundColor(i) {\n    return BACKGROUND_COLORS[i % BACKGROUND_COLORS.length];\n}\nfunction colorizeDefaultDataset(dataset, i) {\n    dataset.borderColor = getBorderColor(i);\n    dataset.backgroundColor = getBackgroundColor(i);\n    return ++i;\n}\nfunction colorizeDoughnutDataset(dataset, i) {\n    dataset.backgroundColor = dataset.data.map(()=>getBorderColor(i++));\n    return i;\n}\nfunction colorizePolarAreaDataset(dataset, i) {\n    dataset.backgroundColor = dataset.data.map(()=>getBackgroundColor(i++));\n    return i;\n}\nfunction getColorizer(chart) {\n    let i = 0;\n    return (dataset, datasetIndex)=>{\n        const controller = chart.getDatasetMeta(datasetIndex).controller;\n        if (controller instanceof DoughnutController) {\n            i = colorizeDoughnutDataset(dataset, i);\n        } else if (controller instanceof PolarAreaController) {\n            i = colorizePolarAreaDataset(dataset, i);\n        } else if (controller) {\n            i = colorizeDefaultDataset(dataset, i);\n        }\n    };\n}\nfunction containsColorsDefinitions(descriptors) {\n    let k;\n    for(k in descriptors){\n        if (descriptors[k].borderColor || descriptors[k].backgroundColor) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction containsColorsDefinition(descriptor) {\n    return descriptor && (descriptor.borderColor || descriptor.backgroundColor);\n}\nfunction containsDefaultColorsDefenitions() {\n    return _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.borderColor !== 'rgba(0,0,0,0.1)' || _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.backgroundColor !== 'rgba(0,0,0,0.1)';\n}\nvar plugin_colors = {\n    id: 'colors',\n    defaults: {\n        enabled: true,\n        forceOverride: false\n    },\n    beforeLayout (chart, _args, options) {\n        if (!options.enabled) {\n            return;\n        }\n        const { data: { datasets }, options: chartOptions } = chart.config;\n        const { elements } = chartOptions;\n        const containsColorDefenition = containsColorsDefinitions(datasets) || containsColorsDefinition(chartOptions) || elements && containsColorsDefinitions(elements) || containsDefaultColorsDefenitions();\n        if (!options.forceOverride && containsColorDefenition) {\n            return;\n        }\n        const colorizer = getColorizer(chart);\n        datasets.forEach(colorizer);\n    }\n};\nfunction lttbDecimation(data, start, count, availableWidth, options) {\n    const samples = options.samples || availableWidth;\n    if (samples >= count) {\n        return data.slice(start, start + count);\n    }\n    const decimated = [];\n    const bucketWidth = (count - 2) / (samples - 2);\n    let sampledIndex = 0;\n    const endIndex = start + count - 1;\n    let a = start;\n    let i, maxAreaPoint, maxArea, area, nextA;\n    decimated[sampledIndex++] = data[a];\n    for(i = 0; i < samples - 2; i++){\n        let avgX = 0;\n        let avgY = 0;\n        let j;\n        const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;\n        const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;\n        const avgRangeLength = avgRangeEnd - avgRangeStart;\n        for(j = avgRangeStart; j < avgRangeEnd; j++){\n            avgX += data[j].x;\n            avgY += data[j].y;\n        }\n        avgX /= avgRangeLength;\n        avgY /= avgRangeLength;\n        const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;\n        const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;\n        const { x: pointAx, y: pointAy } = data[a];\n        maxArea = area = -1;\n        for(j = rangeOffs; j < rangeTo; j++){\n            area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));\n            if (area > maxArea) {\n                maxArea = area;\n                maxAreaPoint = data[j];\n                nextA = j;\n            }\n        }\n        decimated[sampledIndex++] = maxAreaPoint;\n        a = nextA;\n    }\n    decimated[sampledIndex++] = data[endIndex];\n    return decimated;\n}\nfunction minMaxDecimation(data, start, count, availableWidth) {\n    let avgX = 0;\n    let countX = 0;\n    let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;\n    const decimated = [];\n    const endIndex = start + count - 1;\n    const xMin = data[start].x;\n    const xMax = data[endIndex].x;\n    const dx = xMax - xMin;\n    for(i = start; i < start + count; ++i){\n        point = data[i];\n        x = (point.x - xMin) / dx * availableWidth;\n        y = point.y;\n        const truncX = x | 0;\n        if (truncX === prevX) {\n            if (y < minY) {\n                minY = y;\n                minIndex = i;\n            } else if (y > maxY) {\n                maxY = y;\n                maxIndex = i;\n            }\n            avgX = (countX * avgX + point.x) / ++countX;\n        } else {\n            const lastIndex = i - 1;\n            if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(minIndex) && !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(maxIndex)) {\n                const intermediateIndex1 = Math.min(minIndex, maxIndex);\n                const intermediateIndex2 = Math.max(minIndex, maxIndex);\n                if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {\n                    decimated.push({\n                        ...data[intermediateIndex1],\n                        x: avgX\n                    });\n                }\n                if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {\n                    decimated.push({\n                        ...data[intermediateIndex2],\n                        x: avgX\n                    });\n                }\n            }\n            if (i > 0 && lastIndex !== startIndex) {\n                decimated.push(data[lastIndex]);\n            }\n            decimated.push(point);\n            prevX = truncX;\n            countX = 0;\n            minY = maxY = y;\n            minIndex = maxIndex = startIndex = i;\n        }\n    }\n    return decimated;\n}\nfunction cleanDecimatedDataset(dataset) {\n    if (dataset._decimated) {\n        const data = dataset._data;\n        delete dataset._decimated;\n        delete dataset._data;\n        Object.defineProperty(dataset, 'data', {\n            configurable: true,\n            enumerable: true,\n            writable: true,\n            value: data\n        });\n    }\n}\nfunction cleanDecimatedData(chart) {\n    chart.data.datasets.forEach((dataset)=>{\n        cleanDecimatedDataset(dataset);\n    });\n}\nfunction getStartAndCountOfVisiblePointsSimplified(meta, points) {\n    const pointCount = points.length;\n    let start = 0;\n    let count;\n    const { iScale } = meta;\n    const { min, max, minDefined, maxDefined } = iScale.getUserBounds();\n    if (minDefined) {\n        start = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.B)(points, iScale.axis, min).lo, 0, pointCount - 1);\n    }\n    if (maxDefined) {\n        count = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.B)(points, iScale.axis, max).hi + 1, start, pointCount) - start;\n    } else {\n        count = pointCount - start;\n    }\n    return {\n        start,\n        count\n    };\n}\nvar plugin_decimation = {\n    id: 'decimation',\n    defaults: {\n        algorithm: 'min-max',\n        enabled: false\n    },\n    beforeElementsUpdate: (chart, args, options)=>{\n        if (!options.enabled) {\n            cleanDecimatedData(chart);\n            return;\n        }\n        const availableWidth = chart.width;\n        chart.data.datasets.forEach((dataset, datasetIndex)=>{\n            const { _data, indexAxis } = dataset;\n            const meta = chart.getDatasetMeta(datasetIndex);\n            const data = _data || dataset.data;\n            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a)([\n                indexAxis,\n                chart.options.indexAxis\n            ]) === 'y') {\n                return;\n            }\n            if (!meta.controller.supportsDecimation) {\n                return;\n            }\n            const xAxis = chart.scales[meta.xAxisID];\n            if (xAxis.type !== 'linear' && xAxis.type !== 'time') {\n                return;\n            }\n            if (chart.options.parsing) {\n                return;\n            }\n            let { start, count } = getStartAndCountOfVisiblePointsSimplified(meta, data);\n            const threshold = options.threshold || 4 * availableWidth;\n            if (count <= threshold) {\n                cleanDecimatedDataset(dataset);\n                return;\n            }\n            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(_data)) {\n                dataset._data = data;\n                delete dataset.data;\n                Object.defineProperty(dataset, 'data', {\n                    configurable: true,\n                    enumerable: true,\n                    get: function() {\n                        return this._decimated;\n                    },\n                    set: function(d) {\n                        this._data = d;\n                    }\n                });\n            }\n            let decimated;\n            switch(options.algorithm){\n                case 'lttb':\n                    decimated = lttbDecimation(data, start, count, availableWidth, options);\n                    break;\n                case 'min-max':\n                    decimated = minMaxDecimation(data, start, count, availableWidth);\n                    break;\n                default:\n                    throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);\n            }\n            dataset._decimated = decimated;\n        });\n    },\n    destroy (chart) {\n        cleanDecimatedData(chart);\n    }\n};\nfunction _segments(line, target, property) {\n    const segments = line.segments;\n    const points = line.points;\n    const tpoints = target.points;\n    const parts = [];\n    for (const segment of segments){\n        let { start, end } = segment;\n        end = _findSegmentEnd(start, end, points);\n        const bounds = _getBounds(property, points[start], points[end], segment.loop);\n        if (!target.segments) {\n            parts.push({\n                source: segment,\n                target: bounds,\n                start: points[start],\n                end: points[end]\n            });\n            continue;\n        }\n        const targetSegments = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ap)(target, bounds);\n        for (const tgt of targetSegments){\n            const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);\n            const fillSources = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.az)(segment, points, subBounds);\n            for (const fillSource of fillSources){\n                parts.push({\n                    source: fillSource,\n                    target: tgt,\n                    start: {\n                        [property]: _getEdge(bounds, subBounds, 'start', Math.max)\n                    },\n                    end: {\n                        [property]: _getEdge(bounds, subBounds, 'end', Math.min)\n                    }\n                });\n            }\n        }\n    }\n    return parts;\n}\nfunction _getBounds(property, first, last, loop) {\n    if (loop) {\n        return;\n    }\n    let start = first[property];\n    let end = last[property];\n    if (property === 'angle') {\n        start = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.al)(start);\n        end = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.al)(end);\n    }\n    return {\n        property,\n        start,\n        end\n    };\n}\nfunction _pointsFromSegments(boundary, line) {\n    const { x = null, y = null } = boundary || {};\n    const linePoints = line.points;\n    const points = [];\n    line.segments.forEach(({ start, end })=>{\n        end = _findSegmentEnd(start, end, linePoints);\n        const first = linePoints[start];\n        const last = linePoints[end];\n        if (y !== null) {\n            points.push({\n                x: first.x,\n                y\n            });\n            points.push({\n                x: last.x,\n                y\n            });\n        } else if (x !== null) {\n            points.push({\n                x,\n                y: first.y\n            });\n            points.push({\n                x,\n                y: last.y\n            });\n        }\n    });\n    return points;\n}\nfunction _findSegmentEnd(start, end, points) {\n    for(; end > start; end--){\n        const point = points[end];\n        if (!isNaN(point.x) && !isNaN(point.y)) {\n            break;\n        }\n    }\n    return end;\n}\nfunction _getEdge(a, b, prop, fn) {\n    if (a && b) {\n        return fn(a[prop], b[prop]);\n    }\n    return a ? a[prop] : b ? b[prop] : 0;\n}\nfunction _createBoundaryLine(boundary, line) {\n    let points = [];\n    let _loop = false;\n    if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(boundary)) {\n        _loop = true;\n        points = boundary;\n    } else {\n        points = _pointsFromSegments(boundary, line);\n    }\n    return points.length ? new LineElement({\n        points,\n        options: {\n            tension: 0\n        },\n        _loop,\n        _fullLoop: _loop\n    }) : null;\n}\nfunction _shouldApplyFill(source) {\n    return source && source.fill !== false;\n}\nfunction _resolveTarget(sources, index, propagate) {\n    const source = sources[index];\n    let fill = source.fill;\n    const visited = [\n        index\n    ];\n    let target;\n    if (!propagate) {\n        return fill;\n    }\n    while(fill !== false && visited.indexOf(fill) === -1){\n        if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(fill)) {\n            return fill;\n        }\n        target = sources[fill];\n        if (!target) {\n            return false;\n        }\n        if (target.visible) {\n            return fill;\n        }\n        visited.push(fill);\n        fill = target.fill;\n    }\n    return false;\n}\nfunction _decodeFill(line, index, count) {\n    const fill = parseFillOption(line);\n    if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(fill)) {\n        return isNaN(fill.value) ? false : fill;\n    }\n    let target = parseFloat(fill);\n    if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(target) && Math.floor(target) === target) {\n        return decodeTargetIndex(fill[0], index, target, count);\n    }\n    return [\n        'origin',\n        'start',\n        'end',\n        'stack',\n        'shape'\n    ].indexOf(fill) >= 0 && fill;\n}\nfunction decodeTargetIndex(firstCh, index, target, count) {\n    if (firstCh === '-' || firstCh === '+') {\n        target = index + target;\n    }\n    if (target === index || target < 0 || target >= count) {\n        return false;\n    }\n    return target;\n}\nfunction _getTargetPixel(fill, scale) {\n    let pixel = null;\n    if (fill === 'start') {\n        pixel = scale.bottom;\n    } else if (fill === 'end') {\n        pixel = scale.top;\n    } else if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(fill)) {\n        pixel = scale.getPixelForValue(fill.value);\n    } else if (scale.getBasePixel) {\n        pixel = scale.getBasePixel();\n    }\n    return pixel;\n}\nfunction _getTargetValue(fill, scale, startValue) {\n    let value;\n    if (fill === 'start') {\n        value = startValue;\n    } else if (fill === 'end') {\n        value = scale.options.reverse ? scale.min : scale.max;\n    } else if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(fill)) {\n        value = fill.value;\n    } else {\n        value = scale.getBaseValue();\n    }\n    return value;\n}\nfunction parseFillOption(line) {\n    const options = line.options;\n    const fillOption = options.fill;\n    let fill = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(fillOption && fillOption.target, fillOption);\n    if (fill === undefined) {\n        fill = !!options.backgroundColor;\n    }\n    if (fill === false || fill === null) {\n        return false;\n    }\n    if (fill === true) {\n        return 'origin';\n    }\n    return fill;\n}\nfunction _buildStackLine(source) {\n    const { scale, index, line } = source;\n    const points = [];\n    const segments = line.segments;\n    const sourcePoints = line.points;\n    const linesBelow = getLinesBelow(scale, index);\n    linesBelow.push(_createBoundaryLine({\n        x: null,\n        y: scale.bottom\n    }, line));\n    for(let i = 0; i < segments.length; i++){\n        const segment = segments[i];\n        for(let j = segment.start; j <= segment.end; j++){\n            addPointsBelow(points, sourcePoints[j], linesBelow);\n        }\n    }\n    return new LineElement({\n        points,\n        options: {}\n    });\n}\nfunction getLinesBelow(scale, index) {\n    const below = [];\n    const metas = scale.getMatchingVisibleMetas('line');\n    for(let i = 0; i < metas.length; i++){\n        const meta = metas[i];\n        if (meta.index === index) {\n            break;\n        }\n        if (!meta.hidden) {\n            below.unshift(meta.dataset);\n        }\n    }\n    return below;\n}\nfunction addPointsBelow(points, sourcePoint, linesBelow) {\n    const postponed = [];\n    for(let j = 0; j < linesBelow.length; j++){\n        const line = linesBelow[j];\n        const { first, last, point } = findPoint(line, sourcePoint, 'x');\n        if (!point || first && last) {\n            continue;\n        }\n        if (first) {\n            postponed.unshift(point);\n        } else {\n            points.push(point);\n            if (!last) {\n                break;\n            }\n        }\n    }\n    points.push(...postponed);\n}\nfunction findPoint(line, sourcePoint, property) {\n    const point = line.interpolate(sourcePoint, property);\n    if (!point) {\n        return {};\n    }\n    const pointValue = point[property];\n    const segments = line.segments;\n    const linePoints = line.points;\n    let first = false;\n    let last = false;\n    for(let i = 0; i < segments.length; i++){\n        const segment = segments[i];\n        const firstValue = linePoints[segment.start][property];\n        const lastValue = linePoints[segment.end][property];\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ak)(pointValue, firstValue, lastValue)) {\n            first = pointValue === firstValue;\n            last = pointValue === lastValue;\n            break;\n        }\n    }\n    return {\n        first,\n        last,\n        point\n    };\n}\nclass simpleArc {\n    constructor(opts){\n        this.x = opts.x;\n        this.y = opts.y;\n        this.radius = opts.radius;\n    }\n    pathSegment(ctx, bounds, opts) {\n        const { x, y, radius } = this;\n        bounds = bounds || {\n            start: 0,\n            end: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T\n        };\n        ctx.arc(x, y, radius, bounds.end, bounds.start, true);\n        return !opts.bounds;\n    }\n    interpolate(point) {\n        const { x, y, radius } = this;\n        const angle = point.angle;\n        return {\n            x: x + Math.cos(angle) * radius,\n            y: y + Math.sin(angle) * radius,\n            angle\n        };\n    }\n}\nfunction _getTarget(source) {\n    const { chart, fill, line } = source;\n    if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(fill)) {\n        return getLineByIndex(chart, fill);\n    }\n    if (fill === 'stack') {\n        return _buildStackLine(source);\n    }\n    if (fill === 'shape') {\n        return true;\n    }\n    const boundary = computeBoundary(source);\n    if (boundary instanceof simpleArc) {\n        return boundary;\n    }\n    return _createBoundaryLine(boundary, line);\n}\nfunction getLineByIndex(chart, index) {\n    const meta = chart.getDatasetMeta(index);\n    const visible = meta && chart.isDatasetVisible(index);\n    return visible ? meta.dataset : null;\n}\nfunction computeBoundary(source) {\n    const scale = source.scale || {};\n    if (scale.getPointPositionForValue) {\n        return computeCircularBoundary(source);\n    }\n    return computeLinearBoundary(source);\n}\nfunction computeLinearBoundary(source) {\n    const { scale = {}, fill } = source;\n    const pixel = _getTargetPixel(fill, scale);\n    if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(pixel)) {\n        const horizontal = scale.isHorizontal();\n        return {\n            x: horizontal ? pixel : null,\n            y: horizontal ? null : pixel\n        };\n    }\n    return null;\n}\nfunction computeCircularBoundary(source) {\n    const { scale, fill } = source;\n    const options = scale.options;\n    const length = scale.getLabels().length;\n    const start = options.reverse ? scale.max : scale.min;\n    const value = _getTargetValue(fill, scale, start);\n    const target = [];\n    if (options.grid.circular) {\n        const center = scale.getPointPositionForValue(0, start);\n        return new simpleArc({\n            x: center.x,\n            y: center.y,\n            radius: scale.getDistanceFromCenterForValue(value)\n        });\n    }\n    for(let i = 0; i < length; ++i){\n        target.push(scale.getPointPositionForValue(i, value));\n    }\n    return target;\n}\nfunction _drawfill(ctx, source, area) {\n    const target = _getTarget(source);\n    const { chart, index, line, scale, axis } = source;\n    const lineOpts = line.options;\n    const fillOption = lineOpts.fill;\n    const color = lineOpts.backgroundColor;\n    const { above = color, below = color } = fillOption || {};\n    const meta = chart.getDatasetMeta(index);\n    const clip = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ah)(chart, meta);\n    if (target && line.points.length) {\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Y)(ctx, area);\n        doFill(ctx, {\n            line,\n            target,\n            above,\n            below,\n            area,\n            scale,\n            axis,\n            clip\n        });\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.$)(ctx);\n    }\n}\nfunction doFill(ctx, cfg) {\n    const { line, target, above, below, area, scale, clip } = cfg;\n    const property = line._loop ? 'angle' : cfg.axis;\n    ctx.save();\n    let fillColor = below;\n    if (below !== above) {\n        if (property === 'x') {\n            clipVertical(ctx, target, area.top);\n            fill(ctx, {\n                line,\n                target,\n                color: above,\n                scale,\n                property,\n                clip\n            });\n            ctx.restore();\n            ctx.save();\n            clipVertical(ctx, target, area.bottom);\n        } else if (property === 'y') {\n            clipHorizontal(ctx, target, area.left);\n            fill(ctx, {\n                line,\n                target,\n                color: below,\n                scale,\n                property,\n                clip\n            });\n            ctx.restore();\n            ctx.save();\n            clipHorizontal(ctx, target, area.right);\n            fillColor = above;\n        }\n    }\n    fill(ctx, {\n        line,\n        target,\n        color: fillColor,\n        scale,\n        property,\n        clip\n    });\n    ctx.restore();\n}\nfunction clipVertical(ctx, target, clipY) {\n    const { segments, points } = target;\n    let first = true;\n    let lineLoop = false;\n    ctx.beginPath();\n    for (const segment of segments){\n        const { start, end } = segment;\n        const firstPoint = points[start];\n        const lastPoint = points[_findSegmentEnd(start, end, points)];\n        if (first) {\n            ctx.moveTo(firstPoint.x, firstPoint.y);\n            first = false;\n        } else {\n            ctx.lineTo(firstPoint.x, clipY);\n            ctx.lineTo(firstPoint.x, firstPoint.y);\n        }\n        lineLoop = !!target.pathSegment(ctx, segment, {\n            move: lineLoop\n        });\n        if (lineLoop) {\n            ctx.closePath();\n        } else {\n            ctx.lineTo(lastPoint.x, clipY);\n        }\n    }\n    ctx.lineTo(target.first().x, clipY);\n    ctx.closePath();\n    ctx.clip();\n}\nfunction clipHorizontal(ctx, target, clipX) {\n    const { segments, points } = target;\n    let first = true;\n    let lineLoop = false;\n    ctx.beginPath();\n    for (const segment of segments){\n        const { start, end } = segment;\n        const firstPoint = points[start];\n        const lastPoint = points[_findSegmentEnd(start, end, points)];\n        if (first) {\n            ctx.moveTo(firstPoint.x, firstPoint.y);\n            first = false;\n        } else {\n            ctx.lineTo(clipX, firstPoint.y);\n            ctx.lineTo(firstPoint.x, firstPoint.y);\n        }\n        lineLoop = !!target.pathSegment(ctx, segment, {\n            move: lineLoop\n        });\n        if (lineLoop) {\n            ctx.closePath();\n        } else {\n            ctx.lineTo(clipX, lastPoint.y);\n        }\n    }\n    ctx.lineTo(clipX, target.first().y);\n    ctx.closePath();\n    ctx.clip();\n}\nfunction fill(ctx, cfg) {\n    const { line, target, property, color, scale, clip } = cfg;\n    const segments = _segments(line, target, property);\n    for (const { source: src, target: tgt, start, end } of segments){\n        const { style: { backgroundColor = color } = {} } = src;\n        const notShape = target !== true;\n        ctx.save();\n        ctx.fillStyle = backgroundColor;\n        clipBounds(ctx, scale, clip, notShape && _getBounds(property, start, end));\n        ctx.beginPath();\n        const lineLoop = !!line.pathSegment(ctx, src);\n        let loop;\n        if (notShape) {\n            if (lineLoop) {\n                ctx.closePath();\n            } else {\n                interpolatedLineTo(ctx, target, end, property);\n            }\n            const targetLoop = !!target.pathSegment(ctx, tgt, {\n                move: lineLoop,\n                reverse: true\n            });\n            loop = lineLoop && targetLoop;\n            if (!loop) {\n                interpolatedLineTo(ctx, target, start, property);\n            }\n        }\n        ctx.closePath();\n        ctx.fill(loop ? 'evenodd' : 'nonzero');\n        ctx.restore();\n    }\n}\nfunction clipBounds(ctx, scale, clip, bounds) {\n    const chartArea = scale.chart.chartArea;\n    const { property, start, end } = bounds || {};\n    if (property === 'x' || property === 'y') {\n        let left, top, right, bottom;\n        if (property === 'x') {\n            left = start;\n            top = chartArea.top;\n            right = end;\n            bottom = chartArea.bottom;\n        } else {\n            left = chartArea.left;\n            top = start;\n            right = chartArea.right;\n            bottom = end;\n        }\n        ctx.beginPath();\n        if (clip) {\n            left = Math.max(left, clip.left);\n            right = Math.min(right, clip.right);\n            top = Math.max(top, clip.top);\n            bottom = Math.min(bottom, clip.bottom);\n        }\n        ctx.rect(left, top, right - left, bottom - top);\n        ctx.clip();\n    }\n}\nfunction interpolatedLineTo(ctx, target, point, property) {\n    const interpolatedPoint = target.interpolate(point, property);\n    if (interpolatedPoint) {\n        ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);\n    }\n}\nvar index = {\n    id: 'filler',\n    afterDatasetsUpdate (chart, _args, options) {\n        const count = (chart.data.datasets || []).length;\n        const sources = [];\n        let meta, i, line, source;\n        for(i = 0; i < count; ++i){\n            meta = chart.getDatasetMeta(i);\n            line = meta.dataset;\n            source = null;\n            if (line && line.options && line instanceof LineElement) {\n                source = {\n                    visible: chart.isDatasetVisible(i),\n                    index: i,\n                    fill: _decodeFill(line, i, count),\n                    chart,\n                    axis: meta.controller.options.indexAxis,\n                    scale: meta.vScale,\n                    line\n                };\n            }\n            meta.$filler = source;\n            sources.push(source);\n        }\n        for(i = 0; i < count; ++i){\n            source = sources[i];\n            if (!source || source.fill === false) {\n                continue;\n            }\n            source.fill = _resolveTarget(sources, i, options.propagate);\n        }\n    },\n    beforeDraw (chart, _args, options) {\n        const draw = options.drawTime === 'beforeDraw';\n        const metasets = chart.getSortedVisibleDatasetMetas();\n        const area = chart.chartArea;\n        for(let i = metasets.length - 1; i >= 0; --i){\n            const source = metasets[i].$filler;\n            if (!source) {\n                continue;\n            }\n            source.line.updateControlPoints(area, source.axis);\n            if (draw && source.fill) {\n                _drawfill(chart.ctx, source, area);\n            }\n        }\n    },\n    beforeDatasetsDraw (chart, _args, options) {\n        if (options.drawTime !== 'beforeDatasetsDraw') {\n            return;\n        }\n        const metasets = chart.getSortedVisibleDatasetMetas();\n        for(let i = metasets.length - 1; i >= 0; --i){\n            const source = metasets[i].$filler;\n            if (_shouldApplyFill(source)) {\n                _drawfill(chart.ctx, source, chart.chartArea);\n            }\n        }\n    },\n    beforeDatasetDraw (chart, args, options) {\n        const source = args.meta.$filler;\n        if (!_shouldApplyFill(source) || options.drawTime !== 'beforeDatasetDraw') {\n            return;\n        }\n        _drawfill(chart.ctx, source, chart.chartArea);\n    },\n    defaults: {\n        propagate: true,\n        drawTime: 'beforeDatasetDraw'\n    }\n};\nconst getBoxSize = (labelOpts, fontSize)=>{\n    let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;\n    if (labelOpts.usePointStyle) {\n        boxHeight = Math.min(boxHeight, fontSize);\n        boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);\n    }\n    return {\n        boxWidth,\n        boxHeight,\n        itemHeight: Math.max(fontSize, boxHeight)\n    };\n};\nconst itemsEqual = (a, b)=>a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;\nclass Legend extends Element {\n    constructor(config){\n        super();\n        this._added = false;\n        this.legendHitBoxes = [];\n        this._hoveredItem = null;\n        this.doughnutMode = false;\n        this.chart = config.chart;\n        this.options = config.options;\n        this.ctx = config.ctx;\n        this.legendItems = undefined;\n        this.columnSizes = undefined;\n        this.lineWidths = undefined;\n        this.maxHeight = undefined;\n        this.maxWidth = undefined;\n        this.top = undefined;\n        this.bottom = undefined;\n        this.left = undefined;\n        this.right = undefined;\n        this.height = undefined;\n        this.width = undefined;\n        this._margins = undefined;\n        this.position = undefined;\n        this.weight = undefined;\n        this.fullSize = undefined;\n    }\n    update(maxWidth, maxHeight, margins) {\n        this.maxWidth = maxWidth;\n        this.maxHeight = maxHeight;\n        this._margins = margins;\n        this.setDimensions();\n        this.buildLabels();\n        this.fit();\n    }\n    setDimensions() {\n        if (this.isHorizontal()) {\n            this.width = this.maxWidth;\n            this.left = this._margins.left;\n            this.right = this.width;\n        } else {\n            this.height = this.maxHeight;\n            this.top = this._margins.top;\n            this.bottom = this.height;\n        }\n    }\n    buildLabels() {\n        const labelOpts = this.options.labels || {};\n        let legendItems = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(labelOpts.generateLabels, [\n            this.chart\n        ], this) || [];\n        if (labelOpts.filter) {\n            legendItems = legendItems.filter((item)=>labelOpts.filter(item, this.chart.data));\n        }\n        if (labelOpts.sort) {\n            legendItems = legendItems.sort((a, b)=>labelOpts.sort(a, b, this.chart.data));\n        }\n        if (this.options.reverse) {\n            legendItems.reverse();\n        }\n        this.legendItems = legendItems;\n    }\n    fit() {\n        const { options, ctx } = this;\n        if (!options.display) {\n            this.width = this.height = 0;\n            return;\n        }\n        const labelOpts = options.labels;\n        const labelFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(labelOpts.font);\n        const fontSize = labelFont.size;\n        const titleHeight = this._computeTitleHeight();\n        const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);\n        let width, height;\n        ctx.font = labelFont.string;\n        if (this.isHorizontal()) {\n            width = this.maxWidth;\n            height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;\n        } else {\n            height = this.maxHeight;\n            width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;\n        }\n        this.width = Math.min(width, options.maxWidth || this.maxWidth);\n        this.height = Math.min(height, options.maxHeight || this.maxHeight);\n    }\n    _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {\n        const { ctx, maxWidth, options: { labels: { padding } } } = this;\n        const hitboxes = this.legendHitBoxes = [];\n        const lineWidths = this.lineWidths = [\n            0\n        ];\n        const lineHeight = itemHeight + padding;\n        let totalHeight = titleHeight;\n        ctx.textAlign = 'left';\n        ctx.textBaseline = 'middle';\n        let row = -1;\n        let top = -lineHeight;\n        this.legendItems.forEach((legendItem, i)=>{\n            const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;\n            if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {\n                totalHeight += lineHeight;\n                lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;\n                top += lineHeight;\n                row++;\n            }\n            hitboxes[i] = {\n                left: 0,\n                top,\n                row,\n                width: itemWidth,\n                height: itemHeight\n            };\n            lineWidths[lineWidths.length - 1] += itemWidth + padding;\n        });\n        return totalHeight;\n    }\n    _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {\n        const { ctx, maxHeight, options: { labels: { padding } } } = this;\n        const hitboxes = this.legendHitBoxes = [];\n        const columnSizes = this.columnSizes = [];\n        const heightLimit = maxHeight - titleHeight;\n        let totalWidth = padding;\n        let currentColWidth = 0;\n        let currentColHeight = 0;\n        let left = 0;\n        let col = 0;\n        this.legendItems.forEach((legendItem, i)=>{\n            const { itemWidth, itemHeight } = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);\n            if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {\n                totalWidth += currentColWidth + padding;\n                columnSizes.push({\n                    width: currentColWidth,\n                    height: currentColHeight\n                });\n                left += currentColWidth + padding;\n                col++;\n                currentColWidth = currentColHeight = 0;\n            }\n            hitboxes[i] = {\n                left,\n                top: currentColHeight,\n                col,\n                width: itemWidth,\n                height: itemHeight\n            };\n            currentColWidth = Math.max(currentColWidth, itemWidth);\n            currentColHeight += itemHeight + padding;\n        });\n        totalWidth += currentColWidth;\n        columnSizes.push({\n            width: currentColWidth,\n            height: currentColHeight\n        });\n        return totalWidth;\n    }\n    adjustHitBoxes() {\n        if (!this.options.display) {\n            return;\n        }\n        const titleHeight = this._computeTitleHeight();\n        const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;\n        const rtlHelper = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aA)(rtl, this.left, this.width);\n        if (this.isHorizontal()) {\n            let row = 0;\n            let left = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, this.left + padding, this.right - this.lineWidths[row]);\n            for (const hitbox of hitboxes){\n                if (row !== hitbox.row) {\n                    row = hitbox.row;\n                    left = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, this.left + padding, this.right - this.lineWidths[row]);\n                }\n                hitbox.top += this.top + titleHeight + padding;\n                hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);\n                left += hitbox.width + padding;\n            }\n        } else {\n            let col = 0;\n            let top = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n            for (const hitbox of hitboxes){\n                if (hitbox.col !== col) {\n                    col = hitbox.col;\n                    top = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n                }\n                hitbox.top = top;\n                hitbox.left += this.left + padding;\n                hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);\n                top += hitbox.height + padding;\n            }\n        }\n    }\n    isHorizontal() {\n        return this.options.position === 'top' || this.options.position === 'bottom';\n    }\n    draw() {\n        if (this.options.display) {\n            const ctx = this.ctx;\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Y)(ctx, this);\n            this._draw();\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.$)(ctx);\n        }\n    }\n    _draw() {\n        const { options: opts, columnSizes, lineWidths, ctx } = this;\n        const { align, labels: labelOpts } = opts;\n        const defaultColor = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.color;\n        const rtlHelper = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aA)(opts.rtl, this.left, this.width);\n        const labelFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(labelOpts.font);\n        const { padding } = labelOpts;\n        const fontSize = labelFont.size;\n        const halfFontSize = fontSize / 2;\n        let cursor;\n        this.drawTitle();\n        ctx.textAlign = rtlHelper.textAlign('left');\n        ctx.textBaseline = 'middle';\n        ctx.lineWidth = 0.5;\n        ctx.font = labelFont.string;\n        const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);\n        const drawLegendBox = function(x, y, legendItem) {\n            if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {\n                return;\n            }\n            ctx.save();\n            const lineWidth = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.lineWidth, 1);\n            ctx.fillStyle = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.fillStyle, defaultColor);\n            ctx.lineCap = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.lineCap, 'butt');\n            ctx.lineDashOffset = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.lineDashOffset, 0);\n            ctx.lineJoin = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.lineJoin, 'miter');\n            ctx.lineWidth = lineWidth;\n            ctx.strokeStyle = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.strokeStyle, defaultColor);\n            ctx.setLineDash((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.lineDash, []));\n            if (labelOpts.usePointStyle) {\n                const drawOptions = {\n                    radius: boxHeight * Math.SQRT2 / 2,\n                    pointStyle: legendItem.pointStyle,\n                    rotation: legendItem.rotation,\n                    borderWidth: lineWidth\n                };\n                const centerX = rtlHelper.xPlus(x, boxWidth / 2);\n                const centerY = y + halfFontSize;\n                (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aE)(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);\n            } else {\n                const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);\n                const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);\n                const borderRadius = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ay)(legendItem.borderRadius);\n                ctx.beginPath();\n                if (Object.values(borderRadius).some((v)=>v !== 0)) {\n                    (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aw)(ctx, {\n                        x: xBoxLeft,\n                        y: yBoxTop,\n                        w: boxWidth,\n                        h: boxHeight,\n                        radius: borderRadius\n                    });\n                } else {\n                    ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);\n                }\n                ctx.fill();\n                if (lineWidth !== 0) {\n                    ctx.stroke();\n                }\n            }\n            ctx.restore();\n        };\n        const fillText = function(x, y, legendItem) {\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Z)(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {\n                strikethrough: legendItem.hidden,\n                textAlign: rtlHelper.textAlign(legendItem.textAlign)\n            });\n        };\n        const isHorizontal = this.isHorizontal();\n        const titleHeight = this._computeTitleHeight();\n        if (isHorizontal) {\n            cursor = {\n                x: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, this.left + padding, this.right - lineWidths[0]),\n                y: this.top + padding + titleHeight,\n                line: 0\n            };\n        } else {\n            cursor = {\n                x: this.left + padding,\n                y: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),\n                line: 0\n            };\n        }\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aB)(this.ctx, opts.textDirection);\n        const lineHeight = itemHeight + padding;\n        this.legendItems.forEach((legendItem, i)=>{\n            ctx.strokeStyle = legendItem.fontColor;\n            ctx.fillStyle = legendItem.fontColor;\n            const textWidth = ctx.measureText(legendItem.text).width;\n            const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));\n            const width = boxWidth + halfFontSize + textWidth;\n            let x = cursor.x;\n            let y = cursor.y;\n            rtlHelper.setWidth(this.width);\n            if (isHorizontal) {\n                if (i > 0 && x + width + padding > this.right) {\n                    y = cursor.y += lineHeight;\n                    cursor.line++;\n                    x = cursor.x = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, this.left + padding, this.right - lineWidths[cursor.line]);\n                }\n            } else if (i > 0 && y + lineHeight > this.bottom) {\n                x = cursor.x = x + columnSizes[cursor.line].width + padding;\n                cursor.line++;\n                y = cursor.y = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);\n            }\n            const realX = rtlHelper.x(x);\n            drawLegendBox(realX, y, legendItem);\n            x = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aC)(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);\n            fillText(rtlHelper.x(x), y, legendItem);\n            if (isHorizontal) {\n                cursor.x += width + padding;\n            } else if (typeof legendItem.text !== 'string') {\n                const fontLineHeight = labelFont.lineHeight;\n                cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;\n            } else {\n                cursor.y += lineHeight;\n            }\n        });\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aD)(this.ctx, opts.textDirection);\n    }\n    drawTitle() {\n        const opts = this.options;\n        const titleOpts = opts.title;\n        const titleFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(titleOpts.font);\n        const titlePadding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(titleOpts.padding);\n        if (!titleOpts.display) {\n            return;\n        }\n        const rtlHelper = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aA)(opts.rtl, this.left, this.width);\n        const ctx = this.ctx;\n        const position = titleOpts.position;\n        const halfFontSize = titleFont.size / 2;\n        const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;\n        let y;\n        let left = this.left;\n        let maxWidth = this.width;\n        if (this.isHorizontal()) {\n            maxWidth = Math.max(...this.lineWidths);\n            y = this.top + topPaddingPlusHalfFontSize;\n            left = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(opts.align, left, this.right - maxWidth);\n        } else {\n            const maxHeight = this.columnSizes.reduce((acc, size)=>Math.max(acc, size.height), 0);\n            y = topPaddingPlusHalfFontSize + (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());\n        }\n        const x = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(position, left, left + maxWidth);\n        ctx.textAlign = rtlHelper.textAlign((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a1)(position));\n        ctx.textBaseline = 'middle';\n        ctx.strokeStyle = titleOpts.color;\n        ctx.fillStyle = titleOpts.color;\n        ctx.font = titleFont.string;\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Z)(ctx, titleOpts.text, x, y, titleFont);\n    }\n    _computeTitleHeight() {\n        const titleOpts = this.options.title;\n        const titleFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(titleOpts.font);\n        const titlePadding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(titleOpts.padding);\n        return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;\n    }\n    _getLegendItemAt(x, y) {\n        let i, hitBox, lh;\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ak)(x, this.left, this.right) && (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ak)(y, this.top, this.bottom)) {\n            lh = this.legendHitBoxes;\n            for(i = 0; i < lh.length; ++i){\n                hitBox = lh[i];\n                if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ak)(x, hitBox.left, hitBox.left + hitBox.width) && (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ak)(y, hitBox.top, hitBox.top + hitBox.height)) {\n                    return this.legendItems[i];\n                }\n            }\n        }\n        return null;\n    }\n    handleEvent(e) {\n        const opts = this.options;\n        if (!isListened(e.type, opts)) {\n            return;\n        }\n        const hoveredItem = this._getLegendItemAt(e.x, e.y);\n        if (e.type === 'mousemove' || e.type === 'mouseout') {\n            const previous = this._hoveredItem;\n            const sameItem = itemsEqual(previous, hoveredItem);\n            if (previous && !sameItem) {\n                (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(opts.onLeave, [\n                    e,\n                    previous,\n                    this\n                ], this);\n            }\n            this._hoveredItem = hoveredItem;\n            if (hoveredItem && !sameItem) {\n                (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(opts.onHover, [\n                    e,\n                    hoveredItem,\n                    this\n                ], this);\n            }\n        } else if (hoveredItem) {\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(opts.onClick, [\n                e,\n                hoveredItem,\n                this\n            ], this);\n        }\n    }\n}\nfunction calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {\n    const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);\n    const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);\n    return {\n        itemWidth,\n        itemHeight\n    };\n}\nfunction calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {\n    let legendItemText = legendItem.text;\n    if (legendItemText && typeof legendItemText !== 'string') {\n        legendItemText = legendItemText.reduce((a, b)=>a.length > b.length ? a : b);\n    }\n    return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;\n}\nfunction calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {\n    let itemHeight = _itemHeight;\n    if (typeof legendItem.text !== 'string') {\n        itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);\n    }\n    return itemHeight;\n}\nfunction calculateLegendItemHeight(legendItem, fontLineHeight) {\n    const labelHeight = legendItem.text ? legendItem.text.length : 0;\n    return fontLineHeight * labelHeight;\n}\nfunction isListened(type, opts) {\n    if ((type === 'mousemove' || type === 'mouseout') && (opts.onHover || opts.onLeave)) {\n        return true;\n    }\n    if (opts.onClick && (type === 'click' || type === 'mouseup')) {\n        return true;\n    }\n    return false;\n}\nvar plugin_legend = {\n    id: 'legend',\n    _element: Legend,\n    start (chart, _args, options) {\n        const legend = chart.legend = new Legend({\n            ctx: chart.ctx,\n            options,\n            chart\n        });\n        layouts.configure(chart, legend, options);\n        layouts.addBox(chart, legend);\n    },\n    stop (chart) {\n        layouts.removeBox(chart, chart.legend);\n        delete chart.legend;\n    },\n    beforeUpdate (chart, _args, options) {\n        const legend = chart.legend;\n        layouts.configure(chart, legend, options);\n        legend.options = options;\n    },\n    afterUpdate (chart) {\n        const legend = chart.legend;\n        legend.buildLabels();\n        legend.adjustHitBoxes();\n    },\n    afterEvent (chart, args) {\n        if (!args.replay) {\n            chart.legend.handleEvent(args.event);\n        }\n    },\n    defaults: {\n        display: true,\n        position: 'top',\n        align: 'center',\n        fullSize: true,\n        reverse: false,\n        weight: 1000,\n        onClick (e, legendItem, legend) {\n            const index = legendItem.datasetIndex;\n            const ci = legend.chart;\n            if (ci.isDatasetVisible(index)) {\n                ci.hide(index);\n                legendItem.hidden = true;\n            } else {\n                ci.show(index);\n                legendItem.hidden = false;\n            }\n        },\n        onHover: null,\n        onLeave: null,\n        labels: {\n            color: (ctx)=>ctx.chart.options.color,\n            boxWidth: 40,\n            padding: 10,\n            generateLabels (chart) {\n                const datasets = chart.data.datasets;\n                const { labels: { usePointStyle, pointStyle, textAlign, color, useBorderRadius, borderRadius } } = chart.legend.options;\n                return chart._getSortedDatasetMetas().map((meta)=>{\n                    const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);\n                    const borderWidth = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(style.borderWidth);\n                    return {\n                        text: datasets[meta.index].label,\n                        fillStyle: style.backgroundColor,\n                        fontColor: color,\n                        hidden: !meta.visible,\n                        lineCap: style.borderCapStyle,\n                        lineDash: style.borderDash,\n                        lineDashOffset: style.borderDashOffset,\n                        lineJoin: style.borderJoinStyle,\n                        lineWidth: (borderWidth.width + borderWidth.height) / 4,\n                        strokeStyle: style.borderColor,\n                        pointStyle: pointStyle || style.pointStyle,\n                        rotation: style.rotation,\n                        textAlign: textAlign || style.textAlign,\n                        borderRadius: useBorderRadius && (borderRadius || style.borderRadius),\n                        datasetIndex: meta.index\n                    };\n                }, this);\n            }\n        },\n        title: {\n            color: (ctx)=>ctx.chart.options.color,\n            display: false,\n            position: 'center',\n            text: ''\n        }\n    },\n    descriptors: {\n        _scriptable: (name)=>!name.startsWith('on'),\n        labels: {\n            _scriptable: (name)=>![\n                    'generateLabels',\n                    'filter',\n                    'sort'\n                ].includes(name)\n        }\n    }\n};\nclass Title extends Element {\n    constructor(config){\n        super();\n        this.chart = config.chart;\n        this.options = config.options;\n        this.ctx = config.ctx;\n        this._padding = undefined;\n        this.top = undefined;\n        this.bottom = undefined;\n        this.left = undefined;\n        this.right = undefined;\n        this.width = undefined;\n        this.height = undefined;\n        this.position = undefined;\n        this.weight = undefined;\n        this.fullSize = undefined;\n    }\n    update(maxWidth, maxHeight) {\n        const opts = this.options;\n        this.left = 0;\n        this.top = 0;\n        if (!opts.display) {\n            this.width = this.height = this.right = this.bottom = 0;\n            return;\n        }\n        this.width = this.right = maxWidth;\n        this.height = this.bottom = maxHeight;\n        const lineCount = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(opts.text) ? opts.text.length : 1;\n        this._padding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(opts.padding);\n        const textSize = lineCount * (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(opts.font).lineHeight + this._padding.height;\n        if (this.isHorizontal()) {\n            this.height = textSize;\n        } else {\n            this.width = textSize;\n        }\n    }\n    isHorizontal() {\n        const pos = this.options.position;\n        return pos === 'top' || pos === 'bottom';\n    }\n    _drawArgs(offset) {\n        const { top, left, bottom, right, options } = this;\n        const align = options.align;\n        let rotation = 0;\n        let maxWidth, titleX, titleY;\n        if (this.isHorizontal()) {\n            titleX = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, left, right);\n            titleY = top + offset;\n            maxWidth = right - left;\n        } else {\n            if (options.position === 'left') {\n                titleX = left + offset;\n                titleY = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, bottom, top);\n                rotation = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P * -0.5;\n            } else {\n                titleX = right - offset;\n                titleY = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, top, bottom);\n                rotation = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P * 0.5;\n            }\n            maxWidth = bottom - top;\n        }\n        return {\n            titleX,\n            titleY,\n            maxWidth,\n            rotation\n        };\n    }\n    draw() {\n        const ctx = this.ctx;\n        const opts = this.options;\n        if (!opts.display) {\n            return;\n        }\n        const fontOpts = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(opts.font);\n        const lineHeight = fontOpts.lineHeight;\n        const offset = lineHeight / 2 + this._padding.top;\n        const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset);\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Z)(ctx, opts.text, 0, 0, fontOpts, {\n            color: opts.color,\n            maxWidth,\n            rotation,\n            textAlign: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a1)(opts.align),\n            textBaseline: 'middle',\n            translation: [\n                titleX,\n                titleY\n            ]\n        });\n    }\n}\nfunction createTitle(chart, titleOpts) {\n    const title = new Title({\n        ctx: chart.ctx,\n        options: titleOpts,\n        chart\n    });\n    layouts.configure(chart, title, titleOpts);\n    layouts.addBox(chart, title);\n    chart.titleBlock = title;\n}\nvar plugin_title = {\n    id: 'title',\n    _element: Title,\n    start (chart, _args, options) {\n        createTitle(chart, options);\n    },\n    stop (chart) {\n        const titleBlock = chart.titleBlock;\n        layouts.removeBox(chart, titleBlock);\n        delete chart.titleBlock;\n    },\n    beforeUpdate (chart, _args, options) {\n        const title = chart.titleBlock;\n        layouts.configure(chart, title, options);\n        title.options = options;\n    },\n    defaults: {\n        align: 'center',\n        display: false,\n        font: {\n            weight: 'bold'\n        },\n        fullSize: true,\n        padding: 10,\n        position: 'top',\n        text: '',\n        weight: 2000\n    },\n    defaultRoutes: {\n        color: 'color'\n    },\n    descriptors: {\n        _scriptable: true,\n        _indexable: false\n    }\n};\nconst map = new WeakMap();\nvar plugin_subtitle = {\n    id: 'subtitle',\n    start (chart, _args, options) {\n        const title = new Title({\n            ctx: chart.ctx,\n            options,\n            chart\n        });\n        layouts.configure(chart, title, options);\n        layouts.addBox(chart, title);\n        map.set(chart, title);\n    },\n    stop (chart) {\n        layouts.removeBox(chart, map.get(chart));\n        map.delete(chart);\n    },\n    beforeUpdate (chart, _args, options) {\n        const title = map.get(chart);\n        layouts.configure(chart, title, options);\n        title.options = options;\n    },\n    defaults: {\n        align: 'center',\n        display: false,\n        font: {\n            weight: 'normal'\n        },\n        fullSize: true,\n        padding: 0,\n        position: 'top',\n        text: '',\n        weight: 1500\n    },\n    defaultRoutes: {\n        color: 'color'\n    },\n    descriptors: {\n        _scriptable: true,\n        _indexable: false\n    }\n};\nconst positioners = {\n    average (items) {\n        if (!items.length) {\n            return false;\n        }\n        let i, len;\n        let xSet = new Set();\n        let y = 0;\n        let count = 0;\n        for(i = 0, len = items.length; i < len; ++i){\n            const el = items[i].element;\n            if (el && el.hasValue()) {\n                const pos = el.tooltipPosition();\n                xSet.add(pos.x);\n                y += pos.y;\n                ++count;\n            }\n        }\n        if (count === 0 || xSet.size === 0) {\n            return false;\n        }\n        const xAverage = [\n            ...xSet\n        ].reduce((a, b)=>a + b) / xSet.size;\n        return {\n            x: xAverage,\n            y: y / count\n        };\n    },\n    nearest (items, eventPosition) {\n        if (!items.length) {\n            return false;\n        }\n        let x = eventPosition.x;\n        let y = eventPosition.y;\n        let minDistance = Number.POSITIVE_INFINITY;\n        let i, len, nearestElement;\n        for(i = 0, len = items.length; i < len; ++i){\n            const el = items[i].element;\n            if (el && el.hasValue()) {\n                const center = el.getCenterPoint();\n                const d = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aF)(eventPosition, center);\n                if (d < minDistance) {\n                    minDistance = d;\n                    nearestElement = el;\n                }\n            }\n        }\n        if (nearestElement) {\n            const tp = nearestElement.tooltipPosition();\n            x = tp.x;\n            y = tp.y;\n        }\n        return {\n            x,\n            y\n        };\n    }\n};\nfunction pushOrConcat(base, toPush) {\n    if (toPush) {\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(toPush)) {\n            Array.prototype.push.apply(base, toPush);\n        } else {\n            base.push(toPush);\n        }\n    }\n    return base;\n}\nfunction splitNewlines(str) {\n    if ((typeof str === 'string' || str instanceof String) && str.indexOf('\\n') > -1) {\n        return str.split('\\n');\n    }\n    return str;\n}\nfunction createTooltipItem(chart, item) {\n    const { element, datasetIndex, index } = item;\n    const controller = chart.getDatasetMeta(datasetIndex).controller;\n    const { label, value } = controller.getLabelAndValue(index);\n    return {\n        chart,\n        label,\n        parsed: controller.getParsed(index),\n        raw: chart.data.datasets[datasetIndex].data[index],\n        formattedValue: value,\n        dataset: controller.getDataset(),\n        dataIndex: index,\n        datasetIndex,\n        element\n    };\n}\nfunction getTooltipSize(tooltip, options) {\n    const ctx = tooltip.chart.ctx;\n    const { body, footer, title } = tooltip;\n    const { boxWidth, boxHeight } = options;\n    const bodyFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(options.bodyFont);\n    const titleFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(options.titleFont);\n    const footerFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(options.footerFont);\n    const titleLineCount = title.length;\n    const footerLineCount = footer.length;\n    const bodyLineItemCount = body.length;\n    const padding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(options.padding);\n    let height = padding.height;\n    let width = 0;\n    let combinedBodyLength = body.reduce((count, bodyItem)=>count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);\n    combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;\n    if (titleLineCount) {\n        height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;\n    }\n    if (combinedBodyLength) {\n        const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;\n        height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;\n    }\n    if (footerLineCount) {\n        height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;\n    }\n    let widthPadding = 0;\n    const maxLineWidth = function(line) {\n        width = Math.max(width, ctx.measureText(line).width + widthPadding);\n    };\n    ctx.save();\n    ctx.font = titleFont.string;\n    (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(tooltip.title, maxLineWidth);\n    ctx.font = bodyFont.string;\n    (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);\n    widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;\n    (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(body, (bodyItem)=>{\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(bodyItem.before, maxLineWidth);\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(bodyItem.lines, maxLineWidth);\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(bodyItem.after, maxLineWidth);\n    });\n    widthPadding = 0;\n    ctx.font = footerFont.string;\n    (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(tooltip.footer, maxLineWidth);\n    ctx.restore();\n    width += padding.width;\n    return {\n        width,\n        height\n    };\n}\nfunction determineYAlign(chart, size) {\n    const { y, height } = size;\n    if (y < height / 2) {\n        return 'top';\n    } else if (y > chart.height - height / 2) {\n        return 'bottom';\n    }\n    return 'center';\n}\nfunction doesNotFitWithAlign(xAlign, chart, options, size) {\n    const { x, width } = size;\n    const caret = options.caretSize + options.caretPadding;\n    if (xAlign === 'left' && x + width + caret > chart.width) {\n        return true;\n    }\n    if (xAlign === 'right' && x - width - caret < 0) {\n        return true;\n    }\n}\nfunction determineXAlign(chart, options, size, yAlign) {\n    const { x, width } = size;\n    const { width: chartWidth, chartArea: { left, right } } = chart;\n    let xAlign = 'center';\n    if (yAlign === 'center') {\n        xAlign = x <= (left + right) / 2 ? 'left' : 'right';\n    } else if (x <= width / 2) {\n        xAlign = 'left';\n    } else if (x >= chartWidth - width / 2) {\n        xAlign = 'right';\n    }\n    if (doesNotFitWithAlign(xAlign, chart, options, size)) {\n        xAlign = 'center';\n    }\n    return xAlign;\n}\nfunction determineAlignment(chart, options, size) {\n    const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);\n    return {\n        xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),\n        yAlign\n    };\n}\nfunction alignX(size, xAlign) {\n    let { x, width } = size;\n    if (xAlign === 'right') {\n        x -= width;\n    } else if (xAlign === 'center') {\n        x -= width / 2;\n    }\n    return x;\n}\nfunction alignY(size, yAlign, paddingAndSize) {\n    let { y, height } = size;\n    if (yAlign === 'top') {\n        y += paddingAndSize;\n    } else if (yAlign === 'bottom') {\n        y -= height + paddingAndSize;\n    } else {\n        y -= height / 2;\n    }\n    return y;\n}\nfunction getBackgroundPoint(options, size, alignment, chart) {\n    const { caretSize, caretPadding, cornerRadius } = options;\n    const { xAlign, yAlign } = alignment;\n    const paddingAndSize = caretSize + caretPadding;\n    const { topLeft, topRight, bottomLeft, bottomRight } = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ay)(cornerRadius);\n    let x = alignX(size, xAlign);\n    const y = alignY(size, yAlign, paddingAndSize);\n    if (yAlign === 'center') {\n        if (xAlign === 'left') {\n            x += paddingAndSize;\n        } else if (xAlign === 'right') {\n            x -= paddingAndSize;\n        }\n    } else if (xAlign === 'left') {\n        x -= Math.max(topLeft, bottomLeft) + caretSize;\n    } else if (xAlign === 'right') {\n        x += Math.max(topRight, bottomRight) + caretSize;\n    }\n    return {\n        x: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(x, 0, chart.width - size.width),\n        y: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(y, 0, chart.height - size.height)\n    };\n}\nfunction getAlignedX(tooltip, align, options) {\n    const padding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(options.padding);\n    return align === 'center' ? tooltip.x + tooltip.width / 2 : align === 'right' ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;\n}\nfunction getBeforeAfterBodyLines(callback) {\n    return pushOrConcat([], splitNewlines(callback));\n}\nfunction createTooltipContext(parent, tooltip, tooltipItems) {\n    return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.j)(parent, {\n        tooltip,\n        tooltipItems,\n        type: 'tooltip'\n    });\n}\nfunction overrideCallbacks(callbacks, context) {\n    const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;\n    return override ? callbacks.override(override) : callbacks;\n}\nconst defaultCallbacks = {\n    beforeTitle: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aG,\n    title (tooltipItems) {\n        if (tooltipItems.length > 0) {\n            const item = tooltipItems[0];\n            const labels = item.chart.data.labels;\n            const labelCount = labels ? labels.length : 0;\n            if (this && this.options && this.options.mode === 'dataset') {\n                return item.dataset.label || '';\n            } else if (item.label) {\n                return item.label;\n            } else if (labelCount > 0 && item.dataIndex < labelCount) {\n                return labels[item.dataIndex];\n            }\n        }\n        return '';\n    },\n    afterTitle: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aG,\n    beforeBody: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aG,\n    beforeLabel: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aG,\n    label (tooltipItem) {\n        if (this && this.options && this.options.mode === 'dataset') {\n            return tooltipItem.label + ': ' + tooltipItem.formattedValue || tooltipItem.formattedValue;\n        }\n        let label = tooltipItem.dataset.label || '';\n        if (label) {\n            label += ': ';\n        }\n        const value = tooltipItem.formattedValue;\n        if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(value)) {\n            label += value;\n        }\n        return label;\n    },\n    labelColor (tooltipItem) {\n        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n        const options = meta.controller.getStyle(tooltipItem.dataIndex);\n        return {\n            borderColor: options.borderColor,\n            backgroundColor: options.backgroundColor,\n            borderWidth: options.borderWidth,\n            borderDash: options.borderDash,\n            borderDashOffset: options.borderDashOffset,\n            borderRadius: 0\n        };\n    },\n    labelTextColor () {\n        return this.options.bodyColor;\n    },\n    labelPointStyle (tooltipItem) {\n        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n        const options = meta.controller.getStyle(tooltipItem.dataIndex);\n        return {\n            pointStyle: options.pointStyle,\n            rotation: options.rotation\n        };\n    },\n    afterLabel: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aG,\n    afterBody: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aG,\n    beforeFooter: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aG,\n    footer: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aG,\n    afterFooter: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aG\n};\nfunction invokeCallbackWithFallback(callbacks, name, ctx, arg) {\n    const result = callbacks[name].call(ctx, arg);\n    if (typeof result === 'undefined') {\n        return defaultCallbacks[name].call(ctx, arg);\n    }\n    return result;\n}\nclass Tooltip extends Element {\n    static{\n        this.positioners = positioners;\n    }\n    constructor(config){\n        super();\n        this.opacity = 0;\n        this._active = [];\n        this._eventPosition = undefined;\n        this._size = undefined;\n        this._cachedAnimations = undefined;\n        this._tooltipItems = [];\n        this.$animations = undefined;\n        this.$context = undefined;\n        this.chart = config.chart;\n        this.options = config.options;\n        this.dataPoints = undefined;\n        this.title = undefined;\n        this.beforeBody = undefined;\n        this.body = undefined;\n        this.afterBody = undefined;\n        this.footer = undefined;\n        this.xAlign = undefined;\n        this.yAlign = undefined;\n        this.x = undefined;\n        this.y = undefined;\n        this.height = undefined;\n        this.width = undefined;\n        this.caretX = undefined;\n        this.caretY = undefined;\n        this.labelColors = undefined;\n        this.labelPointStyles = undefined;\n        this.labelTextColors = undefined;\n    }\n    initialize(options) {\n        this.options = options;\n        this._cachedAnimations = undefined;\n        this.$context = undefined;\n    }\n    _resolveAnimations() {\n        const cached = this._cachedAnimations;\n        if (cached) {\n            return cached;\n        }\n        const chart = this.chart;\n        const options = this.options.setContext(this.getContext());\n        const opts = options.enabled && chart.options.animation && options.animations;\n        const animations = new Animations(this.chart, opts);\n        if (opts._cacheable) {\n            this._cachedAnimations = Object.freeze(animations);\n        }\n        return animations;\n    }\n    getContext() {\n        return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));\n    }\n    getTitle(context, options) {\n        const { callbacks } = options;\n        const beforeTitle = invokeCallbackWithFallback(callbacks, 'beforeTitle', this, context);\n        const title = invokeCallbackWithFallback(callbacks, 'title', this, context);\n        const afterTitle = invokeCallbackWithFallback(callbacks, 'afterTitle', this, context);\n        let lines = [];\n        lines = pushOrConcat(lines, splitNewlines(beforeTitle));\n        lines = pushOrConcat(lines, splitNewlines(title));\n        lines = pushOrConcat(lines, splitNewlines(afterTitle));\n        return lines;\n    }\n    getBeforeBody(tooltipItems, options) {\n        return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, 'beforeBody', this, tooltipItems));\n    }\n    getBody(tooltipItems, options) {\n        const { callbacks } = options;\n        const bodyItems = [];\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(tooltipItems, (context)=>{\n            const bodyItem = {\n                before: [],\n                lines: [],\n                after: []\n            };\n            const scoped = overrideCallbacks(callbacks, context);\n            pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, 'beforeLabel', this, context)));\n            pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, 'label', this, context));\n            pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, 'afterLabel', this, context)));\n            bodyItems.push(bodyItem);\n        });\n        return bodyItems;\n    }\n    getAfterBody(tooltipItems, options) {\n        return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, 'afterBody', this, tooltipItems));\n    }\n    getFooter(tooltipItems, options) {\n        const { callbacks } = options;\n        const beforeFooter = invokeCallbackWithFallback(callbacks, 'beforeFooter', this, tooltipItems);\n        const footer = invokeCallbackWithFallback(callbacks, 'footer', this, tooltipItems);\n        const afterFooter = invokeCallbackWithFallback(callbacks, 'afterFooter', this, tooltipItems);\n        let lines = [];\n        lines = pushOrConcat(lines, splitNewlines(beforeFooter));\n        lines = pushOrConcat(lines, splitNewlines(footer));\n        lines = pushOrConcat(lines, splitNewlines(afterFooter));\n        return lines;\n    }\n    _createItems(options) {\n        const active = this._active;\n        const data = this.chart.data;\n        const labelColors = [];\n        const labelPointStyles = [];\n        const labelTextColors = [];\n        let tooltipItems = [];\n        let i, len;\n        for(i = 0, len = active.length; i < len; ++i){\n            tooltipItems.push(createTooltipItem(this.chart, active[i]));\n        }\n        if (options.filter) {\n            tooltipItems = tooltipItems.filter((element, index, array)=>options.filter(element, index, array, data));\n        }\n        if (options.itemSort) {\n            tooltipItems = tooltipItems.sort((a, b)=>options.itemSort(a, b, data));\n        }\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(tooltipItems, (context)=>{\n            const scoped = overrideCallbacks(options.callbacks, context);\n            labelColors.push(invokeCallbackWithFallback(scoped, 'labelColor', this, context));\n            labelPointStyles.push(invokeCallbackWithFallback(scoped, 'labelPointStyle', this, context));\n            labelTextColors.push(invokeCallbackWithFallback(scoped, 'labelTextColor', this, context));\n        });\n        this.labelColors = labelColors;\n        this.labelPointStyles = labelPointStyles;\n        this.labelTextColors = labelTextColors;\n        this.dataPoints = tooltipItems;\n        return tooltipItems;\n    }\n    update(changed, replay) {\n        const options = this.options.setContext(this.getContext());\n        const active = this._active;\n        let properties;\n        let tooltipItems = [];\n        if (!active.length) {\n            if (this.opacity !== 0) {\n                properties = {\n                    opacity: 0\n                };\n            }\n        } else {\n            const position = positioners[options.position].call(this, active, this._eventPosition);\n            tooltipItems = this._createItems(options);\n            this.title = this.getTitle(tooltipItems, options);\n            this.beforeBody = this.getBeforeBody(tooltipItems, options);\n            this.body = this.getBody(tooltipItems, options);\n            this.afterBody = this.getAfterBody(tooltipItems, options);\n            this.footer = this.getFooter(tooltipItems, options);\n            const size = this._size = getTooltipSize(this, options);\n            const positionAndSize = Object.assign({}, position, size);\n            const alignment = determineAlignment(this.chart, options, positionAndSize);\n            const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);\n            this.xAlign = alignment.xAlign;\n            this.yAlign = alignment.yAlign;\n            properties = {\n                opacity: 1,\n                x: backgroundPoint.x,\n                y: backgroundPoint.y,\n                width: size.width,\n                height: size.height,\n                caretX: position.x,\n                caretY: position.y\n            };\n        }\n        this._tooltipItems = tooltipItems;\n        this.$context = undefined;\n        if (properties) {\n            this._resolveAnimations().update(this, properties);\n        }\n        if (changed && options.external) {\n            options.external.call(this, {\n                chart: this.chart,\n                tooltip: this,\n                replay\n            });\n        }\n    }\n    drawCaret(tooltipPoint, ctx, size, options) {\n        const caretPosition = this.getCaretPosition(tooltipPoint, size, options);\n        ctx.lineTo(caretPosition.x1, caretPosition.y1);\n        ctx.lineTo(caretPosition.x2, caretPosition.y2);\n        ctx.lineTo(caretPosition.x3, caretPosition.y3);\n    }\n    getCaretPosition(tooltipPoint, size, options) {\n        const { xAlign, yAlign } = this;\n        const { caretSize, cornerRadius } = options;\n        const { topLeft, topRight, bottomLeft, bottomRight } = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ay)(cornerRadius);\n        const { x: ptX, y: ptY } = tooltipPoint;\n        const { width, height } = size;\n        let x1, x2, x3, y1, y2, y3;\n        if (yAlign === 'center') {\n            y2 = ptY + height / 2;\n            if (xAlign === 'left') {\n                x1 = ptX;\n                x2 = x1 - caretSize;\n                y1 = y2 + caretSize;\n                y3 = y2 - caretSize;\n            } else {\n                x1 = ptX + width;\n                x2 = x1 + caretSize;\n                y1 = y2 - caretSize;\n                y3 = y2 + caretSize;\n            }\n            x3 = x1;\n        } else {\n            if (xAlign === 'left') {\n                x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;\n            } else if (xAlign === 'right') {\n                x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;\n            } else {\n                x2 = this.caretX;\n            }\n            if (yAlign === 'top') {\n                y1 = ptY;\n                y2 = y1 - caretSize;\n                x1 = x2 - caretSize;\n                x3 = x2 + caretSize;\n            } else {\n                y1 = ptY + height;\n                y2 = y1 + caretSize;\n                x1 = x2 + caretSize;\n                x3 = x2 - caretSize;\n            }\n            y3 = y1;\n        }\n        return {\n            x1,\n            x2,\n            x3,\n            y1,\n            y2,\n            y3\n        };\n    }\n    drawTitle(pt, ctx, options) {\n        const title = this.title;\n        const length = title.length;\n        let titleFont, titleSpacing, i;\n        if (length) {\n            const rtlHelper = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aA)(options.rtl, this.x, this.width);\n            pt.x = getAlignedX(this, options.titleAlign, options);\n            ctx.textAlign = rtlHelper.textAlign(options.titleAlign);\n            ctx.textBaseline = 'middle';\n            titleFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(options.titleFont);\n            titleSpacing = options.titleSpacing;\n            ctx.fillStyle = options.titleColor;\n            ctx.font = titleFont.string;\n            for(i = 0; i < length; ++i){\n                ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);\n                pt.y += titleFont.lineHeight + titleSpacing;\n                if (i + 1 === length) {\n                    pt.y += options.titleMarginBottom - titleSpacing;\n                }\n            }\n        }\n    }\n    _drawColorBox(ctx, pt, i, rtlHelper, options) {\n        const labelColor = this.labelColors[i];\n        const labelPointStyle = this.labelPointStyles[i];\n        const { boxHeight, boxWidth } = options;\n        const bodyFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(options.bodyFont);\n        const colorX = getAlignedX(this, 'left', options);\n        const rtlColorX = rtlHelper.x(colorX);\n        const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;\n        const colorY = pt.y + yOffSet;\n        if (options.usePointStyle) {\n            const drawOptions = {\n                radius: Math.min(boxWidth, boxHeight) / 2,\n                pointStyle: labelPointStyle.pointStyle,\n                rotation: labelPointStyle.rotation,\n                borderWidth: 1\n            };\n            const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;\n            const centerY = colorY + boxHeight / 2;\n            ctx.strokeStyle = options.multiKeyBackground;\n            ctx.fillStyle = options.multiKeyBackground;\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.av)(ctx, drawOptions, centerX, centerY);\n            ctx.strokeStyle = labelColor.borderColor;\n            ctx.fillStyle = labelColor.backgroundColor;\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.av)(ctx, drawOptions, centerX, centerY);\n        } else {\n            ctx.lineWidth = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : labelColor.borderWidth || 1;\n            ctx.strokeStyle = labelColor.borderColor;\n            ctx.setLineDash(labelColor.borderDash || []);\n            ctx.lineDashOffset = labelColor.borderDashOffset || 0;\n            const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);\n            const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);\n            const borderRadius = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ay)(labelColor.borderRadius);\n            if (Object.values(borderRadius).some((v)=>v !== 0)) {\n                ctx.beginPath();\n                ctx.fillStyle = options.multiKeyBackground;\n                (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aw)(ctx, {\n                    x: outerX,\n                    y: colorY,\n                    w: boxWidth,\n                    h: boxHeight,\n                    radius: borderRadius\n                });\n                ctx.fill();\n                ctx.stroke();\n                ctx.fillStyle = labelColor.backgroundColor;\n                ctx.beginPath();\n                (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aw)(ctx, {\n                    x: innerX,\n                    y: colorY + 1,\n                    w: boxWidth - 2,\n                    h: boxHeight - 2,\n                    radius: borderRadius\n                });\n                ctx.fill();\n            } else {\n                ctx.fillStyle = options.multiKeyBackground;\n                ctx.fillRect(outerX, colorY, boxWidth, boxHeight);\n                ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);\n                ctx.fillStyle = labelColor.backgroundColor;\n                ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);\n            }\n        }\n        ctx.fillStyle = this.labelTextColors[i];\n    }\n    drawBody(pt, ctx, options) {\n        const { body } = this;\n        const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;\n        const bodyFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(options.bodyFont);\n        let bodyLineHeight = bodyFont.lineHeight;\n        let xLinePadding = 0;\n        const rtlHelper = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aA)(options.rtl, this.x, this.width);\n        const fillLineOfText = function(line) {\n            ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);\n            pt.y += bodyLineHeight + bodySpacing;\n        };\n        const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);\n        let bodyItem, textColor, lines, i, j, ilen, jlen;\n        ctx.textAlign = bodyAlign;\n        ctx.textBaseline = 'middle';\n        ctx.font = bodyFont.string;\n        pt.x = getAlignedX(this, bodyAlignForCalculation, options);\n        ctx.fillStyle = options.bodyColor;\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(this.beforeBody, fillLineOfText);\n        xLinePadding = displayColors && bodyAlignForCalculation !== 'right' ? bodyAlign === 'center' ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;\n        for(i = 0, ilen = body.length; i < ilen; ++i){\n            bodyItem = body[i];\n            textColor = this.labelTextColors[i];\n            ctx.fillStyle = textColor;\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(bodyItem.before, fillLineOfText);\n            lines = bodyItem.lines;\n            if (displayColors && lines.length) {\n                this._drawColorBox(ctx, pt, i, rtlHelper, options);\n                bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);\n            }\n            for(j = 0, jlen = lines.length; j < jlen; ++j){\n                fillLineOfText(lines[j]);\n                bodyLineHeight = bodyFont.lineHeight;\n            }\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(bodyItem.after, fillLineOfText);\n        }\n        xLinePadding = 0;\n        bodyLineHeight = bodyFont.lineHeight;\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(this.afterBody, fillLineOfText);\n        pt.y -= bodySpacing;\n    }\n    drawFooter(pt, ctx, options) {\n        const footer = this.footer;\n        const length = footer.length;\n        let footerFont, i;\n        if (length) {\n            const rtlHelper = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aA)(options.rtl, this.x, this.width);\n            pt.x = getAlignedX(this, options.footerAlign, options);\n            pt.y += options.footerMarginTop;\n            ctx.textAlign = rtlHelper.textAlign(options.footerAlign);\n            ctx.textBaseline = 'middle';\n            footerFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(options.footerFont);\n            ctx.fillStyle = options.footerColor;\n            ctx.font = footerFont.string;\n            for(i = 0; i < length; ++i){\n                ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);\n                pt.y += footerFont.lineHeight + options.footerSpacing;\n            }\n        }\n    }\n    drawBackground(pt, ctx, tooltipSize, options) {\n        const { xAlign, yAlign } = this;\n        const { x, y } = pt;\n        const { width, height } = tooltipSize;\n        const { topLeft, topRight, bottomLeft, bottomRight } = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ay)(options.cornerRadius);\n        ctx.fillStyle = options.backgroundColor;\n        ctx.strokeStyle = options.borderColor;\n        ctx.lineWidth = options.borderWidth;\n        ctx.beginPath();\n        ctx.moveTo(x + topLeft, y);\n        if (yAlign === 'top') {\n            this.drawCaret(pt, ctx, tooltipSize, options);\n        }\n        ctx.lineTo(x + width - topRight, y);\n        ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);\n        if (yAlign === 'center' && xAlign === 'right') {\n            this.drawCaret(pt, ctx, tooltipSize, options);\n        }\n        ctx.lineTo(x + width, y + height - bottomRight);\n        ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);\n        if (yAlign === 'bottom') {\n            this.drawCaret(pt, ctx, tooltipSize, options);\n        }\n        ctx.lineTo(x + bottomLeft, y + height);\n        ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);\n        if (yAlign === 'center' && xAlign === 'left') {\n            this.drawCaret(pt, ctx, tooltipSize, options);\n        }\n        ctx.lineTo(x, y + topLeft);\n        ctx.quadraticCurveTo(x, y, x + topLeft, y);\n        ctx.closePath();\n        ctx.fill();\n        if (options.borderWidth > 0) {\n            ctx.stroke();\n        }\n    }\n    _updateAnimationTarget(options) {\n        const chart = this.chart;\n        const anims = this.$animations;\n        const animX = anims && anims.x;\n        const animY = anims && anims.y;\n        if (animX || animY) {\n            const position = positioners[options.position].call(this, this._active, this._eventPosition);\n            if (!position) {\n                return;\n            }\n            const size = this._size = getTooltipSize(this, options);\n            const positionAndSize = Object.assign({}, position, this._size);\n            const alignment = determineAlignment(chart, options, positionAndSize);\n            const point = getBackgroundPoint(options, positionAndSize, alignment, chart);\n            if (animX._to !== point.x || animY._to !== point.y) {\n                this.xAlign = alignment.xAlign;\n                this.yAlign = alignment.yAlign;\n                this.width = size.width;\n                this.height = size.height;\n                this.caretX = position.x;\n                this.caretY = position.y;\n                this._resolveAnimations().update(this, point);\n            }\n        }\n    }\n    _willRender() {\n        return !!this.opacity;\n    }\n    draw(ctx) {\n        const options = this.options.setContext(this.getContext());\n        let opacity = this.opacity;\n        if (!opacity) {\n            return;\n        }\n        this._updateAnimationTarget(options);\n        const tooltipSize = {\n            width: this.width,\n            height: this.height\n        };\n        const pt = {\n            x: this.x,\n            y: this.y\n        };\n        opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;\n        const padding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(options.padding);\n        const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;\n        if (options.enabled && hasTooltipContent) {\n            ctx.save();\n            ctx.globalAlpha = opacity;\n            this.drawBackground(pt, ctx, tooltipSize, options);\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aB)(ctx, options.textDirection);\n            pt.y += padding.top;\n            this.drawTitle(pt, ctx, options);\n            this.drawBody(pt, ctx, options);\n            this.drawFooter(pt, ctx, options);\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aD)(ctx, options.textDirection);\n            ctx.restore();\n        }\n    }\n    getActiveElements() {\n        return this._active || [];\n    }\n    setActiveElements(activeElements, eventPosition) {\n        const lastActive = this._active;\n        const active = activeElements.map(({ datasetIndex, index })=>{\n            const meta = this.chart.getDatasetMeta(datasetIndex);\n            if (!meta) {\n                throw new Error('Cannot find a dataset at index ' + datasetIndex);\n            }\n            return {\n                datasetIndex,\n                element: meta.data[index],\n                index\n            };\n        });\n        const changed = !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ai)(lastActive, active);\n        const positionChanged = this._positionChanged(active, eventPosition);\n        if (changed || positionChanged) {\n            this._active = active;\n            this._eventPosition = eventPosition;\n            this._ignoreReplayEvents = true;\n            this.update(true);\n        }\n    }\n    handleEvent(e, replay, inChartArea = true) {\n        if (replay && this._ignoreReplayEvents) {\n            return false;\n        }\n        this._ignoreReplayEvents = false;\n        const options = this.options;\n        const lastActive = this._active || [];\n        const active = this._getActiveElements(e, lastActive, replay, inChartArea);\n        const positionChanged = this._positionChanged(active, e);\n        const changed = replay || !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ai)(active, lastActive) || positionChanged;\n        if (changed) {\n            this._active = active;\n            if (options.enabled || options.external) {\n                this._eventPosition = {\n                    x: e.x,\n                    y: e.y\n                };\n                this.update(true, replay);\n            }\n        }\n        return changed;\n    }\n    _getActiveElements(e, lastActive, replay, inChartArea) {\n        const options = this.options;\n        if (e.type === 'mouseout') {\n            return [];\n        }\n        if (!inChartArea) {\n            return lastActive.filter((i)=>this.chart.data.datasets[i.datasetIndex] && this.chart.getDatasetMeta(i.datasetIndex).controller.getParsed(i.index) !== undefined);\n        }\n        const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);\n        if (options.reverse) {\n            active.reverse();\n        }\n        return active;\n    }\n    _positionChanged(active, e) {\n        const { caretX, caretY, options } = this;\n        const position = positioners[options.position].call(this, active, e);\n        return position !== false && (caretX !== position.x || caretY !== position.y);\n    }\n}\nvar plugin_tooltip = {\n    id: 'tooltip',\n    _element: Tooltip,\n    positioners,\n    afterInit (chart, _args, options) {\n        if (options) {\n            chart.tooltip = new Tooltip({\n                chart,\n                options\n            });\n        }\n    },\n    beforeUpdate (chart, _args, options) {\n        if (chart.tooltip) {\n            chart.tooltip.initialize(options);\n        }\n    },\n    reset (chart, _args, options) {\n        if (chart.tooltip) {\n            chart.tooltip.initialize(options);\n        }\n    },\n    afterDraw (chart) {\n        const tooltip = chart.tooltip;\n        if (tooltip && tooltip._willRender()) {\n            const args = {\n                tooltip\n            };\n            if (chart.notifyPlugins('beforeTooltipDraw', {\n                ...args,\n                cancelable: true\n            }) === false) {\n                return;\n            }\n            tooltip.draw(chart.ctx);\n            chart.notifyPlugins('afterTooltipDraw', args);\n        }\n    },\n    afterEvent (chart, args) {\n        if (chart.tooltip) {\n            const useFinalPosition = args.replay;\n            if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {\n                args.changed = true;\n            }\n        }\n    },\n    defaults: {\n        enabled: true,\n        external: null,\n        position: 'average',\n        backgroundColor: 'rgba(0,0,0,0.8)',\n        titleColor: '#fff',\n        titleFont: {\n            weight: 'bold'\n        },\n        titleSpacing: 2,\n        titleMarginBottom: 6,\n        titleAlign: 'left',\n        bodyColor: '#fff',\n        bodySpacing: 2,\n        bodyFont: {},\n        bodyAlign: 'left',\n        footerColor: '#fff',\n        footerSpacing: 2,\n        footerMarginTop: 6,\n        footerFont: {\n            weight: 'bold'\n        },\n        footerAlign: 'left',\n        padding: 6,\n        caretPadding: 2,\n        caretSize: 5,\n        cornerRadius: 6,\n        boxHeight: (ctx, opts)=>opts.bodyFont.size,\n        boxWidth: (ctx, opts)=>opts.bodyFont.size,\n        multiKeyBackground: '#fff',\n        displayColors: true,\n        boxPadding: 0,\n        borderColor: 'rgba(0,0,0,0)',\n        borderWidth: 0,\n        animation: {\n            duration: 400,\n            easing: 'easeOutQuart'\n        },\n        animations: {\n            numbers: {\n                type: 'number',\n                properties: [\n                    'x',\n                    'y',\n                    'width',\n                    'height',\n                    'caretX',\n                    'caretY'\n                ]\n            },\n            opacity: {\n                easing: 'linear',\n                duration: 200\n            }\n        },\n        callbacks: defaultCallbacks\n    },\n    defaultRoutes: {\n        bodyFont: 'font',\n        footerFont: 'font',\n        titleFont: 'font'\n    },\n    descriptors: {\n        _scriptable: (name)=>name !== 'filter' && name !== 'itemSort' && name !== 'external',\n        _indexable: false,\n        callbacks: {\n            _scriptable: false,\n            _indexable: false\n        },\n        animation: {\n            _fallback: false\n        },\n        animations: {\n            _fallback: 'animation'\n        }\n    },\n    additionalOptionScopes: [\n        'interaction'\n    ]\n};\nvar plugins = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    Colors: plugin_colors,\n    Decimation: plugin_decimation,\n    Filler: index,\n    Legend: plugin_legend,\n    SubTitle: plugin_subtitle,\n    Title: plugin_title,\n    Tooltip: plugin_tooltip\n});\nconst addIfString = (labels, raw, index, addedLabels)=>{\n    if (typeof raw === 'string') {\n        index = labels.push(raw) - 1;\n        addedLabels.unshift({\n            index,\n            label: raw\n        });\n    } else if (isNaN(raw)) {\n        index = null;\n    }\n    return index;\n};\nfunction findOrAddLabel(labels, raw, index, addedLabels) {\n    const first = labels.indexOf(raw);\n    if (first === -1) {\n        return addIfString(labels, raw, index, addedLabels);\n    }\n    const last = labels.lastIndexOf(raw);\n    return first !== last ? index : first;\n}\nconst validIndex = (index, max)=>index === null ? null : (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(Math.round(index), 0, max);\nfunction _getLabelForValue(value) {\n    const labels = this.getLabels();\n    if (value >= 0 && value < labels.length) {\n        return labels[value];\n    }\n    return value;\n}\nclass CategoryScale extends Scale {\n    static{\n        this.id = 'category';\n    }\n    static{\n        this.defaults = {\n            ticks: {\n                callback: _getLabelForValue\n            }\n        };\n    }\n    constructor(cfg){\n        super(cfg);\n        this._startValue = undefined;\n        this._valueRange = 0;\n        this._addedLabels = [];\n    }\n    init(scaleOptions) {\n        const added = this._addedLabels;\n        if (added.length) {\n            const labels = this.getLabels();\n            for (const { index, label } of added){\n                if (labels[index] === label) {\n                    labels.splice(index, 1);\n                }\n            }\n            this._addedLabels = [];\n        }\n        super.init(scaleOptions);\n    }\n    parse(raw, index) {\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(raw)) {\n            return null;\n        }\n        const labels = this.getLabels();\n        index = isFinite(index) && labels[index] === raw ? index : findOrAddLabel(labels, raw, (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(index, raw), this._addedLabels);\n        return validIndex(index, labels.length - 1);\n    }\n    determineDataLimits() {\n        const { minDefined, maxDefined } = this.getUserBounds();\n        let { min, max } = this.getMinMax(true);\n        if (this.options.bounds === 'ticks') {\n            if (!minDefined) {\n                min = 0;\n            }\n            if (!maxDefined) {\n                max = this.getLabels().length - 1;\n            }\n        }\n        this.min = min;\n        this.max = max;\n    }\n    buildTicks() {\n        const min = this.min;\n        const max = this.max;\n        const offset = this.options.offset;\n        const ticks = [];\n        let labels = this.getLabels();\n        labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);\n        this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);\n        this._startValue = this.min - (offset ? 0.5 : 0);\n        for(let value = min; value <= max; value++){\n            ticks.push({\n                value\n            });\n        }\n        return ticks;\n    }\n    getLabelForValue(value) {\n        return _getLabelForValue.call(this, value);\n    }\n    configure() {\n        super.configure();\n        if (!this.isHorizontal()) {\n            this._reversePixels = !this._reversePixels;\n        }\n    }\n    getPixelForValue(value) {\n        if (typeof value !== 'number') {\n            value = this.parse(value);\n        }\n        return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n    }\n    getPixelForTick(index) {\n        const ticks = this.ticks;\n        if (index < 0 || index > ticks.length - 1) {\n            return null;\n        }\n        return this.getPixelForValue(ticks[index].value);\n    }\n    getValueForPixel(pixel) {\n        return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);\n    }\n    getBasePixel() {\n        return this.bottom;\n    }\n}\nfunction generateTicks$1(generationOptions, dataRange) {\n    const ticks = [];\n    const MIN_SPACING = 1e-14;\n    const { bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;\n    const unit = step || 1;\n    const maxSpaces = maxTicks - 1;\n    const { min: rmin, max: rmax } = dataRange;\n    const minDefined = !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(min);\n    const maxDefined = !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(max);\n    const countDefined = !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(count);\n    const minSpacing = (rmax - rmin) / (maxDigits + 1);\n    let spacing = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aI)((rmax - rmin) / maxSpaces / unit) * unit;\n    let factor, niceMin, niceMax, numSpaces;\n    if (spacing < MIN_SPACING && !minDefined && !maxDefined) {\n        return [\n            {\n                value: rmin\n            },\n            {\n                value: rmax\n            }\n        ];\n    }\n    numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);\n    if (numSpaces > maxSpaces) {\n        spacing = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aI)(numSpaces * spacing / maxSpaces / unit) * unit;\n    }\n    if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(precision)) {\n        factor = Math.pow(10, precision);\n        spacing = Math.ceil(spacing * factor) / factor;\n    }\n    if (bounds === 'ticks') {\n        niceMin = Math.floor(rmin / spacing) * spacing;\n        niceMax = Math.ceil(rmax / spacing) * spacing;\n    } else {\n        niceMin = rmin;\n        niceMax = rmax;\n    }\n    if (minDefined && maxDefined && step && (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aJ)((max - min) / step, spacing / 1000)) {\n        numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));\n        spacing = (max - min) / numSpaces;\n        niceMin = min;\n        niceMax = max;\n    } else if (countDefined) {\n        niceMin = minDefined ? min : niceMin;\n        niceMax = maxDefined ? max : niceMax;\n        numSpaces = count - 1;\n        spacing = (niceMax - niceMin) / numSpaces;\n    } else {\n        numSpaces = (niceMax - niceMin) / spacing;\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aK)(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n            numSpaces = Math.round(numSpaces);\n        } else {\n            numSpaces = Math.ceil(numSpaces);\n        }\n    }\n    const decimalPlaces = Math.max((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aL)(spacing), (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aL)(niceMin));\n    factor = Math.pow(10, (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(precision) ? decimalPlaces : precision);\n    niceMin = Math.round(niceMin * factor) / factor;\n    niceMax = Math.round(niceMax * factor) / factor;\n    let j = 0;\n    if (minDefined) {\n        if (includeBounds && niceMin !== min) {\n            ticks.push({\n                value: min\n            });\n            if (niceMin < min) {\n                j++;\n            }\n            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aK)(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {\n                j++;\n            }\n        } else if (niceMin < min) {\n            j++;\n        }\n    }\n    for(; j < numSpaces; ++j){\n        const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;\n        if (maxDefined && tickValue > max) {\n            break;\n        }\n        ticks.push({\n            value: tickValue\n        });\n    }\n    if (maxDefined && includeBounds && niceMax !== max) {\n        if (ticks.length && (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aK)(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {\n            ticks[ticks.length - 1].value = max;\n        } else {\n            ticks.push({\n                value: max\n            });\n        }\n    } else if (!maxDefined || niceMax === max) {\n        ticks.push({\n            value: niceMax\n        });\n    }\n    return ticks;\n}\nfunction relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {\n    const rad = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(minRotation);\n    const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;\n    const length = 0.75 * minSpacing * ('' + value).length;\n    return Math.min(minSpacing / ratio, length);\n}\nclass LinearScaleBase extends Scale {\n    constructor(cfg){\n        super(cfg);\n        this.start = undefined;\n        this.end = undefined;\n        this._startValue = undefined;\n        this._endValue = undefined;\n        this._valueRange = 0;\n    }\n    parse(raw, index) {\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(raw)) {\n            return null;\n        }\n        if ((typeof raw === 'number' || raw instanceof Number) && !isFinite(+raw)) {\n            return null;\n        }\n        return +raw;\n    }\n    handleTickRangeOptions() {\n        const { beginAtZero } = this.options;\n        const { minDefined, maxDefined } = this.getUserBounds();\n        let { min, max } = this;\n        const setMin = (v)=>min = minDefined ? min : v;\n        const setMax = (v)=>max = maxDefined ? max : v;\n        if (beginAtZero) {\n            const minSign = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.s)(min);\n            const maxSign = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.s)(max);\n            if (minSign < 0 && maxSign < 0) {\n                setMax(0);\n            } else if (minSign > 0 && maxSign > 0) {\n                setMin(0);\n            }\n        }\n        if (min === max) {\n            let offset = max === 0 ? 1 : Math.abs(max * 0.05);\n            setMax(max + offset);\n            if (!beginAtZero) {\n                setMin(min - offset);\n            }\n        }\n        this.min = min;\n        this.max = max;\n    }\n    getTickLimit() {\n        const tickOpts = this.options.ticks;\n        let { maxTicksLimit, stepSize } = tickOpts;\n        let maxTicks;\n        if (stepSize) {\n            maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;\n            if (maxTicks > 1000) {\n                console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);\n                maxTicks = 1000;\n            }\n        } else {\n            maxTicks = this.computeTickLimit();\n            maxTicksLimit = maxTicksLimit || 11;\n        }\n        if (maxTicksLimit) {\n            maxTicks = Math.min(maxTicksLimit, maxTicks);\n        }\n        return maxTicks;\n    }\n    computeTickLimit() {\n        return Number.POSITIVE_INFINITY;\n    }\n    buildTicks() {\n        const opts = this.options;\n        const tickOpts = opts.ticks;\n        let maxTicks = this.getTickLimit();\n        maxTicks = Math.max(2, maxTicks);\n        const numericGeneratorOptions = {\n            maxTicks,\n            bounds: opts.bounds,\n            min: opts.min,\n            max: opts.max,\n            precision: tickOpts.precision,\n            step: tickOpts.stepSize,\n            count: tickOpts.count,\n            maxDigits: this._maxDigits(),\n            horizontal: this.isHorizontal(),\n            minRotation: tickOpts.minRotation || 0,\n            includeBounds: tickOpts.includeBounds !== false\n        };\n        const dataRange = this._range || this;\n        const ticks = generateTicks$1(numericGeneratorOptions, dataRange);\n        if (opts.bounds === 'ticks') {\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aH)(ticks, this, 'value');\n        }\n        if (opts.reverse) {\n            ticks.reverse();\n            this.start = this.max;\n            this.end = this.min;\n        } else {\n            this.start = this.min;\n            this.end = this.max;\n        }\n        return ticks;\n    }\n    configure() {\n        const ticks = this.ticks;\n        let start = this.min;\n        let end = this.max;\n        super.configure();\n        if (this.options.offset && ticks.length) {\n            const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;\n            start -= offset;\n            end += offset;\n        }\n        this._startValue = start;\n        this._endValue = end;\n        this._valueRange = end - start;\n    }\n    getLabelForValue(value) {\n        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.o)(value, this.chart.options.locale, this.options.ticks.format);\n    }\n}\nclass LinearScale extends LinearScaleBase {\n    static{\n        this.id = 'linear';\n    }\n    static{\n        this.defaults = {\n            ticks: {\n                callback: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aM.formatters.numeric\n            }\n        };\n    }\n    determineDataLimits() {\n        const { min, max } = this.getMinMax(true);\n        this.min = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(min) ? min : 0;\n        this.max = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(max) ? max : 1;\n        this.handleTickRangeOptions();\n    }\n    computeTickLimit() {\n        const horizontal = this.isHorizontal();\n        const length = horizontal ? this.width : this.height;\n        const minRotation = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.options.ticks.minRotation);\n        const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;\n        const tickFont = this._resolveTickFontOptions(0);\n        return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));\n    }\n    getPixelForValue(value) {\n        return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n    }\n    getValueForPixel(pixel) {\n        return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;\n    }\n}\nconst log10Floor = (v)=>Math.floor((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aN)(v));\nconst changeExponent = (v, m)=>Math.pow(10, log10Floor(v) + m);\nfunction isMajor(tickVal) {\n    const remain = tickVal / Math.pow(10, log10Floor(tickVal));\n    return remain === 1;\n}\nfunction steps(min, max, rangeExp) {\n    const rangeStep = Math.pow(10, rangeExp);\n    const start = Math.floor(min / rangeStep);\n    const end = Math.ceil(max / rangeStep);\n    return end - start;\n}\nfunction startExp(min, max) {\n    const range = max - min;\n    let rangeExp = log10Floor(range);\n    while(steps(min, max, rangeExp) > 10){\n        rangeExp++;\n    }\n    while(steps(min, max, rangeExp) < 10){\n        rangeExp--;\n    }\n    return Math.min(rangeExp, log10Floor(min));\n}\nfunction generateTicks(generationOptions, { min, max }) {\n    min = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(generationOptions.min, min);\n    const ticks = [];\n    const minExp = log10Floor(min);\n    let exp = startExp(min, max);\n    let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\n    const stepSize = Math.pow(10, exp);\n    const base = minExp > exp ? Math.pow(10, minExp) : 0;\n    const start = Math.round((min - base) * precision) / precision;\n    const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;\n    let significand = Math.floor((start - offset) / Math.pow(10, exp));\n    let value = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);\n    while(value < max){\n        ticks.push({\n            value,\n            major: isMajor(value),\n            significand\n        });\n        if (significand >= 10) {\n            significand = significand < 15 ? 15 : 20;\n        } else {\n            significand++;\n        }\n        if (significand >= 20) {\n            exp++;\n            significand = 2;\n            precision = exp >= 0 ? 1 : precision;\n        }\n        value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;\n    }\n    const lastTick = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(generationOptions.max, value);\n    ticks.push({\n        value: lastTick,\n        major: isMajor(lastTick),\n        significand\n    });\n    return ticks;\n}\nclass LogarithmicScale extends Scale {\n    static{\n        this.id = 'logarithmic';\n    }\n    static{\n        this.defaults = {\n            ticks: {\n                callback: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aM.formatters.logarithmic,\n                major: {\n                    enabled: true\n                }\n            }\n        };\n    }\n    constructor(cfg){\n        super(cfg);\n        this.start = undefined;\n        this.end = undefined;\n        this._startValue = undefined;\n        this._valueRange = 0;\n    }\n    parse(raw, index) {\n        const value = LinearScaleBase.prototype.parse.apply(this, [\n            raw,\n            index\n        ]);\n        if (value === 0) {\n            this._zero = true;\n            return undefined;\n        }\n        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(value) && value > 0 ? value : null;\n    }\n    determineDataLimits() {\n        const { min, max } = this.getMinMax(true);\n        this.min = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(min) ? Math.max(0, min) : null;\n        this.max = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(max) ? Math.max(0, max) : null;\n        if (this.options.beginAtZero) {\n            this._zero = true;\n        }\n        if (this._zero && this.min !== this._suggestedMin && !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(this._userMin)) {\n            this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);\n        }\n        this.handleTickRangeOptions();\n    }\n    handleTickRangeOptions() {\n        const { minDefined, maxDefined } = this.getUserBounds();\n        let min = this.min;\n        let max = this.max;\n        const setMin = (v)=>min = minDefined ? min : v;\n        const setMax = (v)=>max = maxDefined ? max : v;\n        if (min === max) {\n            if (min <= 0) {\n                setMin(1);\n                setMax(10);\n            } else {\n                setMin(changeExponent(min, -1));\n                setMax(changeExponent(max, +1));\n            }\n        }\n        if (min <= 0) {\n            setMin(changeExponent(max, -1));\n        }\n        if (max <= 0) {\n            setMax(changeExponent(min, +1));\n        }\n        this.min = min;\n        this.max = max;\n    }\n    buildTicks() {\n        const opts = this.options;\n        const generationOptions = {\n            min: this._userMin,\n            max: this._userMax\n        };\n        const ticks = generateTicks(generationOptions, this);\n        if (opts.bounds === 'ticks') {\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aH)(ticks, this, 'value');\n        }\n        if (opts.reverse) {\n            ticks.reverse();\n            this.start = this.max;\n            this.end = this.min;\n        } else {\n            this.start = this.min;\n            this.end = this.max;\n        }\n        return ticks;\n    }\n    getLabelForValue(value) {\n        return value === undefined ? '0' : (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.o)(value, this.chart.options.locale, this.options.ticks.format);\n    }\n    configure() {\n        const start = this.min;\n        super.configure();\n        this._startValue = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aN)(start);\n        this._valueRange = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aN)(this.max) - (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aN)(start);\n    }\n    getPixelForValue(value) {\n        if (value === undefined || value === 0) {\n            value = this.min;\n        }\n        if (value === null || isNaN(value)) {\n            return NaN;\n        }\n        return this.getPixelForDecimal(value === this.min ? 0 : ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aN)(value) - this._startValue) / this._valueRange);\n    }\n    getValueForPixel(pixel) {\n        const decimal = this.getDecimalForPixel(pixel);\n        return Math.pow(10, this._startValue + decimal * this._valueRange);\n    }\n}\nfunction getTickBackdropHeight(opts) {\n    const tickOpts = opts.ticks;\n    if (tickOpts.display && opts.display) {\n        const padding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(tickOpts.backdropPadding);\n        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(tickOpts.font && tickOpts.font.size, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.font.size) + padding.height;\n    }\n    return 0;\n}\nfunction measureLabelSize(ctx, font, label) {\n    label = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(label) ? label : [\n        label\n    ];\n    return {\n        w: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aO)(ctx, font.string, label),\n        h: label.length * font.lineHeight\n    };\n}\nfunction determineLimits(angle, pos, size, min, max) {\n    if (angle === min || angle === max) {\n        return {\n            start: pos - size / 2,\n            end: pos + size / 2\n        };\n    } else if (angle < min || angle > max) {\n        return {\n            start: pos - size,\n            end: pos\n        };\n    }\n    return {\n        start: pos,\n        end: pos + size\n    };\n}\nfunction fitWithPointLabels(scale) {\n    const orig = {\n        l: scale.left + scale._padding.left,\n        r: scale.right - scale._padding.right,\n        t: scale.top + scale._padding.top,\n        b: scale.bottom - scale._padding.bottom\n    };\n    const limits = Object.assign({}, orig);\n    const labelSizes = [];\n    const padding = [];\n    const valueCount = scale._pointLabels.length;\n    const pointLabelOpts = scale.options.pointLabels;\n    const additionalAngle = pointLabelOpts.centerPointLabels ? _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P / valueCount : 0;\n    for(let i = 0; i < valueCount; i++){\n        const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));\n        padding[i] = opts.padding;\n        const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);\n        const plFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(opts.font);\n        const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);\n        labelSizes[i] = textSize;\n        const angleRadians = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.al)(scale.getIndexAngle(i) + additionalAngle);\n        const angle = Math.round((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.U)(angleRadians));\n        const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n        const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n        updateLimits(limits, orig, angleRadians, hLimits, vLimits);\n    }\n    scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);\n    scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);\n}\nfunction updateLimits(limits, orig, angle, hLimits, vLimits) {\n    const sin = Math.abs(Math.sin(angle));\n    const cos = Math.abs(Math.cos(angle));\n    let x = 0;\n    let y = 0;\n    if (hLimits.start < orig.l) {\n        x = (orig.l - hLimits.start) / sin;\n        limits.l = Math.min(limits.l, orig.l - x);\n    } else if (hLimits.end > orig.r) {\n        x = (hLimits.end - orig.r) / sin;\n        limits.r = Math.max(limits.r, orig.r + x);\n    }\n    if (vLimits.start < orig.t) {\n        y = (orig.t - vLimits.start) / cos;\n        limits.t = Math.min(limits.t, orig.t - y);\n    } else if (vLimits.end > orig.b) {\n        y = (vLimits.end - orig.b) / cos;\n        limits.b = Math.max(limits.b, orig.b + y);\n    }\n}\nfunction createPointLabelItem(scale, index, itemOpts) {\n    const outerDistance = scale.drawingArea;\n    const { extra, additionalAngle, padding, size } = itemOpts;\n    const pointLabelPosition = scale.getPointPosition(index, outerDistance + extra + padding, additionalAngle);\n    const angle = Math.round((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.U)((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.al)(pointLabelPosition.angle + _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H)));\n    const y = yForAngle(pointLabelPosition.y, size.h, angle);\n    const textAlign = getTextAlignForAngle(angle);\n    const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);\n    return {\n        visible: true,\n        x: pointLabelPosition.x,\n        y,\n        textAlign,\n        left,\n        top: y,\n        right: left + size.w,\n        bottom: y + size.h\n    };\n}\nfunction isNotOverlapped(item, area) {\n    if (!area) {\n        return true;\n    }\n    const { left, top, right, bottom } = item;\n    const apexesInArea = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.C)({\n        x: left,\n        y: top\n    }, area) || (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.C)({\n        x: left,\n        y: bottom\n    }, area) || (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.C)({\n        x: right,\n        y: top\n    }, area) || (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.C)({\n        x: right,\n        y: bottom\n    }, area);\n    return !apexesInArea;\n}\nfunction buildPointLabelItems(scale, labelSizes, padding) {\n    const items = [];\n    const valueCount = scale._pointLabels.length;\n    const opts = scale.options;\n    const { centerPointLabels, display } = opts.pointLabels;\n    const itemOpts = {\n        extra: getTickBackdropHeight(opts) / 2,\n        additionalAngle: centerPointLabels ? _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P / valueCount : 0\n    };\n    let area;\n    for(let i = 0; i < valueCount; i++){\n        itemOpts.padding = padding[i];\n        itemOpts.size = labelSizes[i];\n        const item = createPointLabelItem(scale, i, itemOpts);\n        items.push(item);\n        if (display === 'auto') {\n            item.visible = isNotOverlapped(item, area);\n            if (item.visible) {\n                area = item;\n            }\n        }\n    }\n    return items;\n}\nfunction getTextAlignForAngle(angle) {\n    if (angle === 0 || angle === 180) {\n        return 'center';\n    } else if (angle < 180) {\n        return 'left';\n    }\n    return 'right';\n}\nfunction leftForTextAlign(x, w, align) {\n    if (align === 'right') {\n        x -= w;\n    } else if (align === 'center') {\n        x -= w / 2;\n    }\n    return x;\n}\nfunction yForAngle(y, h, angle) {\n    if (angle === 90 || angle === 270) {\n        y -= h / 2;\n    } else if (angle > 270 || angle < 90) {\n        y -= h;\n    }\n    return y;\n}\nfunction drawPointLabelBox(ctx, opts, item) {\n    const { left, top, right, bottom } = item;\n    const { backdropColor } = opts;\n    if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(backdropColor)) {\n        const borderRadius = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ay)(opts.borderRadius);\n        const padding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(opts.backdropPadding);\n        ctx.fillStyle = backdropColor;\n        const backdropLeft = left - padding.left;\n        const backdropTop = top - padding.top;\n        const backdropWidth = right - left + padding.width;\n        const backdropHeight = bottom - top + padding.height;\n        if (Object.values(borderRadius).some((v)=>v !== 0)) {\n            ctx.beginPath();\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aw)(ctx, {\n                x: backdropLeft,\n                y: backdropTop,\n                w: backdropWidth,\n                h: backdropHeight,\n                radius: borderRadius\n            });\n            ctx.fill();\n        } else {\n            ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);\n        }\n    }\n}\nfunction drawPointLabels(scale, labelCount) {\n    const { ctx, options: { pointLabels } } = scale;\n    for(let i = labelCount - 1; i >= 0; i--){\n        const item = scale._pointLabelItems[i];\n        if (!item.visible) {\n            continue;\n        }\n        const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));\n        drawPointLabelBox(ctx, optsAtIndex, item);\n        const plFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(optsAtIndex.font);\n        const { x, y, textAlign } = item;\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Z)(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {\n            color: optsAtIndex.color,\n            textAlign: textAlign,\n            textBaseline: 'middle'\n        });\n    }\n}\nfunction pathRadiusLine(scale, radius, circular, labelCount) {\n    const { ctx } = scale;\n    if (circular) {\n        ctx.arc(scale.xCenter, scale.yCenter, radius, 0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T);\n    } else {\n        let pointPosition = scale.getPointPosition(0, radius);\n        ctx.moveTo(pointPosition.x, pointPosition.y);\n        for(let i = 1; i < labelCount; i++){\n            pointPosition = scale.getPointPosition(i, radius);\n            ctx.lineTo(pointPosition.x, pointPosition.y);\n        }\n    }\n}\nfunction drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {\n    const ctx = scale.ctx;\n    const circular = gridLineOpts.circular;\n    const { color, lineWidth } = gridLineOpts;\n    if (!circular && !labelCount || !color || !lineWidth || radius < 0) {\n        return;\n    }\n    ctx.save();\n    ctx.strokeStyle = color;\n    ctx.lineWidth = lineWidth;\n    ctx.setLineDash(borderOpts.dash || []);\n    ctx.lineDashOffset = borderOpts.dashOffset;\n    ctx.beginPath();\n    pathRadiusLine(scale, radius, circular, labelCount);\n    ctx.closePath();\n    ctx.stroke();\n    ctx.restore();\n}\nfunction createPointLabelContext(parent, index, label) {\n    return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.j)(parent, {\n        label,\n        index,\n        type: 'pointLabel'\n    });\n}\nclass RadialLinearScale extends LinearScaleBase {\n    static{\n        this.id = 'radialLinear';\n    }\n    static{\n        this.defaults = {\n            display: true,\n            animate: true,\n            position: 'chartArea',\n            angleLines: {\n                display: true,\n                lineWidth: 1,\n                borderDash: [],\n                borderDashOffset: 0.0\n            },\n            grid: {\n                circular: false\n            },\n            startAngle: 0,\n            ticks: {\n                showLabelBackdrop: true,\n                callback: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aM.formatters.numeric\n            },\n            pointLabels: {\n                backdropColor: undefined,\n                backdropPadding: 2,\n                display: true,\n                font: {\n                    size: 10\n                },\n                callback (label) {\n                    return label;\n                },\n                padding: 5,\n                centerPointLabels: false\n            }\n        };\n    }\n    static{\n        this.defaultRoutes = {\n            'angleLines.color': 'borderColor',\n            'pointLabels.color': 'color',\n            'ticks.color': 'color'\n        };\n    }\n    static{\n        this.descriptors = {\n            angleLines: {\n                _fallback: 'grid'\n            }\n        };\n    }\n    constructor(cfg){\n        super(cfg);\n        this.xCenter = undefined;\n        this.yCenter = undefined;\n        this.drawingArea = undefined;\n        this._pointLabels = [];\n        this._pointLabelItems = [];\n    }\n    setDimensions() {\n        const padding = this._padding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(getTickBackdropHeight(this.options) / 2);\n        const w = this.width = this.maxWidth - padding.width;\n        const h = this.height = this.maxHeight - padding.height;\n        this.xCenter = Math.floor(this.left + w / 2 + padding.left);\n        this.yCenter = Math.floor(this.top + h / 2 + padding.top);\n        this.drawingArea = Math.floor(Math.min(w, h) / 2);\n    }\n    determineDataLimits() {\n        const { min, max } = this.getMinMax(false);\n        this.min = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(min) && !isNaN(min) ? min : 0;\n        this.max = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(max) && !isNaN(max) ? max : 0;\n        this.handleTickRangeOptions();\n    }\n    computeTickLimit() {\n        return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));\n    }\n    generateTickLabels(ticks) {\n        LinearScaleBase.prototype.generateTickLabels.call(this, ticks);\n        this._pointLabels = this.getLabels().map((value, index)=>{\n            const label = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options.pointLabels.callback, [\n                value,\n                index\n            ], this);\n            return label || label === 0 ? label : '';\n        }).filter((v, i)=>this.chart.getDataVisibility(i));\n    }\n    fit() {\n        const opts = this.options;\n        if (opts.display && opts.pointLabels.display) {\n            fitWithPointLabels(this);\n        } else {\n            this.setCenterPoint(0, 0, 0, 0);\n        }\n    }\n    setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {\n        this.xCenter += Math.floor((leftMovement - rightMovement) / 2);\n        this.yCenter += Math.floor((topMovement - bottomMovement) / 2);\n        this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));\n    }\n    getIndexAngle(index) {\n        const angleMultiplier = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T / (this._pointLabels.length || 1);\n        const startAngle = this.options.startAngle || 0;\n        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.al)(index * angleMultiplier + (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(startAngle));\n    }\n    getDistanceFromCenterForValue(value) {\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(value)) {\n            return NaN;\n        }\n        const scalingFactor = this.drawingArea / (this.max - this.min);\n        if (this.options.reverse) {\n            return (this.max - value) * scalingFactor;\n        }\n        return (value - this.min) * scalingFactor;\n    }\n    getValueForDistanceFromCenter(distance) {\n        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(distance)) {\n            return NaN;\n        }\n        const scaledDistance = distance / (this.drawingArea / (this.max - this.min));\n        return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;\n    }\n    getPointLabelContext(index) {\n        const pointLabels = this._pointLabels || [];\n        if (index >= 0 && index < pointLabels.length) {\n            const pointLabel = pointLabels[index];\n            return createPointLabelContext(this.getContext(), index, pointLabel);\n        }\n    }\n    getPointPosition(index, distanceFromCenter, additionalAngle = 0) {\n        const angle = this.getIndexAngle(index) - _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H + additionalAngle;\n        return {\n            x: Math.cos(angle) * distanceFromCenter + this.xCenter,\n            y: Math.sin(angle) * distanceFromCenter + this.yCenter,\n            angle\n        };\n    }\n    getPointPositionForValue(index, value) {\n        return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n    }\n    getBasePosition(index) {\n        return this.getPointPositionForValue(index || 0, this.getBaseValue());\n    }\n    getPointLabelPosition(index) {\n        const { left, top, right, bottom } = this._pointLabelItems[index];\n        return {\n            left,\n            top,\n            right,\n            bottom\n        };\n    }\n    drawBackground() {\n        const { backgroundColor, grid: { circular } } = this.options;\n        if (backgroundColor) {\n            const ctx = this.ctx;\n            ctx.save();\n            ctx.beginPath();\n            pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);\n            ctx.closePath();\n            ctx.fillStyle = backgroundColor;\n            ctx.fill();\n            ctx.restore();\n        }\n    }\n    drawGrid() {\n        const ctx = this.ctx;\n        const opts = this.options;\n        const { angleLines, grid, border } = opts;\n        const labelCount = this._pointLabels.length;\n        let i, offset, position;\n        if (opts.pointLabels.display) {\n            drawPointLabels(this, labelCount);\n        }\n        if (grid.display) {\n            this.ticks.forEach((tick, index)=>{\n                if (index !== 0 || index === 0 && this.min < 0) {\n                    offset = this.getDistanceFromCenterForValue(tick.value);\n                    const context = this.getContext(index);\n                    const optsAtIndex = grid.setContext(context);\n                    const optsAtIndexBorder = border.setContext(context);\n                    drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);\n                }\n            });\n        }\n        if (angleLines.display) {\n            ctx.save();\n            for(i = labelCount - 1; i >= 0; i--){\n                const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));\n                const { color, lineWidth } = optsAtIndex;\n                if (!lineWidth || !color) {\n                    continue;\n                }\n                ctx.lineWidth = lineWidth;\n                ctx.strokeStyle = color;\n                ctx.setLineDash(optsAtIndex.borderDash);\n                ctx.lineDashOffset = optsAtIndex.borderDashOffset;\n                offset = this.getDistanceFromCenterForValue(opts.reverse ? this.min : this.max);\n                position = this.getPointPosition(i, offset);\n                ctx.beginPath();\n                ctx.moveTo(this.xCenter, this.yCenter);\n                ctx.lineTo(position.x, position.y);\n                ctx.stroke();\n            }\n            ctx.restore();\n        }\n    }\n    drawBorder() {}\n    drawLabels() {\n        const ctx = this.ctx;\n        const opts = this.options;\n        const tickOpts = opts.ticks;\n        if (!tickOpts.display) {\n            return;\n        }\n        const startAngle = this.getIndexAngle(0);\n        let offset, width;\n        ctx.save();\n        ctx.translate(this.xCenter, this.yCenter);\n        ctx.rotate(startAngle);\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'middle';\n        this.ticks.forEach((tick, index)=>{\n            if (index === 0 && this.min >= 0 && !opts.reverse) {\n                return;\n            }\n            const optsAtIndex = tickOpts.setContext(this.getContext(index));\n            const tickFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(optsAtIndex.font);\n            offset = this.getDistanceFromCenterForValue(this.ticks[index].value);\n            if (optsAtIndex.showLabelBackdrop) {\n                ctx.font = tickFont.string;\n                width = ctx.measureText(tick.label).width;\n                ctx.fillStyle = optsAtIndex.backdropColor;\n                const padding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(optsAtIndex.backdropPadding);\n                ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);\n            }\n            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Z)(ctx, tick.label, 0, -offset, tickFont, {\n                color: optsAtIndex.color,\n                strokeColor: optsAtIndex.textStrokeColor,\n                strokeWidth: optsAtIndex.textStrokeWidth\n            });\n        });\n        ctx.restore();\n    }\n    drawTitle() {}\n}\nconst INTERVALS = {\n    millisecond: {\n        common: true,\n        size: 1,\n        steps: 1000\n    },\n    second: {\n        common: true,\n        size: 1000,\n        steps: 60\n    },\n    minute: {\n        common: true,\n        size: 60000,\n        steps: 60\n    },\n    hour: {\n        common: true,\n        size: 3600000,\n        steps: 24\n    },\n    day: {\n        common: true,\n        size: 86400000,\n        steps: 30\n    },\n    week: {\n        common: false,\n        size: 604800000,\n        steps: 4\n    },\n    month: {\n        common: true,\n        size: 2.628e9,\n        steps: 12\n    },\n    quarter: {\n        common: false,\n        size: 7.884e9,\n        steps: 4\n    },\n    year: {\n        common: true,\n        size: 3.154e10\n    }\n};\nconst UNITS = /* #__PURE__ */ Object.keys(INTERVALS);\nfunction sorter(a, b) {\n    return a - b;\n}\nfunction parse(scale, input) {\n    if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(input)) {\n        return null;\n    }\n    const adapter = scale._adapter;\n    const { parser, round, isoWeekday } = scale._parseOpts;\n    let value = input;\n    if (typeof parser === 'function') {\n        value = parser(value);\n    }\n    if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(value)) {\n        value = typeof parser === 'string' ? adapter.parse(value, parser) : adapter.parse(value);\n    }\n    if (value === null) {\n        return null;\n    }\n    if (round) {\n        value = round === 'week' && ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.x)(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, 'isoWeek', isoWeekday) : adapter.startOf(value, round);\n    }\n    return +value;\n}\nfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\n    const ilen = UNITS.length;\n    for(let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i){\n        const interval = INTERVALS[UNITS[i]];\n        const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;\n        if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\n            return UNITS[i];\n        }\n    }\n    return UNITS[ilen - 1];\n}\nfunction determineUnitForFormatting(scale, numTicks, minUnit, min, max) {\n    for(let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--){\n        const unit = UNITS[i];\n        if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {\n            return unit;\n        }\n    }\n    return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\n}\nfunction determineMajorUnit(unit) {\n    for(let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i){\n        if (INTERVALS[UNITS[i]].common) {\n            return UNITS[i];\n        }\n    }\n}\nfunction addTick(ticks, time, timestamps) {\n    if (!timestamps) {\n        ticks[time] = true;\n    } else if (timestamps.length) {\n        const { lo, hi } = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aQ)(timestamps, time);\n        const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];\n        ticks[timestamp] = true;\n    }\n}\nfunction setMajorTicks(scale, ticks, map, majorUnit) {\n    const adapter = scale._adapter;\n    const first = +adapter.startOf(ticks[0].value, majorUnit);\n    const last = ticks[ticks.length - 1].value;\n    let major, index;\n    for(major = first; major <= last; major = +adapter.add(major, 1, majorUnit)){\n        index = map[major];\n        if (index >= 0) {\n            ticks[index].major = true;\n        }\n    }\n    return ticks;\n}\nfunction ticksFromTimestamps(scale, values, majorUnit) {\n    const ticks = [];\n    const map = {};\n    const ilen = values.length;\n    let i, value;\n    for(i = 0; i < ilen; ++i){\n        value = values[i];\n        map[value] = i;\n        ticks.push({\n            value,\n            major: false\n        });\n    }\n    return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map, majorUnit);\n}\nclass TimeScale extends Scale {\n    static{\n        this.id = 'time';\n    }\n    static{\n        this.defaults = {\n            bounds: 'data',\n            adapters: {},\n            time: {\n                parser: false,\n                unit: false,\n                round: false,\n                isoWeekday: false,\n                minUnit: 'millisecond',\n                displayFormats: {}\n            },\n            ticks: {\n                source: 'auto',\n                callback: false,\n                major: {\n                    enabled: false\n                }\n            }\n        };\n    }\n    constructor(props){\n        super(props);\n        this._cache = {\n            data: [],\n            labels: [],\n            all: []\n        };\n        this._unit = 'day';\n        this._majorUnit = undefined;\n        this._offsets = {};\n        this._normalized = false;\n        this._parseOpts = undefined;\n    }\n    init(scaleOpts, opts = {}) {\n        const time = scaleOpts.time || (scaleOpts.time = {});\n        const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);\n        adapter.init(opts);\n        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ab)(time.displayFormats, adapter.formats());\n        this._parseOpts = {\n            parser: time.parser,\n            round: time.round,\n            isoWeekday: time.isoWeekday\n        };\n        super.init(scaleOpts);\n        this._normalized = opts.normalized;\n    }\n    parse(raw, index) {\n        if (raw === undefined) {\n            return null;\n        }\n        return parse(this, raw);\n    }\n    beforeLayout() {\n        super.beforeLayout();\n        this._cache = {\n            data: [],\n            labels: [],\n            all: []\n        };\n    }\n    determineDataLimits() {\n        const options = this.options;\n        const adapter = this._adapter;\n        const unit = options.time.unit || 'day';\n        let { min, max, minDefined, maxDefined } = this.getUserBounds();\n        function _applyBounds(bounds) {\n            if (!minDefined && !isNaN(bounds.min)) {\n                min = Math.min(min, bounds.min);\n            }\n            if (!maxDefined && !isNaN(bounds.max)) {\n                max = Math.max(max, bounds.max);\n            }\n        }\n        if (!minDefined || !maxDefined) {\n            _applyBounds(this._getLabelBounds());\n            if (options.bounds !== 'ticks' || options.ticks.source !== 'labels') {\n                _applyBounds(this.getMinMax(false));\n            }\n        }\n        min = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);\n        max = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;\n        this.min = Math.min(min, max - 1);\n        this.max = Math.max(min + 1, max);\n    }\n    _getLabelBounds() {\n        const arr = this.getLabelTimestamps();\n        let min = Number.POSITIVE_INFINITY;\n        let max = Number.NEGATIVE_INFINITY;\n        if (arr.length) {\n            min = arr[0];\n            max = arr[arr.length - 1];\n        }\n        return {\n            min,\n            max\n        };\n    }\n    buildTicks() {\n        const options = this.options;\n        const timeOpts = options.time;\n        const tickOpts = options.ticks;\n        const timestamps = tickOpts.source === 'labels' ? this.getLabelTimestamps() : this._generate();\n        if (options.bounds === 'ticks' && timestamps.length) {\n            this.min = this._userMin || timestamps[0];\n            this.max = this._userMax || timestamps[timestamps.length - 1];\n        }\n        const min = this.min;\n        const max = this.max;\n        const ticks = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aP)(timestamps, min, max);\n        this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));\n        this._majorUnit = !tickOpts.major.enabled || this._unit === 'year' ? undefined : determineMajorUnit(this._unit);\n        this.initOffsets(timestamps);\n        if (options.reverse) {\n            ticks.reverse();\n        }\n        return ticksFromTimestamps(this, ticks, this._majorUnit);\n    }\n    afterAutoSkip() {\n        if (this.options.offsetAfterAutoskip) {\n            this.initOffsets(this.ticks.map((tick)=>+tick.value));\n        }\n    }\n    initOffsets(timestamps = []) {\n        let start = 0;\n        let end = 0;\n        let first, last;\n        if (this.options.offset && timestamps.length) {\n            first = this.getDecimalForValue(timestamps[0]);\n            if (timestamps.length === 1) {\n                start = 1 - first;\n            } else {\n                start = (this.getDecimalForValue(timestamps[1]) - first) / 2;\n            }\n            last = this.getDecimalForValue(timestamps[timestamps.length - 1]);\n            if (timestamps.length === 1) {\n                end = last;\n            } else {\n                end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;\n            }\n        }\n        const limit = timestamps.length < 3 ? 0.5 : 0.25;\n        start = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(start, 0, limit);\n        end = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(end, 0, limit);\n        this._offsets = {\n            start,\n            end,\n            factor: 1 / (start + 1 + end)\n        };\n    }\n    _generate() {\n        const adapter = this._adapter;\n        const min = this.min;\n        const max = this.max;\n        const options = this.options;\n        const timeOpts = options.time;\n        const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));\n        const stepSize = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(options.ticks.stepSize, 1);\n        const weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n        const hasWeekday = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.x)(weekday) || weekday === true;\n        const ticks = {};\n        let first = min;\n        let time, count;\n        if (hasWeekday) {\n            first = +adapter.startOf(first, 'isoWeek', weekday);\n        }\n        first = +adapter.startOf(first, hasWeekday ? 'day' : minor);\n        if (adapter.diff(max, min, minor) > 100000 * stepSize) {\n            throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);\n        }\n        const timestamps = options.ticks.source === 'data' && this.getDataTimestamps();\n        for(time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++){\n            addTick(ticks, time, timestamps);\n        }\n        if (time === max || options.bounds === 'ticks' || count === 1) {\n            addTick(ticks, time, timestamps);\n        }\n        return Object.keys(ticks).sort(sorter).map((x)=>+x);\n    }\n    getLabelForValue(value) {\n        const adapter = this._adapter;\n        const timeOpts = this.options.time;\n        if (timeOpts.tooltipFormat) {\n            return adapter.format(value, timeOpts.tooltipFormat);\n        }\n        return adapter.format(value, timeOpts.displayFormats.datetime);\n    }\n    format(value, format) {\n        const options = this.options;\n        const formats = options.time.displayFormats;\n        const unit = this._unit;\n        const fmt = format || formats[unit];\n        return this._adapter.format(value, fmt);\n    }\n    _tickFormatFunction(time, index, ticks, format) {\n        const options = this.options;\n        const formatter = options.ticks.callback;\n        if (formatter) {\n            return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(formatter, [\n                time,\n                index,\n                ticks\n            ], this);\n        }\n        const formats = options.time.displayFormats;\n        const unit = this._unit;\n        const majorUnit = this._majorUnit;\n        const minorFormat = unit && formats[unit];\n        const majorFormat = majorUnit && formats[majorUnit];\n        const tick = ticks[index];\n        const major = majorUnit && majorFormat && tick && tick.major;\n        return this._adapter.format(time, format || (major ? majorFormat : minorFormat));\n    }\n    generateTickLabels(ticks) {\n        let i, ilen, tick;\n        for(i = 0, ilen = ticks.length; i < ilen; ++i){\n            tick = ticks[i];\n            tick.label = this._tickFormatFunction(tick.value, i, ticks);\n        }\n    }\n    getDecimalForValue(value) {\n        return value === null ? NaN : (value - this.min) / (this.max - this.min);\n    }\n    getPixelForValue(value) {\n        const offsets = this._offsets;\n        const pos = this.getDecimalForValue(value);\n        return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);\n    }\n    getValueForPixel(pixel) {\n        const offsets = this._offsets;\n        const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n        return this.min + pos * (this.max - this.min);\n    }\n    _getLabelSize(label) {\n        const ticksOpts = this.options.ticks;\n        const tickLabelWidth = this.ctx.measureText(label).width;\n        const angle = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);\n        const cosRotation = Math.cos(angle);\n        const sinRotation = Math.sin(angle);\n        const tickFontSize = this._resolveTickFontOptions(0).size;\n        return {\n            w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,\n            h: tickLabelWidth * sinRotation + tickFontSize * cosRotation\n        };\n    }\n    _getLabelCapacity(exampleTime) {\n        const timeOpts = this.options.time;\n        const displayFormats = timeOpts.displayFormats;\n        const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;\n        const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [\n            exampleTime\n        ], this._majorUnit), format);\n        const size = this._getLabelSize(exampleLabel);\n        const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;\n        return capacity > 0 ? capacity : 1;\n    }\n    getDataTimestamps() {\n        let timestamps = this._cache.data || [];\n        let i, ilen;\n        if (timestamps.length) {\n            return timestamps;\n        }\n        const metas = this.getMatchingVisibleMetas();\n        if (this._normalized && metas.length) {\n            return this._cache.data = metas[0].controller.getAllParsedValues(this);\n        }\n        for(i = 0, ilen = metas.length; i < ilen; ++i){\n            timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));\n        }\n        return this._cache.data = this.normalize(timestamps);\n    }\n    getLabelTimestamps() {\n        const timestamps = this._cache.labels || [];\n        let i, ilen;\n        if (timestamps.length) {\n            return timestamps;\n        }\n        const labels = this.getLabels();\n        for(i = 0, ilen = labels.length; i < ilen; ++i){\n            timestamps.push(parse(this, labels[i]));\n        }\n        return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);\n    }\n    normalize(values) {\n        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__._)(values.sort(sorter));\n    }\n}\nfunction interpolate(table, val, reverse) {\n    let lo = 0;\n    let hi = table.length - 1;\n    let prevSource, nextSource, prevTarget, nextTarget;\n    if (reverse) {\n        if (val >= table[lo].pos && val <= table[hi].pos) {\n            ({ lo, hi } = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.B)(table, 'pos', val));\n        }\n        ({ pos: prevSource, time: prevTarget } = table[lo]);\n        ({ pos: nextSource, time: nextTarget } = table[hi]);\n    } else {\n        if (val >= table[lo].time && val <= table[hi].time) {\n            ({ lo, hi } = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.B)(table, 'time', val));\n        }\n        ({ time: prevSource, pos: prevTarget } = table[lo]);\n        ({ time: nextSource, pos: nextTarget } = table[hi]);\n    }\n    const span = nextSource - prevSource;\n    return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;\n}\nclass TimeSeriesScale extends TimeScale {\n    static{\n        this.id = 'timeseries';\n    }\n    static{\n        this.defaults = TimeScale.defaults;\n    }\n    constructor(props){\n        super(props);\n        this._table = [];\n        this._minPos = undefined;\n        this._tableRange = undefined;\n    }\n    initOffsets() {\n        const timestamps = this._getTimestampsForTable();\n        const table = this._table = this.buildLookupTable(timestamps);\n        this._minPos = interpolate(table, this.min);\n        this._tableRange = interpolate(table, this.max) - this._minPos;\n        super.initOffsets(timestamps);\n    }\n    buildLookupTable(timestamps) {\n        const { min, max } = this;\n        const items = [];\n        const table = [];\n        let i, ilen, prev, curr, next;\n        for(i = 0, ilen = timestamps.length; i < ilen; ++i){\n            curr = timestamps[i];\n            if (curr >= min && curr <= max) {\n                items.push(curr);\n            }\n        }\n        if (items.length < 2) {\n            return [\n                {\n                    time: min,\n                    pos: 0\n                },\n                {\n                    time: max,\n                    pos: 1\n                }\n            ];\n        }\n        for(i = 0, ilen = items.length; i < ilen; ++i){\n            next = items[i + 1];\n            prev = items[i - 1];\n            curr = items[i];\n            if (Math.round((next + prev) / 2) !== curr) {\n                table.push({\n                    time: curr,\n                    pos: i / (ilen - 1)\n                });\n            }\n        }\n        return table;\n    }\n    _generate() {\n        const min = this.min;\n        const max = this.max;\n        let timestamps = super.getDataTimestamps();\n        if (!timestamps.includes(min) || !timestamps.length) {\n            timestamps.splice(0, 0, min);\n        }\n        if (!timestamps.includes(max) || timestamps.length === 1) {\n            timestamps.push(max);\n        }\n        return timestamps.sort((a, b)=>a - b);\n    }\n    _getTimestampsForTable() {\n        let timestamps = this._cache.all || [];\n        if (timestamps.length) {\n            return timestamps;\n        }\n        const data = this.getDataTimestamps();\n        const label = this.getLabelTimestamps();\n        if (data.length && label.length) {\n            timestamps = this.normalize(data.concat(label));\n        } else {\n            timestamps = data.length ? data : label;\n        }\n        timestamps = this._cache.all = timestamps;\n        return timestamps;\n    }\n    getDecimalForValue(value) {\n        return (interpolate(this._table, value) - this._minPos) / this._tableRange;\n    }\n    getValueForPixel(pixel) {\n        const offsets = this._offsets;\n        const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n        return interpolate(this._table, decimal * this._tableRange + this._minPos, true);\n    }\n}\nvar scales = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    CategoryScale: CategoryScale,\n    LinearScale: LinearScale,\n    LogarithmicScale: LogarithmicScale,\n    RadialLinearScale: RadialLinearScale,\n    TimeScale: TimeScale,\n    TimeSeriesScale: TimeSeriesScale\n});\nconst registerables = [\n    controllers,\n    elements,\n    plugins,\n    scales\n];\n //# sourceMappingURL=chart.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvZGlzdC9jaGFydC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBV08sTUFBTUEsUUFBQUEsQ0FBQUE7SUFDWEMsV0FBYztRQUNaLElBQUksQ0FBQ0MsUUFBUSxHQUFHLElBQUk7UUFDcEIsSUFBSSxDQUFDQyxPQUFPLEdBQUcsSUFBSUMsR0FBQUEsRUFBQUEsQ0FBQUE7UUFDbkIsSUFBSSxDQUFDQyxRQUFRLEdBQUcsS0FBSztRQUNyQixJQUFJLENBQUNDLFNBQVMsR0FBR0MsU0FBQUEsQ0FBQUE7SUFDbkI7SUFLQUMsT0FBQUEsQ0FBUUMsS0FBSyxFQUFFQyxLQUFLLEVBQUVDLElBQUksRUFBRUMsSUFBSSxFQUFFO1FBQ2hDLE1BQU1DLFNBQVlILEdBQUFBLEtBQUFBLENBQU1JLFNBQVMsQ0FBQ0YsSUFBSztRQUN2QyxNQUFNRyxRQUFBQSxHQUFXTCxNQUFNTSxRQUFRO1FBRS9CSCxTQUFBQSxDQUFVSSxPQUFPLENBQUNDLENBQUFBLEVBQUFBLEdBQU1BLEVBQUc7Z0JBQ3pCVCxLQUFBQTtnQkFDQVUsT0FBQUEsRUFBU1QsTUFBTVMsT0FBTztnQkFDdEJKLFFBQUFBO2dCQUNBSyxXQUFBQSxFQUFhQyxLQUFLQyxHQUFHLENBQUNYLElBQU9ELEdBQUFBLEtBQUFBLENBQU1hLEtBQUssRUFBRVIsUUFBQUEsQ0FBQUE7WUFDNUM7SUFDRjtJQUtBUyxRQUFXO1FBQ1QsSUFBSSxJQUFJLENBQUN0QixRQUFRLEVBQUU7WUFDakI7U0FDRDtRQUNELElBQUksQ0FBQ0csUUFBUSxHQUFHLElBQUk7UUFFcEIsSUFBSSxDQUFDSCxRQUFRLEdBQUd1Qix5REFBZ0JBLENBQUNDLElBQUksQ0FBQ0MsUUFBUSxJQUFNO1lBQ2xELElBQUksQ0FBQ0MsT0FBTztZQUNaLElBQUksQ0FBQzFCLFFBQVEsR0FBRyxJQUFJO1lBRXBCLElBQUksSUFB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QUEsTUFBTSxJQUFJaVQsS0FBQUEsQ0FBTWpULE1BQU0sRUFBRTtZQUcvQmloRSxVQUFBQSxHQUFhLElBQUksQ0FBQzRDLFNBQVMsQ0FBQ3g2RCxJQUFBQSxDQUFLOE4sTUFBTSxDQUFDbEUsS0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUE7U0FDbkM7WUFDTGd1RCxVQUFBQSxHQUFhNTNELElBQUtySixDQUFBQSxNQUFNLEdBQUdxSixJQUFBQSxHQUFPNEosS0FBSztTQUN4QztRQUNEZ3VELFVBQUFBLEdBQWEsSUFBSSxDQUFDanFELE1BQU0sQ0FBQ2xRLEdBQUcsR0FBR202RCxVQUFBQSxDQUFBQTtRQUUvQixPQUFPQSxVQUFBQSxDQUFBQTtJQUNUO0lBTUF1QixrQkFBQUEsQ0FBbUIvN0QsS0FBSyxFQUFFO1FBQ3hCLE9BQU8sQ0FBQ3M0QyxXQUFZLEtBQUksQ0FBQ3NsQixNQUFNLEVBQUU1OUQsS0FBUyxRQUFJLENBQUM2OUQsT0FBTSxJQUFLLElBQUksQ0FBQ0MsV0FBVztJQUM1RTtJQU1BN21ELGdCQUFBQSxDQUFpQjhqQixLQUFLLEVBQUU7UUFDdEIsTUFBTTRoQyxPQUFBQSxHQUFVLElBQUksQ0FBQ3hCLFFBQVE7UUFDN0IsTUFBTW5nQyxPQUFBQSxHQUFVLElBQUksQ0FBQ0csa0JBQWtCLENBQUNKLFNBQVM0aEMsT0FBUWxoRSxDQUFBQSxNQUFNLEdBQUdraEUsT0FBQUEsQ0FBUWg4RCxHQUFHO1FBQzdFLE9BQU8yM0MsV0FBWSxLQUFJLENBQUNzbEIsTUFBTSxFQUFFNWlDLE9BQVUsT0FBSSxDQUFDOGlDLFdBQVcsR0FBRyxJQUFJLENBQUNELE9BQU8sRUFBRSxJQUFJO0lBQ2pGO0FBQ0Y7Ozs7Ozs7Ozs7TUMzSmFJLGFBQWdCO0lBQzNCbDhCLFdBQUFBO0lBQ0FuMUIsUUFBQUE7SUFDQTBOLE9BQUFBO0lBQ0FoVixNQUFBQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxGYWl6YW5KYW1pbFxcT25lRHJpdmUgLSBKYWZmZXIgQnVzaW5lc3MgU3lzdGVtcyAoUHJpdmF0ZSkgTGltaXRlZFxcRGVza3RvcFxcUHJvamVjdHNcXEJpZF9SZXZpZXdfU3lzdGVtLW1hc3RlclxcQmlkX1Jldmlld19TeXN0ZW0tbWFzdGVyXFxzcmNcXGNvcmVcXGNvcmUuYW5pbWF0b3IuanMiLCJDOlxcVXNlcnNcXEZhaXphbkphbWlsXFxPbmVEcml2ZSAtIEphZmZlciBCdXNpbmVzcyBTeXN0ZW1zIChQcml2YXRlKSBMaW1pdGVkXFxEZXNrdG9wXFxQcm9qZWN0c1xcQmlkX1Jldmlld19TeXN0ZW0tbWFzdGVyXFxCaWRfUmV2aWV3X1N5c3RlbS1tYXN0ZXJcXHNyY1xcY29yZVxcY29yZS5hbmltYXRpb24uanMiLCJDOlxcVXNlcnNcXEZhaXphbkphbWlsXFxPbmVEcml2ZSAtIEphZmZlciBCdXNpbmVzcyBTeXN0ZW1zIChQcml2YXRlKSBMaW1pdGVkXFxEZXNrdG9wXFxQcm9qZWN0c1xcQmlkX1Jldmlld19TeXN0ZW0tbWFzdGVyXFxCaWRfUmV2aWV3X1N5c3RlbS1tYXN0ZXJcXHNyY1xcY29yZVxcY29yZS5hbmltYXRpb25zLmpzIiwiQzpcXFVzZXJzXFxGYWl6YW5KYW1pbFxcT25lRHJpdmUgLSBKYWZmZXIgQnVzaW5lc3MgU3lzdGVtcyAoUHJpdmF0ZSkgTGltaXRlZFxcRGVza3RvcFxcUHJvamVjdHNcXEJpZF9SZXZpZXdfU3lzdGVtLW1hc3RlclxcQmlkX1Jldmlld19TeXN0ZW0tbWFzdGVyXFxzcmNcXGNvcmVcXGNvcmUuZGF0YXNldENvbnRyb2xsZXIuanMiLCJDOlxcVXNlcnNcXEZhaXphbkphbWlsXFxPbmVEcml2ZSAtIEphZmZlciBCdXNpbmVzcyBTeXN0ZW1zIChQcml2YXRlKSBMaW1pdGVkXFxEZXNrdG9wXFxQcm9qZWN0c1xcQmlkX1Jldmlld19TeXN0ZW0tbWFzdGVyXFxCaWRfUmV2aWV3X1N5c3RlbS1tYXN0ZXJcXHNyY1xcY29udHJvbGxlcnNcXGNvbnRyb2xsZXIuYmFyLmpzIiwiQzpcXFVzZXJzXFxGYWl6YW5KYW1pbFxcT25lRHJpdmUgLSBKYWZmZXIgQnVzaW5lc3MgU3lzdGVtcyAoUHJpdmF0ZSkgTGltaXRlZFxcRGVza3RvcFxcUHJvamVjdHNcXEJpZF9SZXZpZXdfU3lzdGVtLW1hc3RlclxcQmlkX1Jldmlld19TeXN0ZW0tbWFzdGVyXFxzcmNcXGNvbnRyb2xsZXJzXFxjb250cm9sbGVyLmJ1YmJsZS5qcyIsIkM6XFxVc2Vyc1xcRmFpemFuSmFtaWxcXE9uZURyaXZlIC0gSmFmZmVyIEJ1c2luZXNzIFN5c3RlbXMgKFByaXZhdGUpIExpbWl0ZWRcXERlc2t0b3BcXFByb2plY3RzXFxCaWRfUmV2aWV3X1N5c3RlbS1tYXN0ZXJcXEJpZF9SZXZpZXdfU3lzdGVtLW1hc3Rlclxcc3JjXFxjb250cm9sbGVyc1xcY29udHJvbGxlci5kb3VnaG51dC5qcyIsIkM6XFxVc2Vyc1xcRmFpemFuSmFtaWxcXE9uZURyaXZlIC0gSmFmZmVyIEJ1c2luZXNzIFN5c3RlbXMgKFByaXZhdGUpIExpbWl0ZWRcXERlc2t0b3BcXFByb2plY3RzXFxCaWRfUmV2aWV3X1N5c3RlbS1tYXN0ZXJcXEJpZF9SZXZpZXdfU3lzdGVtLW1hc3Rlclxcc3JjXFxjb250cm9sbGVyc1xcY29udHJvbGxlci5saW5lLmpzIiwiQzpcXFVzZXJzXFxGYWl6YW5KYW1pbFxcT25lRHJpdmUgLSBKYWZmZXIgQnVzaW5lc3MgU3lzdGVtcyAoUHJpdmF0ZSkgTGltaXRlZFxcRGVza3RvcFxcUHJvamVjdHNcXEJpZF9SZXZpZXdfU3lzdGVtLW1hc3RlclxcQmlkX1Jldmlld19TeXN0ZW0tbWFzdGVyXFxzcmNcXGNvbnRyb2xsZXJzXFxjb250cm9sbGVyLnBvbGFyQXJlYS5qcyIsIkM6XFxVc2Vyc1xcRmFpemFuSmFtaWxcXE9uZURyaXZlIC0gSmFmZmVyIEJ1c2luZXNzIFN5c3RlbXMgKFByaXZhdGUpIExpbWl0ZWRcXERlc2t0b3BcXFByb2plY3RzXFxCaWRfUmV2aWV3X1N5c3RlbS1tYXN0ZXJcXEJpZF9SZXZpZXdfU3lzdGVtLW1hc3Rlclxcc3JjXFxjb250cm9sbGVyc1xcY29udHJvbGxlci5waWUuanMiLCJDOlxcVXNlcnNcXEZhaXphbkphbWlsXFxPbmVEcml2ZSAtIEphZmZlciBCdXNpbmVzcyBTeXN0ZW1zIChQcml2YXRlKSBMaW1pdGVkXFxEZXNrdG9wXFxQcm9qZWN0c1xcQmlkX1Jldmlld19TeXN0ZW0tbWFzdGVyXFxCaWRfUmV2aWV3X1N5c3RlbS1tYXN0ZXJcXHNyY1xcY29udHJvbGxlcnNcXGNvbnRyb2xsZXIucmFkYXIuanMiLCJDOlxcVXNlcnNcXEZhaXphbkphbWlsXFxPbmVEcml2ZSAtIEphZmZlciBCdXNpbmVzcyBTeXN0ZW1zIChQcml2YXRlKSBMaW1pdGVkXFxEZXNrdG9wXFxQcm9qZWN0c1xcQmlkX1Jldmlld19TeXN0ZW0tbWFzdGVyXFxCaWRfUmV2aWV3X1N5c3RlbS1tYXN0ZXJcXHNyY1xcY29udHJvbGxlcnNcXGNvbnRyb2xsZXIuc2NhdHRlci5qcyIsIkM6XFxVc2Vyc1xcRmFpemFuSmFtaWxcXE9uZURyaXZlIC0gSmFmZmVyIEJ1c2luZXNzIFN5c3RlbXMgKFByaXZhdGUpIExpbWl0ZWRcXERlc2t0b3BcXFByb2plY3RzXFxCaWRfUmV2aWV3X1N5c3RlbS1tYXN0ZXJcXEJpZF9SZXZpZXdfU3lzdGVtLW1hc3Rlclxcc3JjXFxjb3JlXFxjb3JlLmFkYXB0ZXJzLnRzIiwiQzpcXFVzZXJzXFxGYWl6YW5KYW1pbFxcT25lRHJpdmUgLSBKYWZmZXIgQnVzaW5lc3MgU3lzdGVtcyAoUHJpdmF0ZSkgTGltaXRlZFxcRGVza3RvcFxcUHJvamVjdHNcXEJpZF9SZXZpZXdfU3lzdGVtLW1hc3RlclxcQmlkX1Jldmlld19TeXN0ZW0tbWFzdGVyXFxzcmNcXGNvcmVcXGNvcmUuaW50ZXJhY3Rpb24uanMiLCJDOlxcVXNlcnNcXEZhaXphbkphbWlsXFxPbmVEcml2ZSAtIEphZmZlciBCdXNpbmVzcyBTeXN0ZW1zIChQcml2YXRlKSBMaW1pdGVkXFxEZXNrdG9wXFxQcm9qZWN0c1xcQmlkX1Jldmlld19TeXN0ZW0tbWFzdGVyXFxCaWRfUmV2aWV3X1N5c3RlbS1tYXN0ZXJcXHNyY1xcY29yZVxcY29yZS5sYXlvdXRzLmpzIiwiQzpcXFVzZXJzXFxGYWl6YW5KYW1pbFxcT25lRHJpdmUgLSBKYWZmZXIgQnVzaW5lc3MgU3lzdGVtcyAoUHJpdmF0ZSkgTGltaXRlZFxcRGVza3RvcFxcUHJvamVjdHNcXEJpZF9SZXZpZXdfU3lzdGVtLW1hc3RlclxcQmlkX1Jldmlld19TeXN0ZW0tbWFzdGVyXFxzcmNcXHBsYXRmb3JtXFxwbGF0Zm9ybS5iYXNlLmpzIiwiQzpcXFVzZXJzXFxGYWl6YW5KYW1pbFxcT25lRHJpdmUgLSBKYWZmZXIgQnVzaW5lc3MgU3lzdGVtcyAoUHJpdmF0ZSkgTGltaXRlZFxcRGVza3RvcFxcUHJvamVjdHNcXEJpZF9SZXZpZXdfU3lzdGVtLW1hc3RlclxcQmlkX1Jldmlld19TeXN0ZW0tbWFzdGVyXFxzcmNcXHBsYXRmb3JtXFxwbGF0Zm9ybS5iYXNpYy5qcyIsIkM6XFxVc2Vyc1xcRmFpemFuSmFtaWxcXE9uZURyaXZlIC0gSmFmZmVyIEJ1c2luZXNzIFN5c3RlbXMgKFByaXZhdGUpIExpbWl0ZWRcXERlc2t0b3BcXFByb2plY3RzXFxCaWRfUmV2aWV3X1N5c3RlbS1tYXN0ZXJcXEJpZF9SZXZpZXdfU3lzdGVtLW1hc3Rlclxcc3JjXFxwbGF0Zm9ybVxccGxhdGZvcm0uZG9tLmpzIiwiQzpcXFVzZXJzXFxGYWl6YW5KYW1pbFxcT25lRHJpdmUgLSBKYWZmZXIgQnVzaW5lc3MgU3lzdGVtcyAoUHJpdmF0ZSkgTGltaXRlZFxcRGVza3RvcFxcUHJvamVjdHNcXEJpZF9SZXZpZXdfU3lzdGVtLW1hc3RlclxcQmlkX1Jldmlld19TeXN0ZW0tbWFzdGVyXFxzcmNcXHBsYXRmb3JtXFxpbmRleC5qcyIsIkM6XFxVc2Vyc1xcRmFpemFuSmFtaWxcXE9uZURyaXZlIC0gSmFmZmVyIEJ1c2luZXNzIFN5c3RlbXMgKFByaXZhdGUpIExpbWl0ZWRcXERlc2t0b3BcXFByb2plY3RzXFxCaWRfUmV2aWV3X1N5c3RlbS1tYXN0ZXJcXEJpZF9SZXZpZXdfU3lzdGVtLW1hc3Rlclxcc3JjXFxjb3JlXFxjb3JlLmVsZW1lbnQudHMiLCJDOlxcVXNlcnNcXEZhaXphbkphbWlsXFxPbmVEcml2ZSAtIEphZmZlciBCdXNpbmVzcyBTeXN0ZW1zIChQcml2YXRlKSBMaW1pdGVkXFxEZXNrdG9wXFxQcm9qZWN0c1xcQmlkX1Jldmlld19TeXN0ZW0tbWFzdGVyXFxCaWRfUmV2aWV3X1N5c3RlbS1tYXN0ZXJcXHNyY1xcY29yZVxcY29yZS5zY2FsZS5hdXRvc2tpcC5qcyIsIkM6XFxVc2Vyc1xcRmFpemFuSmFtaWxcXE9uZURyaXZlIC0gSmFmZmVyIEJ1c2luZXNzIFN5c3RlbXMgKFByaXZhdGUpIExpbWl0ZWRcXERlc2t0b3BcXFByb2plY3RzXFxCaWRfUmV2aWV3X1N5c3RlbS1tYXN0ZXJcXEJpZF9SZXZpZXdfU3lzdGVtLW1hc3Rlclxcc3JjXFxjb3JlXFxjb3JlLnNjYWxlLmpzIiwiQzpcXFVzZXJzXFxGYWl6YW5KYW1pbFxcT25lRHJpdmUgLSBKYWZmZXIgQnVzaW5lc3MgU3lzdGVtcyAoUHJpdmF0ZSkgTGltaXRlZFxcRGVza3RvcFxcUHJvamVjdHNcXEJpZF9SZXZpZXdfU3lzdGVtLW1hc3RlclxcQmlkX1Jldmlld19TeXN0ZW0tbWFzdGVyXFxzcmNcXGNvcmVcXGNvcmUudHlwZWRSZWdpc3RyeS5qcyIsIkM6XFxVc2Vyc1xcRmFpemFuSmFtaWxcXE9uZURyaXZlIC0gSmFmZmVyIEJ1c2luZXNzIFN5c3RlbXMgKFByaXZhdGUpIExpbWl0ZWRcXERlc2t0b3BcXFByb2plY3RzXFxCaWRfUmV2aWV3X1N5c3RlbS1tYXN0ZXJcXEJpZF9SZXZpZXdfU3lzdGVtLW1hc3Rlclxcc3JjXFxjb3JlXFxjb3JlLnJlZ2lzdHJ5LmpzIiwiQzpcXFVzZXJzXFxGYWl6YW5KYW1pbFxcT25lRHJpdmUgLSBKYWZmZXIgQnVzaW5lc3MgU3lzdGVtcyAoUHJpdmF0ZSkgTGltaXRlZFxcRGVza3RvcFxcUHJvamVjdHNcXEJpZF9SZXZpZXdfU3lzdGVtLW1hc3RlclxcQmlkX1Jldmlld19TeXN0ZW0tbWFzdGVyXFxzcmNcXGNvcmVcXGNvcmUucGx1Z2lucy5qcyIsIkM6XFxVc2Vyc1xcRmFpemFuSmFtaWxcXE9uZURyaXZlIC0gSmFmZmVyIEJ1c2luZXNzIFN5c3RlbXMgKFByaXZhdGUpIExpbWl0ZWRcXERlc2t0b3BcXFByb2plY3RzXFxCaWRfUmV2aWV3X1N5c3RlbS1tYXN0ZXJcXEJpZF9SZXZpZXdfU3lzdGVtLW1hc3Rlclxcc3JjXFxjb3JlXFxjb3JlLmNvbmZpZy5qcyIsIkM6XFxVc2Vyc1xcRmFpemFuSmFtaWxcXE9uZURyaXZlIC0gSmFmZmVyIEJ1c2luZXNzIFN5c3RlbXMgKFByaXZhdGUpIExpbWl0ZWRcXERlc2t0b3BcXFByb2plY3RzXFxCaWRfUmV2aWV3X1N5c3RlbS1tYXN0ZXJcXEJpZF9SZXZpZXdfU3lzdGVtLW1hc3Rlclxcc3JjXFxjb3JlXFxjb3JlLmNvbnRyb2xsZXIuanMiLCJDOlxcVXNlcnNcXEZhaXphbkphbWlsXFxPbmVEcml2ZSAtIEphZmZlciBCdXNpbmVzcyBTeXN0ZW1zIChQcml2YXRlKSBMaW1pdGVkXFxEZXNrdG9wXFxQcm9qZWN0c1xcQmlkX1Jldmlld19TeXN0ZW0tbWFzdGVyXFxCaWRfUmV2aWV3X1N5c3RlbS1tYXN0ZXJcXHNyY1xcZWxlbWVudHNcXGVsZW1lbnQuYXJjLnRzIiwiQzpcXFVzZXJzXFxGYWl6YW5KYW1pbFxcT25lRHJpdmUgLSBKYWZmZXIgQnVzaW5lc3MgU3lzdGVtcyAoUHJpdmF0ZSkgTGltaXRlZFxcRGVza3RvcFxcUHJvamVjdHNcXEJpZF9SZXZpZXdfU3lzdGVtLW1hc3RlclxcQmlkX1Jldmlld19TeXN0ZW0tbWFzdGVyXFxzcmNcXGVsZW1lbnRzXFxlbGVtZW50LmxpbmUuanMiLCJDOlxcVXNlcnNcXEZhaXphbkphbWlsXFxPbmVEcml2ZSAtIEphZmZlciBCdXNpbmVzcyBTeXN0ZW1zIChQcml2YXRlKSBMaW1pdGVkXFxEZXNrdG9wXFxQcm9qZWN0c1xcQmlkX1Jldmlld19TeXN0ZW0tbWFzdGVyXFxCaWRfUmV2aWV3X1N5c3RlbS1tYXN0ZXJcXHNyY1xcZWxlbWVudHNcXGVsZW1lbnQucG9pbnQudHMiLCJDOlxcVXNlcnNcXEZhaXphbkphbWlsXFxPbmVEcml2ZSAtIEphZmZlciBCdXNpbmVzcyBTeXN0ZW1zIChQcml2YXRlKSBMaW1pdGVkXFxEZXNrdG9wXFxQcm9qZWN0c1xcQmlkX1Jldmlld19TeXN0ZW0tbWFzdGVyXFxCaWRfUmV2aWV3X1N5c3RlbS1tYXN0ZXJcXHNyY1xcZWxlbWVudHNcXGVsZW1lbnQuYmFyLmpzIiwiQzpcXFVzZXJzXFxGYWl6YW5KYW1pbFxcT25lRHJpdmUgLSBKYWZmZXIgQnVzaW5lc3MgU3lzdGVtcyAoUHJpdmF0ZSkgTGltaXRlZFxcRGVza3RvcFxcUHJvamVjdHNcXEJpZF9SZXZpZXdfU3lzdGVtLW1hc3RlclxcQmlkX1Jldmlld19TeXN0ZW0tbWFzdGVyXFxzcmNcXHBsdWdpbnNcXHBsdWdpbi5jb2xvcnMudHMiLCJDOlxcVXNlcnNcXEZhaXphbkphbWlsXFxPbmVEcml2ZSAtIEphZmZlciBCdXNpbmVzcyBTeXN0ZW1zIChQcml2YXRlKSBMaW1pdGVkXFxEZXNrdG9wXFxQcm9qZWN0c1xcQmlkX1Jldmlld19TeXN0ZW0tbWFzdGVyXFxCaWRfUmV2aWV3X1N5c3RlbS1tYXN0ZXJcXHNyY1xccGx1Z2luc1xccGx1Z2luLmRlY2ltYXRpb24uanMiLCJDOlxcVXNlcnNcXEZhaXphbkphbWlsXFxPbmVEcml2ZSAtIEphZmZlciBCdXNpbmVzcyBTeXN0ZW1zIChQcml2YXRlKSBMaW1pdGVkXFxEZXNrdG9wXFxQcm9qZWN0c1xcQmlkX1Jldmlld19TeXN0ZW0tbWFzdGVyXFxCaWRfUmV2aWV3X1N5c3RlbS1tYXN0ZXJcXHNyY1xccGx1Z2luc1xccGx1Z2luLmZpbGxlclxcZmlsbGVyLnNlZ21lbnQuanMiLCJDOlxcVXNlcnNcXEZhaXphbkphbWlsXFxPbmVEcml2ZSAtIEphZmZlciBCdXNpbmVzcyBTeXN0ZW1zIChQcml2YXRlKSBMaW1pdGVkXFxEZXNrdG9wXFxQcm9qZWN0c1xcQmlkX1Jldmlld19TeXN0ZW0tbWFzdGVyXFxCaWRfUmV2aWV3X1N5c3RlbS1tYXN0ZXJcXHNyY1xccGx1Z2luc1xccGx1Z2luLmZpbGxlclxcZmlsbGVyLmhlbHBlci5qcyIsIkM6XFxVc2Vyc1xcRmFpemFuSmFtaWxcXE9uZURyaXZlIC0gSmFmZmVyIEJ1c2luZXNzIFN5c3RlbXMgKFByaXZhdGUpIExpbWl0ZWRcXERlc2t0b3BcXFByb2plY3RzXFxCaWRfUmV2aWV3X1N5c3RlbS1tYXN0ZXJcXEJpZF9SZXZpZXdfU3lzdGVtLW1hc3Rlclxcc3JjXFxwbHVnaW5zXFxwbHVnaW4uZmlsbGVyXFxmaWxsZXIub3B0aW9ucy5qcyIsIkM6XFxVc2Vyc1xcRmFpemFuSmFtaWxcXE9uZURyaXZlIC0gSmFmZmVyIEJ1c2luZXNzIFN5c3RlbXMgKFByaXZhdGUpIExpbWl0ZWRcXERlc2t0b3BcXFByb2plY3RzXFxCaWRfUmV2aWV3X1N5c3RlbS1tYXN0ZXJcXEJpZF9SZXZpZXdfU3lzdGVtLW1hc3Rlclxcc3JjXFxwbHVnaW5zXFxwbHVnaW4uZmlsbGVyXFxmaWxsZXIudGFyZ2V0LnN0YWNrLmpzIiwiQzpcXFVzZXJzXFxGYWl6YW5KYW1pbFxcT25lRHJpdmUgLSBKYWZmZXIgQnVzaW5lc3MgU3lzdGVtcyAoUHJpdmF0ZSkgTGltaXRlZFxcRGVza3RvcFxcUHJvamVjdHNcXEJpZF9SZXZpZXdfU3lzdGVtLW1hc3RlclxcQmlkX1Jldmlld19TeXN0ZW0tbWFzdGVyXFxzcmNcXHBsdWdpbnNcXHBsdWdpbi5maWxsZXJcXHNpbXBsZUFyYy5qcyIsIkM6XFxVc2Vyc1xcRmFpemFuSmFtaWxcXE9uZURyaXZlIC0gSmFmZmVyIEJ1c2luZXNzIFN5c3RlbXMgKFByaXZhdGUpIExpbWl0ZWRcXERlc2t0b3BcXFByb2plY3RzXFxCaWRfUmV2aWV3X1N5c3RlbS1tYXN0ZXJcXEJpZF9SZXZpZXdfU3lzdGVtLW1hc3Rlclxcc3JjXFxwbHVnaW5zXFxwbHVnaW4uZmlsbGVyXFxmaWxsZXIudGFyZ2V0LmpzIiwiQzpcXFVzZXJzXFxGYWl6YW5KYW1pbFxcT25lRHJpdmUgLSBKYWZmZXIgQnVzaW5lc3MgU3lzdGVtcyAoUHJpdmF0ZSkgTGltaXRlZFxcRGVza3RvcFxcUHJvamVjdHNcXEJpZF9SZXZpZXdfU3lzdGVtLW1hc3RlclxcQmlkX1Jldmlld19TeXN0ZW0tbWFzdGVyXFxzcmNcXHBsdWdpbnNcXHBsdWdpbi5maWxsZXJcXGZpbGxlci5kcmF3aW5nLmpzIiwiQzpcXFVzZXJzXFxGYWl6YW5KYW1pbFxcT25lRHJpdmUgLSBKYWZmZXIgQnVzaW5lc3MgU3lzdGVtcyAoUHJpdmF0ZSkgTGltaXRlZFxcRGVza3RvcFxcUHJvamVjdHNcXEJpZF9SZXZpZXdfU3lzdGVtLW1hc3RlclxcQmlkX1Jldmlld19TeXN0ZW0tbWFzdGVyXFxzcmNcXHBsdWdpbnNcXHBsdWdpbi5maWxsZXJcXGluZGV4LmpzIiwiQzpcXFVzZXJzXFxGYWl6YW5KYW1pbFxcT25lRHJpdmUgLSBKYWZmZXIgQnVzaW5lc3MgU3lzdGVtcyAoUHJpdmF0ZSkgTGltaXRlZFxcRGVza3RvcFxcUHJvamVjdHNcXEJpZF9SZXZpZXdfU3lzdGVtLW1hc3RlclxcQmlkX1Jldmlld19TeXN0ZW0tbWFzdGVyXFxzcmNcXHBsdWdpbnNcXHBsdWdpbi5sZWdlbmQuanMiLCJDOlxcVXNlcnNcXEZhaXphbkphbWlsXFxPbmVEcml2ZSAtIEphZmZlciBCdXNpbmVzcyBTeXN0ZW1zIChQcml2YXRlKSBMaW1pdGVkXFxEZXNrdG9wXFxQcm9qZWN0c1xcQmlkX1Jldmlld19TeXN0ZW0tbWFzdGVyXFxCaWRfUmV2aWV3X1N5c3RlbS1tYXN0ZXJcXHNyY1xccGx1Z2luc1xccGx1Z2luLnRpdGxlLmpzIiwiQzpcXFVzZXJzXFxGYWl6YW5KYW1pbFxcT25lRHJpdmUgLSBKYWZmZXIgQnVzaW5lc3MgU3lzdGVtcyAoUHJpdmF0ZSkgTGltaXRlZFxcRGVza3RvcFxcUHJvamVjdHNcXEJpZF9SZXZpZXdfU3lzdGVtLW1hc3RlclxcQmlkX1Jldmlld19TeXN0ZW0tbWFzdGVyXFxzcmNcXHBsdWdpbnNcXHBsdWdpbi5zdWJ0aXRsZS5qcyIsIkM6XFxVc2Vyc1xcRmFpemFuSmFtaWxcXE9uZURyaXZlIC0gSmFmZmVyIEJ1c2luZXNzIFN5c3RlbXMgKFByaXZhdGUpIExpbWl0ZWRcXERlc2t0b3BcXFByb2plY3RzXFxCaWRfUmV2aWV3X1N5c3RlbS1tYXN0ZXJcXEJpZF9SZXZpZXdfU3lzdGVtLW1hc3Rlclxcc3JjXFxwbHVnaW5zXFxwbHVnaW4udG9vbHRpcC5qcyIsIkM6XFxVc2Vyc1xcRmFpemFuSmFtaWxcXE9uZURyaXZlIC0gSmFmZmVyIEJ1c2luZXNzIFN5c3RlbXMgKFByaXZhdGUpIExpbWl0ZWRcXERlc2t0b3BcXFByb2plY3RzXFxCaWRfUmV2aWV3X1N5c3RlbS1tYXN0ZXJcXEJpZF9SZXZpZXdfU3lzdGVtLW1hc3Rlclxcc3JjXFxzY2FsZXNcXHNjYWxlLmNhdGVnb3J5LmpzIiwiQzpcXFVzZXJzXFxGYWl6YW5KYW1pbFxcT25lRHJpdmUgLSBKYWZmZXIgQnVzaW5lc3MgU3lzdGVtcyAoUHJpdmF0ZSkgTGltaXRlZFxcRGVza3RvcFxcUHJvamVjdHNcXEJpZF9SZXZpZXdfU3lzdGVtLW1hc3RlclxcQmlkX1Jldmlld19TeXN0ZW0tbWFzdGVyXFxzcmNcXHNjYWxlc1xcc2NhbGUubGluZWFyYmFzZS5qcyIsIkM6XFxVc2Vyc1xcRmFpemFuSmFtaWxcXE9uZURyaXZlIC0gSmFmZmVyIEJ1c2luZXNzIFN5c3RlbXMgKFByaXZhdGUpIExpbWl0ZWRcXERlc2t0b3BcXFByb2plY3RzXFxCaWRfUmV2aWV3X1N5c3RlbS1tYXN0ZXJcXEJpZF9SZXZpZXdfU3lzdGVtLW1hc3Rlclxcc3JjXFxzY2FsZXNcXHNjYWxlLmxpbmVhci5qcyIsIkM6XFxVc2Vyc1xcRmFpemFuSmFtaWxcXE9uZURyaXZlIC0gSmFmZmVyIEJ1c2luZXNzIFN5c3RlbXMgKFByaXZhdGUpIExpbWl0ZWRcXERlc2t0b3BcXFByb2plY3RzXFxCaWRfUmV2aWV3X1N5c3RlbS1tYXN0ZXJcXEJpZF9SZXZpZXdfU3lzdGVtLW1hc3Rlclxcc3JjXFxzY2FsZXNcXHNjYWxlLmxvZ2FyaXRobWljLmpzIiwiQzpcXFVzZXJzXFxGYWl6YW5KYW1pbFxcT25lRHJpdmUgLSBKYWZmZXIgQnVzaW5lc3MgU3lzdGVtcyAoUHJpdmF0ZSkgTGltaXRlZFxcRGVza3RvcFxcUHJvamVjdHNcXEJpZF9SZXZpZXdfU3lzdGVtLW1hc3RlclxcQmlkX1Jldmlld19TeXN0ZW0tbWFzdGVyXFxzcmNcXHNjYWxlc1xcc2NhbGUucmFkaWFsTGluZWFyLmpzIiwiQzpcXFVzZXJzXFxGYWl6YW5KYW1pbFxcT25lRHJpdmUgLSBKYWZmZXIgQnVzaW5lc3MgU3lzdGVtcyAoUHJpdmF0ZSkgTGltaXRlZFxcRGVza3RvcFxcUHJvamVjdHNcXEJpZF9SZXZpZXdfU3lzdGVtLW1hc3RlclxcQmlkX1Jldmlld19TeXN0ZW0tbWFzdGVyXFxzcmNcXHNjYWxlc1xcc2NhbGUudGltZS5qcyIsIkM6XFxVc2Vyc1xcRmFpemFuSmFtaWxcXE9uZURyaXZlIC0gSmFmZmVyIEJ1c2luZXNzIFN5c3RlbXMgKFByaXZhdGUpIExpbWl0ZWRcXERlc2t0b3BcXFByb2plY3RzXFxCaWRfUmV2aWV3X1N5c3RlbS1tYXN0ZXJcXEJpZF9SZXZpZXdfU3lzdGVtLW1hc3Rlclxcc3JjXFxzY2FsZXNcXHNjYWxlLnRpbWVzZXJpZXMuanMiLCJDOlxcVXNlcnNcXEZhaXphbkphbWlsXFxPbmVEcml2ZSAtIEphZmZlciBCdXNpbmVzcyBTeXN0ZW1zIChQcml2YXRlKSBMaW1pdGVkXFxEZXNrdG9wXFxQcm9qZWN0c1xcQmlkX1Jldmlld19TeXN0ZW0tbWFzdGVyXFxCaWRfUmV2aWV3X1N5c3RlbS1tYXN0ZXJcXHNyY1xcaW5kZXgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtyZXF1ZXN0QW5pbUZyYW1lfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuZXh0cmFzLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9jb3JlLmFuaW1hdGlvbi5qcycpLmRlZmF1bHQgfSBBbmltYXRpb25cbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICovXG5cbi8qKlxuICogUGxlYXNlIHVzZSB0aGUgbW9kdWxlJ3MgZGVmYXVsdCBleHBvcnQgd2hpY2ggcHJvdmlkZXMgYSBzaW5nbGV0b24gaW5zdGFuY2VcbiAqIE5vdGU6IGNsYXNzIGlzIGV4cG9ydCBmb3IgdHlwZWRvY1xuICovXG5leHBvcnQgY2xhc3MgQW5pbWF0b3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcbiAgICB0aGlzLl9jaGFydHMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMuX2xhc3REYXRlID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfbm90aWZ5KGNoYXJ0LCBhbmltcywgZGF0ZSwgdHlwZSkge1xuICAgIGNvbnN0IGNhbGxiYWNrcyA9IGFuaW1zLmxpc3RlbmVyc1t0eXBlXTtcbiAgICBjb25zdCBudW1TdGVwcyA9IGFuaW1zLmR1cmF0aW9uO1xuXG4gICAgY2FsbGJhY2tzLmZvckVhY2goZm4gPT4gZm4oe1xuICAgICAgY2hhcnQsXG4gICAgICBpbml0aWFsOiBhbmltcy5pbml0aWFsLFxuICAgICAgbnVtU3RlcHMsXG4gICAgICBjdXJyZW50U3RlcDogTWF0aC5taW4oZGF0ZSAtIGFuaW1zLnN0YXJ0LCBudW1TdGVwcylcbiAgICB9KSk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9yZWZyZXNoKCkge1xuICAgIGlmICh0aGlzLl9yZXF1ZXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3J1bm5pbmcgPSB0cnVlO1xuXG4gICAgdGhpcy5fcmVxdWVzdCA9IHJlcXVlc3RBbmltRnJhbWUuY2FsbCh3aW5kb3csICgpID0+IHtcbiAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgdGhpcy5fcmVxdWVzdCA9IG51bGw7XG5cbiAgICAgIGlmICh0aGlzLl9ydW5uaW5nKSB7XG4gICAgICAgIHRoaXMuX3JlZnJlc2goKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3VwZGF0ZShkYXRlID0gRGF0ZS5ub3coKSkge1xuICAgIGxldCByZW1haW5pbmcgPSAwO1xuXG4gICAgdGhpcy5fY2hhcnRzLmZvckVhY2goKGFuaW1zLCBjaGFydCkgPT4ge1xuICAgICAgaWYgKCFhbmltcy5ydW5uaW5nIHx8ICFhbmltcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaXRlbXMgPSBhbmltcy5pdGVtcztcbiAgICAgIGxldCBpID0gaXRlbXMubGVuZ3RoIC0gMTtcbiAgICAgIGxldCBkcmF3ID0gZmFsc2U7XG4gICAgICBsZXQgaXRlbTtcblxuICAgICAgZm9yICg7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcblxuICAgICAgICBpZiAoaXRlbS5fYWN0aXZlKSB7XG4gICAgICAgICAgaWYgKGl0ZW0uX3RvdGFsID4gYW5pbXMuZHVyYXRpb24pIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBhbmltYXRpb24gaGFzIGJlZW4gdXBkYXRlZCBhbmQgaXRzIGR1cmF0aW9uIHByb2xvbmdlZCxcbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0byB0b3RhbCBkdXJhdGlvbiBvZiBjdXJyZW50IGFuaW1hdGlvbnMgcnVuIChmb3IgcHJvZ3Jlc3MgZXZlbnQpXG4gICAgICAgICAgICBhbmltcy5kdXJhdGlvbiA9IGl0ZW0uX3RvdGFsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpdGVtLnRpY2soZGF0ZSk7XG4gICAgICAgICAgZHJhdyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIHRoZSBpdGVtIGJ5IHJlcGxhY2luZyBpdCB3aXRoIGxhc3QgaXRlbSBhbmQgcmVtb3ZpbmcgdGhlIGxhc3RcbiAgICAgICAgICAvLyBBIGxvdCBmYXN0ZXIgdGhhbiBzcGxpY2UuXG4gICAgICAgICAgaXRlbXNbaV0gPSBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICBpdGVtcy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZHJhdykge1xuICAgICAgICBjaGFydC5kcmF3KCk7XG4gICAgICAgIHRoaXMuX25vdGlmeShjaGFydCwgYW5pbXMsIGRhdGUsICdwcm9ncmVzcycpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgICBhbmltcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX25vdGlmeShjaGFydCwgYW5pbXMsIGRhdGUsICdjb21wbGV0ZScpO1xuICAgICAgICBhbmltcy5pbml0aWFsID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJlbWFpbmluZyArPSBpdGVtcy5sZW5ndGg7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9sYXN0RGF0ZSA9IGRhdGU7XG5cbiAgICBpZiAocmVtYWluaW5nID09PSAwKSB7XG4gICAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0QW5pbXMoY2hhcnQpIHtcbiAgICBjb25zdCBjaGFydHMgPSB0aGlzLl9jaGFydHM7XG4gICAgbGV0IGFuaW1zID0gY2hhcnRzLmdldChjaGFydCk7XG4gICAgaWYgKCFhbmltcykge1xuICAgICAgYW5pbXMgPSB7XG4gICAgICAgIHJ1bm5pbmc6IGZhbHNlLFxuICAgICAgICBpbml0aWFsOiB0cnVlLFxuICAgICAgICBpdGVtczogW10sXG4gICAgICAgIGxpc3RlbmVyczoge1xuICAgICAgICAgIGNvbXBsZXRlOiBbXSxcbiAgICAgICAgICBwcm9ncmVzczogW11cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNoYXJ0cy5zZXQoY2hhcnQsIGFuaW1zKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1zO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCAtIGV2ZW50IG5hbWVcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgLSBjYWxsYmFja1xuXHQgKi9cbiAgbGlzdGVuKGNoYXJ0LCBldmVudCwgY2IpIHtcbiAgICB0aGlzLl9nZXRBbmltcyhjaGFydCkubGlzdGVuZXJzW2V2ZW50XS5wdXNoKGNiKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBBZGQgYW5pbWF0aW9uc1xuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKiBAcGFyYW0ge0FuaW1hdGlvbltdfSBpdGVtcyAtIGFuaW1hdGlvbnNcblx0ICovXG4gIGFkZChjaGFydCwgaXRlbXMpIHtcbiAgICBpZiAoIWl0ZW1zIHx8ICFpdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZ2V0QW5pbXMoY2hhcnQpLml0ZW1zLnB1c2goLi4uaXRlbXMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIENvdW50cyBudW1iZXIgb2YgYWN0aXZlIGFuaW1hdGlvbnMgZm9yIHRoZSBjaGFydFxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKi9cbiAgaGFzKGNoYXJ0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldEFuaW1zKGNoYXJ0KS5pdGVtcy5sZW5ndGggPiAwO1xuICB9XG5cbiAgLyoqXG5cdCAqIFN0YXJ0IGFuaW1hdGluZyAoYWxsIGNoYXJ0cylcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICovXG4gIHN0YXJ0KGNoYXJ0KSB7XG4gICAgY29uc3QgYW5pbXMgPSB0aGlzLl9jaGFydHMuZ2V0KGNoYXJ0KTtcbiAgICBpZiAoIWFuaW1zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFuaW1zLnJ1bm5pbmcgPSB0cnVlO1xuICAgIGFuaW1zLnN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICBhbmltcy5kdXJhdGlvbiA9IGFuaW1zLml0ZW1zLnJlZHVjZSgoYWNjLCBjdXIpID0+IE1hdGgubWF4KGFjYywgY3VyLl9kdXJhdGlvbiksIDApO1xuICAgIHRoaXMuX3JlZnJlc2goKTtcbiAgfVxuXG4gIHJ1bm5pbmcoY2hhcnQpIHtcbiAgICBpZiAoIXRoaXMuX3J1bm5pbmcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgYW5pbXMgPSB0aGlzLl9jaGFydHMuZ2V0KGNoYXJ0KTtcbiAgICBpZiAoIWFuaW1zIHx8ICFhbmltcy5ydW5uaW5nIHx8ICFhbmltcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcblx0ICogU3RvcCBhbGwgYW5pbWF0aW9ucyBmb3IgdGhlIGNoYXJ0XG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG5cdCAqL1xuICBzdG9wKGNoYXJ0KSB7XG4gICAgY29uc3QgYW5pbXMgPSB0aGlzLl9jaGFydHMuZ2V0KGNoYXJ0KTtcbiAgICBpZiAoIWFuaW1zIHx8ICFhbmltcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaXRlbXMgPSBhbmltcy5pdGVtcztcbiAgICBsZXQgaSA9IGl0ZW1zLmxlbmd0aCAtIDE7XG5cbiAgICBmb3IgKDsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGl0ZW1zW2ldLmNhbmNlbCgpO1xuICAgIH1cbiAgICBhbmltcy5pdGVtcyA9IFtdO1xuICAgIHRoaXMuX25vdGlmeShjaGFydCwgYW5pbXMsIERhdGUubm93KCksICdjb21wbGV0ZScpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJlbW92ZSBjaGFydCBmcm9tIEFuaW1hdG9yXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG5cdCAqL1xuICByZW1vdmUoY2hhcnQpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hhcnRzLmRlbGV0ZShjaGFydCk7XG4gIH1cbn1cblxuLy8gc2luZ2xldG9uIGluc3RhbmNlXG5leHBvcnQgZGVmYXVsdCAvKiAjX19QVVJFX18gKi8gbmV3IEFuaW1hdG9yKCk7XG4iLCJpbXBvcnQgZWZmZWN0cyBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuZWFzaW5nLmpzJztcbmltcG9ydCB7cmVzb2x2ZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm9wdGlvbnMuanMnO1xuaW1wb3J0IHtjb2xvciBhcyBoZWxwZXJzQ29sb3J9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb2xvci5qcyc7XG5cbmNvbnN0IHRyYW5zcGFyZW50ID0gJ3RyYW5zcGFyZW50JztcbmNvbnN0IGludGVycG9sYXRvcnMgPSB7XG4gIGJvb2xlYW4oZnJvbSwgdG8sIGZhY3Rvcikge1xuICAgIHJldHVybiBmYWN0b3IgPiAwLjUgPyB0byA6IGZyb207XG4gIH0sXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZnJvbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZhY3RvclxuICAgKi9cbiAgY29sb3IoZnJvbSwgdG8sIGZhY3Rvcikge1xuICAgIGNvbnN0IGMwID0gaGVscGVyc0NvbG9yKGZyb20gfHwgdHJhbnNwYXJlbnQpO1xuICAgIGNvbnN0IGMxID0gYzAudmFsaWQgJiYgaGVscGVyc0NvbG9yKHRvIHx8IHRyYW5zcGFyZW50KTtcbiAgICByZXR1cm4gYzEgJiYgYzEudmFsaWRcbiAgICAgID8gYzEubWl4KGMwLCBmYWN0b3IpLmhleFN0cmluZygpXG4gICAgICA6IHRvO1xuICB9LFxuICBudW1iZXIoZnJvbSwgdG8sIGZhY3Rvcikge1xuICAgIHJldHVybiBmcm9tICsgKHRvIC0gZnJvbSkgKiBmYWN0b3I7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFuaW1hdGlvbiB7XG4gIGNvbnN0cnVjdG9yKGNmZywgdGFyZ2V0LCBwcm9wLCB0bykge1xuICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHRhcmdldFtwcm9wXTtcblxuICAgIHRvID0gcmVzb2x2ZShbY2ZnLnRvLCB0bywgY3VycmVudFZhbHVlLCBjZmcuZnJvbV0pO1xuICAgIGNvbnN0IGZyb20gPSByZXNvbHZlKFtjZmcuZnJvbSwgY3VycmVudFZhbHVlLCB0b10pO1xuXG4gICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLl9mbiA9IGNmZy5mbiB8fCBpbnRlcnBvbGF0b3JzW2NmZy50eXBlIHx8IHR5cGVvZiBmcm9tXTtcbiAgICB0aGlzLl9lYXNpbmcgPSBlZmZlY3RzW2NmZy5lYXNpbmddIHx8IGVmZmVjdHMubGluZWFyO1xuICAgIHRoaXMuX3N0YXJ0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpICsgKGNmZy5kZWxheSB8fCAwKSk7XG4gICAgdGhpcy5fZHVyYXRpb24gPSB0aGlzLl90b3RhbCA9IE1hdGguZmxvb3IoY2ZnLmR1cmF0aW9uKTtcbiAgICB0aGlzLl9sb29wID0gISFjZmcubG9vcDtcbiAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5fcHJvcCA9IHByb3A7XG4gICAgdGhpcy5fZnJvbSA9IGZyb207XG4gICAgdGhpcy5fdG8gPSB0bztcbiAgICB0aGlzLl9wcm9taXNlcyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlO1xuICB9XG5cbiAgdXBkYXRlKGNmZywgdG8sIGRhdGUpIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICB0aGlzLl9ub3RpZnkoZmFsc2UpO1xuXG4gICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0aGlzLl90YXJnZXRbdGhpcy5fcHJvcF07XG4gICAgICBjb25zdCBlbGFwc2VkID0gZGF0ZSAtIHRoaXMuX3N0YXJ0O1xuICAgICAgY29uc3QgcmVtYWluID0gdGhpcy5fZHVyYXRpb24gLSBlbGFwc2VkO1xuICAgICAgdGhpcy5fc3RhcnQgPSBkYXRlO1xuICAgICAgdGhpcy5fZHVyYXRpb24gPSBNYXRoLmZsb29yKE1hdGgubWF4KHJlbWFpbiwgY2ZnLmR1cmF0aW9uKSk7XG4gICAgICB0aGlzLl90b3RhbCArPSBlbGFwc2VkO1xuICAgICAgdGhpcy5fbG9vcCA9ICEhY2ZnLmxvb3A7XG4gICAgICB0aGlzLl90byA9IHJlc29sdmUoW2NmZy50bywgdG8sIGN1cnJlbnRWYWx1ZSwgY2ZnLmZyb21dKTtcbiAgICAgIHRoaXMuX2Zyb20gPSByZXNvbHZlKFtjZmcuZnJvbSwgY3VycmVudFZhbHVlLCB0b10pO1xuICAgIH1cbiAgfVxuXG4gIGNhbmNlbCgpIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICAvLyB1cGRhdGUgY3VycmVudCBldmFsdWF0ZWQgdmFsdWUsIGZvciBzbW9vdGhlciBhbmltYXRpb25zXG4gICAgICB0aGlzLnRpY2soRGF0ZS5ub3coKSk7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuX25vdGlmeShmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgdGljayhkYXRlKSB7XG4gICAgY29uc3QgZWxhcHNlZCA9IGRhdGUgLSB0aGlzLl9zdGFydDtcbiAgICBjb25zdCBkdXJhdGlvbiA9IHRoaXMuX2R1cmF0aW9uO1xuICAgIGNvbnN0IHByb3AgPSB0aGlzLl9wcm9wO1xuICAgIGNvbnN0IGZyb20gPSB0aGlzLl9mcm9tO1xuICAgIGNvbnN0IGxvb3AgPSB0aGlzLl9sb29wO1xuICAgIGNvbnN0IHRvID0gdGhpcy5fdG87XG4gICAgbGV0IGZhY3RvcjtcblxuICAgIHRoaXMuX2FjdGl2ZSA9IGZyb20gIT09IHRvICYmIChsb29wIHx8IChlbGFwc2VkIDwgZHVyYXRpb24pKTtcblxuICAgIGlmICghdGhpcy5fYWN0aXZlKSB7XG4gICAgICB0aGlzLl90YXJnZXRbcHJvcF0gPSB0bztcbiAgICAgIHRoaXMuX25vdGlmeSh0cnVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWxhcHNlZCA8IDApIHtcbiAgICAgIHRoaXMuX3RhcmdldFtwcm9wXSA9IGZyb207XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZmFjdG9yID0gKGVsYXBzZWQgLyBkdXJhdGlvbikgJSAyO1xuICAgIGZhY3RvciA9IGxvb3AgJiYgZmFjdG9yID4gMSA/IDIgLSBmYWN0b3IgOiBmYWN0b3I7XG4gICAgZmFjdG9yID0gdGhpcy5fZWFzaW5nKE1hdGgubWluKDEsIE1hdGgubWF4KDAsIGZhY3RvcikpKTtcblxuICAgIHRoaXMuX3RhcmdldFtwcm9wXSA9IHRoaXMuX2ZuKGZyb20sIHRvLCBmYWN0b3IpO1xuICB9XG5cbiAgd2FpdCgpIHtcbiAgICBjb25zdCBwcm9taXNlcyA9IHRoaXMuX3Byb21pc2VzIHx8ICh0aGlzLl9wcm9taXNlcyA9IFtdKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICBwcm9taXNlcy5wdXNoKHtyZXMsIHJlan0pO1xuICAgIH0pO1xuICB9XG5cbiAgX25vdGlmeShyZXNvbHZlZCkge1xuICAgIGNvbnN0IG1ldGhvZCA9IHJlc29sdmVkID8gJ3JlcycgOiAncmVqJztcbiAgICBjb25zdCBwcm9taXNlcyA9IHRoaXMuX3Byb21pc2VzIHx8IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvbWlzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHByb21pc2VzW2ldW21ldGhvZF0oKTtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCBhbmltYXRvciBmcm9tICcuL2NvcmUuYW5pbWF0b3IuanMnO1xuaW1wb3J0IEFuaW1hdGlvbiBmcm9tICcuL2NvcmUuYW5pbWF0aW9uLmpzJztcbmltcG9ydCBkZWZhdWx0cyBmcm9tICcuL2NvcmUuZGVmYXVsdHMuanMnO1xuaW1wb3J0IHtpc0FycmF5LCBpc09iamVjdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbmltYXRpb25zIHtcbiAgY29uc3RydWN0b3IoY2hhcnQsIGNvbmZpZykge1xuICAgIHRoaXMuX2NoYXJ0ID0gY2hhcnQ7XG4gICAgdGhpcy5fcHJvcGVydGllcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmNvbmZpZ3VyZShjb25maWcpO1xuICB9XG5cbiAgY29uZmlndXJlKGNvbmZpZykge1xuICAgIGlmICghaXNPYmplY3QoY29uZmlnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGFuaW1hdGlvbk9wdGlvbnMgPSBPYmplY3Qua2V5cyhkZWZhdWx0cy5hbmltYXRpb24pO1xuICAgIGNvbnN0IGFuaW1hdGVkUHJvcHMgPSB0aGlzLl9wcm9wZXJ0aWVzO1xuXG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY29uZmlnKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBjb25zdCBjZmcgPSBjb25maWdba2V5XTtcbiAgICAgIGlmICghaXNPYmplY3QoY2ZnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCByZXNvbHZlZCA9IHt9O1xuICAgICAgZm9yIChjb25zdCBvcHRpb24gb2YgYW5pbWF0aW9uT3B0aW9ucykge1xuICAgICAgICByZXNvbHZlZFtvcHRpb25dID0gY2ZnW29wdGlvbl07XG4gICAgICB9XG5cbiAgICAgIChpc0FycmF5KGNmZy5wcm9wZXJ0aWVzKSAmJiBjZmcucHJvcGVydGllcyB8fCBba2V5XSkuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgICBpZiAocHJvcCA9PT0ga2V5IHx8ICFhbmltYXRlZFByb3BzLmhhcyhwcm9wKSkge1xuICAgICAgICAgIGFuaW1hdGVkUHJvcHMuc2V0KHByb3AsIHJlc29sdmVkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcblx0ICogVXRpbGl0eSB0byBoYW5kbGUgYW5pbWF0aW9uIG9mIGBvcHRpb25zYC5cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9hbmltYXRlT3B0aW9ucyh0YXJnZXQsIHZhbHVlcykge1xuICAgIGNvbnN0IG5ld09wdGlvbnMgPSB2YWx1ZXMub3B0aW9ucztcbiAgICBjb25zdCBvcHRpb25zID0gcmVzb2x2ZVRhcmdldE9wdGlvbnModGFyZ2V0LCBuZXdPcHRpb25zKTtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBjb25zdCBhbmltYXRpb25zID0gdGhpcy5fY3JlYXRlQW5pbWF0aW9ucyhvcHRpb25zLCBuZXdPcHRpb25zKTtcbiAgICBpZiAobmV3T3B0aW9ucy4kc2hhcmVkKSB7XG4gICAgICAvLyBHb2luZyB0byBzaGFyZWQgb3B0aW9uczpcbiAgICAgIC8vIEFmdGVyIGFsbCBhbmltYXRpb25zIGFyZSBkb25lLCBhc3NpZ24gdGhlIHNoYXJlZCBvcHRpb25zIG9iamVjdCB0byB0aGUgZWxlbWVudFxuICAgICAgLy8gU28gYW55IG5ldyB1cGRhdGVzIHRvIHRoZSBzaGFyZWQgb3B0aW9ucyBhcmUgb2JzZXJ2ZWRcbiAgICAgIGF3YWl0QWxsKHRhcmdldC5vcHRpb25zLiRhbmltYXRpb25zLCBuZXdPcHRpb25zKS50aGVuKCgpID0+IHtcbiAgICAgICAgdGFyZ2V0Lm9wdGlvbnMgPSBuZXdPcHRpb25zO1xuICAgICAgfSwgKCkgPT4ge1xuICAgICAgICAvLyByZWplY3RlZCwgbm9vcFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuaW1hdGlvbnM7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9jcmVhdGVBbmltYXRpb25zKHRhcmdldCwgdmFsdWVzKSB7XG4gICAgY29uc3QgYW5pbWF0ZWRQcm9wcyA9IHRoaXMuX3Byb3BlcnRpZXM7XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IFtdO1xuICAgIGNvbnN0IHJ1bm5pbmcgPSB0YXJnZXQuJGFuaW1hdGlvbnMgfHwgKHRhcmdldC4kYW5pbWF0aW9ucyA9IHt9KTtcbiAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5rZXlzKHZhbHVlcyk7XG4gICAgY29uc3QgZGF0ZSA9IERhdGUubm93KCk7XG4gICAgbGV0IGk7XG5cbiAgICBmb3IgKGkgPSBwcm9wcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgY29uc3QgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgaWYgKHByb3AuY2hhckF0KDApID09PSAnJCcpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9wID09PSAnb3B0aW9ucycpIHtcbiAgICAgICAgYW5pbWF0aW9ucy5wdXNoKC4uLnRoaXMuX2FuaW1hdGVPcHRpb25zKHRhcmdldCwgdmFsdWVzKSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbcHJvcF07XG4gICAgICBsZXQgYW5pbWF0aW9uID0gcnVubmluZ1twcm9wXTtcbiAgICAgIGNvbnN0IGNmZyA9IGFuaW1hdGVkUHJvcHMuZ2V0KHByb3ApO1xuXG4gICAgICBpZiAoYW5pbWF0aW9uKSB7XG4gICAgICAgIGlmIChjZmcgJiYgYW5pbWF0aW9uLmFjdGl2ZSgpKSB7XG4gICAgICAgICAgLy8gVGhlcmUgaXMgYW4gZXhpc3RpbmcgYWN0aXZlIGFuaW1hdGlvbiwgbGV0J3MgdXBkYXRlIHRoYXRcbiAgICAgICAgICBhbmltYXRpb24udXBkYXRlKGNmZywgdmFsdWUsIGRhdGUpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFuaW1hdGlvbi5jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFjZmcgfHwgIWNmZy5kdXJhdGlvbikge1xuICAgICAgICAvLyBub3QgYW5pbWF0ZWQsIHNldCBkaXJlY3RseSB0byBuZXcgdmFsdWVcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBydW5uaW5nW3Byb3BdID0gYW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbihjZmcsIHRhcmdldCwgcHJvcCwgdmFsdWUpO1xuICAgICAgYW5pbWF0aW9ucy5wdXNoKGFuaW1hdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBhbmltYXRpb25zO1xuICB9XG5cblxuICAvKipcblx0ICogVXBkYXRlIGB0YXJnZXRgIHByb3BlcnRpZXMgdG8gbmV3IHZhbHVlcywgdXNpbmcgY29uZmlndXJlZCBhbmltYXRpb25zXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgLSBvYmplY3QgdG8gdXBkYXRlXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgLSBuZXcgdGFyZ2V0IHByb3BlcnRpZXNcblx0ICogQHJldHVybnMge2Jvb2xlYW58dW5kZWZpbmVkfSAtIGB0cnVlYCBpZiBhbmltYXRpb25zIHdlcmUgc3RhcnRlZFxuXHQgKiovXG4gIHVwZGF0ZSh0YXJnZXQsIHZhbHVlcykge1xuICAgIGlmICh0aGlzLl9wcm9wZXJ0aWVzLnNpemUgPT09IDApIHtcbiAgICAgIC8vIE5vdGhpbmcgaXMgYW5pbWF0ZWQsIGp1c3QgYXBwbHkgdGhlIG5ldyB2YWx1ZXMuXG4gICAgICBPYmplY3QuYXNzaWduKHRhcmdldCwgdmFsdWVzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBhbmltYXRpb25zID0gdGhpcy5fY3JlYXRlQW5pbWF0aW9ucyh0YXJnZXQsIHZhbHVlcyk7XG5cbiAgICBpZiAoYW5pbWF0aW9ucy5sZW5ndGgpIHtcbiAgICAgIGFuaW1hdG9yLmFkZCh0aGlzLl9jaGFydCwgYW5pbWF0aW9ucyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXdhaXRBbGwoYW5pbWF0aW9ucywgcHJvcGVydGllcykge1xuICBjb25zdCBydW5uaW5nID0gW107XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYW5pbSA9IGFuaW1hdGlvbnNba2V5c1tpXV07XG4gICAgaWYgKGFuaW0gJiYgYW5pbS5hY3RpdmUoKSkge1xuICAgICAgcnVubmluZy5wdXNoKGFuaW0ud2FpdCgpKTtcbiAgICB9XG4gIH1cbiAgLy8gQHRzLWlnbm9yZVxuICByZXR1cm4gUHJvbWlzZS5hbGwocnVubmluZyk7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVUYXJnZXRPcHRpb25zKHRhcmdldCwgbmV3T3B0aW9ucykge1xuICBpZiAoIW5ld09wdGlvbnMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IG9wdGlvbnMgPSB0YXJnZXQub3B0aW9ucztcbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgdGFyZ2V0Lm9wdGlvbnMgPSBuZXdPcHRpb25zO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAob3B0aW9ucy4kc2hhcmVkKSB7XG4gICAgLy8gR29pbmcgZnJvbSBzaGFyZWQgb3B0aW9ucyB0byBkaXN0aW5jdCBvbmU6XG4gICAgLy8gQ3JlYXRlIG5ldyBvcHRpb25zIG9iamVjdCBjb250YWluaW5nIHRoZSBvbGQgc2hhcmVkIHZhbHVlcyBhbmQgc3RhcnQgdXBkYXRpbmcgdGhhdC5cbiAgICB0YXJnZXQub3B0aW9ucyA9IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7JHNoYXJlZDogZmFsc2UsICRhbmltYXRpb25zOiB7fX0pO1xuICB9XG4gIHJldHVybiBvcHRpb25zO1xufVxuIiwiaW1wb3J0IEFuaW1hdGlvbnMgZnJvbSAnLi9jb3JlLmFuaW1hdGlvbnMuanMnO1xuaW1wb3J0IGRlZmF1bHRzIGZyb20gJy4vY29yZS5kZWZhdWx0cy5qcyc7XG5pbXBvcnQge2lzQXJyYXksIGlzRmluaXRlLCBpc09iamVjdCwgdmFsdWVPckRlZmF1bHQsIHJlc29sdmVPYmplY3RLZXksIGRlZmluZWR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7bGlzdGVuQXJyYXlFdmVudHMsIHVubGlzdGVuQXJyYXlFdmVudHN9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb2xsZWN0aW9uLmpzJztcbmltcG9ydCB7Y3JlYXRlQ29udGV4dCwgc2lnbn0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4vY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9jb3JlLnNjYWxlLmpzJykuZGVmYXVsdCB9IFNjYWxlXG4gKi9cblxuZnVuY3Rpb24gc2NhbGVDbGlwKHNjYWxlLCBhbGxvd2VkT3ZlcmZsb3cpIHtcbiAgY29uc3Qgb3B0cyA9IHNjYWxlICYmIHNjYWxlLm9wdGlvbnMgfHwge307XG4gIGNvbnN0IHJldmVyc2UgPSBvcHRzLnJldmVyc2U7XG4gIGNvbnN0IG1pbiA9IG9wdHMubWluID09PSB1bmRlZmluZWQgPyBhbGxvd2VkT3ZlcmZsb3cgOiAwO1xuICBjb25zdCBtYXggPSBvcHRzLm1heCA9PT0gdW5kZWZpbmVkID8gYWxsb3dlZE92ZXJmbG93IDogMDtcbiAgcmV0dXJuIHtcbiAgICBzdGFydDogcmV2ZXJzZSA/IG1heCA6IG1pbixcbiAgICBlbmQ6IHJldmVyc2UgPyBtaW4gOiBtYXhcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdENsaXAoeFNjYWxlLCB5U2NhbGUsIGFsbG93ZWRPdmVyZmxvdykge1xuICBpZiAoYWxsb3dlZE92ZXJmbG93ID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCB4ID0gc2NhbGVDbGlwKHhTY2FsZSwgYWxsb3dlZE92ZXJmbG93KTtcbiAgY29uc3QgeSA9IHNjYWxlQ2xpcCh5U2NhbGUsIGFsbG93ZWRPdmVyZmxvdyk7XG5cbiAgcmV0dXJuIHtcbiAgICB0b3A6IHkuZW5kLFxuICAgIHJpZ2h0OiB4LmVuZCxcbiAgICBib3R0b206IHkuc3RhcnQsXG4gICAgbGVmdDogeC5zdGFydFxuICB9O1xufVxuXG5mdW5jdGlvbiB0b0NsaXAodmFsdWUpIHtcbiAgbGV0IHQsIHIsIGIsIGw7XG5cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHQgPSB2YWx1ZS50b3A7XG4gICAgciA9IHZhbHVlLnJpZ2h0O1xuICAgIGIgPSB2YWx1ZS5ib3R0b207XG4gICAgbCA9IHZhbHVlLmxlZnQ7XG4gIH0gZWxzZSB7XG4gICAgdCA9IHIgPSBiID0gbCA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0b3A6IHQsXG4gICAgcmlnaHQ6IHIsXG4gICAgYm90dG9tOiBiLFxuICAgIGxlZnQ6IGwsXG4gICAgZGlzYWJsZWQ6IHZhbHVlID09PSBmYWxzZVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRTb3J0ZWREYXRhc2V0SW5kaWNlcyhjaGFydCwgZmlsdGVyVmlzaWJsZSkge1xuICBjb25zdCBrZXlzID0gW107XG4gIGNvbnN0IG1ldGFzZXRzID0gY2hhcnQuX2dldFNvcnRlZERhdGFzZXRNZXRhcyhmaWx0ZXJWaXNpYmxlKTtcbiAgbGV0IGksIGlsZW47XG5cbiAgZm9yIChpID0gMCwgaWxlbiA9IG1ldGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGtleXMucHVzaChtZXRhc2V0c1tpXS5pbmRleCk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIGFwcGx5U3RhY2soc3RhY2ssIHZhbHVlLCBkc0luZGV4LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qga2V5cyA9IHN0YWNrLmtleXM7XG4gIGNvbnN0IHNpbmdsZU1vZGUgPSBvcHRpb25zLm1vZGUgPT09ICdzaW5nbGUnO1xuICBsZXQgaSwgaWxlbiwgZGF0YXNldEluZGV4LCBvdGhlclZhbHVlO1xuXG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCBmb3VuZCA9IGZhbHNlO1xuICBmb3IgKGkgPSAwLCBpbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBkYXRhc2V0SW5kZXggPSAra2V5c1tpXTtcbiAgICBpZiAoZGF0YXNldEluZGV4ID09PSBkc0luZGV4KSB7XG4gICAgICBmb3VuZCA9IHRydWU7XG4gICAgICBpZiAob3B0aW9ucy5hbGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb3RoZXJWYWx1ZSA9IHN0YWNrLnZhbHVlc1tkYXRhc2V0SW5kZXhdO1xuICAgIGlmIChpc0Zpbml0ZShvdGhlclZhbHVlKSAmJiAoc2luZ2xlTW9kZSB8fCAodmFsdWUgPT09IDAgfHwgc2lnbih2YWx1ZSkgPT09IHNpZ24ob3RoZXJWYWx1ZSkpKSkge1xuICAgICAgdmFsdWUgKz0gb3RoZXJWYWx1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWZvdW5kICYmICFvcHRpb25zLmFsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0T2JqZWN0RGF0YVRvQXJyYXkoZGF0YSwgbWV0YSkge1xuICBjb25zdCB7aVNjYWxlLCB2U2NhbGV9ID0gbWV0YTtcbiAgY29uc3QgaUF4aXNLZXkgPSBpU2NhbGUuYXhpcyA9PT0gJ3gnID8gJ3gnIDogJ3knO1xuICBjb25zdCB2QXhpc0tleSA9IHZTY2FsZS5heGlzID09PSAneCcgPyAneCcgOiAneSc7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgY29uc3QgYWRhdGEgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xuICBsZXQgaSwgaWxlbiwga2V5O1xuICBmb3IgKGkgPSAwLCBpbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIGFkYXRhW2ldID0ge1xuICAgICAgW2lBeGlzS2V5XToga2V5LFxuICAgICAgW3ZBeGlzS2V5XTogZGF0YVtrZXldXG4gICAgfTtcbiAgfVxuICByZXR1cm4gYWRhdGE7XG59XG5cbmZ1bmN0aW9uIGlzU3RhY2tlZChzY2FsZSwgbWV0YSkge1xuICBjb25zdCBzdGFja2VkID0gc2NhbGUgJiYgc2NhbGUub3B0aW9ucy5zdGFja2VkO1xuICByZXR1cm4gc3RhY2tlZCB8fCAoc3RhY2tlZCA9PT0gdW5kZWZpbmVkICYmIG1ldGEuc3RhY2sgIT09IHVuZGVmaW5lZCk7XG59XG5cbmZ1bmN0aW9uIGdldFN0YWNrS2V5KGluZGV4U2NhbGUsIHZhbHVlU2NhbGUsIG1ldGEpIHtcbiAgcmV0dXJuIGAke2luZGV4U2NhbGUuaWR9LiR7dmFsdWVTY2FsZS5pZH0uJHttZXRhLnN0YWNrIHx8IG1ldGEudHlwZX1gO1xufVxuXG5mdW5jdGlvbiBnZXRVc2VyQm91bmRzKHNjYWxlKSB7XG4gIGNvbnN0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSBzY2FsZS5nZXRVc2VyQm91bmRzKCk7XG4gIHJldHVybiB7XG4gICAgbWluOiBtaW5EZWZpbmVkID8gbWluIDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLFxuICAgIG1heDogbWF4RGVmaW5lZCA/IG1heCA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRPckNyZWF0ZVN0YWNrKHN0YWNrcywgc3RhY2tLZXksIGluZGV4VmFsdWUpIHtcbiAgY29uc3Qgc3ViU3RhY2sgPSBzdGFja3Nbc3RhY2tLZXldIHx8IChzdGFja3Nbc3RhY2tLZXldID0ge30pO1xuICByZXR1cm4gc3ViU3RhY2tbaW5kZXhWYWx1ZV0gfHwgKHN1YlN0YWNrW2luZGV4VmFsdWVdID0ge30pO1xufVxuXG5mdW5jdGlvbiBnZXRMYXN0SW5kZXhJblN0YWNrKHN0YWNrLCB2U2NhbGUsIHBvc2l0aXZlLCB0eXBlKSB7XG4gIGZvciAoY29uc3QgbWV0YSBvZiB2U2NhbGUuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXModHlwZSkucmV2ZXJzZSgpKSB7XG4gICAgY29uc3QgdmFsdWUgPSBzdGFja1ttZXRhLmluZGV4XTtcbiAgICBpZiAoKHBvc2l0aXZlICYmIHZhbHVlID4gMCkgfHwgKCFwb3NpdGl2ZSAmJiB2YWx1ZSA8IDApKSB7XG4gICAgICByZXR1cm4gbWV0YS5pbmRleDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU3RhY2tzKGNvbnRyb2xsZXIsIHBhcnNlZCkge1xuICBjb25zdCB7Y2hhcnQsIF9jYWNoZWRNZXRhOiBtZXRhfSA9IGNvbnRyb2xsZXI7XG4gIGNvbnN0IHN0YWNrcyA9IGNoYXJ0Ll9zdGFja3MgfHwgKGNoYXJ0Ll9zdGFja3MgPSB7fSk7IC8vIG1hcCBzdHJ1Y3R1cmUgaXMge3N0YWNrS2V5OiB7ZGF0YXNldEluZGV4OiB2YWx1ZX19XG4gIGNvbnN0IHtpU2NhbGUsIHZTY2FsZSwgaW5kZXg6IGRhdGFzZXRJbmRleH0gPSBtZXRhO1xuICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICBjb25zdCB2QXhpcyA9IHZTY2FsZS5heGlzO1xuICBjb25zdCBrZXkgPSBnZXRTdGFja0tleShpU2NhbGUsIHZTY2FsZSwgbWV0YSk7XG4gIGNvbnN0IGlsZW4gPSBwYXJzZWQubGVuZ3RoO1xuICBsZXQgc3RhY2s7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBjb25zdCBpdGVtID0gcGFyc2VkW2ldO1xuICAgIGNvbnN0IHtbaUF4aXNdOiBpbmRleCwgW3ZBeGlzXTogdmFsdWV9ID0gaXRlbTtcbiAgICBjb25zdCBpdGVtU3RhY2tzID0gaXRlbS5fc3RhY2tzIHx8IChpdGVtLl9zdGFja3MgPSB7fSk7XG4gICAgc3RhY2sgPSBpdGVtU3RhY2tzW3ZBeGlzXSA9IGdldE9yQ3JlYXRlU3RhY2soc3RhY2tzLCBrZXksIGluZGV4KTtcbiAgICBzdGFja1tkYXRhc2V0SW5kZXhdID0gdmFsdWU7XG5cbiAgICBzdGFjay5fdG9wID0gZ2V0TGFzdEluZGV4SW5TdGFjayhzdGFjaywgdlNjYWxlLCB0cnVlLCBtZXRhLnR5cGUpO1xuICAgIHN0YWNrLl9ib3R0b20gPSBnZXRMYXN0SW5kZXhJblN0YWNrKHN0YWNrLCB2U2NhbGUsIGZhbHNlLCBtZXRhLnR5cGUpO1xuXG4gICAgY29uc3QgdmlzdWFsVmFsdWVzID0gc3RhY2suX3Zpc3VhbFZhbHVlcyB8fCAoc3RhY2suX3Zpc3VhbFZhbHVlcyA9IHt9KTtcbiAgICB2aXN1YWxWYWx1ZXNbZGF0YXNldEluZGV4XSA9IHZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEZpcnN0U2NhbGVJZChjaGFydCwgYXhpcykge1xuICBjb25zdCBzY2FsZXMgPSBjaGFydC5zY2FsZXM7XG4gIHJldHVybiBPYmplY3Qua2V5cyhzY2FsZXMpLmZpbHRlcihrZXkgPT4gc2NhbGVzW2tleV0uYXhpcyA9PT0gYXhpcykuc2hpZnQoKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGF0YXNldENvbnRleHQocGFyZW50LCBpbmRleCkge1xuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsXG4gICAge1xuICAgICAgYWN0aXZlOiBmYWxzZSxcbiAgICAgIGRhdGFzZXQ6IHVuZGVmaW5lZCxcbiAgICAgIGRhdGFzZXRJbmRleDogaW5kZXgsXG4gICAgICBpbmRleCxcbiAgICAgIG1vZGU6ICdkZWZhdWx0JyxcbiAgICAgIHR5cGU6ICdkYXRhc2V0J1xuICAgIH1cbiAgKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGF0YUNvbnRleHQocGFyZW50LCBpbmRleCwgZWxlbWVudCkge1xuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsIHtcbiAgICBhY3RpdmU6IGZhbHNlLFxuICAgIGRhdGFJbmRleDogaW5kZXgsXG4gICAgcGFyc2VkOiB1bmRlZmluZWQsXG4gICAgcmF3OiB1bmRlZmluZWQsXG4gICAgZWxlbWVudCxcbiAgICBpbmRleCxcbiAgICBtb2RlOiAnZGVmYXVsdCcsXG4gICAgdHlwZTogJ2RhdGEnXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjbGVhclN0YWNrcyhtZXRhLCBpdGVtcykge1xuICAvLyBOb3QgdXNpbmcgbWV0YS5pbmRleCBoZXJlLCBiZWNhdXNlIGl0IG1pZ2h0IGJlIGFscmVhZHkgdXBkYXRlZCBpZiB0aGUgZGF0YXNldCBjaGFuZ2VkIGxvY2F0aW9uXG4gIGNvbnN0IGRhdGFzZXRJbmRleCA9IG1ldGEuY29udHJvbGxlci5pbmRleDtcbiAgY29uc3QgYXhpcyA9IG1ldGEudlNjYWxlICYmIG1ldGEudlNjYWxlLmF4aXM7XG4gIGlmICghYXhpcykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGl0ZW1zID0gaXRlbXMgfHwgbWV0YS5fcGFyc2VkO1xuICBmb3IgKGNvbnN0IHBhcnNlZCBvZiBpdGVtcykge1xuICAgIGNvbnN0IHN0YWNrcyA9IHBhcnNlZC5fc3RhY2tzO1xuICAgIGlmICghc3RhY2tzIHx8IHN0YWNrc1theGlzXSA9PT0gdW5kZWZpbmVkIHx8IHN0YWNrc1theGlzXVtkYXRhc2V0SW5kZXhdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVsZXRlIHN0YWNrc1theGlzXVtkYXRhc2V0SW5kZXhdO1xuICAgIGlmIChzdGFja3NbYXhpc10uX3Zpc3VhbFZhbHVlcyAhPT0gdW5kZWZpbmVkICYmIHN0YWNrc1theGlzXS5fdmlzdWFsVmFsdWVzW2RhdGFzZXRJbmRleF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgZGVsZXRlIHN0YWNrc1theGlzXS5fdmlzdWFsVmFsdWVzW2RhdGFzZXRJbmRleF07XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IGlzRGlyZWN0VXBkYXRlTW9kZSA9IChtb2RlKSA9PiBtb2RlID09PSAncmVzZXQnIHx8IG1vZGUgPT09ICdub25lJztcbmNvbnN0IGNsb25lSWZOb3RTaGFyZWQgPSAoY2FjaGVkLCBzaGFyZWQpID0+IHNoYXJlZCA/IGNhY2hlZCA6IE9iamVjdC5hc3NpZ24oe30sIGNhY2hlZCk7XG5jb25zdCBjcmVhdGVTdGFjayA9IChjYW5TdGFjaywgbWV0YSwgY2hhcnQpID0+IGNhblN0YWNrICYmICFtZXRhLmhpZGRlbiAmJiBtZXRhLl9zdGFja2VkXG4gICYmIHtrZXlzOiBnZXRTb3J0ZWREYXRhc2V0SW5kaWNlcyhjaGFydCwgdHJ1ZSksIHZhbHVlczogbnVsbH07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERhdGFzZXRDb250cm9sbGVyIHtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHt9O1xuXG4gIC8qKlxuICAgKiBFbGVtZW50IHR5cGUgdXNlZCB0byBnZW5lcmF0ZSBhIG1ldGEgZGF0YXNldCAoZS5nLiBDaGFydC5lbGVtZW50LkxpbmVFbGVtZW50KS5cbiAgICovXG4gIHN0YXRpYyBkYXRhc2V0RWxlbWVudFR5cGUgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBFbGVtZW50IHR5cGUgdXNlZCB0byBnZW5lcmF0ZSBhIG1ldGEgZGF0YSAoZS5nLiBDaGFydC5lbGVtZW50LlBvaW50RWxlbWVudCkuXG4gICAqL1xuICBzdGF0aWMgZGF0YUVsZW1lbnRUeXBlID0gbnVsbDtcblxuICAvKipcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICogQHBhcmFtIHtudW1iZXJ9IGRhdGFzZXRJbmRleFxuXHQgKi9cbiAgY29uc3RydWN0b3IoY2hhcnQsIGRhdGFzZXRJbmRleCkge1xuICAgIHRoaXMuY2hhcnQgPSBjaGFydDtcbiAgICB0aGlzLl9jdHggPSBjaGFydC5jdHg7XG4gICAgdGhpcy5pbmRleCA9IGRhdGFzZXRJbmRleDtcbiAgICB0aGlzLl9jYWNoZWREYXRhT3B0cyA9IHt9O1xuICAgIHRoaXMuX2NhY2hlZE1ldGEgPSB0aGlzLmdldE1ldGEoKTtcbiAgICB0aGlzLl90eXBlID0gdGhpcy5fY2FjaGVkTWV0YS50eXBlO1xuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge2Jvb2xlYW4gfCBvYmplY3R9ICovXG4gICAgdGhpcy5fcGFyc2luZyA9IGZhbHNlO1xuICAgIHRoaXMuX2RhdGEgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fb2JqZWN0RGF0YSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zaGFyZWRPcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2RyYXdTdGFydCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9kcmF3Q291bnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gZmFsc2U7XG4gICAgdGhpcy5zdXBwb3J0c0RlY2ltYXRpb24gPSBmYWxzZTtcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3N5bmNMaXN0ID0gW107XG4gICAgdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUgPSBuZXcudGFyZ2V0LmRhdGFzZXRFbGVtZW50VHlwZTtcbiAgICB0aGlzLmRhdGFFbGVtZW50VHlwZSA9IG5ldy50YXJnZXQuZGF0YUVsZW1lbnRUeXBlO1xuXG4gICAgdGhpcy5pbml0aWFsaXplKCk7XG4gIH1cblxuICBpbml0aWFsaXplKCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIHRoaXMuY29uZmlndXJlKCk7XG4gICAgdGhpcy5saW5rU2NhbGVzKCk7XG4gICAgbWV0YS5fc3RhY2tlZCA9IGlzU3RhY2tlZChtZXRhLnZTY2FsZSwgbWV0YSk7XG4gICAgdGhpcy5hZGRFbGVtZW50cygpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5maWxsICYmICF0aGlzLmNoYXJ0LmlzUGx1Z2luRW5hYmxlZCgnZmlsbGVyJykpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlRyaWVkIHRvIHVzZSB0aGUgJ2ZpbGwnIG9wdGlvbiB3aXRob3V0IHRoZSAnRmlsbGVyJyBwbHVnaW4gZW5hYmxlZC4gUGxlYXNlIGltcG9ydCBhbmQgcmVnaXN0ZXIgdGhlICdGaWxsZXInIHBsdWdpbiBhbmQgbWFrZSBzdXJlIGl0IGlzIG5vdCBkaXNhYmxlZCBpbiB0aGUgb3B0aW9uc1wiKTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVJbmRleChkYXRhc2V0SW5kZXgpIHtcbiAgICBpZiAodGhpcy5pbmRleCAhPT0gZGF0YXNldEluZGV4KSB7XG4gICAgICBjbGVhclN0YWNrcyh0aGlzLl9jYWNoZWRNZXRhKTtcbiAgICB9XG4gICAgdGhpcy5pbmRleCA9IGRhdGFzZXRJbmRleDtcbiAgfVxuXG4gIGxpbmtTY2FsZXMoKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcblxuICAgIGNvbnN0IGNob29zZUlkID0gKGF4aXMsIHgsIHksIHIpID0+IGF4aXMgPT09ICd4JyA/IHggOiBheGlzID09PSAncicgPyByIDogeTtcblxuICAgIGNvbnN0IHhpZCA9IG1ldGEueEF4aXNJRCA9IHZhbHVlT3JEZWZhdWx0KGRhdGFzZXQueEF4aXNJRCwgZ2V0Rmlyc3RTY2FsZUlkKGNoYXJ0LCAneCcpKTtcbiAgICBjb25zdCB5aWQgPSBtZXRhLnlBeGlzSUQgPSB2YWx1ZU9yRGVmYXVsdChkYXRhc2V0LnlBeGlzSUQsIGdldEZpcnN0U2NhbGVJZChjaGFydCwgJ3knKSk7XG4gICAgY29uc3QgcmlkID0gbWV0YS5yQXhpc0lEID0gdmFsdWVPckRlZmF1bHQoZGF0YXNldC5yQXhpc0lELCBnZXRGaXJzdFNjYWxlSWQoY2hhcnQsICdyJykpO1xuICAgIGNvbnN0IGluZGV4QXhpcyA9IG1ldGEuaW5kZXhBeGlzO1xuICAgIGNvbnN0IGlpZCA9IG1ldGEuaUF4aXNJRCA9IGNob29zZUlkKGluZGV4QXhpcywgeGlkLCB5aWQsIHJpZCk7XG4gICAgY29uc3QgdmlkID0gbWV0YS52QXhpc0lEID0gY2hvb3NlSWQoaW5kZXhBeGlzLCB5aWQsIHhpZCwgcmlkKTtcbiAgICBtZXRhLnhTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZCh4aWQpO1xuICAgIG1ldGEueVNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKHlpZCk7XG4gICAgbWV0YS5yU2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQocmlkKTtcbiAgICBtZXRhLmlTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZChpaWQpO1xuICAgIG1ldGEudlNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKHZpZCk7XG4gIH1cblxuICBnZXREYXRhc2V0KCkge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbdGhpcy5pbmRleF07XG4gIH1cblxuICBnZXRNZXRhKCkge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0LmdldERhdGFzZXRNZXRhKHRoaXMuaW5kZXgpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzY2FsZUlEXG5cdCAqIEByZXR1cm4ge1NjYWxlfVxuXHQgKi9cbiAgZ2V0U2NhbGVGb3JJZChzY2FsZUlEKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQuc2NhbGVzW3NjYWxlSURdO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0T3RoZXJTY2FsZShzY2FsZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIHJldHVybiBzY2FsZSA9PT0gbWV0YS5pU2NhbGVcbiAgICAgID8gbWV0YS52U2NhbGVcbiAgICAgIDogbWV0YS5pU2NhbGU7XG4gIH1cblxuICByZXNldCgpIHtcbiAgICB0aGlzLl91cGRhdGUoJ3Jlc2V0Jyk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9kZXN0cm95KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGlmICh0aGlzLl9kYXRhKSB7XG4gICAgICB1bmxpc3RlbkFycmF5RXZlbnRzKHRoaXMuX2RhdGEsIHRoaXMpO1xuICAgIH1cbiAgICBpZiAobWV0YS5fc3RhY2tlZCkge1xuICAgICAgY2xlYXJTdGFja3MobWV0YSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZGF0YUNoZWNrKCkge1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcbiAgICBjb25zdCBkYXRhID0gZGF0YXNldC5kYXRhIHx8IChkYXRhc2V0LmRhdGEgPSBbXSk7XG4gICAgY29uc3QgX2RhdGEgPSB0aGlzLl9kYXRhO1xuXG4gICAgLy8gSW4gb3JkZXIgdG8gY29ycmVjdGx5IGhhbmRsZSBkYXRhIGFkZGl0aW9uL2RlbGV0aW9uIGFuaW1hdGlvbiAoYW5kIHRodXMgc2ltdWxhdGVcbiAgICAvLyByZWFsLXRpbWUgY2hhcnRzKSwgd2UgbmVlZCB0byBtb25pdG9yIHRoZXNlIGRhdGEgbW9kaWZpY2F0aW9ucyBhbmQgc3luY2hyb25pemVcbiAgICAvLyB0aGUgaW50ZXJuYWwgbWV0YWRhdGEgYWNjb3JkaW5nbHkuXG5cbiAgICBpZiAoaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgICAgdGhpcy5fZGF0YSA9IGNvbnZlcnRPYmplY3REYXRhVG9BcnJheShkYXRhLCBtZXRhKTtcbiAgICB9IGVsc2UgaWYgKF9kYXRhICE9PSBkYXRhKSB7XG4gICAgICBpZiAoX2RhdGEpIHtcbiAgICAgICAgLy8gVGhpcyBjYXNlIGhhcHBlbnMgd2hlbiB0aGUgdXNlciByZXBsYWNlZCB0aGUgZGF0YSBhcnJheSBpbnN0YW5jZS5cbiAgICAgICAgdW5saXN0ZW5BcnJheUV2ZW50cyhfZGF0YSwgdGhpcyk7XG4gICAgICAgIC8vIERpc2NhcmQgb2xkIHBhcnNlZCBkYXRhIGFuZCBzdGFja3NcbiAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICAgIGNsZWFyU3RhY2tzKG1ldGEpO1xuICAgICAgICBtZXRhLl9wYXJzZWQgPSBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhICYmIE9iamVjdC5pc0V4dGVuc2libGUoZGF0YSkpIHtcbiAgICAgICAgbGlzdGVuQXJyYXlFdmVudHMoZGF0YSwgdGhpcyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zeW5jTGlzdCA9IFtdO1xuICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgfVxuICB9XG5cbiAgYWRkRWxlbWVudHMoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG5cbiAgICB0aGlzLl9kYXRhQ2hlY2soKTtcblxuICAgIGlmICh0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSkge1xuICAgICAgbWV0YS5kYXRhc2V0ID0gbmV3IHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlKCk7XG4gICAgfVxuICB9XG5cbiAgYnVpbGRPclVwZGF0ZUVsZW1lbnRzKHJlc2V0TmV3RWxlbWVudHMpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG4gICAgbGV0IHN0YWNrQ2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5fZGF0YUNoZWNrKCk7XG5cbiAgICAvLyBtYWtlIHN1cmUgY2FjaGVkIF9zdGFja2VkIHN0YXR1cyBpcyBjdXJyZW50XG4gICAgY29uc3Qgb2xkU3RhY2tlZCA9IG1ldGEuX3N0YWNrZWQ7XG4gICAgbWV0YS5fc3RhY2tlZCA9IGlzU3RhY2tlZChtZXRhLnZTY2FsZSwgbWV0YSk7XG5cbiAgICAvLyBkZXRlY3QgY2hhbmdlIGluIHN0YWNrIG9wdGlvblxuICAgIGlmIChtZXRhLnN0YWNrICE9PSBkYXRhc2V0LnN0YWNrKSB7XG4gICAgICBzdGFja0NoYW5nZWQgPSB0cnVlO1xuICAgICAgLy8gcmVtb3ZlIHZhbHVlcyBmcm9tIG9sZCBzdGFja1xuICAgICAgY2xlYXJTdGFja3MobWV0YSk7XG4gICAgICBtZXRhLnN0YWNrID0gZGF0YXNldC5zdGFjaztcbiAgICB9XG5cbiAgICAvLyBSZS1zeW5jIG1ldGEgZGF0YSBpbiBjYXNlIHRoZSB1c2VyIHJlcGxhY2VkIHRoZSBkYXRhIGFycmF5IG9yIGlmIHdlIG1pc3NlZFxuICAgIC8vIGFueSB1cGRhdGVzIGFuZCBzbyBtYWtlIHN1cmUgdGhhdCB3ZSBoYW5kbGUgbnVtYmVyIG9mIGRhdGFwb2ludHMgY2hhbmdpbmcuXG4gICAgdGhpcy5fcmVzeW5jRWxlbWVudHMocmVzZXROZXdFbGVtZW50cyk7XG5cbiAgICAvLyBpZiBzdGFjayBjaGFuZ2VkLCB1cGRhdGUgc3RhY2sgdmFsdWVzIGZvciB0aGUgd2hvbGUgZGF0YXNldFxuICAgIGlmIChzdGFja0NoYW5nZWQgfHwgb2xkU3RhY2tlZCAhPT0gbWV0YS5fc3RhY2tlZCkge1xuICAgICAgdXBkYXRlU3RhY2tzKHRoaXMsIG1ldGEuX3BhcnNlZCk7XG4gICAgICBtZXRhLl9zdGFja2VkID0gaXNTdGFja2VkKG1ldGEudlNjYWxlLCBtZXRhKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogTWVyZ2VzIHVzZXItc3VwcGxpZWQgYW5kIGRlZmF1bHQgZGF0YXNldC1sZXZlbCBvcHRpb25zXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBjb25maWd1cmUoKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jaGFydC5jb25maWc7XG4gICAgY29uc3Qgc2NvcGVLZXlzID0gY29uZmlnLmRhdGFzZXRTY29wZUtleXModGhpcy5fdHlwZSk7XG4gICAgY29uc3Qgc2NvcGVzID0gY29uZmlnLmdldE9wdGlvblNjb3Blcyh0aGlzLmdldERhdGFzZXQoKSwgc2NvcGVLZXlzLCB0cnVlKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBjb25maWcuY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCB0aGlzLmdldENvbnRleHQoKSk7XG4gICAgdGhpcy5fcGFyc2luZyA9IHRoaXMub3B0aW9ucy5wYXJzaW5nO1xuICAgIHRoaXMuX2NhY2hlZERhdGFPcHRzID0ge307XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudFxuXHQgKi9cbiAgcGFyc2Uoc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge19jYWNoZWRNZXRhOiBtZXRhLCBfZGF0YTogZGF0YX0gPSB0aGlzO1xuICAgIGNvbnN0IHtpU2NhbGUsIF9zdGFja2VkfSA9IG1ldGE7XG4gICAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcblxuICAgIGxldCBzb3J0ZWQgPSBzdGFydCA9PT0gMCAmJiBjb3VudCA9PT0gZGF0YS5sZW5ndGggPyB0cnVlIDogbWV0YS5fc29ydGVkO1xuICAgIGxldCBwcmV2ID0gc3RhcnQgPiAwICYmIG1ldGEuX3BhcnNlZFtzdGFydCAtIDFdO1xuICAgIGxldCBpLCBjdXIsIHBhcnNlZDtcblxuICAgIGlmICh0aGlzLl9wYXJzaW5nID09PSBmYWxzZSkge1xuICAgICAgbWV0YS5fcGFyc2VkID0gZGF0YTtcbiAgICAgIG1ldGEuX3NvcnRlZCA9IHRydWU7XG4gICAgICBwYXJzZWQgPSBkYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNBcnJheShkYXRhW3N0YXJ0XSkpIHtcbiAgICAgICAgcGFyc2VkID0gdGhpcy5wYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChkYXRhW3N0YXJ0XSkpIHtcbiAgICAgICAgcGFyc2VkID0gdGhpcy5wYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZCA9IHRoaXMucGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlzTm90SW5PcmRlckNvbXBhcmVkVG9QcmV2ID0gKCkgPT4gY3VyW2lBeGlzXSA9PT0gbnVsbCB8fCAocHJldiAmJiBjdXJbaUF4aXNdIDwgcHJldltpQXhpc10pO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgICAgbWV0YS5fcGFyc2VkW2kgKyBzdGFydF0gPSBjdXIgPSBwYXJzZWRbaV07XG4gICAgICAgIGlmIChzb3J0ZWQpIHtcbiAgICAgICAgICBpZiAoaXNOb3RJbk9yZGVyQ29tcGFyZWRUb1ByZXYoKSkge1xuICAgICAgICAgICAgc29ydGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHByZXYgPSBjdXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1ldGEuX3NvcnRlZCA9IHNvcnRlZDtcbiAgICB9XG5cbiAgICBpZiAoX3N0YWNrZWQpIHtcbiAgICAgIHVwZGF0ZVN0YWNrcyh0aGlzLCBwYXJzZWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBQYXJzZSBhcnJheSBvZiBwcmltaXRpdmUgdmFsdWVzXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBtZXRhIC0gZGF0YXNldCBtZXRhXG5cdCAqIEBwYXJhbSB7YXJyYXl9IGRhdGEgLSBkYXRhIGFycmF5LiBFeGFtcGxlIFsxLDMsNF1cblx0ICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gc3RhcnQgaW5kZXhcblx0ICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IC0gbnVtYmVyIG9mIGl0ZW1zIHRvIHBhcnNlXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IHBhcnNlZCBpdGVtIC0gaXRlbSBjb250YWluaW5nIGluZGV4IGFuZCBhIHBhcnNlZCB2YWx1ZVxuXHQgKiBmb3IgZWFjaCBzY2FsZSBpZC5cblx0ICogRXhhbXBsZToge3hTY2FsZTA6IDAsIHlTY2FsZTA6IDF9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gICAgY29uc3QgbGFiZWxzID0gaVNjYWxlLmdldExhYmVscygpO1xuICAgIGNvbnN0IHNpbmdsZVNjYWxlID0gaVNjYWxlID09PSB2U2NhbGU7XG4gICAgY29uc3QgcGFyc2VkID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBsZXQgaSwgaWxlbiwgaW5kZXg7XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGluZGV4ID0gaSArIHN0YXJ0O1xuICAgICAgcGFyc2VkW2ldID0ge1xuICAgICAgICBbaUF4aXNdOiBzaW5nbGVTY2FsZSB8fCBpU2NhbGUucGFyc2UobGFiZWxzW2luZGV4XSwgaW5kZXgpLFxuICAgICAgICBbdkF4aXNdOiB2U2NhbGUucGFyc2UoZGF0YVtpbmRleF0sIGluZGV4KVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBQYXJzZSBhcnJheSBvZiBhcnJheXNcblx0ICogQHBhcmFtIHtvYmplY3R9IG1ldGEgLSBkYXRhc2V0IG1ldGFcblx0ICogQHBhcmFtIHthcnJheX0gZGF0YSAtIGRhdGEgYXJyYXkuIEV4YW1wbGUgW1sxLDJdLFszLDRdXVxuXHQgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBzdGFydCBpbmRleFxuXHQgKiBAcGFyYW0ge251bWJlcn0gY291bnQgLSBudW1iZXIgb2YgaXRlbXMgdG8gcGFyc2Vcblx0ICogQHJldHVybnMge29iamVjdH0gcGFyc2VkIGl0ZW0gLSBpdGVtIGNvbnRhaW5pbmcgaW5kZXggYW5kIGEgcGFyc2VkIHZhbHVlXG5cdCAqIGZvciBlYWNoIHNjYWxlIGlkLlxuXHQgKiBFeGFtcGxlOiB7eDogMCwgeTogMX1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcGFyc2VBcnJheURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge3hTY2FsZSwgeVNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3QgcGFyc2VkID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBsZXQgaSwgaWxlbiwgaW5kZXgsIGl0ZW07XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGluZGV4ID0gaSArIHN0YXJ0O1xuICAgICAgaXRlbSA9IGRhdGFbaW5kZXhdO1xuICAgICAgcGFyc2VkW2ldID0ge1xuICAgICAgICB4OiB4U2NhbGUucGFyc2UoaXRlbVswXSwgaW5kZXgpLFxuICAgICAgICB5OiB5U2NhbGUucGFyc2UoaXRlbVsxXSwgaW5kZXgpXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgLyoqXG5cdCAqIFBhcnNlIGFycmF5IG9mIG9iamVjdHNcblx0ICogQHBhcmFtIHtvYmplY3R9IG1ldGEgLSBkYXRhc2V0IG1ldGFcblx0ICogQHBhcmFtIHthcnJheX0gZGF0YSAtIGRhdGEgYXJyYXkuIEV4YW1wbGUgW3t4OjEsIHk6NX0sIHt4OjIsIHk6MTB9XVxuXHQgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBzdGFydCBpbmRleFxuXHQgKiBAcGFyYW0ge251bWJlcn0gY291bnQgLSBudW1iZXIgb2YgaXRlbXMgdG8gcGFyc2Vcblx0ICogQHJldHVybnMge29iamVjdH0gcGFyc2VkIGl0ZW0gLSBpdGVtIGNvbnRhaW5pbmcgaW5kZXggYW5kIGEgcGFyc2VkIHZhbHVlXG5cdCAqIGZvciBlYWNoIHNjYWxlIGlkLiBfY3VzdG9tIGlzIG9wdGlvbmFsXG5cdCAqIEV4YW1wbGU6IHt4U2NhbGUwOiAwLCB5U2NhbGUwOiAxLCBfY3VzdG9tOiB7cjogMTAsIGZvbzogJ2Jhcid9fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBwYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge3hTY2FsZSwgeVNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3Qge3hBeGlzS2V5ID0gJ3gnLCB5QXhpc0tleSA9ICd5J30gPSB0aGlzLl9wYXJzaW5nO1xuICAgIGNvbnN0IHBhcnNlZCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgbGV0IGksIGlsZW4sIGluZGV4LCBpdGVtO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpbmRleCA9IGkgKyBzdGFydDtcbiAgICAgIGl0ZW0gPSBkYXRhW2luZGV4XTtcbiAgICAgIHBhcnNlZFtpXSA9IHtcbiAgICAgICAgeDogeFNjYWxlLnBhcnNlKHJlc29sdmVPYmplY3RLZXkoaXRlbSwgeEF4aXNLZXkpLCBpbmRleCksXG4gICAgICAgIHk6IHlTY2FsZS5wYXJzZShyZXNvbHZlT2JqZWN0S2V5KGl0ZW0sIHlBeGlzS2V5KSwgaW5kZXgpXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldFBhcnNlZChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9jYWNoZWRNZXRhLl9wYXJzZWRbaW5kZXhdO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldERhdGFFbGVtZW50KGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZE1ldGEuZGF0YVtpbmRleF07XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgYXBwbHlTdGFjayhzY2FsZSwgcGFyc2VkLCBtb2RlKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHZhbHVlID0gcGFyc2VkW3NjYWxlLmF4aXNdO1xuICAgIGNvbnN0IHN0YWNrID0ge1xuICAgICAga2V5czogZ2V0U29ydGVkRGF0YXNldEluZGljZXMoY2hhcnQsIHRydWUpLFxuICAgICAgdmFsdWVzOiBwYXJzZWQuX3N0YWNrc1tzY2FsZS5heGlzXS5fdmlzdWFsVmFsdWVzXG4gICAgfTtcbiAgICByZXR1cm4gYXBwbHlTdGFjayhzdGFjaywgdmFsdWUsIG1ldGEuaW5kZXgsIHttb2RlfSk7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgdXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHJhbmdlLCBzY2FsZSwgcGFyc2VkLCBzdGFjaykge1xuICAgIGNvbnN0IHBhcnNlZFZhbHVlID0gcGFyc2VkW3NjYWxlLmF4aXNdO1xuICAgIGxldCB2YWx1ZSA9IHBhcnNlZFZhbHVlID09PSBudWxsID8gTmFOIDogcGFyc2VkVmFsdWU7XG4gICAgY29uc3QgdmFsdWVzID0gc3RhY2sgJiYgcGFyc2VkLl9zdGFja3Nbc2NhbGUuYXhpc107XG4gICAgaWYgKHN0YWNrICYmIHZhbHVlcykge1xuICAgICAgc3RhY2sudmFsdWVzID0gdmFsdWVzO1xuICAgICAgdmFsdWUgPSBhcHBseVN0YWNrKHN0YWNrLCBwYXJzZWRWYWx1ZSwgdGhpcy5fY2FjaGVkTWV0YS5pbmRleCk7XG4gICAgfVxuICAgIHJhbmdlLm1pbiA9IE1hdGgubWluKHJhbmdlLm1pbiwgdmFsdWUpO1xuICAgIHJhbmdlLm1heCA9IE1hdGgubWF4KHJhbmdlLm1heCwgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldE1pbk1heChzY2FsZSwgY2FuU3RhY2spIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBfcGFyc2VkID0gbWV0YS5fcGFyc2VkO1xuICAgIGNvbnN0IHNvcnRlZCA9IG1ldGEuX3NvcnRlZCAmJiBzY2FsZSA9PT0gbWV0YS5pU2NhbGU7XG4gICAgY29uc3QgaWxlbiA9IF9wYXJzZWQubGVuZ3RoO1xuICAgIGNvbnN0IG90aGVyU2NhbGUgPSB0aGlzLl9nZXRPdGhlclNjYWxlKHNjYWxlKTtcbiAgICBjb25zdCBzdGFjayA9IGNyZWF0ZVN0YWNrKGNhblN0YWNrLCBtZXRhLCB0aGlzLmNoYXJ0KTtcbiAgICBjb25zdCByYW5nZSA9IHttaW46IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgbWF4OiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFl9O1xuICAgIGNvbnN0IHttaW46IG90aGVyTWluLCBtYXg6IG90aGVyTWF4fSA9IGdldFVzZXJCb3VuZHMob3RoZXJTY2FsZSk7XG4gICAgbGV0IGksIHBhcnNlZDtcblxuICAgIGZ1bmN0aW9uIF9za2lwKCkge1xuICAgICAgcGFyc2VkID0gX3BhcnNlZFtpXTtcbiAgICAgIGNvbnN0IG90aGVyVmFsdWUgPSBwYXJzZWRbb3RoZXJTY2FsZS5heGlzXTtcbiAgICAgIHJldHVybiAhaXNGaW5pdGUocGFyc2VkW3NjYWxlLmF4aXNdKSB8fCBvdGhlck1pbiA+IG90aGVyVmFsdWUgfHwgb3RoZXJNYXggPCBvdGhlclZhbHVlO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGlmIChfc2tpcCgpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKTtcbiAgICAgIGlmIChzb3J0ZWQpIHtcbiAgICAgICAgLy8gaWYgdGhlIGRhdGEgaXMgc29ydGVkLCB3ZSBkb24ndCBuZWVkIHRvIGNoZWNrIGZ1cnRoZXIgZnJvbSB0aGlzIGVuZCBvZiBhcnJheVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNvcnRlZCkge1xuICAgICAgLy8gaW4gdGhlIHNvcnRlZCBjYXNlLCBmaW5kIGZpcnN0IG5vbi1za2lwcGVkIHZhbHVlIGZyb20gb3RoZXIgZW5kIG9mIGFycmF5XG4gICAgICBmb3IgKGkgPSBpbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgaWYgKF9za2lwKCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlO1xuICB9XG5cbiAgZ2V0QWxsUGFyc2VkVmFsdWVzKHNjYWxlKSB7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5fY2FjaGVkTWV0YS5fcGFyc2VkO1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgIGxldCBpLCBpbGVuLCB2YWx1ZTtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBwYXJzZWQubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB2YWx1ZSA9IHBhcnNlZFtpXVtzY2FsZS5heGlzXTtcbiAgICAgIGlmIChpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEByZXR1cm4ge251bWJlcnxib29sZWFufVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGlTY2FsZSA9IG1ldGEuaVNjYWxlO1xuICAgIGNvbnN0IHZTY2FsZSA9IG1ldGEudlNjYWxlO1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IGlTY2FsZSA/ICcnICsgaVNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW2lTY2FsZS5heGlzXSkgOiAnJyxcbiAgICAgIHZhbHVlOiB2U2NhbGUgPyAnJyArIHZTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFt2U2NhbGUuYXhpc10pIDogJydcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICB0aGlzLnVwZGF0ZShtb2RlIHx8ICdkZWZhdWx0Jyk7XG4gICAgbWV0YS5fY2xpcCA9IHRvQ2xpcCh2YWx1ZU9yRGVmYXVsdCh0aGlzLm9wdGlvbnMuY2xpcCwgZGVmYXVsdENsaXAobWV0YS54U2NhbGUsIG1ldGEueVNjYWxlLCB0aGlzLmdldE1heE92ZXJmbG93KCkpKSk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IG1vZGVcblx0ICovXG4gIHVwZGF0ZShtb2RlKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgZHJhdygpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLl9jdHg7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGVsZW1lbnRzID0gbWV0YS5kYXRhIHx8IFtdO1xuICAgIGNvbnN0IGFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG4gICAgY29uc3QgYWN0aXZlID0gW107XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9kcmF3U3RhcnQgfHwgMDtcbiAgICBjb25zdCBjb3VudCA9IHRoaXMuX2RyYXdDb3VudCB8fCAoZWxlbWVudHMubGVuZ3RoIC0gc3RhcnQpO1xuICAgIGNvbnN0IGRyYXdBY3RpdmVFbGVtZW50c09uVG9wID0gdGhpcy5vcHRpb25zLmRyYXdBY3RpdmVFbGVtZW50c09uVG9wO1xuICAgIGxldCBpO1xuXG4gICAgaWYgKG1ldGEuZGF0YXNldCkge1xuICAgICAgbWV0YS5kYXRhc2V0LmRyYXcoY3R4LCBhcmVhLCBzdGFydCwgY291bnQpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgKytpKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICBpZiAoZWxlbWVudC5oaWRkZW4pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoZWxlbWVudC5hY3RpdmUgJiYgZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3ApIHtcbiAgICAgICAgYWN0aXZlLnB1c2goZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LmRyYXcoY3R4LCBhcmVhKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgYWN0aXZlLmxlbmd0aDsgKytpKSB7XG4gICAgICBhY3RpdmVbaV0uZHJhdyhjdHgsIGFyZWEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIGEgc2V0IG9mIHByZWRlZmluZWQgc3R5bGUgcHJvcGVydGllcyB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHJlcHJlc2VudCB0aGUgZGF0YXNldFxuXHQgKiBvciB0aGUgZGF0YSBpZiB0aGUgaW5kZXggaXMgc3BlY2lmaWVkXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIGRhdGEgaW5kZXhcblx0ICogQHBhcmFtIHtib29sZWFufSBbYWN0aXZlXSAtIHRydWUgaWYgaG92ZXJcblx0ICogQHJldHVybiB7b2JqZWN0fSBzdHlsZSBvYmplY3Rcblx0ICovXG4gIGdldFN0eWxlKGluZGV4LCBhY3RpdmUpIHtcbiAgICBjb25zdCBtb2RlID0gYWN0aXZlID8gJ2FjdGl2ZScgOiAnZGVmYXVsdCc7XG4gICAgcmV0dXJuIGluZGV4ID09PSB1bmRlZmluZWQgJiYgdGhpcy5fY2FjaGVkTWV0YS5kYXRhc2V0XG4gICAgICA/IHRoaXMucmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKVxuICAgICAgOiB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXggfHwgMCwgbW9kZSk7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0Q29udGV4dChpbmRleCwgYWN0aXZlLCBtb2RlKSB7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuICAgIGxldCBjb250ZXh0O1xuICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5fY2FjaGVkTWV0YS5kYXRhLmxlbmd0aCkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YVtpbmRleF07XG4gICAgICBjb250ZXh0ID0gZWxlbWVudC4kY29udGV4dCB8fFxuICAgICAgICAoZWxlbWVudC4kY29udGV4dCA9IGNyZWF0ZURhdGFDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpLCBpbmRleCwgZWxlbWVudCkpO1xuICAgICAgY29udGV4dC5wYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgICBjb250ZXh0LnJhdyA9IGRhdGFzZXQuZGF0YVtpbmRleF07XG4gICAgICBjb250ZXh0LmluZGV4ID0gY29udGV4dC5kYXRhSW5kZXggPSBpbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dCA9IHRoaXMuJGNvbnRleHQgfHxcbiAgICAgICAgKHRoaXMuJGNvbnRleHQgPSBjcmVhdGVEYXRhc2V0Q29udGV4dCh0aGlzLmNoYXJ0LmdldENvbnRleHQoKSwgdGhpcy5pbmRleCkpO1xuICAgICAgY29udGV4dC5kYXRhc2V0ID0gZGF0YXNldDtcbiAgICAgIGNvbnRleHQuaW5kZXggPSBjb250ZXh0LmRhdGFzZXRJbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgfVxuXG4gICAgY29udGV4dC5hY3RpdmUgPSAhIWFjdGl2ZTtcbiAgICBjb250ZXh0Lm1vZGUgPSBtb2RlO1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbbW9kZV1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVFbGVtZW50T3B0aW9ucyh0aGlzLmRhdGFzZXRFbGVtZW50VHlwZS5pZCwgbW9kZSk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbbW9kZV1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCwgbW9kZSkge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlRWxlbWVudE9wdGlvbnModGhpcy5kYXRhRWxlbWVudFR5cGUuaWQsIG1vZGUsIGluZGV4KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3Jlc29sdmVFbGVtZW50T3B0aW9ucyhlbGVtZW50VHlwZSwgbW9kZSA9ICdkZWZhdWx0JywgaW5kZXgpIHtcbiAgICBjb25zdCBhY3RpdmUgPSBtb2RlID09PSAnYWN0aXZlJztcbiAgICBjb25zdCBjYWNoZSA9IHRoaXMuX2NhY2hlZERhdGFPcHRzO1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gZWxlbWVudFR5cGUgKyAnLScgKyBtb2RlO1xuICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICBjb25zdCBzaGFyaW5nID0gdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nICYmIGRlZmluZWQoaW5kZXgpO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjbG9uZUlmTm90U2hhcmVkKGNhY2hlZCwgc2hhcmluZyk7XG4gICAgfVxuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY2hhcnQuY29uZmlnO1xuICAgIGNvbnN0IHNjb3BlS2V5cyA9IGNvbmZpZy5kYXRhc2V0RWxlbWVudFNjb3BlS2V5cyh0aGlzLl90eXBlLCBlbGVtZW50VHlwZSk7XG4gICAgY29uc3QgcHJlZml4ZXMgPSBhY3RpdmUgPyBbYCR7ZWxlbWVudFR5cGV9SG92ZXJgLCAnaG92ZXInLCBlbGVtZW50VHlwZSwgJyddIDogW2VsZW1lbnRUeXBlLCAnJ107XG4gICAgY29uc3Qgc2NvcGVzID0gY29uZmlnLmdldE9wdGlvblNjb3Blcyh0aGlzLmdldERhdGFzZXQoKSwgc2NvcGVLZXlzKTtcbiAgICBjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKGRlZmF1bHRzLmVsZW1lbnRzW2VsZW1lbnRUeXBlXSk7XG4gICAgLy8gY29udGV4dCBpcyBwcm92aWRlZCBhcyBhIGZ1bmN0aW9uLCBhbmQgaXMgY2FsbGVkIG9ubHkgaWYgbmVlZGVkLFxuICAgIC8vIHNvIHdlIGRvbid0IGNyZWF0ZSBhIGNvbnRleHQgZm9yIGVhY2ggZWxlbWVudCBpZiBub3QgbmVlZGVkLlxuICAgIGNvbnN0IGNvbnRleHQgPSAoKSA9PiB0aGlzLmdldENvbnRleHQoaW5kZXgsIGFjdGl2ZSwgbW9kZSk7XG4gICAgY29uc3QgdmFsdWVzID0gY29uZmlnLnJlc29sdmVOYW1lZE9wdGlvbnMoc2NvcGVzLCBuYW1lcywgY29udGV4dCwgcHJlZml4ZXMpO1xuXG4gICAgaWYgKHZhbHVlcy4kc2hhcmVkKSB7XG4gICAgICAvLyBgJHNoYXJlZGAgaW5kaWNhdGVzIHRoaXMgc2V0IG9mIG9wdGlvbnMgY2FuIGJlIHNoYXJlZCBiZXR3ZWVuIG11bHRpcGxlIGVsZW1lbnRzLlxuICAgICAgLy8gU2hhcmluZyBpcyB1c2VkIHRvIHJlZHVjZSBudW1iZXIgb2YgcHJvcGVydGllcyB0byBjaGFuZ2UgZHVyaW5nIGFuaW1hdGlvbi5cbiAgICAgIHZhbHVlcy4kc2hhcmVkID0gc2hhcmluZztcblxuICAgICAgLy8gV2UgY2FjaGUgb3B0aW9ucyBieSBgbW9kZWAsIHdoaWNoIGNhbiBiZSAnYWN0aXZlJyBmb3IgZXhhbXBsZS4gVGhpcyBlbmFibGVzIHVzXG4gICAgICAvLyB0byBoYXZlIHRoZSAnYWN0aXZlJyBlbGVtZW50IG9wdGlvbnMgYW5kICdkZWZhdWx0JyBvcHRpb25zIHRvIHN3aXRjaCBiZXR3ZWVuXG4gICAgICAvLyB3aGVuIGludGVyYWN0aW5nLlxuICAgICAgY2FjaGVbY2FjaGVLZXldID0gT2JqZWN0LmZyZWV6ZShjbG9uZUlmTm90U2hhcmVkKHZhbHVlcywgc2hhcmluZykpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cblxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3Jlc29sdmVBbmltYXRpb25zKGluZGV4LCB0cmFuc2l0aW9uLCBhY3RpdmUpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgY2FjaGUgPSB0aGlzLl9jYWNoZWREYXRhT3B0cztcbiAgICBjb25zdCBjYWNoZUtleSA9IGBhbmltYXRpb24tJHt0cmFuc2l0aW9ufWA7XG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGVbY2FjaGVLZXldO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxuICAgIGxldCBvcHRpb25zO1xuICAgIGlmIChjaGFydC5vcHRpb25zLmFuaW1hdGlvbiAhPT0gZmFsc2UpIHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY2hhcnQuY29uZmlnO1xuICAgICAgY29uc3Qgc2NvcGVLZXlzID0gY29uZmlnLmRhdGFzZXRBbmltYXRpb25TY29wZUtleXModGhpcy5fdHlwZSwgdHJhbnNpdGlvbik7XG4gICAgICBjb25zdCBzY29wZXMgPSBjb25maWcuZ2V0T3B0aW9uU2NvcGVzKHRoaXMuZ2V0RGF0YXNldCgpLCBzY29wZUtleXMpO1xuICAgICAgb3B0aW9ucyA9IGNvbmZpZy5jcmVhdGVSZXNvbHZlcihzY29wZXMsIHRoaXMuZ2V0Q29udGV4dChpbmRleCwgYWN0aXZlLCB0cmFuc2l0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBuZXcgQW5pbWF0aW9ucyhjaGFydCwgb3B0aW9ucyAmJiBvcHRpb25zLmFuaW1hdGlvbnMpO1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2NhY2hlYWJsZSkge1xuICAgICAgY2FjaGVbY2FjaGVLZXldID0gT2JqZWN0LmZyZWV6ZShhbmltYXRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGlvbnM7XG4gIH1cblxuICAvKipcblx0ICogVXRpbGl0eSBmb3IgZ2V0dGluZyB0aGUgb3B0aW9ucyBvYmplY3Qgc2hhcmVkIGJldHdlZW4gZWxlbWVudHNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0U2hhcmVkT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLiRzaGFyZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NoYXJlZE9wdGlvbnMgfHwgKHRoaXMuX3NoYXJlZE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSk7XG4gIH1cblxuICAvKipcblx0ICogVXRpbGl0eSBmb3IgZGV0ZXJtaW5pbmcgaWYgYG9wdGlvbnNgIHNob3VsZCBiZSBpbmNsdWRlZCBpbiB0aGUgdXBkYXRlZCBwcm9wZXJ0aWVzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGluY2x1ZGVPcHRpb25zKG1vZGUsIHNoYXJlZE9wdGlvbnMpIHtcbiAgICByZXR1cm4gIXNoYXJlZE9wdGlvbnMgfHwgaXNEaXJlY3RVcGRhdGVNb2RlKG1vZGUpIHx8IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdG9kbyB2NCwgcmVuYW1lIHRvIGdldFNoYXJlZE9wdGlvbnMgYW5kIHJlbW92ZSBleGNlc3MgZnVuY3Rpb25zXG4gICAqL1xuICBfZ2V0U2hhcmVkT3B0aW9ucyhzdGFydCwgbW9kZSkge1xuICAgIGNvbnN0IGZpcnN0T3B0cyA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgY29uc3QgcHJldmlvdXNseVNoYXJlZE9wdGlvbnMgPSB0aGlzLl9zaGFyZWRPcHRpb25zO1xuICAgIGNvbnN0IHNoYXJlZE9wdGlvbnMgPSB0aGlzLmdldFNoYXJlZE9wdGlvbnMoZmlyc3RPcHRzKTtcbiAgICBjb25zdCBpbmNsdWRlT3B0aW9ucyA9IHRoaXMuaW5jbHVkZU9wdGlvbnMobW9kZSwgc2hhcmVkT3B0aW9ucykgfHwgKHNoYXJlZE9wdGlvbnMgIT09IHByZXZpb3VzbHlTaGFyZWRPcHRpb25zKTtcbiAgICB0aGlzLnVwZGF0ZVNoYXJlZE9wdGlvbnMoc2hhcmVkT3B0aW9ucywgbW9kZSwgZmlyc3RPcHRzKTtcbiAgICByZXR1cm4ge3NoYXJlZE9wdGlvbnMsIGluY2x1ZGVPcHRpb25zfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVdGlsaXR5IGZvciB1cGRhdGluZyBhbiBlbGVtZW50IHdpdGggbmV3IHByb3BlcnRpZXMsIHVzaW5nIGFuaW1hdGlvbnMgd2hlbiBhcHByb3ByaWF0ZS5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgdXBkYXRlRWxlbWVudChlbGVtZW50LCBpbmRleCwgcHJvcGVydGllcywgbW9kZSkge1xuICAgIGlmIChpc0RpcmVjdFVwZGF0ZU1vZGUobW9kZSkpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudCwgcHJvcGVydGllcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKGluZGV4LCBtb2RlKS51cGRhdGUoZWxlbWVudCwgcHJvcGVydGllcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIFV0aWxpdHkgdG8gYW5pbWF0ZSB0aGUgc2hhcmVkIG9wdGlvbnMsIHRoYXQgYXJlIHBvdGVudGlhbGx5IGFmZmVjdGluZyBtdWx0aXBsZSBlbGVtZW50cy5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgdXBkYXRlU2hhcmVkT3B0aW9ucyhzaGFyZWRPcHRpb25zLCBtb2RlLCBuZXdPcHRpb25zKSB7XG4gICAgaWYgKHNoYXJlZE9wdGlvbnMgJiYgIWlzRGlyZWN0VXBkYXRlTW9kZShtb2RlKSkge1xuICAgICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnModW5kZWZpbmVkLCBtb2RlKS51cGRhdGUoc2hhcmVkT3B0aW9ucywgbmV3T3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfc2V0U3R5bGUoZWxlbWVudCwgaW5kZXgsIG1vZGUsIGFjdGl2ZSkge1xuICAgIGVsZW1lbnQuYWN0aXZlID0gYWN0aXZlO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmdldFN0eWxlKGluZGV4LCBhY3RpdmUpO1xuICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKGluZGV4LCBtb2RlLCBhY3RpdmUpLnVwZGF0ZShlbGVtZW50LCB7XG4gICAgICAvLyBXaGVuIGdvaW5nIGZyb20gYWN0aXZlIHRvIGluYWN0aXZlLCB3ZSBuZWVkIHRvIHVwZGF0ZSB0byB0aGUgc2hhcmVkIG9wdGlvbnMuXG4gICAgICAvLyBUaGlzIHdheSB0aGUgb25jZSBob3ZlcmVkIGVsZW1lbnQgd2lsbCBlbmQgdXAgd2l0aCB0aGUgc2FtZSBvcmlnaW5hbCBzaGFyZWQgb3B0aW9ucyBpbnN0YW5jZSwgYWZ0ZXIgYW5pbWF0aW9uLlxuICAgICAgb3B0aW9uczogKCFhY3RpdmUgJiYgdGhpcy5nZXRTaGFyZWRPcHRpb25zKG9wdGlvbnMpKSB8fCBvcHRpb25zXG4gICAgfSk7XG4gIH1cblxuICByZW1vdmVIb3ZlclN0eWxlKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcbiAgICB0aGlzLl9zZXRTdHlsZShlbGVtZW50LCBpbmRleCwgJ2FjdGl2ZScsIGZhbHNlKTtcbiAgfVxuXG4gIHNldEhvdmVyU3R5bGUoZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkge1xuICAgIHRoaXMuX3NldFN0eWxlKGVsZW1lbnQsIGluZGV4LCAnYWN0aXZlJywgdHJ1ZSk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9yZW1vdmVEYXRhc2V0SG92ZXJTdHlsZSgpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhc2V0O1xuXG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX3NldFN0eWxlKGVsZW1lbnQsIHVuZGVmaW5lZCwgJ2FjdGl2ZScsIGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9zZXREYXRhc2V0SG92ZXJTdHlsZSgpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhc2V0O1xuXG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX3NldFN0eWxlKGVsZW1lbnQsIHVuZGVmaW5lZCwgJ2FjdGl2ZScsIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3Jlc3luY0VsZW1lbnRzKHJlc2V0TmV3RWxlbWVudHMpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YTtcblxuICAgIC8vIEFwcGx5IGNoYW5nZXMgZGV0ZWN0ZWQgdGhyb3VnaCBhcnJheSBsaXN0ZW5lcnNcbiAgICBmb3IgKGNvbnN0IFttZXRob2QsIGFyZzEsIGFyZzJdIG9mIHRoaXMuX3N5bmNMaXN0KSB7XG4gICAgICB0aGlzW21ldGhvZF0oYXJnMSwgYXJnMik7XG4gICAgfVxuICAgIHRoaXMuX3N5bmNMaXN0ID0gW107XG5cbiAgICBjb25zdCBudW1NZXRhID0gZWxlbWVudHMubGVuZ3RoO1xuICAgIGNvbnN0IG51bURhdGEgPSBkYXRhLmxlbmd0aDtcbiAgICBjb25zdCBjb3VudCA9IE1hdGgubWluKG51bURhdGEsIG51bU1ldGEpO1xuXG4gICAgaWYgKGNvdW50KSB7XG4gICAgICAvLyBUT0RPOiBJdCBpcyBub3Qgb3B0aW1hbCB0byBhbHdheXMgcGFyc2UgdGhlIG9sZCBkYXRhXG4gICAgICAvLyBUaGlzIGlzIGRvbmUgYmVjYXVzZSB3ZSBhcmUgbm90IGRldGVjdGluZyBkaXJlY3QgYXNzaWdubWVudHM6XG4gICAgICAvLyBjaGFydC5kYXRhLmRhdGFzZXRzWzBdLmRhdGFbNV0gPSAxMDtcbiAgICAgIC8vIGNoYXJ0LmRhdGEuZGF0YXNldHNbMF0uZGF0YVs1XS55ID0gMTA7XG4gICAgICB0aGlzLnBhcnNlKDAsIGNvdW50KTtcbiAgICB9XG5cbiAgICBpZiAobnVtRGF0YSA+IG51bU1ldGEpIHtcbiAgICAgIHRoaXMuX2luc2VydEVsZW1lbnRzKG51bU1ldGEsIG51bURhdGEgLSBudW1NZXRhLCByZXNldE5ld0VsZW1lbnRzKTtcbiAgICB9IGVsc2UgaWYgKG51bURhdGEgPCBudW1NZXRhKSB7XG4gICAgICB0aGlzLl9yZW1vdmVFbGVtZW50cyhudW1EYXRhLCBudW1NZXRhIC0gbnVtRGF0YSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfaW5zZXJ0RWxlbWVudHMoc3RhcnQsIGNvdW50LCByZXNldE5ld0VsZW1lbnRzID0gdHJ1ZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGRhdGEgPSBtZXRhLmRhdGE7XG4gICAgY29uc3QgZW5kID0gc3RhcnQgKyBjb3VudDtcbiAgICBsZXQgaTtcblxuICAgIGNvbnN0IG1vdmUgPSAoYXJyKSA9PiB7XG4gICAgICBhcnIubGVuZ3RoICs9IGNvdW50O1xuICAgICAgZm9yIChpID0gYXJyLmxlbmd0aCAtIDE7IGkgPj0gZW5kOyBpLS0pIHtcbiAgICAgICAgYXJyW2ldID0gYXJyW2kgLSBjb3VudF07XG4gICAgICB9XG4gICAgfTtcbiAgICBtb3ZlKGRhdGEpO1xuXG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgZGF0YVtpXSA9IG5ldyB0aGlzLmRhdGFFbGVtZW50VHlwZSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9wYXJzaW5nKSB7XG4gICAgICBtb3ZlKG1ldGEuX3BhcnNlZCk7XG4gICAgfVxuICAgIHRoaXMucGFyc2Uoc3RhcnQsIGNvdW50KTtcblxuICAgIGlmIChyZXNldE5ld0VsZW1lbnRzKSB7XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKGRhdGEsIHN0YXJ0LCBjb3VudCwgJ3Jlc2V0Jyk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlRWxlbWVudHMoZWxlbWVudCwgc3RhcnQsIGNvdW50LCBtb2RlKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfcmVtb3ZlRWxlbWVudHMoc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgaWYgKHRoaXMuX3BhcnNpbmcpIHtcbiAgICAgIGNvbnN0IHJlbW92ZWQgPSBtZXRhLl9wYXJzZWQuc3BsaWNlKHN0YXJ0LCBjb3VudCk7XG4gICAgICBpZiAobWV0YS5fc3RhY2tlZCkge1xuICAgICAgICBjbGVhclN0YWNrcyhtZXRhLCByZW1vdmVkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbWV0YS5kYXRhLnNwbGljZShzdGFydCwgY291bnQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG4gICAqL1xuICBfc3luYyhhcmdzKSB7XG4gICAgaWYgKHRoaXMuX3BhcnNpbmcpIHtcbiAgICAgIHRoaXMuX3N5bmNMaXN0LnB1c2goYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IFttZXRob2QsIGFyZzEsIGFyZzJdID0gYXJncztcbiAgICAgIHRoaXNbbWV0aG9kXShhcmcxLCBhcmcyKTtcbiAgICB9XG4gICAgdGhpcy5jaGFydC5fZGF0YUNoYW5nZXMucHVzaChbdGhpcy5pbmRleCwgLi4uYXJnc10pO1xuICB9XG5cbiAgX29uRGF0YVB1c2goKSB7XG4gICAgY29uc3QgY291bnQgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHRoaXMuX3N5bmMoWydfaW5zZXJ0RWxlbWVudHMnLCB0aGlzLmdldERhdGFzZXQoKS5kYXRhLmxlbmd0aCAtIGNvdW50LCBjb3VudF0pO1xuICB9XG5cbiAgX29uRGF0YVBvcCgpIHtcbiAgICB0aGlzLl9zeW5jKFsnX3JlbW92ZUVsZW1lbnRzJywgdGhpcy5fY2FjaGVkTWV0YS5kYXRhLmxlbmd0aCAtIDEsIDFdKTtcbiAgfVxuXG4gIF9vbkRhdGFTaGlmdCgpIHtcbiAgICB0aGlzLl9zeW5jKFsnX3JlbW92ZUVsZW1lbnRzJywgMCwgMV0pO1xuICB9XG5cbiAgX29uRGF0YVNwbGljZShzdGFydCwgY291bnQpIHtcbiAgICBpZiAoY291bnQpIHtcbiAgICAgIHRoaXMuX3N5bmMoWydfcmVtb3ZlRWxlbWVudHMnLCBzdGFydCwgY291bnRdKTtcbiAgICB9XG4gICAgY29uc3QgbmV3Q291bnQgPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgICBpZiAobmV3Q291bnQpIHtcbiAgICAgIHRoaXMuX3N5bmMoWydfaW5zZXJ0RWxlbWVudHMnLCBzdGFydCwgbmV3Q291bnRdKTtcbiAgICB9XG4gIH1cblxuICBfb25EYXRhVW5zaGlmdCgpIHtcbiAgICB0aGlzLl9zeW5jKFsnX2luc2VydEVsZW1lbnRzJywgMCwgYXJndW1lbnRzLmxlbmd0aF0pO1xuICB9XG59XG4iLCJpbXBvcnQgRGF0YXNldENvbnRyb2xsZXIgZnJvbSAnLi4vY29yZS9jb3JlLmRhdGFzZXRDb250cm9sbGVyLmpzJztcbmltcG9ydCB7XG4gIF9hcnJheVVuaXF1ZSwgaXNBcnJheSwgaXNOdWxsT3JVbmRlZixcbiAgdmFsdWVPckRlZmF1bHQsIHJlc29sdmVPYmplY3RLZXksIHNpZ24sIGRlZmluZWRcbn0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbmZ1bmN0aW9uIGdldEFsbFNjYWxlVmFsdWVzKHNjYWxlLCB0eXBlKSB7XG4gIGlmICghc2NhbGUuX2NhY2hlLiRiYXIpIHtcbiAgICBjb25zdCB2aXNpYmxlTWV0YXMgPSBzY2FsZS5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcyh0eXBlKTtcbiAgICBsZXQgdmFsdWVzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IHZpc2libGVNZXRhcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQodmlzaWJsZU1ldGFzW2ldLmNvbnRyb2xsZXIuZ2V0QWxsUGFyc2VkVmFsdWVzKHNjYWxlKSk7XG4gICAgfVxuICAgIHNjYWxlLl9jYWNoZS4kYmFyID0gX2FycmF5VW5pcXVlKHZhbHVlcy5zb3J0KChhLCBiKSA9PiBhIC0gYikpO1xuICB9XG4gIHJldHVybiBzY2FsZS5fY2FjaGUuJGJhcjtcbn1cblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgXCJvcHRpbWFsXCIgc2FtcGxlIHNpemUgdG8gbWFpbnRhaW4gYmFycyBlcXVhbGx5IHNpemVkIHdoaWxlIHByZXZlbnRpbmcgb3ZlcmxhcC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVNaW5TYW1wbGVTaXplKG1ldGEpIHtcbiAgY29uc3Qgc2NhbGUgPSBtZXRhLmlTY2FsZTtcbiAgY29uc3QgdmFsdWVzID0gZ2V0QWxsU2NhbGVWYWx1ZXMoc2NhbGUsIG1ldGEudHlwZSk7XG4gIGxldCBtaW4gPSBzY2FsZS5fbGVuZ3RoO1xuICBsZXQgaSwgaWxlbiwgY3VyciwgcHJldjtcbiAgY29uc3QgdXBkYXRlTWluQW5kUHJldiA9ICgpID0+IHtcbiAgICBpZiAoY3VyciA9PT0gMzI3NjcgfHwgY3VyciA9PT0gLTMyNzY4KSB7XG4gICAgICAvLyBJZ25vcmUgdHJ1bmNhdGVkIHBpeGVsc1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZGVmaW5lZChwcmV2KSkge1xuICAgICAgLy8gY3VyciAtIHByZXYgPT09IDAgaXMgaWdub3JlZFxuICAgICAgbWluID0gTWF0aC5taW4obWluLCBNYXRoLmFicyhjdXJyIC0gcHJldikgfHwgbWluKTtcbiAgICB9XG4gICAgcHJldiA9IGN1cnI7XG4gIH07XG5cbiAgZm9yIChpID0gMCwgaWxlbiA9IHZhbHVlcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBjdXJyID0gc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZXNbaV0pO1xuICAgIHVwZGF0ZU1pbkFuZFByZXYoKTtcbiAgfVxuXG4gIHByZXYgPSB1bmRlZmluZWQ7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBzY2FsZS50aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBjdXJyID0gc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKGkpO1xuICAgIHVwZGF0ZU1pbkFuZFByZXYoKTtcbiAgfVxuXG4gIHJldHVybiBtaW47XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgYW4gXCJpZGVhbFwiIGNhdGVnb3J5IGJhc2VkIG9uIHRoZSBhYnNvbHV0ZSBiYXIgdGhpY2tuZXNzIG9yLCBpZiB1bmRlZmluZWQgb3IgbnVsbCxcbiAqIHVzZXMgdGhlIHNtYWxsZXN0IGludGVydmFsIChzZWUgY29tcHV0ZU1pblNhbXBsZVNpemUpIHRoYXQgcHJldmVudHMgYmFyIG92ZXJsYXBwaW5nLiBUaGlzXG4gKiBtb2RlIGN1cnJlbnRseSBhbHdheXMgZ2VuZXJhdGVzIGJhcnMgZXF1YWxseSBzaXplZCAodW50aWwgd2UgaW50cm9kdWNlIHNjcmlwdGFibGUgb3B0aW9ucz8pLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUZpdENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucywgc3RhY2tDb3VudCkge1xuICBjb25zdCB0aGlja25lc3MgPSBvcHRpb25zLmJhclRoaWNrbmVzcztcbiAgbGV0IHNpemUsIHJhdGlvO1xuXG4gIGlmIChpc051bGxPclVuZGVmKHRoaWNrbmVzcykpIHtcbiAgICBzaXplID0gcnVsZXIubWluICogb3B0aW9ucy5jYXRlZ29yeVBlcmNlbnRhZ2U7XG4gICAgcmF0aW8gPSBvcHRpb25zLmJhclBlcmNlbnRhZ2U7XG4gIH0gZWxzZSB7XG4gICAgLy8gV2hlbiBiYXIgdGhpY2tuZXNzIGlzIGVuZm9yY2VkLCBjYXRlZ29yeSBhbmQgYmFyIHBlcmNlbnRhZ2VzIGFyZSBpZ25vcmVkLlxuICAgIC8vIE5vdGUoU0IpOiB3ZSBjb3VsZCBhZGQgc3VwcG9ydCBmb3IgcmVsYXRpdmUgYmFyIHRoaWNrbmVzcyAoZS5nLiBiYXJUaGlja25lc3M6ICc1MCUnKVxuICAgIC8vIGFuZCBkZXByZWNhdGUgYmFyUGVyY2VudGFnZSBzaW5jZSB0aGlzIHZhbHVlIGlzIGlnbm9yZWQgd2hlbiB0aGlja25lc3MgaXMgYWJzb2x1dGUuXG4gICAgc2l6ZSA9IHRoaWNrbmVzcyAqIHN0YWNrQ291bnQ7XG4gICAgcmF0aW8gPSAxO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjaHVuazogc2l6ZSAvIHN0YWNrQ291bnQsXG4gICAgcmF0aW8sXG4gICAgc3RhcnQ6IHJ1bGVyLnBpeGVsc1tpbmRleF0gLSAoc2l6ZSAvIDIpXG4gIH07XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgYW4gXCJvcHRpbWFsXCIgY2F0ZWdvcnkgdGhhdCBnbG9iYWxseSBhcnJhbmdlcyBiYXJzIHNpZGUgYnkgc2lkZSAobm8gZ2FwIHdoZW5cbiAqIHBlcmNlbnRhZ2Ugb3B0aW9ucyBhcmUgMSksIGJhc2VkIG9uIHRoZSBwcmV2aW91cyBhbmQgZm9sbG93aW5nIGNhdGVnb3JpZXMuIFRoaXMgbW9kZVxuICogZ2VuZXJhdGVzIGJhcnMgd2l0aCBkaWZmZXJlbnQgd2lkdGhzIHdoZW4gZGF0YSBhcmUgbm90IGV2ZW5seSBzcGFjZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb21wdXRlRmxleENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucywgc3RhY2tDb3VudCkge1xuICBjb25zdCBwaXhlbHMgPSBydWxlci5waXhlbHM7XG4gIGNvbnN0IGN1cnIgPSBwaXhlbHNbaW5kZXhdO1xuICBsZXQgcHJldiA9IGluZGV4ID4gMCA/IHBpeGVsc1tpbmRleCAtIDFdIDogbnVsbDtcbiAgbGV0IG5leHQgPSBpbmRleCA8IHBpeGVscy5sZW5ndGggLSAxID8gcGl4ZWxzW2luZGV4ICsgMV0gOiBudWxsO1xuICBjb25zdCBwZXJjZW50ID0gb3B0aW9ucy5jYXRlZ29yeVBlcmNlbnRhZ2U7XG5cbiAgaWYgKHByZXYgPT09IG51bGwpIHtcbiAgICAvLyBmaXJzdCBkYXRhOiBpdHMgc2l6ZSBpcyBkb3VibGUgYmFzZWQgb24gdGhlIG5leHQgcG9pbnQgb3IsXG4gICAgLy8gaWYgaXQncyBhbHNvIHRoZSBsYXN0IGRhdGEsIHdlIHVzZSB0aGUgc2NhbGUgc2l6ZS5cbiAgICBwcmV2ID0gY3VyciAtIChuZXh0ID09PSBudWxsID8gcnVsZXIuZW5kIC0gcnVsZXIuc3RhcnQgOiBuZXh0IC0gY3Vycik7XG4gIH1cblxuICBpZiAobmV4dCA9PT0gbnVsbCkge1xuICAgIC8vIGxhc3QgZGF0YTogaXRzIHNpemUgaXMgYWxzbyBkb3VibGUgYmFzZWQgb24gdGhlIHByZXZpb3VzIHBvaW50LlxuICAgIG5leHQgPSBjdXJyICsgY3VyciAtIHByZXY7XG4gIH1cblxuICBjb25zdCBzdGFydCA9IGN1cnIgLSAoY3VyciAtIE1hdGgubWluKHByZXYsIG5leHQpKSAvIDIgKiBwZXJjZW50O1xuICBjb25zdCBzaXplID0gTWF0aC5hYnMobmV4dCAtIHByZXYpIC8gMiAqIHBlcmNlbnQ7XG5cbiAgcmV0dXJuIHtcbiAgICBjaHVuazogc2l6ZSAvIHN0YWNrQ291bnQsXG4gICAgcmF0aW86IG9wdGlvbnMuYmFyUGVyY2VudGFnZSxcbiAgICBzdGFydFxuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZUZsb2F0QmFyKGVudHJ5LCBpdGVtLCB2U2NhbGUsIGkpIHtcbiAgY29uc3Qgc3RhcnRWYWx1ZSA9IHZTY2FsZS5wYXJzZShlbnRyeVswXSwgaSk7XG4gIGNvbnN0IGVuZFZhbHVlID0gdlNjYWxlLnBhcnNlKGVudHJ5WzFdLCBpKTtcbiAgY29uc3QgbWluID0gTWF0aC5taW4oc3RhcnRWYWx1ZSwgZW5kVmFsdWUpO1xuICBjb25zdCBtYXggPSBNYXRoLm1heChzdGFydFZhbHVlLCBlbmRWYWx1ZSk7XG4gIGxldCBiYXJTdGFydCA9IG1pbjtcbiAgbGV0IGJhckVuZCA9IG1heDtcblxuICBpZiAoTWF0aC5hYnMobWluKSA+IE1hdGguYWJzKG1heCkpIHtcbiAgICBiYXJTdGFydCA9IG1heDtcbiAgICBiYXJFbmQgPSBtaW47XG4gIH1cblxuICAvLyBTdG9yZSBgYmFyRW5kYCAoZnVydGhlc3QgYXdheSBmcm9tIG9yaWdpbikgYXMgcGFyc2VkIHZhbHVlLFxuICAvLyB0byBtYWtlIHN0YWNraW5nIHN0cmFpZ2h0IGZvcndhcmRcbiAgaXRlbVt2U2NhbGUuYXhpc10gPSBiYXJFbmQ7XG5cbiAgaXRlbS5fY3VzdG9tID0ge1xuICAgIGJhclN0YXJ0LFxuICAgIGJhckVuZCxcbiAgICBzdGFydDogc3RhcnRWYWx1ZSxcbiAgICBlbmQ6IGVuZFZhbHVlLFxuICAgIG1pbixcbiAgICBtYXhcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VWYWx1ZShlbnRyeSwgaXRlbSwgdlNjYWxlLCBpKSB7XG4gIGlmIChpc0FycmF5KGVudHJ5KSkge1xuICAgIHBhcnNlRmxvYXRCYXIoZW50cnksIGl0ZW0sIHZTY2FsZSwgaSk7XG4gIH0gZWxzZSB7XG4gICAgaXRlbVt2U2NhbGUuYXhpc10gPSB2U2NhbGUucGFyc2UoZW50cnksIGkpO1xuICB9XG4gIHJldHVybiBpdGVtO1xufVxuXG5mdW5jdGlvbiBwYXJzZUFycmF5T3JQcmltaXRpdmUobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gIGNvbnN0IGlTY2FsZSA9IG1ldGEuaVNjYWxlO1xuICBjb25zdCB2U2NhbGUgPSBtZXRhLnZTY2FsZTtcbiAgY29uc3QgbGFiZWxzID0gaVNjYWxlLmdldExhYmVscygpO1xuICBjb25zdCBzaW5nbGVTY2FsZSA9IGlTY2FsZSA9PT0gdlNjYWxlO1xuICBjb25zdCBwYXJzZWQgPSBbXTtcbiAgbGV0IGksIGlsZW4sIGl0ZW0sIGVudHJ5O1xuXG4gIGZvciAoaSA9IHN0YXJ0LCBpbGVuID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgIGVudHJ5ID0gZGF0YVtpXTtcbiAgICBpdGVtID0ge307XG4gICAgaXRlbVtpU2NhbGUuYXhpc10gPSBzaW5nbGVTY2FsZSB8fCBpU2NhbGUucGFyc2UobGFiZWxzW2ldLCBpKTtcbiAgICBwYXJzZWQucHVzaChwYXJzZVZhbHVlKGVudHJ5LCBpdGVtLCB2U2NhbGUsIGkpKTtcbiAgfVxuICByZXR1cm4gcGFyc2VkO1xufVxuXG5mdW5jdGlvbiBpc0Zsb2F0QmFyKGN1c3RvbSkge1xuICByZXR1cm4gY3VzdG9tICYmIGN1c3RvbS5iYXJTdGFydCAhPT0gdW5kZWZpbmVkICYmIGN1c3RvbS5iYXJFbmQgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gYmFyU2lnbihzaXplLCB2U2NhbGUsIGFjdHVhbEJhc2UpIHtcbiAgaWYgKHNpemUgIT09IDApIHtcbiAgICByZXR1cm4gc2lnbihzaXplKTtcbiAgfVxuICByZXR1cm4gKHZTY2FsZS5pc0hvcml6b250YWwoKSA/IDEgOiAtMSkgKiAodlNjYWxlLm1pbiA+PSBhY3R1YWxCYXNlID8gMSA6IC0xKTtcbn1cblxuZnVuY3Rpb24gYm9yZGVyUHJvcHMocHJvcGVydGllcykge1xuICBsZXQgcmV2ZXJzZSwgc3RhcnQsIGVuZCwgdG9wLCBib3R0b207XG4gIGlmIChwcm9wZXJ0aWVzLmhvcml6b250YWwpIHtcbiAgICByZXZlcnNlID0gcHJvcGVydGllcy5iYXNlID4gcHJvcGVydGllcy54O1xuICAgIHN0YXJ0ID0gJ2xlZnQnO1xuICAgIGVuZCA9ICdyaWdodCc7XG4gIH0gZWxzZSB7XG4gICAgcmV2ZXJzZSA9IHByb3BlcnRpZXMuYmFzZSA8IHByb3BlcnRpZXMueTtcbiAgICBzdGFydCA9ICdib3R0b20nO1xuICAgIGVuZCA9ICd0b3AnO1xuICB9XG4gIGlmIChyZXZlcnNlKSB7XG4gICAgdG9wID0gJ2VuZCc7XG4gICAgYm90dG9tID0gJ3N0YXJ0JztcbiAgfSBlbHNlIHtcbiAgICB0b3AgPSAnc3RhcnQnO1xuICAgIGJvdHRvbSA9ICdlbmQnO1xuICB9XG4gIHJldHVybiB7c3RhcnQsIGVuZCwgcmV2ZXJzZSwgdG9wLCBib3R0b219O1xufVxuXG5mdW5jdGlvbiBzZXRCb3JkZXJTa2lwcGVkKHByb3BlcnRpZXMsIG9wdGlvbnMsIHN0YWNrLCBpbmRleCkge1xuICBsZXQgZWRnZSA9IG9wdGlvbnMuYm9yZGVyU2tpcHBlZDtcbiAgY29uc3QgcmVzID0ge307XG5cbiAgaWYgKCFlZGdlKSB7XG4gICAgcHJvcGVydGllcy5ib3JkZXJTa2lwcGVkID0gcmVzO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChlZGdlID09PSB0cnVlKSB7XG4gICAgcHJvcGVydGllcy5ib3JkZXJTa2lwcGVkID0ge3RvcDogdHJ1ZSwgcmlnaHQ6IHRydWUsIGJvdHRvbTogdHJ1ZSwgbGVmdDogdHJ1ZX07XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qge3N0YXJ0LCBlbmQsIHJldmVyc2UsIHRvcCwgYm90dG9tfSA9IGJvcmRlclByb3BzKHByb3BlcnRpZXMpO1xuXG4gIGlmIChlZGdlID09PSAnbWlkZGxlJyAmJiBzdGFjaykge1xuICAgIHByb3BlcnRpZXMuZW5hYmxlQm9yZGVyUmFkaXVzID0gdHJ1ZTtcbiAgICBpZiAoKHN0YWNrLl90b3AgfHwgMCkgPT09IGluZGV4KSB7XG4gICAgICBlZGdlID0gdG9wO1xuICAgIH0gZWxzZSBpZiAoKHN0YWNrLl9ib3R0b20gfHwgMCkgPT09IGluZGV4KSB7XG4gICAgICBlZGdlID0gYm90dG9tO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNbcGFyc2VFZGdlKGJvdHRvbSwgc3RhcnQsIGVuZCwgcmV2ZXJzZSldID0gdHJ1ZTtcbiAgICAgIGVkZ2UgPSB0b3A7XG4gICAgfVxuICB9XG5cbiAgcmVzW3BhcnNlRWRnZShlZGdlLCBzdGFydCwgZW5kLCByZXZlcnNlKV0gPSB0cnVlO1xuICBwcm9wZXJ0aWVzLmJvcmRlclNraXBwZWQgPSByZXM7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRWRnZShlZGdlLCBhLCBiLCByZXZlcnNlKSB7XG4gIGlmIChyZXZlcnNlKSB7XG4gICAgZWRnZSA9IHN3YXAoZWRnZSwgYSwgYik7XG4gICAgZWRnZSA9IHN0YXJ0RW5kKGVkZ2UsIGIsIGEpO1xuICB9IGVsc2Uge1xuICAgIGVkZ2UgPSBzdGFydEVuZChlZGdlLCBhLCBiKTtcbiAgfVxuICByZXR1cm4gZWRnZTtcbn1cblxuZnVuY3Rpb24gc3dhcChvcmlnLCB2MSwgdjIpIHtcbiAgcmV0dXJuIG9yaWcgPT09IHYxID8gdjIgOiBvcmlnID09PSB2MiA/IHYxIDogb3JpZztcbn1cblxuZnVuY3Rpb24gc3RhcnRFbmQodiwgc3RhcnQsIGVuZCkge1xuICByZXR1cm4gdiA9PT0gJ3N0YXJ0JyA/IHN0YXJ0IDogdiA9PT0gJ2VuZCcgPyBlbmQgOiB2O1xufVxuXG5mdW5jdGlvbiBzZXRJbmZsYXRlQW1vdW50KHByb3BlcnRpZXMsIHtpbmZsYXRlQW1vdW50fSwgcmF0aW8pIHtcbiAgcHJvcGVydGllcy5pbmZsYXRlQW1vdW50ID0gaW5mbGF0ZUFtb3VudCA9PT0gJ2F1dG8nXG4gICAgPyByYXRpbyA9PT0gMSA/IDAuMzMgOiAwXG4gICAgOiBpbmZsYXRlQW1vdW50O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXJDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuXG4gIHN0YXRpYyBpZCA9ICdiYXInO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGRhdGFzZXRFbGVtZW50VHlwZTogZmFsc2UsXG4gICAgZGF0YUVsZW1lbnRUeXBlOiAnYmFyJyxcblxuICAgIGNhdGVnb3J5UGVyY2VudGFnZTogMC44LFxuICAgIGJhclBlcmNlbnRhZ2U6IDAuOSxcbiAgICBncm91cGVkOiB0cnVlLFxuXG4gICAgYW5pbWF0aW9uczoge1xuICAgICAgbnVtYmVyczoge1xuICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgcHJvcGVydGllczogWyd4JywgJ3knLCAnYmFzZScsICd3aWR0aCcsICdoZWlnaHQnXVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBvdmVycmlkZXMgPSB7XG4gICAgc2NhbGVzOiB7XG4gICAgICBfaW5kZXhfOiB7XG4gICAgICAgIHR5cGU6ICdjYXRlZ29yeScsXG4gICAgICAgIG9mZnNldDogdHJ1ZSxcbiAgICAgICAgZ3JpZDoge1xuICAgICAgICAgIG9mZnNldDogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX3ZhbHVlXzoge1xuICAgICAgICB0eXBlOiAnbGluZWFyJyxcbiAgICAgICAgYmVnaW5BdFplcm86IHRydWUsXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG5cbiAgLyoqXG5cdCAqIE92ZXJyaWRpbmcgcHJpbWl0aXZlIGRhdGEgcGFyc2luZyBzaW5jZSB3ZSBzdXBwb3J0IG1peGVkIHByaW1pdGl2ZS9hcnJheVxuXHQgKiBkYXRhIGZvciBmbG9hdCBiYXJzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICByZXR1cm4gcGFyc2VBcnJheU9yUHJpbWl0aXZlKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gIH1cblxuICAvKipcblx0ICogT3ZlcnJpZGluZyBhcnJheSBkYXRhIHBhcnNpbmcgc2luY2Ugd2Ugc3VwcG9ydCBtaXhlZCBwcmltaXRpdmUvYXJyYXlcblx0ICogZGF0YSBmb3IgZmxvYXQgYmFyc1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBwYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICByZXR1cm4gcGFyc2VBcnJheU9yUHJpbWl0aXZlKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gIH1cblxuICAvKipcblx0ICogT3ZlcnJpZGluZyBvYmplY3QgZGF0YSBwYXJzaW5nIHNpbmNlIHdlIHN1cHBvcnQgbWl4ZWQgcHJpbWl0aXZlL2FycmF5XG5cdCAqIHZhbHVlLXNjYWxlIGRhdGEgZm9yIGZsb2F0IGJhcnNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZX0gPSBtZXRhO1xuICAgIGNvbnN0IHt4QXhpc0tleSA9ICd4JywgeUF4aXNLZXkgPSAneSd9ID0gdGhpcy5fcGFyc2luZztcbiAgICBjb25zdCBpQXhpc0tleSA9IGlTY2FsZS5heGlzID09PSAneCcgPyB4QXhpc0tleSA6IHlBeGlzS2V5O1xuICAgIGNvbnN0IHZBeGlzS2V5ID0gdlNjYWxlLmF4aXMgPT09ICd4JyA/IHhBeGlzS2V5IDogeUF4aXNLZXk7XG4gICAgY29uc3QgcGFyc2VkID0gW107XG4gICAgbGV0IGksIGlsZW4sIGl0ZW0sIG9iajtcbiAgICBmb3IgKGkgPSBzdGFydCwgaWxlbiA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIG9iaiA9IGRhdGFbaV07XG4gICAgICBpdGVtID0ge307XG4gICAgICBpdGVtW2lTY2FsZS5heGlzXSA9IGlTY2FsZS5wYXJzZShyZXNvbHZlT2JqZWN0S2V5KG9iaiwgaUF4aXNLZXkpLCBpKTtcbiAgICAgIHBhcnNlZC5wdXNoKHBhcnNlVmFsdWUocmVzb2x2ZU9iamVjdEtleShvYmosIHZBeGlzS2V5KSwgaXRlbSwgdlNjYWxlLCBpKSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgdXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHJhbmdlLCBzY2FsZSwgcGFyc2VkLCBzdGFjaykge1xuICAgIHN1cGVyLnVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spO1xuICAgIGNvbnN0IGN1c3RvbSA9IHBhcnNlZC5fY3VzdG9tO1xuICAgIGlmIChjdXN0b20gJiYgc2NhbGUgPT09IHRoaXMuX2NhY2hlZE1ldGEudlNjYWxlKSB7XG4gICAgICAvLyBmbG9hdCBiYXI6IG9ubHkgb25lIGVuZCBvZiB0aGUgYmFyIGlzIGNvbnNpZGVyZWQgYnkgYHN1cGVyYFxuICAgICAgcmFuZ2UubWluID0gTWF0aC5taW4ocmFuZ2UubWluLCBjdXN0b20ubWluKTtcbiAgICAgIHJhbmdlLm1heCA9IE1hdGgubWF4KHJhbmdlLm1heCwgY3VzdG9tLm1heCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEByZXR1cm4ge251bWJlcnxib29sZWFufVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIGNvbnN0IGN1c3RvbSA9IHBhcnNlZC5fY3VzdG9tO1xuICAgIGNvbnN0IHZhbHVlID0gaXNGbG9hdEJhcihjdXN0b20pXG4gICAgICA/ICdbJyArIGN1c3RvbS5zdGFydCArICcsICcgKyBjdXN0b20uZW5kICsgJ10nXG4gICAgICA6ICcnICsgdlNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW3ZTY2FsZS5heGlzXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6ICcnICsgaVNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW2lTY2FsZS5heGlzXSksXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cblxuICBpbml0aWFsaXplKCkge1xuICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9IHRydWU7XG5cbiAgICBzdXBlci5pbml0aWFsaXplKCk7XG5cbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBtZXRhLnN0YWNrID0gdGhpcy5nZXREYXRhc2V0KCkuc3RhY2s7XG4gIH1cblxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIHRoaXMudXBkYXRlRWxlbWVudHMobWV0YS5kYXRhLCAwLCBtZXRhLmRhdGEubGVuZ3RoLCBtb2RlKTtcbiAgfVxuXG4gIHVwZGF0ZUVsZW1lbnRzKGJhcnMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCB7aW5kZXgsIF9jYWNoZWRNZXRhOiB7dlNjYWxlfX0gPSB0aGlzO1xuICAgIGNvbnN0IGJhc2UgPSB2U2NhbGUuZ2V0QmFzZVBpeGVsKCk7XG4gICAgY29uc3QgaG9yaXpvbnRhbCA9IHZTY2FsZS5pc0hvcml6b250YWwoKTtcbiAgICBjb25zdCBydWxlciA9IHRoaXMuX2dldFJ1bGVyKCk7XG4gICAgY29uc3Qge3NoYXJlZE9wdGlvbnMsIGluY2x1ZGVPcHRpb25zfSA9IHRoaXMuX2dldFNoYXJlZE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuXG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpKTtcbiAgICAgIGNvbnN0IHZwaXhlbHMgPSByZXNldCB8fCBpc051bGxPclVuZGVmKHBhcnNlZFt2U2NhbGUuYXhpc10pID8ge2Jhc2UsIGhlYWQ6IGJhc2V9IDogdGhpcy5fY2FsY3VsYXRlQmFyVmFsdWVQaXhlbHMoaSk7XG4gICAgICBjb25zdCBpcGl4ZWxzID0gdGhpcy5fY2FsY3VsYXRlQmFySW5kZXhQaXhlbHMoaSwgcnVsZXIpO1xuICAgICAgY29uc3Qgc3RhY2sgPSAocGFyc2VkLl9zdGFja3MgfHwge30pW3ZTY2FsZS5heGlzXTtcblxuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgICAgaG9yaXpvbnRhbCxcbiAgICAgICAgYmFzZTogdnBpeGVscy5iYXNlLFxuICAgICAgICBlbmFibGVCb3JkZXJSYWRpdXM6ICFzdGFjayB8fCBpc0Zsb2F0QmFyKHBhcnNlZC5fY3VzdG9tKSB8fCAoaW5kZXggPT09IHN0YWNrLl90b3AgfHwgaW5kZXggPT09IHN0YWNrLl9ib3R0b20pLFxuICAgICAgICB4OiBob3Jpem9udGFsID8gdnBpeGVscy5oZWFkIDogaXBpeGVscy5jZW50ZXIsXG4gICAgICAgIHk6IGhvcml6b250YWwgPyBpcGl4ZWxzLmNlbnRlciA6IHZwaXhlbHMuaGVhZCxcbiAgICAgICAgaGVpZ2h0OiBob3Jpem9udGFsID8gaXBpeGVscy5zaXplIDogTWF0aC5hYnModnBpeGVscy5zaXplKSxcbiAgICAgICAgd2lkdGg6IGhvcml6b250YWwgPyBNYXRoLmFicyh2cGl4ZWxzLnNpemUpIDogaXBpeGVscy5zaXplXG4gICAgICB9O1xuXG4gICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gc2hhcmVkT3B0aW9ucyB8fCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgYmFyc1tpXS5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHByb3BlcnRpZXMub3B0aW9ucyB8fCBiYXJzW2ldLm9wdGlvbnM7XG4gICAgICBzZXRCb3JkZXJTa2lwcGVkKHByb3BlcnRpZXMsIG9wdGlvbnMsIHN0YWNrLCBpbmRleCk7XG4gICAgICBzZXRJbmZsYXRlQW1vdW50KHByb3BlcnRpZXMsIG9wdGlvbnMsIHJ1bGVyLnJhdGlvKTtcbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChiYXJzW2ldLCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgc3RhY2tzIGJhc2VkIG9uIGdyb3VwcyBhbmQgYmFyIHZpc2liaWxpdHkuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbbGFzdF0gLSBUaGUgZGF0YXNldCBpbmRleFxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2RhdGFJbmRleF0gLSBUaGUgZGF0YSBpbmRleCBvZiB0aGUgcnVsZXJcblx0ICogQHJldHVybnMge3N0cmluZ1tdfSBUaGUgbGlzdCBvZiBzdGFjayBJRHNcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRTdGFja3MobGFzdCwgZGF0YUluZGV4KSB7XG4gICAgY29uc3Qge2lTY2FsZX0gPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IG1ldGFzZXRzID0gaVNjYWxlLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKHRoaXMuX3R5cGUpXG4gICAgICAuZmlsdGVyKG1ldGEgPT4gbWV0YS5jb250cm9sbGVyLm9wdGlvbnMuZ3JvdXBlZCk7XG4gICAgY29uc3Qgc3RhY2tlZCA9IGlTY2FsZS5vcHRpb25zLnN0YWNrZWQ7XG4gICAgY29uc3Qgc3RhY2tzID0gW107XG4gICAgY29uc3QgY3VycmVudFBhcnNlZCA9IHRoaXMuX2NhY2hlZE1ldGEuY29udHJvbGxlci5nZXRQYXJzZWQoZGF0YUluZGV4KTtcbiAgICBjb25zdCBpU2NhbGVWYWx1ZSA9IGN1cnJlbnRQYXJzZWQgJiYgY3VycmVudFBhcnNlZFtpU2NhbGUuYXhpc107XG5cbiAgICBjb25zdCBza2lwTnVsbCA9IChtZXRhKSA9PiB7XG4gICAgICBjb25zdCBwYXJzZWQgPSBtZXRhLl9wYXJzZWQuZmluZChpdGVtID0+IGl0ZW1baVNjYWxlLmF4aXNdID09PSBpU2NhbGVWYWx1ZSk7XG4gICAgICBjb25zdCB2YWwgPSBwYXJzZWQgJiYgcGFyc2VkW21ldGEudlNjYWxlLmF4aXNdO1xuXG4gICAgICBpZiAoaXNOdWxsT3JVbmRlZih2YWwpIHx8IGlzTmFOKHZhbCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAoY29uc3QgbWV0YSBvZiBtZXRhc2V0cykge1xuICAgICAgaWYgKGRhdGFJbmRleCAhPT0gdW5kZWZpbmVkICYmIHNraXBOdWxsKG1ldGEpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBzdGFja2VkICAgfCBtZXRhLnN0YWNrXG4gICAgICAvLyAgICAgICAgICAgfCBmb3VuZCB8IG5vdCBmb3VuZCB8IHVuZGVmaW5lZFxuICAgICAgLy8gZmFsc2UgICAgIHwgICB4ICAgfCAgICAgeCAgICAgfCAgICAgeFxuICAgICAgLy8gdHJ1ZSAgICAgIHwgICAgICAgfCAgICAgeCAgICAgfFxuICAgICAgLy8gdW5kZWZpbmVkIHwgICAgICAgfCAgICAgeCAgICAgfCAgICAgeFxuICAgICAgaWYgKHN0YWNrZWQgPT09IGZhbHNlIHx8IHN0YWNrcy5pbmRleE9mKG1ldGEuc3RhY2spID09PSAtMSB8fFxuXHRcdFx0XHQoc3RhY2tlZCA9PT0gdW5kZWZpbmVkICYmIG1ldGEuc3RhY2sgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgc3RhY2tzLnB1c2gobWV0YS5zdGFjayk7XG4gICAgICB9XG4gICAgICBpZiAobWV0YS5pbmRleCA9PT0gbGFzdCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBObyBzdGFja3M/IHRoYXQgbWVhbnMgdGhlcmUgaXMgbm8gdmlzaWJsZSBkYXRhLiBMZXQncyBzdGlsbCBpbml0aWFsaXplIGFuIGB1bmRlZmluZWRgXG4gICAgLy8gc3RhY2sgd2hlcmUgcG9zc2libGUgaW52aXNpYmxlIGJhcnMgd2lsbCBiZSBsb2NhdGVkLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy82MzY4XG4gICAgaWYgKCFzdGFja3MubGVuZ3RoKSB7XG4gICAgICBzdGFja3MucHVzaCh1bmRlZmluZWQpO1xuICAgIH1cblxuICAgIHJldHVybiBzdGFja3M7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgZWZmZWN0aXZlIG51bWJlciBvZiBzdGFja3MgYmFzZWQgb24gZ3JvdXBzIGFuZCBiYXIgdmlzaWJpbGl0eS5cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRTdGFja0NvdW50KGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFN0YWNrcyh1bmRlZmluZWQsIGluZGV4KS5sZW5ndGg7XG4gIH1cblxuICBfZ2V0QXhpc0NvdW50KCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRBeGlzKCkubGVuZ3RoO1xuICB9XG5cbiAgZ2V0Rmlyc3RTY2FsZUlkRm9ySW5kZXhBeGlzKCkge1xuICAgIGNvbnN0IHNjYWxlcyA9IHRoaXMuY2hhcnQuc2NhbGVzO1xuICAgIGNvbnN0IGluZGV4U2NhbGVJZCA9IHRoaXMuY2hhcnQub3B0aW9ucy5pbmRleEF4aXM7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHNjYWxlcykuZmlsdGVyKGtleSA9PiBzY2FsZXNba2V5XS5heGlzID09PSBpbmRleFNjYWxlSWQpLnNoaWZ0KCk7XG4gIH1cblxuICBfZ2V0QXhpcygpIHtcbiAgICBjb25zdCBheGlzID0ge307XG4gICAgY29uc3QgZmlyc3RTY2FsZUF4aXNJZCA9IHRoaXMuZ2V0Rmlyc3RTY2FsZUlkRm9ySW5kZXhBeGlzKCk7XG4gICAgZm9yIChjb25zdCBkYXRhc2V0IG9mIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0cykge1xuICAgICAgYXhpc1t2YWx1ZU9yRGVmYXVsdChcbiAgICAgICAgdGhpcy5jaGFydC5vcHRpb25zLmluZGV4QXhpcyA9PT0gJ3gnID8gZGF0YXNldC54QXhpc0lEIDogZGF0YXNldC55QXhpc0lELCBmaXJzdFNjYWxlQXhpc0lkXG4gICAgICApXSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3Qua2V5cyhheGlzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBzdGFjayBpbmRleCBmb3IgdGhlIGdpdmVuIGRhdGFzZXQgYmFzZWQgb24gZ3JvdXBzIGFuZCBiYXIgdmlzaWJpbGl0eS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtkYXRhc2V0SW5kZXhdIC0gVGhlIGRhdGFzZXQgaW5kZXhcblx0ICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lXSAtIFRoZSBzdGFjayBuYW1lIHRvIGZpbmRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtkYXRhSW5kZXhdXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBzdGFjayBpbmRleFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldFN0YWNrSW5kZXgoZGF0YXNldEluZGV4LCBuYW1lLCBkYXRhSW5kZXgpIHtcbiAgICBjb25zdCBzdGFja3MgPSB0aGlzLl9nZXRTdGFja3MoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgpO1xuICAgIGNvbnN0IGluZGV4ID0gKG5hbWUgIT09IHVuZGVmaW5lZClcbiAgICAgID8gc3RhY2tzLmluZGV4T2YobmFtZSlcbiAgICAgIDogLTE7IC8vIGluZGV4T2YgcmV0dXJucyAtMSBpZiBlbGVtZW50IGlzIG5vdCBwcmVzZW50XG5cbiAgICByZXR1cm4gKGluZGV4ID09PSAtMSlcbiAgICAgID8gc3RhY2tzLmxlbmd0aCAtIDFcbiAgICAgIDogaW5kZXg7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRSdWxlcigpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGlTY2FsZSA9IG1ldGEuaVNjYWxlO1xuICAgIGNvbnN0IHBpeGVscyA9IFtdO1xuICAgIGxldCBpLCBpbGVuO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IG1ldGEuZGF0YS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHBpeGVscy5wdXNoKGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHRoaXMuZ2V0UGFyc2VkKGkpW2lTY2FsZS5heGlzXSwgaSkpO1xuICAgIH1cblxuICAgIGNvbnN0IGJhclRoaWNrbmVzcyA9IG9wdHMuYmFyVGhpY2tuZXNzO1xuICAgIGNvbnN0IG1pbiA9IGJhclRoaWNrbmVzcyB8fCBjb21wdXRlTWluU2FtcGxlU2l6ZShtZXRhKTtcblxuICAgIHJldHVybiB7XG4gICAgICBtaW4sXG4gICAgICBwaXhlbHMsXG4gICAgICBzdGFydDogaVNjYWxlLl9zdGFydFBpeGVsLFxuICAgICAgZW5kOiBpU2NhbGUuX2VuZFBpeGVsLFxuICAgICAgc3RhY2tDb3VudDogdGhpcy5fZ2V0U3RhY2tDb3VudCgpLFxuICAgICAgc2NhbGU6IGlTY2FsZSxcbiAgICAgIGdyb3VwZWQ6IG9wdHMuZ3JvdXBlZCxcbiAgICAgIC8vIGJhciB0aGlja25lc3MgcmF0aW8gdXNlZCBmb3Igbm9uLWdyb3VwZWQgYmFyc1xuICAgICAgcmF0aW86IGJhclRoaWNrbmVzcyA/IDEgOiBvcHRzLmNhdGVnb3J5UGVyY2VudGFnZSAqIG9wdHMuYmFyUGVyY2VudGFnZVxuICAgIH07XG4gIH1cblxuICAvKipcblx0ICogTm90ZTogcGl4ZWwgdmFsdWVzIGFyZSBub3QgY2xhbXBlZCB0byB0aGUgc2NhbGUgYXJlYS5cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9jYWxjdWxhdGVCYXJWYWx1ZVBpeGVscyhpbmRleCkge1xuICAgIGNvbnN0IHtfY2FjaGVkTWV0YToge3ZTY2FsZSwgX3N0YWNrZWQsIGluZGV4OiBkYXRhc2V0SW5kZXh9LCBvcHRpb25zOiB7YmFzZTogYmFzZVZhbHVlLCBtaW5CYXJMZW5ndGh9fSA9IHRoaXM7XG4gICAgY29uc3QgYWN0dWFsQmFzZSA9IGJhc2VWYWx1ZSB8fCAwO1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICBjb25zdCBjdXN0b20gPSBwYXJzZWQuX2N1c3RvbTtcbiAgICBjb25zdCBmbG9hdGluZyA9IGlzRmxvYXRCYXIoY3VzdG9tKTtcbiAgICBsZXQgdmFsdWUgPSBwYXJzZWRbdlNjYWxlLmF4aXNdO1xuICAgIGxldCBzdGFydCA9IDA7XG4gICAgbGV0IGxlbmd0aCA9IF9zdGFja2VkID8gdGhpcy5hcHBseVN0YWNrKHZTY2FsZSwgcGFyc2VkLCBfc3RhY2tlZCkgOiB2YWx1ZTtcbiAgICBsZXQgaGVhZCwgc2l6ZTtcblxuICAgIGlmIChsZW5ndGggIT09IHZhbHVlKSB7XG4gICAgICBzdGFydCA9IGxlbmd0aCAtIHZhbHVlO1xuICAgICAgbGVuZ3RoID0gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKGZsb2F0aW5nKSB7XG4gICAgICB2YWx1ZSA9IGN1c3RvbS5iYXJTdGFydDtcbiAgICAgIGxlbmd0aCA9IGN1c3RvbS5iYXJFbmQgLSBjdXN0b20uYmFyU3RhcnQ7XG4gICAgICAvLyBiYXJzIGNyb3NzaW5nIG9yaWdpbiBhcmUgbm90IHN0YWNrZWRcbiAgICAgIGlmICh2YWx1ZSAhPT0gMCAmJiBzaWduKHZhbHVlKSAhPT0gc2lnbihjdXN0b20uYmFyRW5kKSkge1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICB9XG4gICAgICBzdGFydCArPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBzdGFydFZhbHVlID0gIWlzTnVsbE9yVW5kZWYoYmFzZVZhbHVlKSAmJiAhZmxvYXRpbmcgPyBiYXNlVmFsdWUgOiBzdGFydDtcbiAgICBsZXQgYmFzZSA9IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHN0YXJ0VmFsdWUpO1xuXG4gICAgaWYgKHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaW5kZXgpKSB7XG4gICAgICBoZWFkID0gdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoc3RhcnQgKyBsZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXaGVuIG5vdCB2aXNpYmxlLCBubyBoZWlnaHRcbiAgICAgIGhlYWQgPSBiYXNlO1xuICAgIH1cblxuICAgIHNpemUgPSBoZWFkIC0gYmFzZTtcblxuICAgIGlmIChNYXRoLmFicyhzaXplKSA8IG1pbkJhckxlbmd0aCkge1xuICAgICAgc2l6ZSA9IGJhclNpZ24oc2l6ZSwgdlNjYWxlLCBhY3R1YWxCYXNlKSAqIG1pbkJhckxlbmd0aDtcbiAgICAgIGlmICh2YWx1ZSA9PT0gYWN0dWFsQmFzZSkge1xuICAgICAgICBiYXNlIC09IHNpemUgLyAyO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhcnRQaXhlbCA9IHZTY2FsZS5nZXRQaXhlbEZvckRlY2ltYWwoMCk7XG4gICAgICBjb25zdCBlbmRQaXhlbCA9IHZTY2FsZS5nZXRQaXhlbEZvckRlY2ltYWwoMSk7XG4gICAgICBjb25zdCBtaW4gPSBNYXRoLm1pbihzdGFydFBpeGVsLCBlbmRQaXhlbCk7XG4gICAgICBjb25zdCBtYXggPSBNYXRoLm1heChzdGFydFBpeGVsLCBlbmRQaXhlbCk7XG4gICAgICBiYXNlID0gTWF0aC5tYXgoTWF0aC5taW4oYmFzZSwgbWF4KSwgbWluKTtcbiAgICAgIGhlYWQgPSBiYXNlICsgc2l6ZTtcblxuICAgICAgaWYgKF9zdGFja2VkICYmICFmbG9hdGluZykge1xuICAgICAgICAvLyB2aXN1YWwgZGF0YSBjb29yZGluYXRlcyBhZnRlciBhcHBseWluZyBtaW5CYXJMZW5ndGhcbiAgICAgICAgcGFyc2VkLl9zdGFja3NbdlNjYWxlLmF4aXNdLl92aXN1YWxWYWx1ZXNbZGF0YXNldEluZGV4XSA9IHZTY2FsZS5nZXRWYWx1ZUZvclBpeGVsKGhlYWQpIC0gdlNjYWxlLmdldFZhbHVlRm9yUGl4ZWwoYmFzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGJhc2UgPT09IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKGFjdHVhbEJhc2UpKSB7XG4gICAgICBjb25zdCBoYWxmR3JpZCA9IHNpZ24oc2l6ZSkgKiB2U2NhbGUuZ2V0TGluZVdpZHRoRm9yVmFsdWUoYWN0dWFsQmFzZSkgLyAyO1xuICAgICAgYmFzZSArPSBoYWxmR3JpZDtcbiAgICAgIHNpemUgLT0gaGFsZkdyaWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHNpemUsXG4gICAgICBiYXNlLFxuICAgICAgaGVhZCxcbiAgICAgIGNlbnRlcjogaGVhZCArIHNpemUgLyAyXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2NhbGN1bGF0ZUJhckluZGV4UGl4ZWxzKGluZGV4LCBydWxlcikge1xuICAgIGNvbnN0IHNjYWxlID0gcnVsZXIuc2NhbGU7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBza2lwTnVsbCA9IG9wdGlvbnMuc2tpcE51bGw7XG4gICAgY29uc3QgbWF4QmFyVGhpY2tuZXNzID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5tYXhCYXJUaGlja25lc3MsIEluZmluaXR5KTtcbiAgICBsZXQgY2VudGVyLCBzaXplO1xuICAgIGNvbnN0IGF4aXNDb3VudCA9IHRoaXMuX2dldEF4aXNDb3VudCgpO1xuICAgIGlmIChydWxlci5ncm91cGVkKSB7XG4gICAgICBjb25zdCBzdGFja0NvdW50ID0gc2tpcE51bGwgPyB0aGlzLl9nZXRTdGFja0NvdW50KGluZGV4KSA6IHJ1bGVyLnN0YWNrQ291bnQ7XG4gICAgICBjb25zdCByYW5nZSA9IG9wdGlvbnMuYmFyVGhpY2tuZXNzID09PSAnZmxleCdcbiAgICAgICAgPyBjb21wdXRlRmxleENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucywgc3RhY2tDb3VudCAqIGF4aXNDb3VudClcbiAgICAgICAgOiBjb21wdXRlRml0Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zLCBzdGFja0NvdW50ICogYXhpc0NvdW50KTtcbiAgICAgIGNvbnN0IGF4aXNJRCA9IHRoaXMuY2hhcnQub3B0aW9ucy5pbmRleEF4aXMgPT09ICd4JyA/IHRoaXMuZ2V0RGF0YXNldCgpLnhBeGlzSUQgOiB0aGlzLmdldERhdGFzZXQoKS55QXhpc0lEO1xuICAgICAgY29uc3QgYXhpc051bWJlciA9IHRoaXMuX2dldEF4aXMoKS5pbmRleE9mKHZhbHVlT3JEZWZhdWx0KGF4aXNJRCwgdGhpcy5nZXRGaXJzdFNjYWxlSWRGb3JJbmRleEF4aXMoKSkpO1xuICAgICAgY29uc3Qgc3RhY2tJbmRleCA9IHRoaXMuX2dldFN0YWNrSW5kZXgodGhpcy5pbmRleCwgdGhpcy5fY2FjaGVkTWV0YS5zdGFjaywgc2tpcE51bGwgPyBpbmRleCA6IHVuZGVmaW5lZCkgKyBheGlzTnVtYmVyO1xuICAgICAgY2VudGVyID0gcmFuZ2Uuc3RhcnQgKyAocmFuZ2UuY2h1bmsgKiBzdGFja0luZGV4KSArIChyYW5nZS5jaHVuayAvIDIpO1xuICAgICAgc2l6ZSA9IE1hdGgubWluKG1heEJhclRoaWNrbmVzcywgcmFuZ2UuY2h1bmsgKiByYW5nZS5yYXRpbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvciBub24tZ3JvdXBlZCBiYXIgY2hhcnRzLCBleGFjdCBwaXhlbCB2YWx1ZXMgYXJlIHVzZWRcbiAgICAgIGNlbnRlciA9IHNjYWxlLmdldFBpeGVsRm9yVmFsdWUodGhpcy5nZXRQYXJzZWQoaW5kZXgpW3NjYWxlLmF4aXNdLCBpbmRleCk7XG4gICAgICBzaXplID0gTWF0aC5taW4obWF4QmFyVGhpY2tuZXNzLCBydWxlci5taW4gKiBydWxlci5yYXRpbyk7XG4gICAgfVxuXG5cbiAgICByZXR1cm4ge1xuICAgICAgYmFzZTogY2VudGVyIC0gc2l6ZSAvIDIsXG4gICAgICBoZWFkOiBjZW50ZXIgKyBzaXplIC8gMixcbiAgICAgIGNlbnRlcixcbiAgICAgIHNpemVcbiAgICB9O1xuICB9XG5cbiAgZHJhdygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB2U2NhbGUgPSBtZXRhLnZTY2FsZTtcbiAgICBjb25zdCByZWN0cyA9IG1ldGEuZGF0YTtcbiAgICBjb25zdCBpbGVuID0gcmVjdHMubGVuZ3RoO1xuICAgIGxldCBpID0gMDtcblxuICAgIGZvciAoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpZiAodGhpcy5nZXRQYXJzZWQoaSlbdlNjYWxlLmF4aXNdICE9PSBudWxsICYmICFyZWN0c1tpXS5oaWRkZW4pIHtcbiAgICAgICAgcmVjdHNbaV0uZHJhdyh0aGlzLl9jdHgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59XG4iLCJpbXBvcnQgRGF0YXNldENvbnRyb2xsZXIgZnJvbSAnLi4vY29yZS9jb3JlLmRhdGFzZXRDb250cm9sbGVyLmpzJztcbmltcG9ydCB7dmFsdWVPckRlZmF1bHR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnViYmxlQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcblxuICBzdGF0aWMgaWQgPSAnYnViYmxlJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBkYXRhc2V0RWxlbWVudFR5cGU6IGZhbHNlLFxuICAgIGRhdGFFbGVtZW50VHlwZTogJ3BvaW50JyxcblxuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIG51bWJlcnM6IHtcbiAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgIHByb3BlcnRpZXM6IFsneCcsICd5JywgJ2JvcmRlcldpZHRoJywgJ3JhZGl1cyddXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIG92ZXJyaWRlcyA9IHtcbiAgICBzY2FsZXM6IHtcbiAgICAgIHg6IHtcbiAgICAgICAgdHlwZTogJ2xpbmVhcidcbiAgICAgIH0sXG4gICAgICB5OiB7XG4gICAgICAgIHR5cGU6ICdsaW5lYXInXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gdHJ1ZTtcbiAgICBzdXBlci5pbml0aWFsaXplKCk7XG4gIH1cblxuICAvKipcblx0ICogUGFyc2UgYXJyYXkgb2YgcHJpbWl0aXZlIHZhbHVlc1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBwYXJzZVByaW1pdGl2ZURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3QgcGFyc2VkID0gc3VwZXIucGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJzZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBhcnNlZFtpXS5fY3VzdG9tID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkgKyBzdGFydCkucmFkaXVzO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgLyoqXG5cdCAqIFBhcnNlIGFycmF5IG9mIGFycmF5c1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBwYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBzdXBlci5wYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyc2VkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpdGVtID0gZGF0YVtzdGFydCArIGldO1xuICAgICAgcGFyc2VkW2ldLl9jdXN0b20gPSB2YWx1ZU9yRGVmYXVsdChpdGVtWzJdLCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSArIHN0YXJ0KS5yYWRpdXMpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgLyoqXG5cdCAqIFBhcnNlIGFycmF5IG9mIG9iamVjdHNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHN1cGVyLnBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyc2VkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpdGVtID0gZGF0YVtzdGFydCArIGldO1xuICAgICAgcGFyc2VkW2ldLl9jdXN0b20gPSB2YWx1ZU9yRGVmYXVsdChpdGVtICYmIGl0ZW0uciAmJiAraXRlbS5yLCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSArIHN0YXJ0KS5yYWRpdXMpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldE1heE92ZXJmbG93KCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGE7XG5cbiAgICBsZXQgbWF4ID0gMDtcbiAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBkYXRhW2ldLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkpKSAvIDIpO1xuICAgIH1cbiAgICByZXR1cm4gbWF4ID4gMCAmJiBtYXg7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuY2hhcnQuZGF0YS5sYWJlbHMgfHwgW107XG4gICAgY29uc3Qge3hTY2FsZSwgeVNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIGNvbnN0IHggPSB4U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWQueCk7XG4gICAgY29uc3QgeSA9IHlTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZC55KTtcbiAgICBjb25zdCByID0gcGFyc2VkLl9jdXN0b207XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IGxhYmVsc1tpbmRleF0gfHwgJycsXG4gICAgICB2YWx1ZTogJygnICsgeCArICcsICcgKyB5ICsgKHIgPyAnLCAnICsgciA6ICcnKSArICcpJ1xuICAgIH07XG4gIH1cblxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YTtcblxuICAgIC8vIFVwZGF0ZSBQb2ludHNcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKHBvaW50cywgMCwgcG9pbnRzLmxlbmd0aCwgbW9kZSk7XG4gIH1cblxuICB1cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGV9ID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB7c2hhcmVkT3B0aW9ucywgaW5jbHVkZU9wdGlvbnN9ID0gdGhpcy5fZ2V0U2hhcmVkT3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcbiAgICBjb25zdCB2QXhpcyA9IHZTY2FsZS5heGlzO1xuXG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnN0IHBhcnNlZCA9ICFyZXNldCAmJiB0aGlzLmdldFBhcnNlZChpKTtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7fTtcbiAgICAgIGNvbnN0IGlQaXhlbCA9IHByb3BlcnRpZXNbaUF4aXNdID0gcmVzZXQgPyBpU2NhbGUuZ2V0UGl4ZWxGb3JEZWNpbWFsKDAuNSkgOiBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShwYXJzZWRbaUF4aXNdKTtcbiAgICAgIGNvbnN0IHZQaXhlbCA9IHByb3BlcnRpZXNbdkF4aXNdID0gcmVzZXQgPyB2U2NhbGUuZ2V0QmFzZVBpeGVsKCkgOiB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShwYXJzZWRbdkF4aXNdKTtcblxuICAgICAgcHJvcGVydGllcy5za2lwID0gaXNOYU4oaVBpeGVsKSB8fCBpc05hTih2UGl4ZWwpO1xuXG4gICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gc2hhcmVkT3B0aW9ucyB8fCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgcG9pbnQuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcblxuICAgICAgICBpZiAocmVzZXQpIHtcbiAgICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMucmFkaXVzID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQocG9pbnQsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcblx0ICogQHBhcmFtIHtzdHJpbmd9IFttb2RlXVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICByZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4LCBtb2RlKSB7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIGxldCB2YWx1ZXMgPSBzdXBlci5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4LCBtb2RlKTtcblxuICAgIC8vIEluIGNhc2UgdmFsdWVzIHdlcmUgY2FjaGVkIChhbmQgdGh1cyBmcm96ZW4pLCB3ZSBuZWVkIHRvIGNsb25lIHRoZSB2YWx1ZXNcbiAgICBpZiAodmFsdWVzLiRzaGFyZWQpIHtcbiAgICAgIHZhbHVlcyA9IE9iamVjdC5hc3NpZ24oe30sIHZhbHVlcywgeyRzaGFyZWQ6IGZhbHNlfSk7XG4gICAgfVxuXG4gICAgLy8gQ3VzdG9tIHJhZGl1cyByZXNvbHV0aW9uXG4gICAgY29uc3QgcmFkaXVzID0gdmFsdWVzLnJhZGl1cztcbiAgICBpZiAobW9kZSAhPT0gJ2FjdGl2ZScpIHtcbiAgICAgIHZhbHVlcy5yYWRpdXMgPSAwO1xuICAgIH1cbiAgICB2YWx1ZXMucmFkaXVzICs9IHZhbHVlT3JEZWZhdWx0KHBhcnNlZCAmJiBwYXJzZWQuX2N1c3RvbSwgcmFkaXVzKTtcblxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cbn1cbiIsImltcG9ydCBEYXRhc2V0Q29udHJvbGxlciBmcm9tICcuLi9jb3JlL2NvcmUuZGF0YXNldENvbnRyb2xsZXIuanMnO1xuaW1wb3J0IHtpc09iamVjdCwgcmVzb2x2ZU9iamVjdEtleSwgdG9QZXJjZW50YWdlLCB0b0RpbWVuc2lvbiwgdmFsdWVPckRlZmF1bHR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7Zm9ybWF0TnVtYmVyfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuaW50bC5qcyc7XG5pbXBvcnQge3RvUmFkaWFucywgUEksIFRBVSwgSEFMRl9QSSwgX2FuZ2xlQmV0d2Vlbn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9jb3JlL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICovXG5cbmZ1bmN0aW9uIGdldFJhdGlvQW5kT2Zmc2V0KHJvdGF0aW9uLCBjaXJjdW1mZXJlbmNlLCBjdXRvdXQpIHtcbiAgbGV0IHJhdGlvWCA9IDE7XG4gIGxldCByYXRpb1kgPSAxO1xuICBsZXQgb2Zmc2V0WCA9IDA7XG4gIGxldCBvZmZzZXRZID0gMDtcbiAgLy8gSWYgdGhlIGNoYXJ0J3MgY2lyY3VtZmVyZW5jZSBpc24ndCBhIGZ1bGwgY2lyY2xlLCBjYWxjdWxhdGUgc2l6ZSBhcyBhIHJhdGlvIG9mIHRoZSB3aWR0aC9oZWlnaHQgb2YgdGhlIGFyY1xuICBpZiAoY2lyY3VtZmVyZW5jZSA8IFRBVSkge1xuICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSByb3RhdGlvbjtcbiAgICBjb25zdCBlbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBjaXJjdW1mZXJlbmNlO1xuICAgIGNvbnN0IHN0YXJ0WCA9IE1hdGguY29zKHN0YXJ0QW5nbGUpO1xuICAgIGNvbnN0IHN0YXJ0WSA9IE1hdGguc2luKHN0YXJ0QW5nbGUpO1xuICAgIGNvbnN0IGVuZFggPSBNYXRoLmNvcyhlbmRBbmdsZSk7XG4gICAgY29uc3QgZW5kWSA9IE1hdGguc2luKGVuZEFuZ2xlKTtcbiAgICBjb25zdCBjYWxjTWF4ID0gKGFuZ2xlLCBhLCBiKSA9PiBfYW5nbGVCZXR3ZWVuKGFuZ2xlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgdHJ1ZSkgPyAxIDogTWF0aC5tYXgoYSwgYSAqIGN1dG91dCwgYiwgYiAqIGN1dG91dCk7XG4gICAgY29uc3QgY2FsY01pbiA9IChhbmdsZSwgYSwgYikgPT4gX2FuZ2xlQmV0d2VlbihhbmdsZSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIHRydWUpID8gLTEgOiBNYXRoLm1pbihhLCBhICogY3V0b3V0LCBiLCBiICogY3V0b3V0KTtcbiAgICBjb25zdCBtYXhYID0gY2FsY01heCgwLCBzdGFydFgsIGVuZFgpO1xuICAgIGNvbnN0IG1heFkgPSBjYWxjTWF4KEhBTEZfUEksIHN0YXJ0WSwgZW5kWSk7XG4gICAgY29uc3QgbWluWCA9IGNhbGNNaW4oUEksIHN0YXJ0WCwgZW5kWCk7XG4gICAgY29uc3QgbWluWSA9IGNhbGNNaW4oUEkgKyBIQUxGX1BJLCBzdGFydFksIGVuZFkpO1xuICAgIHJhdGlvWCA9IChtYXhYIC0gbWluWCkgLyAyO1xuICAgIHJhdGlvWSA9IChtYXhZIC0gbWluWSkgLyAyO1xuICAgIG9mZnNldFggPSAtKG1heFggKyBtaW5YKSAvIDI7XG4gICAgb2Zmc2V0WSA9IC0obWF4WSArIG1pblkpIC8gMjtcbiAgfVxuICByZXR1cm4ge3JhdGlvWCwgcmF0aW9ZLCBvZmZzZXRYLCBvZmZzZXRZfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRG91Z2hudXRDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuXG4gIHN0YXRpYyBpZCA9ICdkb3VnaG51dCc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgZGF0YXNldEVsZW1lbnRUeXBlOiBmYWxzZSxcbiAgICBkYXRhRWxlbWVudFR5cGU6ICdhcmMnLFxuICAgIGFuaW1hdGlvbjoge1xuICAgICAgLy8gQm9vbGVhbiAtIFdoZXRoZXIgd2UgYW5pbWF0ZSB0aGUgcm90YXRpb24gb2YgdGhlIERvdWdobnV0XG4gICAgICBhbmltYXRlUm90YXRlOiB0cnVlLFxuICAgICAgLy8gQm9vbGVhbiAtIFdoZXRoZXIgd2UgYW5pbWF0ZSBzY2FsaW5nIHRoZSBEb3VnaG51dCBmcm9tIHRoZSBjZW50cmVcbiAgICAgIGFuaW1hdGVTY2FsZTogZmFsc2VcbiAgICB9LFxuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIG51bWJlcnM6IHtcbiAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgIHByb3BlcnRpZXM6IFsnY2lyY3VtZmVyZW5jZScsICdlbmRBbmdsZScsICdpbm5lclJhZGl1cycsICdvdXRlclJhZGl1cycsICdzdGFydEFuZ2xlJywgJ3gnLCAneScsICdvZmZzZXQnLCAnYm9yZGVyV2lkdGgnLCAnc3BhY2luZyddXG4gICAgICB9LFxuICAgIH0sXG4gICAgLy8gVGhlIHBlcmNlbnRhZ2Ugb2YgdGhlIGNoYXJ0IHRoYXQgd2UgY3V0IG91dCBvZiB0aGUgbWlkZGxlLlxuICAgIGN1dG91dDogJzUwJScsXG5cbiAgICAvLyBUaGUgcm90YXRpb24gb2YgdGhlIGNoYXJ0LCB3aGVyZSB0aGUgZmlyc3QgZGF0YSBhcmMgYmVnaW5zLlxuICAgIHJvdGF0aW9uOiAwLFxuXG4gICAgLy8gVGhlIHRvdGFsIGNpcmN1bWZlcmVuY2Ugb2YgdGhlIGNoYXJ0LlxuICAgIGNpcmN1bWZlcmVuY2U6IDM2MCxcblxuICAgIC8vIFRoZSBvdXRlciByYWRpdXMgb2YgdGhlIGNoYXJ0XG4gICAgcmFkaXVzOiAnMTAwJScsXG5cbiAgICAvLyBTcGFjaW5nIGJldHdlZW4gYXJjc1xuICAgIHNwYWNpbmc6IDAsXG5cbiAgICBpbmRleEF4aXM6ICdyJyxcbiAgfTtcblxuICBzdGF0aWMgZGVzY3JpcHRvcnMgPSB7XG4gICAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnc3BhY2luZycsXG4gICAgX2luZGV4YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdzcGFjaW5nJyAmJiAhbmFtZS5zdGFydHNXaXRoKCdib3JkZXJEYXNoJykgJiYgIW5hbWUuc3RhcnRzV2l0aCgnaG92ZXJCb3JkZXJEYXNoJyksXG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgb3ZlcnJpZGVzID0ge1xuICAgIGFzcGVjdFJhdGlvOiAxLFxuXG4gICAgLy8gTmVlZCB0byBvdmVycmlkZSB0aGVzZSB0byBnaXZlIGEgbmljZSBkZWZhdWx0XG4gICAgcGx1Z2luczoge1xuICAgICAgbGVnZW5kOiB7XG4gICAgICAgIGxhYmVsczoge1xuICAgICAgICAgIGdlbmVyYXRlTGFiZWxzKGNoYXJ0KSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gY2hhcnQuZGF0YTtcbiAgICAgICAgICAgIGNvbnN0IHtsYWJlbHM6IHtwb2ludFN0eWxlLCB0ZXh0QWxpZ24sIGNvbG9yLCB1c2VCb3JkZXJSYWRpdXMsIGJvcmRlclJhZGl1c319ID0gY2hhcnQubGVnZW5kLm9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoZGF0YS5sYWJlbHMubGVuZ3RoICYmIGRhdGEuZGF0YXNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkYXRhLmxhYmVscy5tYXAoKGxhYmVsLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKDApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKGkpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIHRleHQ6IGxhYmVsLFxuICAgICAgICAgICAgICAgICAgZmlsbFN0eWxlOiBzdHlsZS5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICAgICAgICBmb250Q29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgICAgICAgaGlkZGVuOiAhY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSksXG4gICAgICAgICAgICAgICAgICBsaW5lRGFzaDogc3R5bGUuYm9yZGVyRGFzaCxcbiAgICAgICAgICAgICAgICAgIGxpbmVEYXNoT2Zmc2V0OiBzdHlsZS5ib3JkZXJEYXNoT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgbGluZUpvaW46IHN0eWxlLmJvcmRlckpvaW5TdHlsZSxcbiAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogc3R5bGUuYm9yZGVyV2lkdGgsXG4gICAgICAgICAgICAgICAgICBzdHJva2VTdHlsZTogc3R5bGUuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICAgICAgICAgICAgICAgIHBvaW50U3R5bGU6IHBvaW50U3R5bGUsXG4gICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IHVzZUJvcmRlclJhZGl1cyAmJiAoYm9yZGVyUmFkaXVzIHx8IHN0eWxlLmJvcmRlclJhZGl1cyksXG4gICAgICAgICAgICAgICAgICAvLyBFeHRyYSBkYXRhIHVzZWQgZm9yIHRvZ2dsaW5nIHRoZSBjb3JyZWN0IGl0ZW1cbiAgICAgICAgICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uQ2xpY2soZSwgbGVnZW5kSXRlbSwgbGVnZW5kKSB7XG4gICAgICAgICAgbGVnZW5kLmNoYXJ0LnRvZ2dsZURhdGFWaXNpYmlsaXR5KGxlZ2VuZEl0ZW0uaW5kZXgpO1xuICAgICAgICAgIGxlZ2VuZC5jaGFydC51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBjb25zdHJ1Y3RvcihjaGFydCwgZGF0YXNldEluZGV4KSB7XG4gICAgc3VwZXIoY2hhcnQsIGRhdGFzZXRJbmRleCk7XG5cbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSB0cnVlO1xuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9mZnNldFggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vZmZzZXRZID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgbGlua1NjYWxlcygpIHt9XG5cbiAgLyoqXG5cdCAqIE92ZXJyaWRlIGRhdGEgcGFyc2luZywgc2luY2Ugd2UgYXJlIG5vdCB1c2luZyBzY2FsZXNcblx0ICovXG4gIHBhcnNlKHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmdldERhdGFzZXQoKS5kYXRhO1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuXG4gICAgaWYgKHRoaXMuX3BhcnNpbmcgPT09IGZhbHNlKSB7XG4gICAgICBtZXRhLl9wYXJzZWQgPSBkYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZ2V0dGVyID0gKGkpID0+ICtkYXRhW2ldO1xuXG4gICAgICBpZiAoaXNPYmplY3QoZGF0YVtzdGFydF0pKSB7XG4gICAgICAgIGNvbnN0IHtrZXkgPSAndmFsdWUnfSA9IHRoaXMuX3BhcnNpbmc7XG4gICAgICAgIGdldHRlciA9IChpKSA9PiArcmVzb2x2ZU9iamVjdEtleShkYXRhW2ldLCBrZXkpO1xuICAgICAgfVxuXG4gICAgICBsZXQgaSwgaWxlbjtcbiAgICAgIGZvciAoaSA9IHN0YXJ0LCBpbGVuID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgICBtZXRhLl9wYXJzZWRbaV0gPSBnZXR0ZXIoaSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0Um90YXRpb24oKSB7XG4gICAgcmV0dXJuIHRvUmFkaWFucyh0aGlzLm9wdGlvbnMucm90YXRpb24gLSA5MCk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRDaXJjdW1mZXJlbmNlKCkge1xuICAgIHJldHVybiB0b1JhZGlhbnModGhpcy5vcHRpb25zLmNpcmN1bWZlcmVuY2UpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEdldCB0aGUgbWF4aW1hbCByb3RhdGlvbiAmIGNpcmN1bWZlcmVuY2UgZXh0ZW50c1xuXHQgKiBhY3Jvc3MgYWxsIHZpc2libGUgZGF0YXNldHMuXG5cdCAqL1xuICBfZ2V0Um90YXRpb25FeHRlbnRzKCkge1xuICAgIGxldCBtaW4gPSBUQVU7XG4gICAgbGV0IG1heCA9IC1UQVU7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKHRoaXMuY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSAmJiB0aGlzLmNoYXJ0LmdldERhdGFzZXRNZXRhKGkpLnR5cGUgPT09IHRoaXMuX3R5cGUpIHtcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSkuY29udHJvbGxlcjtcbiAgICAgICAgY29uc3Qgcm90YXRpb24gPSBjb250cm9sbGVyLl9nZXRSb3RhdGlvbigpO1xuICAgICAgICBjb25zdCBjaXJjdW1mZXJlbmNlID0gY29udHJvbGxlci5fZ2V0Q2lyY3VtZmVyZW5jZSgpO1xuXG4gICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgcm90YXRpb24pO1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIHJvdGF0aW9uICsgY2lyY3VtZmVyZW5jZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHJvdGF0aW9uOiBtaW4sXG4gICAgICBjaXJjdW1mZXJlbmNlOiBtYXggLSBtaW4sXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbW9kZVxuXHQgKi9cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3Qge2NoYXJ0QXJlYX0gPSBjaGFydDtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBhcmNzID0gbWV0YS5kYXRhO1xuICAgIGNvbnN0IHNwYWNpbmcgPSB0aGlzLmdldE1heEJvcmRlcldpZHRoKCkgKyB0aGlzLmdldE1heE9mZnNldChhcmNzKSArIHRoaXMub3B0aW9ucy5zcGFjaW5nO1xuICAgIGNvbnN0IG1heFNpemUgPSBNYXRoLm1heCgoTWF0aC5taW4oY2hhcnRBcmVhLndpZHRoLCBjaGFydEFyZWEuaGVpZ2h0KSAtIHNwYWNpbmcpIC8gMiwgMCk7XG4gICAgY29uc3QgY3V0b3V0ID0gTWF0aC5taW4odG9QZXJjZW50YWdlKHRoaXMub3B0aW9ucy5jdXRvdXQsIG1heFNpemUpLCAxKTtcbiAgICBjb25zdCBjaGFydFdlaWdodCA9IHRoaXMuX2dldFJpbmdXZWlnaHQodGhpcy5pbmRleCk7XG5cbiAgICAvLyBDb21wdXRlIHRoZSBtYXhpbWFsIHJvdGF0aW9uICYgY2lyY3VtZmVyZW5jZSBsaW1pdHMuXG4gICAgLy8gSWYgd2Ugb25seSBjb25zaWRlciBvdXIgZGF0YXNldCwgdGhpcyBjYW4gY2F1c2UgcHJvYmxlbXMgd2hlbiB0d28gZGF0YXNldHNcbiAgICAvLyBhcmUgYm90aCBsZXNzIHRoYW4gYSBjaXJjbGUgd2l0aCBkaWZmZXJlbnQgcm90YXRpb25zIChzdGFydGluZyBhbmdsZXMpXG4gICAgY29uc3Qge2NpcmN1bWZlcmVuY2UsIHJvdGF0aW9ufSA9IHRoaXMuX2dldFJvdGF0aW9uRXh0ZW50cygpO1xuICAgIGNvbnN0IHtyYXRpb1gsIHJhdGlvWSwgb2Zmc2V0WCwgb2Zmc2V0WX0gPSBnZXRSYXRpb0FuZE9mZnNldChyb3RhdGlvbiwgY2lyY3VtZmVyZW5jZSwgY3V0b3V0KTtcbiAgICBjb25zdCBtYXhXaWR0aCA9IChjaGFydEFyZWEud2lkdGggLSBzcGFjaW5nKSAvIHJhdGlvWDtcbiAgICBjb25zdCBtYXhIZWlnaHQgPSAoY2hhcnRBcmVhLmhlaWdodCAtIHNwYWNpbmcpIC8gcmF0aW9ZO1xuICAgIGNvbnN0IG1heFJhZGl1cyA9IE1hdGgubWF4KE1hdGgubWluKG1heFdpZHRoLCBtYXhIZWlnaHQpIC8gMiwgMCk7XG4gICAgY29uc3Qgb3V0ZXJSYWRpdXMgPSB0b0RpbWVuc2lvbih0aGlzLm9wdGlvbnMucmFkaXVzLCBtYXhSYWRpdXMpO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gTWF0aC5tYXgob3V0ZXJSYWRpdXMgKiBjdXRvdXQsIDApO1xuICAgIGNvbnN0IHJhZGl1c0xlbmd0aCA9IChvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzKSAvIHRoaXMuX2dldFZpc2libGVEYXRhc2V0V2VpZ2h0VG90YWwoKTtcbiAgICB0aGlzLm9mZnNldFggPSBvZmZzZXRYICogb3V0ZXJSYWRpdXM7XG4gICAgdGhpcy5vZmZzZXRZID0gb2Zmc2V0WSAqIG91dGVyUmFkaXVzO1xuXG4gICAgbWV0YS50b3RhbCA9IHRoaXMuY2FsY3VsYXRlVG90YWwoKTtcblxuICAgIHRoaXMub3V0ZXJSYWRpdXMgPSBvdXRlclJhZGl1cyAtIHJhZGl1c0xlbmd0aCAqIHRoaXMuX2dldFJpbmdXZWlnaHRPZmZzZXQodGhpcy5pbmRleCk7XG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IE1hdGgubWF4KHRoaXMub3V0ZXJSYWRpdXMgLSByYWRpdXNMZW5ndGggKiBjaGFydFdlaWdodCwgMCk7XG5cbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKGFyY3MsIDAsIGFyY3MubGVuZ3RoLCBtb2RlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NpcmN1bWZlcmVuY2UoaSwgcmVzZXQpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGNpcmN1bWZlcmVuY2UgPSB0aGlzLl9nZXRDaXJjdW1mZXJlbmNlKCk7XG4gICAgaWYgKChyZXNldCAmJiBvcHRzLmFuaW1hdGlvbi5hbmltYXRlUm90YXRlKSB8fCAhdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSB8fCBtZXRhLl9wYXJzZWRbaV0gPT09IG51bGwgfHwgbWV0YS5kYXRhW2ldLmhpZGRlbikge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNhbGN1bGF0ZUNpcmN1bWZlcmVuY2UobWV0YS5fcGFyc2VkW2ldICogY2lyY3VtZmVyZW5jZSAvIFRBVSk7XG4gIH1cblxuICB1cGRhdGVFbGVtZW50cyhhcmNzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGNoYXJ0QXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcbiAgICBjb25zdCBvcHRzID0gY2hhcnQub3B0aW9ucztcbiAgICBjb25zdCBhbmltYXRpb25PcHRzID0gb3B0cy5hbmltYXRpb247XG4gICAgY29uc3QgY2VudGVyWCA9IChjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS5yaWdodCkgLyAyO1xuICAgIGNvbnN0IGNlbnRlclkgPSAoY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5ib3R0b20pIC8gMjtcbiAgICBjb25zdCBhbmltYXRlU2NhbGUgPSByZXNldCAmJiBhbmltYXRpb25PcHRzLmFuaW1hdGVTY2FsZTtcbiAgICBjb25zdCBpbm5lclJhZGl1cyA9IGFuaW1hdGVTY2FsZSA/IDAgOiB0aGlzLmlubmVyUmFkaXVzO1xuICAgIGNvbnN0IG91dGVyUmFkaXVzID0gYW5pbWF0ZVNjYWxlID8gMCA6IHRoaXMub3V0ZXJSYWRpdXM7XG4gICAgY29uc3Qge3NoYXJlZE9wdGlvbnMsIGluY2x1ZGVPcHRpb25zfSA9IHRoaXMuX2dldFNoYXJlZE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuICAgIGxldCBzdGFydEFuZ2xlID0gdGhpcy5fZ2V0Um90YXRpb24oKTtcbiAgICBsZXQgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzdGFydDsgKytpKSB7XG4gICAgICBzdGFydEFuZ2xlICs9IHRoaXMuX2NpcmN1bWZlcmVuY2UoaSwgcmVzZXQpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgKytpKSB7XG4gICAgICBjb25zdCBjaXJjdW1mZXJlbmNlID0gdGhpcy5fY2lyY3VtZmVyZW5jZShpLCByZXNldCk7XG4gICAgICBjb25zdCBhcmMgPSBhcmNzW2ldO1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgICAgeDogY2VudGVyWCArIHRoaXMub2Zmc2V0WCxcbiAgICAgICAgeTogY2VudGVyWSArIHRoaXMub2Zmc2V0WSxcbiAgICAgICAgc3RhcnRBbmdsZSxcbiAgICAgICAgZW5kQW5nbGU6IHN0YXJ0QW5nbGUgKyBjaXJjdW1mZXJlbmNlLFxuICAgICAgICBjaXJjdW1mZXJlbmNlLFxuICAgICAgICBvdXRlclJhZGl1cyxcbiAgICAgICAgaW5uZXJSYWRpdXNcbiAgICAgIH07XG4gICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gc2hhcmVkT3B0aW9ucyB8fCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgYXJjLmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICB9XG4gICAgICBzdGFydEFuZ2xlICs9IGNpcmN1bWZlcmVuY2U7XG5cbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChhcmMsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGNhbGN1bGF0ZVRvdGFsKCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IG1ldGFEYXRhID0gbWV0YS5kYXRhO1xuICAgIGxldCB0b3RhbCA9IDA7XG4gICAgbGV0IGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbWV0YURhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gbWV0YS5fcGFyc2VkW2ldO1xuICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmICFpc05hTih2YWx1ZSkgJiYgdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSAmJiAhbWV0YURhdGFbaV0uaGlkZGVuKSB7XG4gICAgICAgIHRvdGFsICs9IE1hdGguYWJzKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdG90YWw7XG4gIH1cblxuICBjYWxjdWxhdGVDaXJjdW1mZXJlbmNlKHZhbHVlKSB7XG4gICAgY29uc3QgdG90YWwgPSB0aGlzLl9jYWNoZWRNZXRhLnRvdGFsO1xuICAgIGlmICh0b3RhbCA+IDAgJiYgIWlzTmFOKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIFRBVSAqIChNYXRoLmFicyh2YWx1ZSkgLyB0b3RhbCk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBsYWJlbHMgPSBjaGFydC5kYXRhLmxhYmVscyB8fCBbXTtcbiAgICBjb25zdCB2YWx1ZSA9IGZvcm1hdE51bWJlcihtZXRhLl9wYXJzZWRbaW5kZXhdLCBjaGFydC5vcHRpb25zLmxvY2FsZSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IGxhYmVsc1tpbmRleF0gfHwgJycsXG4gICAgICB2YWx1ZSxcbiAgICB9O1xuICB9XG5cbiAgZ2V0TWF4Qm9yZGVyV2lkdGgoYXJjcykge1xuICAgIGxldCBtYXggPSAwO1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBsZXQgaSwgaWxlbiwgbWV0YSwgY29udHJvbGxlciwgb3B0aW9ucztcblxuICAgIGlmICghYXJjcykge1xuICAgICAgLy8gRmluZCB0aGUgb3V0bW9zdCB2aXNpYmxlIGRhdGFzZXRcbiAgICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgICBpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuICAgICAgICAgIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcbiAgICAgICAgICBhcmNzID0gbWV0YS5kYXRhO1xuICAgICAgICAgIGNvbnRyb2xsZXIgPSBtZXRhLmNvbnRyb2xsZXI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWFyY3MpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBhcmNzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgb3B0aW9ucyA9IGNvbnRyb2xsZXIucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpKTtcbiAgICAgIGlmIChvcHRpb25zLmJvcmRlckFsaWduICE9PSAnaW5uZXInKSB7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgb3B0aW9ucy5ib3JkZXJXaWR0aCB8fCAwLCBvcHRpb25zLmhvdmVyQm9yZGVyV2lkdGggfHwgMCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXg7XG4gIH1cblxuICBnZXRNYXhPZmZzZXQoYXJjcykge1xuICAgIGxldCBtYXggPSAwO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSBhcmNzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpKTtcbiAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgb3B0aW9ucy5vZmZzZXQgfHwgMCwgb3B0aW9ucy5ob3Zlck9mZnNldCB8fCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIG1heDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXQgcmFkaXVzIGxlbmd0aCBvZmZzZXQgb2YgdGhlIGRhdGFzZXQgaW4gcmVsYXRpb24gdG8gdGhlIHZpc2libGUgZGF0YXNldHMgd2VpZ2h0cy4gVGhpcyBhbGxvd3MgZGV0ZXJtaW5pbmcgdGhlIGlubmVyIGFuZCBvdXRlciByYWRpdXMgY29ycmVjdGx5XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0UmluZ1dlaWdodE9mZnNldChkYXRhc2V0SW5kZXgpIHtcbiAgICBsZXQgcmluZ1dlaWdodE9mZnNldCA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFzZXRJbmRleDsgKytpKSB7XG4gICAgICBpZiAodGhpcy5jaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG4gICAgICAgIHJpbmdXZWlnaHRPZmZzZXQgKz0gdGhpcy5fZ2V0UmluZ1dlaWdodChpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmluZ1dlaWdodE9mZnNldDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldFJpbmdXZWlnaHQoZGF0YXNldEluZGV4KSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KHZhbHVlT3JEZWZhdWx0KHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLndlaWdodCwgMSksIDApO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIHN1bSBvZiBhbGwgdmlzaWJsZSBkYXRhIHNldCB3ZWlnaHRzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldFZpc2libGVEYXRhc2V0V2VpZ2h0VG90YWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFJpbmdXZWlnaHRPZmZzZXQodGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aCkgfHwgMTtcbiAgfVxufVxuIiwiaW1wb3J0IERhdGFzZXRDb250cm9sbGVyIGZyb20gJy4uL2NvcmUvY29yZS5kYXRhc2V0Q29udHJvbGxlci5qcyc7XG5pbXBvcnQge2lzTnVsbE9yVW5kZWZ9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IHtpc051bWJlcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IHtfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cywgX3NjYWxlUmFuZ2VzQ2hhbmdlZH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmV4dHJhcy5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpbmVDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuXG4gIHN0YXRpYyBpZCA9ICdsaW5lJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBkYXRhc2V0RWxlbWVudFR5cGU6ICdsaW5lJyxcbiAgICBkYXRhRWxlbWVudFR5cGU6ICdwb2ludCcsXG5cbiAgICBzaG93TGluZTogdHJ1ZSxcbiAgICBzcGFuR2FwczogZmFsc2UsXG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgb3ZlcnJpZGVzID0ge1xuICAgIHNjYWxlczoge1xuICAgICAgX2luZGV4Xzoge1xuICAgICAgICB0eXBlOiAnY2F0ZWdvcnknLFxuICAgICAgfSxcbiAgICAgIF92YWx1ZV86IHtcbiAgICAgICAgdHlwZTogJ2xpbmVhcicsXG4gICAgICB9LFxuICAgIH1cbiAgfTtcblxuICBpbml0aWFsaXplKCkge1xuICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9IHRydWU7XG4gICAgdGhpcy5zdXBwb3J0c0RlY2ltYXRpb24gPSB0cnVlO1xuICAgIHN1cGVyLmluaXRpYWxpemUoKTtcbiAgfVxuXG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3Qge2RhdGFzZXQ6IGxpbmUsIGRhdGE6IHBvaW50cyA9IFtdLCBfZGF0YXNldH0gPSBtZXRhO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBhbmltYXRpb25zRGlzYWJsZWQgPSB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQ7XG4gICAgbGV0IHtzdGFydCwgY291bnR9ID0gX2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMobWV0YSwgcG9pbnRzLCBhbmltYXRpb25zRGlzYWJsZWQpO1xuXG4gICAgdGhpcy5fZHJhd1N0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5fZHJhd0NvdW50ID0gY291bnQ7XG5cbiAgICBpZiAoX3NjYWxlUmFuZ2VzQ2hhbmdlZChtZXRhKSkge1xuICAgICAgc3RhcnQgPSAwO1xuICAgICAgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBMaW5lXG4gICAgbGluZS5fY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGxpbmUuX2RhdGFzZXRJbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgbGluZS5fZGVjaW1hdGVkID0gISFfZGF0YXNldC5fZGVjaW1hdGVkO1xuICAgIGxpbmUucG9pbnRzID0gcG9pbnRzO1xuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMucmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKTtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5zaG93TGluZSkge1xuICAgICAgb3B0aW9ucy5ib3JkZXJXaWR0aCA9IDA7XG4gICAgfVxuICAgIG9wdGlvbnMuc2VnbWVudCA9IHRoaXMub3B0aW9ucy5zZWdtZW50O1xuICAgIHRoaXMudXBkYXRlRWxlbWVudChsaW5lLCB1bmRlZmluZWQsIHtcbiAgICAgIGFuaW1hdGVkOiAhYW5pbWF0aW9uc0Rpc2FibGVkLFxuICAgICAgb3B0aW9uc1xuICAgIH0sIG1vZGUpO1xuXG4gICAgLy8gVXBkYXRlIFBvaW50c1xuICAgIHRoaXMudXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpO1xuICB9XG5cbiAgdXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlLCBfc3RhY2tlZCwgX2RhdGFzZXR9ID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB7c2hhcmVkT3B0aW9ucywgaW5jbHVkZU9wdGlvbnN9ID0gdGhpcy5fZ2V0U2hhcmVkT3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcbiAgICBjb25zdCB2QXhpcyA9IHZTY2FsZS5heGlzO1xuICAgIGNvbnN0IHtzcGFuR2Fwcywgc2VnbWVudH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbWF4R2FwTGVuZ3RoID0gaXNOdW1iZXIoc3BhbkdhcHMpID8gc3BhbkdhcHMgOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgY29uc3QgZGlyZWN0VXBkYXRlID0gdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkIHx8IHJlc2V0IHx8IG1vZGUgPT09ICdub25lJztcbiAgICBjb25zdCBlbmQgPSBzdGFydCArIGNvdW50O1xuICAgIGNvbnN0IHBvaW50c0NvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgICBsZXQgcHJldlBhcnNlZCA9IHN0YXJ0ID4gMCAmJiB0aGlzLmdldFBhcnNlZChzdGFydCAtIDEpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHNDb3VudDsgKytpKSB7XG4gICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBkaXJlY3RVcGRhdGUgPyBwb2ludCA6IHt9O1xuXG4gICAgICBpZiAoaSA8IHN0YXJ0IHx8IGkgPj0gZW5kKSB7XG4gICAgICAgIHByb3BlcnRpZXMuc2tpcCA9IHRydWU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpKTtcbiAgICAgIGNvbnN0IG51bGxEYXRhID0gaXNOdWxsT3JVbmRlZihwYXJzZWRbdkF4aXNdKTtcbiAgICAgIGNvbnN0IGlQaXhlbCA9IHByb3BlcnRpZXNbaUF4aXNdID0gaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUocGFyc2VkW2lBeGlzXSwgaSk7XG4gICAgICBjb25zdCB2UGl4ZWwgPSBwcm9wZXJ0aWVzW3ZBeGlzXSA9IHJlc2V0IHx8IG51bGxEYXRhID8gdlNjYWxlLmdldEJhc2VQaXhlbCgpIDogdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoX3N0YWNrZWQgPyB0aGlzLmFwcGx5U3RhY2sodlNjYWxlLCBwYXJzZWQsIF9zdGFja2VkKSA6IHBhcnNlZFt2QXhpc10sIGkpO1xuXG4gICAgICBwcm9wZXJ0aWVzLnNraXAgPSBpc05hTihpUGl4ZWwpIHx8IGlzTmFOKHZQaXhlbCkgfHwgbnVsbERhdGE7XG4gICAgICBwcm9wZXJ0aWVzLnN0b3AgPSBpID4gMCAmJiAoTWF0aC5hYnMocGFyc2VkW2lBeGlzXSAtIHByZXZQYXJzZWRbaUF4aXNdKSkgPiBtYXhHYXBMZW5ndGg7XG4gICAgICBpZiAoc2VnbWVudCkge1xuICAgICAgICBwcm9wZXJ0aWVzLnBhcnNlZCA9IHBhcnNlZDtcbiAgICAgICAgcHJvcGVydGllcy5yYXcgPSBfZGF0YXNldC5kYXRhW2ldO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gc2hhcmVkT3B0aW9ucyB8fCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgcG9pbnQuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkaXJlY3RVcGRhdGUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50KHBvaW50LCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICAgIH1cblxuICAgICAgcHJldlBhcnNlZCA9IHBhcnNlZDtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZGF0YXNldCA9IG1ldGEuZGF0YXNldDtcbiAgICBjb25zdCBib3JkZXIgPSBkYXRhc2V0Lm9wdGlvbnMgJiYgZGF0YXNldC5vcHRpb25zLmJvcmRlcldpZHRoIHx8IDA7XG4gICAgY29uc3QgZGF0YSA9IG1ldGEuZGF0YSB8fCBbXTtcbiAgICBpZiAoIWRhdGEubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gYm9yZGVyO1xuICAgIH1cbiAgICBjb25zdCBmaXJzdFBvaW50ID0gZGF0YVswXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucygwKSk7XG4gICAgY29uc3QgbGFzdFBvaW50ID0gZGF0YVtkYXRhLmxlbmd0aCAtIDFdLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGRhdGEubGVuZ3RoIC0gMSkpO1xuICAgIHJldHVybiBNYXRoLm1heChib3JkZXIsIGZpcnN0UG9pbnQsIGxhc3RQb2ludCkgLyAyO1xuICB9XG5cbiAgZHJhdygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBtZXRhLmRhdGFzZXQudXBkYXRlQ29udHJvbFBvaW50cyh0aGlzLmNoYXJ0LmNoYXJ0QXJlYSwgbWV0YS5pU2NhbGUuYXhpcyk7XG4gICAgc3VwZXIuZHJhdygpO1xuICB9XG59XG4iLCJpbXBvcnQgRGF0YXNldENvbnRyb2xsZXIgZnJvbSAnLi4vY29yZS9jb3JlLmRhdGFzZXRDb250cm9sbGVyLmpzJztcbmltcG9ydCB7dG9SYWRpYW5zLCBQSSwgZm9ybWF0TnVtYmVyLCBfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGV9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb2xhckFyZWFDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuXG4gIHN0YXRpYyBpZCA9ICdwb2xhckFyZWEnO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGRhdGFFbGVtZW50VHlwZTogJ2FyYycsXG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICBhbmltYXRlUm90YXRlOiB0cnVlLFxuICAgICAgYW5pbWF0ZVNjYWxlOiB0cnVlXG4gICAgfSxcbiAgICBhbmltYXRpb25zOiB7XG4gICAgICBudW1iZXJzOiB7XG4gICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICBwcm9wZXJ0aWVzOiBbJ3gnLCAneScsICdzdGFydEFuZ2xlJywgJ2VuZEFuZ2xlJywgJ2lubmVyUmFkaXVzJywgJ291dGVyUmFkaXVzJ11cbiAgICAgIH0sXG4gICAgfSxcbiAgICBpbmRleEF4aXM6ICdyJyxcbiAgICBzdGFydEFuZ2xlOiAwLFxuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIG92ZXJyaWRlcyA9IHtcbiAgICBhc3BlY3RSYXRpbzogMSxcblxuICAgIHBsdWdpbnM6IHtcbiAgICAgIGxlZ2VuZDoge1xuICAgICAgICBsYWJlbHM6IHtcbiAgICAgICAgICBnZW5lcmF0ZUxhYmVscyhjaGFydCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGNoYXJ0LmRhdGE7XG4gICAgICAgICAgICBpZiAoZGF0YS5sYWJlbHMubGVuZ3RoICYmIGRhdGEuZGF0YXNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHtsYWJlbHM6IHtwb2ludFN0eWxlLCBjb2xvcn19ID0gY2hhcnQubGVnZW5kLm9wdGlvbnM7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGRhdGEubGFiZWxzLm1hcCgobGFiZWwsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoMCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUoaSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgdGV4dDogbGFiZWwsXG4gICAgICAgICAgICAgICAgICBmaWxsU3R5bGU6IHN0eWxlLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgICAgICAgIHN0cm9rZVN0eWxlOiBzdHlsZS5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICAgIGZvbnRDb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IHN0eWxlLmJvcmRlcldpZHRoLFxuICAgICAgICAgICAgICAgICAgcG9pbnRTdHlsZTogcG9pbnRTdHlsZSxcbiAgICAgICAgICAgICAgICAgIGhpZGRlbjogIWNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpLFxuXG4gICAgICAgICAgICAgICAgICAvLyBFeHRyYSBkYXRhIHVzZWQgZm9yIHRvZ2dsaW5nIHRoZSBjb3JyZWN0IGl0ZW1cbiAgICAgICAgICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uQ2xpY2soZSwgbGVnZW5kSXRlbSwgbGVnZW5kKSB7XG4gICAgICAgICAgbGVnZW5kLmNoYXJ0LnRvZ2dsZURhdGFWaXNpYmlsaXR5KGxlZ2VuZEl0ZW0uaW5kZXgpO1xuICAgICAgICAgIGxlZ2VuZC5jaGFydC51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzY2FsZXM6IHtcbiAgICAgIHI6IHtcbiAgICAgICAgdHlwZTogJ3JhZGlhbExpbmVhcicsXG4gICAgICAgIGFuZ2xlTGluZXM6IHtcbiAgICAgICAgICBkaXNwbGF5OiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBiZWdpbkF0WmVybzogdHJ1ZSxcbiAgICAgICAgZ3JpZDoge1xuICAgICAgICAgIGNpcmN1bGFyOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIHBvaW50TGFiZWxzOiB7XG4gICAgICAgICAgZGlzcGxheTogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgc3RhcnRBbmdsZTogMFxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBjb25zdHJ1Y3RvcihjaGFydCwgZGF0YXNldEluZGV4KSB7XG4gICAgc3VwZXIoY2hhcnQsIGRhdGFzZXRJbmRleCk7XG5cbiAgICB0aGlzLmlubmVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub3V0ZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGxhYmVscyA9IGNoYXJ0LmRhdGEubGFiZWxzIHx8IFtdO1xuICAgIGNvbnN0IHZhbHVlID0gZm9ybWF0TnVtYmVyKG1ldGEuX3BhcnNlZFtpbmRleF0uciwgY2hhcnQub3B0aW9ucy5sb2NhbGUpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiBsYWJlbHNbaW5kZXhdIHx8ICcnLFxuICAgICAgdmFsdWUsXG4gICAgfTtcbiAgfVxuXG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICByZXR1cm4gX3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlLmJpbmQodGhpcykobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgfVxuXG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgYXJjcyA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YTtcblxuICAgIHRoaXMuX3VwZGF0ZVJhZGl1cygpO1xuICAgIHRoaXMudXBkYXRlRWxlbWVudHMoYXJjcywgMCwgYXJjcy5sZW5ndGgsIG1vZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGdldE1pbk1heCgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCByYW5nZSA9IHttaW46IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgbWF4OiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFl9O1xuXG4gICAgbWV0YS5kYXRhLmZvckVhY2goKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCkucjtcblxuICAgICAgaWYgKCFpc05hTihwYXJzZWQpICYmIHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaW5kZXgpKSB7XG4gICAgICAgIGlmIChwYXJzZWQgPCByYW5nZS5taW4pIHtcbiAgICAgICAgICByYW5nZS5taW4gPSBwYXJzZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyc2VkID4gcmFuZ2UubWF4KSB7XG4gICAgICAgICAgcmFuZ2UubWF4ID0gcGFyc2VkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF91cGRhdGVSYWRpdXMoKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGNoYXJ0QXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcbiAgICBjb25zdCBvcHRzID0gY2hhcnQub3B0aW9ucztcbiAgICBjb25zdCBtaW5TaXplID0gTWF0aC5taW4oY2hhcnRBcmVhLnJpZ2h0IC0gY2hhcnRBcmVhLmxlZnQsIGNoYXJ0QXJlYS5ib3R0b20gLSBjaGFydEFyZWEudG9wKTtcblxuICAgIGNvbnN0IG91dGVyUmFkaXVzID0gTWF0aC5tYXgobWluU2l6ZSAvIDIsIDApO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gTWF0aC5tYXgob3B0cy5jdXRvdXRQZXJjZW50YWdlID8gKG91dGVyUmFkaXVzIC8gMTAwKSAqIChvcHRzLmN1dG91dFBlcmNlbnRhZ2UpIDogMSwgMCk7XG4gICAgY29uc3QgcmFkaXVzTGVuZ3RoID0gKG91dGVyUmFkaXVzIC0gaW5uZXJSYWRpdXMpIC8gY2hhcnQuZ2V0VmlzaWJsZURhdGFzZXRDb3VudCgpO1xuXG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IG91dGVyUmFkaXVzIC0gKHJhZGl1c0xlbmd0aCAqIHRoaXMuaW5kZXgpO1xuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSB0aGlzLm91dGVyUmFkaXVzIC0gcmFkaXVzTGVuZ3RoO1xuICB9XG5cbiAgdXBkYXRlRWxlbWVudHMoYXJjcywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBvcHRzID0gY2hhcnQub3B0aW9ucztcbiAgICBjb25zdCBhbmltYXRpb25PcHRzID0gb3B0cy5hbmltYXRpb247XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLl9jYWNoZWRNZXRhLnJTY2FsZTtcbiAgICBjb25zdCBjZW50ZXJYID0gc2NhbGUueENlbnRlcjtcbiAgICBjb25zdCBjZW50ZXJZID0gc2NhbGUueUNlbnRlcjtcbiAgICBjb25zdCBkYXRhc2V0U3RhcnRBbmdsZSA9IHNjYWxlLmdldEluZGV4QW5nbGUoMCkgLSAwLjUgKiBQSTtcbiAgICBsZXQgYW5nbGUgPSBkYXRhc2V0U3RhcnRBbmdsZTtcbiAgICBsZXQgaTtcblxuICAgIGNvbnN0IGRlZmF1bHRBbmdsZSA9IDM2MCAvIHRoaXMuY291bnRWaXNpYmxlRWxlbWVudHMoKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzdGFydDsgKytpKSB7XG4gICAgICBhbmdsZSArPSB0aGlzLl9jb21wdXRlQW5nbGUoaSwgbW9kZSwgZGVmYXVsdEFuZ2xlKTtcbiAgICB9XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IGFyYyA9IGFyY3NbaV07XG4gICAgICBsZXQgc3RhcnRBbmdsZSA9IGFuZ2xlO1xuICAgICAgbGV0IGVuZEFuZ2xlID0gYW5nbGUgKyB0aGlzLl9jb21wdXRlQW5nbGUoaSwgbW9kZSwgZGVmYXVsdEFuZ2xlKTtcbiAgICAgIGxldCBvdXRlclJhZGl1cyA9IGNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpID8gc2NhbGUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodGhpcy5nZXRQYXJzZWQoaSkucikgOiAwO1xuICAgICAgYW5nbGUgPSBlbmRBbmdsZTtcblxuICAgICAgaWYgKHJlc2V0KSB7XG4gICAgICAgIGlmIChhbmltYXRpb25PcHRzLmFuaW1hdGVTY2FsZSkge1xuICAgICAgICAgIG91dGVyUmFkaXVzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5pbWF0aW9uT3B0cy5hbmltYXRlUm90YXRlKSB7XG4gICAgICAgICAgc3RhcnRBbmdsZSA9IGVuZEFuZ2xlID0gZGF0YXNldFN0YXJ0QW5nbGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgICAgeDogY2VudGVyWCxcbiAgICAgICAgeTogY2VudGVyWSxcbiAgICAgICAgaW5uZXJSYWRpdXM6IDAsXG4gICAgICAgIG91dGVyUmFkaXVzLFxuICAgICAgICBzdGFydEFuZ2xlLFxuICAgICAgICBlbmRBbmdsZSxcbiAgICAgICAgb3B0aW9uczogdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIGFyYy5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpXG4gICAgICB9O1xuXG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQoYXJjLCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG4gIH1cblxuICBjb3VudFZpc2libGVFbGVtZW50cygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBsZXQgY291bnQgPSAwO1xuXG4gICAgbWV0YS5kYXRhLmZvckVhY2goKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoIWlzTmFOKHRoaXMuZ2V0UGFyc2VkKGluZGV4KS5yKSAmJiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGluZGV4KSkge1xuICAgICAgICBjb3VudCsrO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNvdW50O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY29tcHV0ZUFuZ2xlKGluZGV4LCBtb2RlLCBkZWZhdWx0QW5nbGUpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpbmRleClcbiAgICAgID8gdG9SYWRpYW5zKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCwgbW9kZSkuYW5nbGUgfHwgZGVmYXVsdEFuZ2xlKVxuICAgICAgOiAwO1xuICB9XG59XG4iLCJpbXBvcnQgRG91Z2hudXRDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci5kb3VnaG51dC5qcyc7XG5cbi8vIFBpZSBjaGFydHMgYXJlIERvdWdobnV0IGNoYXJ0IHdpdGggZGlmZmVyZW50IGRlZmF1bHRzXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQaWVDb250cm9sbGVyIGV4dGVuZHMgRG91Z2hudXRDb250cm9sbGVyIHtcblxuICBzdGF0aWMgaWQgPSAncGllJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICAvLyBUaGUgcGVyY2VudGFnZSBvZiB0aGUgY2hhcnQgdGhhdCB3ZSBjdXQgb3V0IG9mIHRoZSBtaWRkbGUuXG4gICAgY3V0b3V0OiAwLFxuXG4gICAgLy8gVGhlIHJvdGF0aW9uIG9mIHRoZSBjaGFydCwgd2hlcmUgdGhlIGZpcnN0IGRhdGEgYXJjIGJlZ2lucy5cbiAgICByb3RhdGlvbjogMCxcblxuICAgIC8vIFRoZSB0b3RhbCBjaXJjdW1mZXJlbmNlIG9mIHRoZSBjaGFydC5cbiAgICBjaXJjdW1mZXJlbmNlOiAzNjAsXG5cbiAgICAvLyBUaGUgb3V0ZXIgcmFkaXVzIG9mIHRoZSBjaGFydFxuICAgIHJhZGl1czogJzEwMCUnXG4gIH07XG59XG4iLCJpbXBvcnQgRGF0YXNldENvbnRyb2xsZXIgZnJvbSAnLi4vY29yZS9jb3JlLmRhdGFzZXRDb250cm9sbGVyLmpzJztcbmltcG9ydCB7X3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmFkYXJDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuXG4gIHN0YXRpYyBpZCA9ICdyYWRhcic7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgZGF0YXNldEVsZW1lbnRUeXBlOiAnbGluZScsXG4gICAgZGF0YUVsZW1lbnRUeXBlOiAncG9pbnQnLFxuICAgIGluZGV4QXhpczogJ3InLFxuICAgIHNob3dMaW5lOiB0cnVlLFxuICAgIGVsZW1lbnRzOiB7XG4gICAgICBsaW5lOiB7XG4gICAgICAgIGZpbGw6ICdzdGFydCdcbiAgICAgIH1cbiAgICB9LFxuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIG92ZXJyaWRlcyA9IHtcbiAgICBhc3BlY3RSYXRpbzogMSxcblxuICAgIHNjYWxlczoge1xuICAgICAgcjoge1xuICAgICAgICB0eXBlOiAncmFkaWFsTGluZWFyJyxcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCB2U2NhbGUgPSB0aGlzLl9jYWNoZWRNZXRhLnZTY2FsZTtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IHZTY2FsZS5nZXRMYWJlbHMoKVtpbmRleF0sXG4gICAgICB2YWx1ZTogJycgKyB2U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWRbdlNjYWxlLmF4aXNdKVxuICAgIH07XG4gIH1cblxuICBwYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgcmV0dXJuIF9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZS5iaW5kKHRoaXMpKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gIH1cblxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGxpbmUgPSBtZXRhLmRhdGFzZXQ7XG4gICAgY29uc3QgcG9pbnRzID0gbWV0YS5kYXRhIHx8IFtdO1xuICAgIGNvbnN0IGxhYmVscyA9IG1ldGEuaVNjYWxlLmdldExhYmVscygpO1xuXG4gICAgLy8gVXBkYXRlIExpbmVcbiAgICBsaW5lLnBvaW50cyA9IHBvaW50cztcbiAgICAvLyBJbiByZXNpemUgbW9kZSBvbmx5IHBvaW50IGxvY2F0aW9ucyBjaGFuZ2UsIHNvIG5vIG5lZWQgdG8gc2V0IHRoZSBwb2ludHMgb3Igb3B0aW9ucy5cbiAgICBpZiAobW9kZSAhPT0gJ3Jlc2l6ZScpIHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMobW9kZSk7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5zaG93TGluZSkge1xuICAgICAgICBvcHRpb25zLmJvcmRlcldpZHRoID0gMDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgICAgX2xvb3A6IHRydWUsXG4gICAgICAgIF9mdWxsTG9vcDogbGFiZWxzLmxlbmd0aCA9PT0gcG9pbnRzLmxlbmd0aCxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfTtcblxuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KGxpbmUsIHVuZGVmaW5lZCwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIFBvaW50c1xuICAgIHRoaXMudXBkYXRlRWxlbWVudHMocG9pbnRzLCAwLCBwb2ludHMubGVuZ3RoLCBtb2RlKTtcbiAgfVxuXG4gIHVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLl9jYWNoZWRNZXRhLnJTY2FsZTtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG5cbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBwb2ludC5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgY29uc3QgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpLCB0aGlzLmdldFBhcnNlZChpKS5yKTtcblxuICAgICAgY29uc3QgeCA9IHJlc2V0ID8gc2NhbGUueENlbnRlciA6IHBvaW50UG9zaXRpb24ueDtcbiAgICAgIGNvbnN0IHkgPSByZXNldCA/IHNjYWxlLnlDZW50ZXIgOiBwb2ludFBvc2l0aW9uLnk7XG5cbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIGFuZ2xlOiBwb2ludFBvc2l0aW9uLmFuZ2xlLFxuICAgICAgICBza2lwOiBpc05hTih4KSB8fCBpc05hTih5KSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfTtcblxuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KHBvaW50LCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCBEYXRhc2V0Q29udHJvbGxlciBmcm9tICcuLi9jb3JlL2NvcmUuZGF0YXNldENvbnRyb2xsZXIuanMnO1xuaW1wb3J0IHtpc051bGxPclVuZGVmfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCB7aXNOdW1iZXJ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5tYXRoLmpzJztcbmltcG9ydCB7X2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMsIF9zY2FsZVJhbmdlc0NoYW5nZWR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5leHRyYXMuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTY2F0dGVyQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcblxuICBzdGF0aWMgaWQgPSAnc2NhdHRlcic7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgZGF0YXNldEVsZW1lbnRUeXBlOiBmYWxzZSxcbiAgICBkYXRhRWxlbWVudFR5cGU6ICdwb2ludCcsXG4gICAgc2hvd0xpbmU6IGZhbHNlLFxuICAgIGZpbGw6IGZhbHNlXG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgb3ZlcnJpZGVzID0ge1xuXG4gICAgaW50ZXJhY3Rpb246IHtcbiAgICAgIG1vZGU6ICdwb2ludCdcbiAgICB9LFxuXG4gICAgc2NhbGVzOiB7XG4gICAgICB4OiB7XG4gICAgICAgIHR5cGU6ICdsaW5lYXInXG4gICAgICB9LFxuICAgICAgeToge1xuICAgICAgICB0eXBlOiAnbGluZWFyJ1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuY2hhcnQuZGF0YS5sYWJlbHMgfHwgW107XG4gICAgY29uc3Qge3hTY2FsZSwgeVNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIGNvbnN0IHggPSB4U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWQueCk7XG4gICAgY29uc3QgeSA9IHlTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZC55KTtcblxuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogbGFiZWxzW2luZGV4XSB8fCAnJyxcbiAgICAgIHZhbHVlOiAnKCcgKyB4ICsgJywgJyArIHkgKyAnKSdcbiAgICB9O1xuICB9XG5cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB7ZGF0YTogcG9pbnRzID0gW119ID0gbWV0YTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgYW5pbWF0aW9uc0Rpc2FibGVkID0gdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkO1xuICAgIGxldCB7c3RhcnQsIGNvdW50fSA9IF9nZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzKG1ldGEsIHBvaW50cywgYW5pbWF0aW9uc0Rpc2FibGVkKTtcblxuICAgIHRoaXMuX2RyYXdTdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuX2RyYXdDb3VudCA9IGNvdW50O1xuXG4gICAgaWYgKF9zY2FsZVJhbmdlc0NoYW5nZWQobWV0YSkpIHtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnNob3dMaW5lKSB7XG5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8xMTMzM1xuICAgICAgaWYgKCF0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSkge1xuICAgICAgICB0aGlzLmFkZEVsZW1lbnRzKCk7XG4gICAgICB9XG4gICAgICBjb25zdCB7ZGF0YXNldDogbGluZSwgX2RhdGFzZXR9ID0gbWV0YTtcblxuICAgICAgLy8gVXBkYXRlIExpbmVcbiAgICAgIGxpbmUuX2NoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICAgIGxpbmUuX2RhdGFzZXRJbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICBsaW5lLl9kZWNpbWF0ZWQgPSAhIV9kYXRhc2V0Ll9kZWNpbWF0ZWQ7XG4gICAgICBsaW5lLnBvaW50cyA9IHBvaW50cztcblxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMucmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKTtcbiAgICAgIG9wdGlvbnMuc2VnbWVudCA9IHRoaXMub3B0aW9ucy5zZWdtZW50O1xuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KGxpbmUsIHVuZGVmaW5lZCwge1xuICAgICAgICBhbmltYXRlZDogIWFuaW1hdGlvbnNEaXNhYmxlZCxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfSwgbW9kZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSkge1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzExMzMzXG4gICAgICBkZWxldGUgbWV0YS5kYXRhc2V0O1xuICAgICAgdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgUG9pbnRzXG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSk7XG4gIH1cblxuICBhZGRFbGVtZW50cygpIHtcbiAgICBjb25zdCB7c2hvd0xpbmV9ID0gdGhpcy5vcHRpb25zO1xuXG4gICAgaWYgKCF0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSAmJiBzaG93TGluZSkge1xuICAgICAgdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUgPSB0aGlzLmNoYXJ0LnJlZ2lzdHJ5LmdldEVsZW1lbnQoJ2xpbmUnKTtcbiAgICB9XG5cbiAgICBzdXBlci5hZGRFbGVtZW50cygpO1xuICB9XG5cbiAgdXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlLCBfc3RhY2tlZCwgX2RhdGFzZXR9ID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBmaXJzdE9wdHMgPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuICAgIGNvbnN0IHNoYXJlZE9wdGlvbnMgPSB0aGlzLmdldFNoYXJlZE9wdGlvbnMoZmlyc3RPcHRzKTtcbiAgICBjb25zdCBpbmNsdWRlT3B0aW9ucyA9IHRoaXMuaW5jbHVkZU9wdGlvbnMobW9kZSwgc2hhcmVkT3B0aW9ucyk7XG4gICAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcbiAgICBjb25zdCB2QXhpcyA9IHZTY2FsZS5heGlzO1xuICAgIGNvbnN0IHtzcGFuR2Fwcywgc2VnbWVudH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbWF4R2FwTGVuZ3RoID0gaXNOdW1iZXIoc3BhbkdhcHMpID8gc3BhbkdhcHMgOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgY29uc3QgZGlyZWN0VXBkYXRlID0gdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkIHx8IHJlc2V0IHx8IG1vZGUgPT09ICdub25lJztcbiAgICBsZXQgcHJldlBhcnNlZCA9IHN0YXJ0ID4gMCAmJiB0aGlzLmdldFBhcnNlZChzdGFydCAtIDEpO1xuXG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgKytpKSB7XG4gICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGkpO1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IGRpcmVjdFVwZGF0ZSA/IHBvaW50IDoge307XG4gICAgICBjb25zdCBudWxsRGF0YSA9IGlzTnVsbE9yVW5kZWYocGFyc2VkW3ZBeGlzXSk7XG4gICAgICBjb25zdCBpUGl4ZWwgPSBwcm9wZXJ0aWVzW2lBeGlzXSA9IGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHBhcnNlZFtpQXhpc10sIGkpO1xuICAgICAgY29uc3QgdlBpeGVsID0gcHJvcGVydGllc1t2QXhpc10gPSByZXNldCB8fCBudWxsRGF0YSA/IHZTY2FsZS5nZXRCYXNlUGl4ZWwoKSA6IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKF9zdGFja2VkID8gdGhpcy5hcHBseVN0YWNrKHZTY2FsZSwgcGFyc2VkLCBfc3RhY2tlZCkgOiBwYXJzZWRbdkF4aXNdLCBpKTtcblxuICAgICAgcHJvcGVydGllcy5za2lwID0gaXNOYU4oaVBpeGVsKSB8fCBpc05hTih2UGl4ZWwpIHx8IG51bGxEYXRhO1xuICAgICAgcHJvcGVydGllcy5zdG9wID0gaSA+IDAgJiYgKE1hdGguYWJzKHBhcnNlZFtpQXhpc10gLSBwcmV2UGFyc2VkW2lBeGlzXSkpID4gbWF4R2FwTGVuZ3RoO1xuICAgICAgaWYgKHNlZ21lbnQpIHtcbiAgICAgICAgcHJvcGVydGllcy5wYXJzZWQgPSBwYXJzZWQ7XG4gICAgICAgIHByb3BlcnRpZXMucmF3ID0gX2RhdGFzZXQuZGF0YVtpXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluY2x1ZGVPcHRpb25zKSB7XG4gICAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IHNoYXJlZE9wdGlvbnMgfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIHBvaW50LmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZGlyZWN0VXBkYXRlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRWxlbWVudChwb2ludCwgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgICB9XG5cbiAgICAgIHByZXZQYXJzZWQgPSBwYXJzZWQ7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVTaGFyZWRPcHRpb25zKHNoYXJlZE9wdGlvbnMsIG1vZGUsIGZpcnN0T3B0cyk7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZGF0YSA9IG1ldGEuZGF0YSB8fCBbXTtcblxuICAgIGlmICghdGhpcy5vcHRpb25zLnNob3dMaW5lKSB7XG4gICAgICBsZXQgbWF4ID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgZGF0YVtpXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpKSkgLyAyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXggPiAwICYmIG1heDtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhc2V0ID0gbWV0YS5kYXRhc2V0O1xuICAgIGNvbnN0IGJvcmRlciA9IGRhdGFzZXQub3B0aW9ucyAmJiBkYXRhc2V0Lm9wdGlvbnMuYm9yZGVyV2lkdGggfHwgMDtcblxuICAgIGlmICghZGF0YS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBib3JkZXI7XG4gICAgfVxuXG4gICAgY29uc3QgZmlyc3RQb2ludCA9IGRhdGFbMF0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoMCkpO1xuICAgIGNvbnN0IGxhc3RQb2ludCA9IGRhdGFbZGF0YS5sZW5ndGggLSAxXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhkYXRhLmxlbmd0aCAtIDEpKTtcbiAgICByZXR1cm4gTWF0aC5tYXgoYm9yZGVyLCBmaXJzdFBvaW50LCBsYXN0UG9pbnQpIC8gMjtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbmFtZXNwYWNlIENoYXJ0Ll9hZGFwdGVyc1xuICogQHNpbmNlIDIuOC4wXG4gKiBAcHJpdmF0ZVxuICovXG5cbmltcG9ydCB0eXBlIHtBbnlPYmplY3R9IGZyb20gJy4uL3R5cGVzL2Jhc2ljLmpzJztcbmltcG9ydCB0eXBlIHtDaGFydE9wdGlvbnN9IGZyb20gJy4uL3R5cGVzL2luZGV4LmpzJztcblxuZXhwb3J0IHR5cGUgVGltZVVuaXQgPSAnbWlsbGlzZWNvbmQnIHwgJ3NlY29uZCcgfCAnbWludXRlJyB8ICdob3VyJyB8ICdkYXknIHwgJ3dlZWsnIHwgJ21vbnRoJyB8ICdxdWFydGVyJyB8ICd5ZWFyJztcblxuZXhwb3J0IGludGVyZmFjZSBEYXRlQWRhcHRlcjxUIGV4dGVuZHMgQW55T2JqZWN0ID0gQW55T2JqZWN0PiB7XG4gIHJlYWRvbmx5IG9wdGlvbnM6IFQ7XG4gIC8qKlxuICAgKiBXaWxsIGNhbGxlZCB3aXRoIGNoYXJ0IG9wdGlvbnMgYWZ0ZXIgYWRhcHRlciBjcmVhdGlvbi5cbiAgICovXG4gIGluaXQodGhpczogRGF0ZUFkYXB0ZXI8VD4sIGNoYXJ0T3B0aW9uczogQ2hhcnRPcHRpb25zKTogdm9pZDtcbiAgLyoqXG4gICAqIFJldHVybnMgYSBtYXAgb2YgdGltZSBmb3JtYXRzIGZvciB0aGUgc3VwcG9ydGVkIGZvcm1hdHRpbmcgdW5pdHMgZGVmaW5lZFxuICAgKiBpbiBVbml0IGFzIHdlbGwgYXMgJ2RhdGV0aW1lJyByZXByZXNlbnRpbmcgYSBkZXRhaWxlZCBkYXRlL3RpbWUgc3RyaW5nLlxuICAgKi9cbiAgZm9ybWF0cyh0aGlzOiBEYXRlQWRhcHRlcjxUPik6IFJlY29yZDxUaW1lVW5pdCB8ICdkYXRldGltZScsIHN0cmluZz47XG4gIC8qKlxuICAgKiBQYXJzZXMgdGhlIGdpdmVuIGB2YWx1ZWAgYW5kIHJldHVybiB0aGUgYXNzb2NpYXRlZCB0aW1lc3RhbXAuXG4gICAqIEBwYXJhbSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBwYXJzZSAodXN1YWxseSBjb21lcyBmcm9tIHRoZSBkYXRhKVxuICAgKiBAcGFyYW0gW2Zvcm1hdF0gLSB0aGUgZXhwZWN0ZWQgZGF0YSBmb3JtYXRcbiAgICovXG4gIHBhcnNlKHRoaXM6IERhdGVBZGFwdGVyPFQ+LCB2YWx1ZTogdW5rbm93biwgZm9ybWF0Pzogc3RyaW5nKTogbnVtYmVyIHwgbnVsbDtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZvcm1hdHRlZCBkYXRlIGluIHRoZSBzcGVjaWZpZWQgYGZvcm1hdGAgZm9yIGEgZ2l2ZW4gYHRpbWVzdGFtcGAuXG4gICAqIEBwYXJhbSB0aW1lc3RhbXAgLSB0aGUgdGltZXN0YW1wIHRvIGZvcm1hdFxuICAgKiBAcGFyYW0gZm9ybWF0IC0gdGhlIGRhdGUvdGltZSB0b2tlblxuICAgKi9cbiAgZm9ybWF0KHRoaXM6IERhdGVBZGFwdGVyPFQ+LCB0aW1lc3RhbXA6IG51bWJlciwgZm9ybWF0OiBzdHJpbmcpOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBBZGRzIHRoZSBzcGVjaWZpZWQgYGFtb3VudGAgb2YgYHVuaXRgIHRvIHRoZSBnaXZlbiBgdGltZXN0YW1wYC5cbiAgICogQHBhcmFtIHRpbWVzdGFtcCAtIHRoZSBpbnB1dCB0aW1lc3RhbXBcbiAgICogQHBhcmFtIGFtb3VudCAtIHRoZSBhbW91bnQgdG8gYWRkXG4gICAqIEBwYXJhbSB1bml0IC0gdGhlIHVuaXQgYXMgc3RyaW5nXG4gICAqL1xuICBhZGQodGhpczogRGF0ZUFkYXB0ZXI8VD4sIHRpbWVzdGFtcDogbnVtYmVyLCBhbW91bnQ6IG51bWJlciwgdW5pdDogVGltZVVuaXQpOiBudW1iZXI7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgYHVuaXRgIGJldHdlZW4gdGhlIGdpdmVuIHRpbWVzdGFtcHMuXG4gICAqIEBwYXJhbSBhIC0gdGhlIGlucHV0IHRpbWVzdGFtcCAocmVmZXJlbmNlKVxuICAgKiBAcGFyYW0gYiAtIHRoZSB0aW1lc3RhbXAgdG8gc3VidHJhY3RcbiAgICogQHBhcmFtIHVuaXQgLSB0aGUgdW5pdCBhcyBzdHJpbmdcbiAgICovXG4gIGRpZmYodGhpczogRGF0ZUFkYXB0ZXI8VD4sIGE6IG51bWJlciwgYjogbnVtYmVyLCB1bml0OiBUaW1lVW5pdCk6IG51bWJlcjtcbiAgLyoqXG4gICAqIFJldHVybnMgc3RhcnQgb2YgYHVuaXRgIGZvciB0aGUgZ2l2ZW4gYHRpbWVzdGFtcGAuXG4gICAqIEBwYXJhbSB0aW1lc3RhbXAgLSB0aGUgaW5wdXQgdGltZXN0YW1wXG4gICAqIEBwYXJhbSB1bml0IC0gdGhlIHVuaXQgYXMgc3RyaW5nXG4gICAqIEBwYXJhbSBbd2Vla2RheV0gLSB0aGUgSVNPIGRheSBvZiB0aGUgd2VlayB3aXRoIDEgYmVpbmcgTW9uZGF5XG4gICAqIGFuZCA3IGJlaW5nIFN1bmRheSAob25seSBuZWVkZWQgaWYgcGFyYW0gKnVuaXQqIGlzIGBpc29XZWVrYCkuXG4gICAqL1xuICBzdGFydE9mKHRoaXM6IERhdGVBZGFwdGVyPFQ+LCB0aW1lc3RhbXA6IG51bWJlciwgdW5pdDogVGltZVVuaXQgfCAnaXNvV2VlaycsIHdlZWtkYXk/OiBudW1iZXIgfCBib29sZWFuKTogbnVtYmVyO1xuICAvKipcbiAgICogUmV0dXJucyBlbmQgb2YgYHVuaXRgIGZvciB0aGUgZ2l2ZW4gYHRpbWVzdGFtcGAuXG4gICAqIEBwYXJhbSB0aW1lc3RhbXAgLSB0aGUgaW5wdXQgdGltZXN0YW1wXG4gICAqIEBwYXJhbSB1bml0IC0gdGhlIHVuaXQgYXMgc3RyaW5nXG4gICAqL1xuICBlbmRPZih0aGlzOiBEYXRlQWRhcHRlcjxUPiwgdGltZXN0YW1wOiBudW1iZXIsIHVuaXQ6IFRpbWVVbml0KTogbnVtYmVyO1xufVxuXG5mdW5jdGlvbiBhYnN0cmFjdDxUID0gdm9pZD4oKTogVCB7XG4gIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkOiBDaGVjayB0aGF0IGEgY29tcGxldGUgZGF0ZSBhZGFwdGVyIGlzIHByb3ZpZGVkLicpO1xufVxuXG4vKipcbiAqIERhdGUgYWRhcHRlciAoY3VycmVudCB1c2VkIGJ5IHRoZSB0aW1lIHNjYWxlKVxuICogQG5hbWVzcGFjZSBDaGFydC5fYWRhcHRlcnMuX2RhdGVcbiAqIEBtZW1iZXJvZiBDaGFydC5fYWRhcHRlcnNcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIERhdGVBZGFwdGVyQmFzZSBpbXBsZW1lbnRzIERhdGVBZGFwdGVyIHtcblxuICAvKipcbiAgICogT3ZlcnJpZGUgZGVmYXVsdCBkYXRlIGFkYXB0ZXIgbWV0aG9kcy5cbiAgICogQWNjZXB0cyB0eXBlIHBhcmFtZXRlciB0byBkZWZpbmUgb3B0aW9ucyB0eXBlLlxuICAgKiBAZXhhbXBsZVxuICAgKiBDaGFydC5fYWRhcHRlcnMuX2RhdGUub3ZlcnJpZGU8e215QWRhcHRlck9wdGlvbjogc3RyaW5nfT4oe1xuICAgKiAgIGluaXQoKSB7XG4gICAqICAgICBjb25zb2xlLmxvZyh0aGlzLm9wdGlvbnMubXlBZGFwdGVyT3B0aW9uKTtcbiAgICogICB9XG4gICAqIH0pXG4gICAqL1xuICBzdGF0aWMgb3ZlcnJpZGU8VCBleHRlbmRzIEFueU9iamVjdCA9IEFueU9iamVjdD4oXG4gICAgbWVtYmVyczogUGFydGlhbDxPbWl0PERhdGVBZGFwdGVyPFQ+LCAnb3B0aW9ucyc+PlxuICApIHtcbiAgICBPYmplY3QuYXNzaWduKERhdGVBZGFwdGVyQmFzZS5wcm90b3R5cGUsIG1lbWJlcnMpO1xuICB9XG5cbiAgcmVhZG9ubHkgb3B0aW9uczogQW55T2JqZWN0O1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM/OiBBbnlPYmplY3QpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuICBpbml0KCkge31cblxuICBmb3JtYXRzKCk6IFJlY29yZDxUaW1lVW5pdCB8ICdkYXRldGltZScsIHN0cmluZz4ge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgcGFyc2UoKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICBmb3JtYXQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIGFkZCgpOiBudW1iZXIge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgZGlmZigpOiBudW1iZXIge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgc3RhcnRPZigpOiBudW1iZXIge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgZW5kT2YoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9kYXRlOiBEYXRlQWRhcHRlckJhc2UgYXMge1xuICAgIG5ldyAob3B0aW9ucz86IEFueU9iamVjdCk6IERhdGVBZGFwdGVyO1xuICAgIG92ZXJyaWRlPFQgZXh0ZW5kcyBBbnlPYmplY3QgPSBBbnlPYmplY3Q+KFxuICAgICAgbWVtYmVyczogUGFydGlhbDxPbWl0PERhdGVBZGFwdGVyPFQ+LCAnb3B0aW9ucyc+PlxuICAgICk6IHZvaWQ7XG4gIH1cbn07XG4iLCJpbXBvcnQge19sb29rdXBCeUtleSwgX3Jsb29rdXBCeUtleX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvbGxlY3Rpb24uanMnO1xuaW1wb3J0IHtnZXRSZWxhdGl2ZVBvc2l0aW9ufSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuZG9tLmpzJztcbmltcG9ydCB7X2FuZ2xlQmV0d2VlbiwgZ2V0QW5nbGVGcm9tUG9pbnR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5tYXRoLmpzJztcbmltcG9ydCB7X2lzUG9pbnRJbkFyZWEsIGlzTnVsbE9yVW5kZWZ9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuQ2hhcnRFdmVudCB9IENoYXJ0RXZlbnRcbiAqIEB0eXBlZGVmIHt7YXhpcz86IHN0cmluZywgaW50ZXJzZWN0PzogYm9vbGVhbiwgaW5jbHVkZUludmlzaWJsZT86IGJvb2xlYW59fSBJbnRlcmFjdGlvbk9wdGlvbnNcbiAqIEB0eXBlZGVmIHt7ZGF0YXNldEluZGV4OiBudW1iZXIsIGluZGV4OiBudW1iZXIsIGVsZW1lbnQ6IGltcG9ydCgnLi9jb3JlLmVsZW1lbnQuanMnKS5kZWZhdWx0fX0gSW50ZXJhY3Rpb25JdGVtXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5Qb2ludCB9IFBvaW50XG4gKi9cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZG8gYmluYXJ5IHNlYXJjaCB3aGVuIHBvc3NpYmxlXG4gKiBAcGFyYW0ge29iamVjdH0gbWV0YXNldCAtIHRoZSBkYXRhc2V0IG1ldGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBheGlzIC0gdGhlIGF4aXMgbW9kZS4geHx5fHh5fHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBmaW5kXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbnRlcnNlY3RdIC0gc2hvdWxkIHRoZSBlbGVtZW50IGludGVyc2VjdFxuICogQHJldHVybnMge3tsbzpudW1iZXIsIGhpOm51bWJlcn19IGluZGljZXMgdG8gc2VhcmNoIGRhdGEgYXJyYXkgYmV0d2VlblxuICovXG5mdW5jdGlvbiBiaW5hcnlTZWFyY2gobWV0YXNldCwgYXhpcywgdmFsdWUsIGludGVyc2VjdCkge1xuICBjb25zdCB7Y29udHJvbGxlciwgZGF0YSwgX3NvcnRlZH0gPSBtZXRhc2V0O1xuICBjb25zdCBpU2NhbGUgPSBjb250cm9sbGVyLl9jYWNoZWRNZXRhLmlTY2FsZTtcbiAgY29uc3Qgc3BhbkdhcHMgPSBtZXRhc2V0LmRhdGFzZXQgPyBtZXRhc2V0LmRhdGFzZXQub3B0aW9ucyA/IG1ldGFzZXQuZGF0YXNldC5vcHRpb25zLnNwYW5HYXBzIDogbnVsbCA6IG51bGw7XG5cbiAgaWYgKGlTY2FsZSAmJiBheGlzID09PSBpU2NhbGUuYXhpcyAmJiBheGlzICE9PSAncicgJiYgX3NvcnRlZCAmJiBkYXRhLmxlbmd0aCkge1xuICAgIGNvbnN0IGxvb2t1cE1ldGhvZCA9IGlTY2FsZS5fcmV2ZXJzZVBpeGVscyA/IF9ybG9va3VwQnlLZXkgOiBfbG9va3VwQnlLZXk7XG4gICAgaWYgKCFpbnRlcnNlY3QpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGxvb2t1cE1ldGhvZChkYXRhLCBheGlzLCB2YWx1ZSk7XG4gICAgICBpZiAoc3BhbkdhcHMpIHtcbiAgICAgICAgY29uc3Qge3ZTY2FsZX0gPSBjb250cm9sbGVyLl9jYWNoZWRNZXRhO1xuICAgICAgICBjb25zdCB7X3BhcnNlZH0gPSBtZXRhc2V0O1xuXG4gICAgICAgIGNvbnN0IGRpc3RhbmNlVG9EZWZpbmVkTG8gPSAoX3BhcnNlZFxuICAgICAgICAgIC5zbGljZSgwLCByZXN1bHQubG8gKyAxKVxuICAgICAgICAgIC5yZXZlcnNlKClcbiAgICAgICAgICAuZmluZEluZGV4KFxuICAgICAgICAgICAgcG9pbnQgPT4gIWlzTnVsbE9yVW5kZWYocG9pbnRbdlNjYWxlLmF4aXNdKSkpO1xuICAgICAgICByZXN1bHQubG8gLT0gTWF0aC5tYXgoMCwgZGlzdGFuY2VUb0RlZmluZWRMbyk7XG5cbiAgICAgICAgY29uc3QgZGlzdGFuY2VUb0RlZmluZWRIaSA9IChfcGFyc2VkXG4gICAgICAgICAgLnNsaWNlKHJlc3VsdC5oaSlcbiAgICAgICAgICAuZmluZEluZGV4KFxuICAgICAgICAgICAgcG9pbnQgPT4gIWlzTnVsbE9yVW5kZWYocG9pbnRbdlNjYWxlLmF4aXNdKSkpO1xuICAgICAgICByZXN1bHQuaGkgKz0gTWF0aC5tYXgoMCwgZGlzdGFuY2VUb0RlZmluZWRIaSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSBpZiAoY29udHJvbGxlci5fc2hhcmVkT3B0aW9ucykge1xuICAgICAgLy8gX3NoYXJlZE9wdGlvbnMgaW5kaWNhdGVzIHRoYXQgZWFjaCBlbGVtZW50IGhhcyBlcXVhbCBvcHRpb25zIC0+IGVxdWFsIHByb3BvcnRpb25zXG4gICAgICAvLyBTbyB3ZSBjYW4gZG8gYSByYW5nZWQgYmluYXJ5IHNlYXJjaCBiYXNlZCBvbiB0aGUgcmFuZ2Ugb2YgZmlyc3QgZWxlbWVudCBhbmRcbiAgICAgIC8vIGJlIGNvbmZpZGVudCB0byBnZXQgdGhlIGZ1bGwgcmFuZ2Ugb2YgaW5kaWNlcyB0aGF0IGNhbiBpbnRlcnNlY3Qgd2l0aCB0aGUgdmFsdWUuXG4gICAgICBjb25zdCBlbCA9IGRhdGFbMF07XG4gICAgICBjb25zdCByYW5nZSA9IHR5cGVvZiBlbC5nZXRSYW5nZSA9PT0gJ2Z1bmN0aW9uJyAmJiBlbC5nZXRSYW5nZShheGlzKTtcbiAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICBjb25zdCBzdGFydCA9IGxvb2t1cE1ldGhvZChkYXRhLCBheGlzLCB2YWx1ZSAtIHJhbmdlKTtcbiAgICAgICAgY29uc3QgZW5kID0gbG9va3VwTWV0aG9kKGRhdGEsIGF4aXMsIHZhbHVlICsgcmFuZ2UpO1xuICAgICAgICByZXR1cm4ge2xvOiBzdGFydC5sbywgaGk6IGVuZC5oaX07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIERlZmF1bHQgdG8gYWxsIGVsZW1lbnRzLCB3aGVuIGJpbmFyeSBzZWFyY2ggY2FuIG5vdCBiZSB1c2VkLlxuICByZXR1cm4ge2xvOiAwLCBoaTogZGF0YS5sZW5ndGggLSAxfTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gc2VsZWN0IGNhbmRpZGF0ZSBlbGVtZW50cyBmb3IgaW50ZXJhY3Rpb25cbiAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0XG4gKiBAcGFyYW0ge3N0cmluZ30gYXhpcyAtIHRoZSBheGlzIG1vZGUuIHh8eXx4eXxyXG4gKiBAcGFyYW0ge1BvaW50fSBwb3NpdGlvbiAtIHRoZSBwb2ludCB0byBiZSBuZWFyZXN0IHRvLCBpbiByZWxhdGl2ZSBjb29yZGluYXRlc1xuICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlciAtIHRoZSBjYWxsYmFjayB0byBleGVjdXRlIGZvciBlYWNoIHZpc2libGUgaXRlbVxuICogQHBhcmFtIHtib29sZWFufSBbaW50ZXJzZWN0XSAtIGNvbnNpZGVyIGludGVyc2VjdGluZyBpdGVtc1xuICovXG5mdW5jdGlvbiBldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMoY2hhcnQsIGF4aXMsIHBvc2l0aW9uLCBoYW5kbGVyLCBpbnRlcnNlY3QpIHtcbiAgY29uc3QgbWV0YXNldHMgPSBjaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bYXhpc107XG4gIGZvciAobGV0IGkgPSAwLCBpbGVuID0gbWV0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgY29uc3Qge2luZGV4LCBkYXRhfSA9IG1ldGFzZXRzW2ldO1xuICAgIGNvbnN0IHtsbywgaGl9ID0gYmluYXJ5U2VhcmNoKG1ldGFzZXRzW2ldLCBheGlzLCB2YWx1ZSwgaW50ZXJzZWN0KTtcbiAgICBmb3IgKGxldCBqID0gbG87IGogPD0gaGk7ICsraikge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGRhdGFbal07XG4gICAgICBpZiAoIWVsZW1lbnQuc2tpcCkge1xuICAgICAgICBoYW5kbGVyKGVsZW1lbnQsIGluZGV4LCBqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgYSBkaXN0YW5jZSBtZXRyaWMgZnVuY3Rpb24gZm9yIHR3byBwb2ludHMgYmFzZWQgb24gdGhlXG4gKiBheGlzIG1vZGUgc2V0dGluZ1xuICogQHBhcmFtIHtzdHJpbmd9IGF4aXMgLSB0aGUgYXhpcyBtb2RlLiB4fHl8eHl8clxuICovXG5mdW5jdGlvbiBnZXREaXN0YW5jZU1ldHJpY0ZvckF4aXMoYXhpcykge1xuICBjb25zdCB1c2VYID0gYXhpcy5pbmRleE9mKCd4JykgIT09IC0xO1xuICBjb25zdCB1c2VZID0gYXhpcy5pbmRleE9mKCd5JykgIT09IC0xO1xuXG4gIHJldHVybiBmdW5jdGlvbihwdDEsIHB0Mikge1xuICAgIGNvbnN0IGRlbHRhWCA9IHVzZVggPyBNYXRoLmFicyhwdDEueCAtIHB0Mi54KSA6IDA7XG4gICAgY29uc3QgZGVsdGFZID0gdXNlWSA/IE1hdGguYWJzKHB0MS55IC0gcHQyLnkpIDogMDtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KGRlbHRhWCwgMikgKyBNYXRoLnBvdyhkZWx0YVksIDIpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBpdGVtcyB0aGF0IGludGVyc2VjdCB0aGUgZXZlbnQgcG9zaXRpb25cbiAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0XG4gKiBAcGFyYW0ge1BvaW50fSBwb3NpdGlvbiAtIHRoZSBwb2ludCB0byBiZSBuZWFyZXN0IHRvLCBpbiByZWxhdGl2ZSBjb29yZGluYXRlc1xuICogQHBhcmFtIHtzdHJpbmd9IGF4aXMgLSB0aGUgYXhpcyBtb2RlLiB4fHl8eHl8clxuICogQHBhcmFtIHtib29sZWFufSBbdXNlRmluYWxQb3NpdGlvbl0gLSB1c2UgdGhlIGVsZW1lbnQncyBhbmltYXRpb24gdGFyZ2V0IGluc3RlYWQgb2YgY3VycmVudCBwb3NpdGlvblxuICogQHBhcmFtIHtib29sZWFufSBbaW5jbHVkZUludmlzaWJsZV0gLSBpbmNsdWRlIGludmlzaWJsZSBwb2ludHMgdGhhdCBhcmUgb3V0c2lkZSBvZiB0aGUgY2hhcnQgYXJlYVxuICogQHJldHVybiB7SW50ZXJhY3Rpb25JdGVtW119IHRoZSBuZWFyZXN0IGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSkge1xuICBjb25zdCBpdGVtcyA9IFtdO1xuXG4gIGlmICghaW5jbHVkZUludmlzaWJsZSAmJiAhY2hhcnQuaXNQb2ludEluQXJlYShwb3NpdGlvbikpIHtcbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cblxuICBjb25zdCBldmFsdWF0aW9uRnVuYyA9IGZ1bmN0aW9uKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcbiAgICBpZiAoIWluY2x1ZGVJbnZpc2libGUgJiYgIV9pc1BvaW50SW5BcmVhKGVsZW1lbnQsIGNoYXJ0LmNoYXJ0QXJlYSwgMCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuaW5SYW5nZShwb3NpdGlvbi54LCBwb3NpdGlvbi55LCB1c2VGaW5hbFBvc2l0aW9uKSkge1xuICAgICAgaXRlbXMucHVzaCh7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH0pO1xuICAgIH1cbiAgfTtcblxuICBldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMoY2hhcnQsIGF4aXMsIHBvc2l0aW9uLCBldmFsdWF0aW9uRnVuYywgdHJ1ZSk7XG4gIHJldHVybiBpdGVtcztcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBpdGVtcyBuZWFyZXN0IHRvIHRoZSBldmVudCBwb3NpdGlvbiBmb3IgYSByYWRpYWwgY2hhcnRcbiAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHRvIGxvb2sgYXQgZWxlbWVudHMgZnJvbVxuICogQHBhcmFtIHtQb2ludH0gcG9zaXRpb24gLSB0aGUgcG9pbnQgdG8gYmUgbmVhcmVzdCB0bywgaW4gcmVsYXRpdmUgY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBheGlzIC0gdGhlIGF4ZXMgYWxvbmcgd2hpY2ggdG8gbWVhc3VyZSBkaXN0YW5jZVxuICogQHBhcmFtIHtib29sZWFufSBbdXNlRmluYWxQb3NpdGlvbl0gLSB1c2UgdGhlIGVsZW1lbnQncyBhbmltYXRpb24gdGFyZ2V0IGluc3RlYWQgb2YgY3VycmVudCBwb3NpdGlvblxuICogQHJldHVybiB7SW50ZXJhY3Rpb25JdGVtW119IHRoZSBuZWFyZXN0IGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIGdldE5lYXJlc3RSYWRpYWxJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgbGV0IGl0ZW1zID0gW107XG5cbiAgZnVuY3Rpb24gZXZhbHVhdGlvbkZ1bmMoZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkge1xuICAgIGNvbnN0IHtzdGFydEFuZ2xlLCBlbmRBbmdsZX0gPSBlbGVtZW50LmdldFByb3BzKFsnc3RhcnRBbmdsZScsICdlbmRBbmdsZSddLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBjb25zdCB7YW5nbGV9ID0gZ2V0QW5nbGVGcm9tUG9pbnQoZWxlbWVudCwge3g6IHBvc2l0aW9uLngsIHk6IHBvc2l0aW9uLnl9KTtcblxuICAgIGlmIChfYW5nbGVCZXR3ZWVuKGFuZ2xlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSkpIHtcbiAgICAgIGl0ZW1zLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9KTtcbiAgICB9XG4gIH1cblxuICBldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMoY2hhcnQsIGF4aXMsIHBvc2l0aW9uLCBldmFsdWF0aW9uRnVuYyk7XG4gIHJldHVybiBpdGVtcztcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBpdGVtcyBuZWFyZXN0IHRvIHRoZSBldmVudCBwb3NpdGlvbiBmb3IgYSBjYXJ0ZXNpYW4gY2hhcnRcbiAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHRvIGxvb2sgYXQgZWxlbWVudHMgZnJvbVxuICogQHBhcmFtIHtQb2ludH0gcG9zaXRpb24gLSB0aGUgcG9pbnQgdG8gYmUgbmVhcmVzdCB0bywgaW4gcmVsYXRpdmUgY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBheGlzIC0gdGhlIGF4ZXMgYWxvbmcgd2hpY2ggdG8gbWVhc3VyZSBkaXN0YW5jZVxuICogQHBhcmFtIHtib29sZWFufSBbaW50ZXJzZWN0XSAtIGlmIHRydWUsIG9ubHkgY29uc2lkZXIgaXRlbXMgdGhhdCBpbnRlcnNlY3QgdGhlIHBvc2l0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSB0aGUgZWxlbWVudCdzIGFuaW1hdGlvbiB0YXJnZXQgaW5zdGVhZCBvZiBjdXJyZW50IHBvc2l0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbmNsdWRlSW52aXNpYmxlXSAtIGluY2x1ZGUgaW52aXNpYmxlIHBvaW50cyB0aGF0IGFyZSBvdXRzaWRlIG9mIHRoZSBjaGFydCBhcmVhXG4gKiBAcmV0dXJuIHtJbnRlcmFjdGlvbkl0ZW1bXX0gdGhlIG5lYXJlc3QgaXRlbXNcbiAqL1xuZnVuY3Rpb24gZ2V0TmVhcmVzdENhcnRlc2lhbkl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKSB7XG4gIGxldCBpdGVtcyA9IFtdO1xuICBjb25zdCBkaXN0YW5jZU1ldHJpYyA9IGdldERpc3RhbmNlTWV0cmljRm9yQXhpcyhheGlzKTtcbiAgbGV0IG1pbkRpc3RhbmNlID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXG4gIGZ1bmN0aW9uIGV2YWx1YXRpb25GdW5jKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcbiAgICBjb25zdCBpblJhbmdlID0gZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGlmIChpbnRlcnNlY3QgJiYgIWluUmFuZ2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjZW50ZXIgPSBlbGVtZW50LmdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IHBvaW50SW5BcmVhID0gISFpbmNsdWRlSW52aXNpYmxlIHx8IGNoYXJ0LmlzUG9pbnRJbkFyZWEoY2VudGVyKTtcbiAgICBpZiAoIXBvaW50SW5BcmVhICYmICFpblJhbmdlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZGlzdGFuY2UgPSBkaXN0YW5jZU1ldHJpYyhwb3NpdGlvbiwgY2VudGVyKTtcbiAgICBpZiAoZGlzdGFuY2UgPCBtaW5EaXN0YW5jZSkge1xuICAgICAgaXRlbXMgPSBbe2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9XTtcbiAgICAgIG1pbkRpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgfSBlbHNlIGlmIChkaXN0YW5jZSA9PT0gbWluRGlzdGFuY2UpIHtcbiAgICAgIC8vIENhbiBoYXZlIG11bHRpcGxlIGl0ZW1zIGF0IHRoZSBzYW1lIGRpc3RhbmNlIGluIHdoaWNoIGNhc2Ugd2Ugc29ydCBieSBzaXplXG4gICAgICBpdGVtcy5wdXNoKHtlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fSk7XG4gICAgfVxuICB9XG5cbiAgZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgZXZhbHVhdGlvbkZ1bmMpO1xuICByZXR1cm4gaXRlbXM7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgaXRlbXMgbmVhcmVzdCB0byB0aGUgZXZlbnQgcG9zaXRpb24gY29uc2lkZXJpbmcgYWxsIHZpc2libGUgaXRlbXMgaW4gdGhlIGNoYXJ0XG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB0byBsb29rIGF0IGVsZW1lbnRzIGZyb21cbiAqIEBwYXJhbSB7UG9pbnR9IHBvc2l0aW9uIC0gdGhlIHBvaW50IHRvIGJlIG5lYXJlc3QgdG8sIGluIHJlbGF0aXZlIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gYXhpcyAtIHRoZSBheGVzIGFsb25nIHdoaWNoIHRvIG1lYXN1cmUgZGlzdGFuY2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ludGVyc2VjdF0gLSBpZiB0cnVlLCBvbmx5IGNvbnNpZGVyIGl0ZW1zIHRoYXQgaW50ZXJzZWN0IHRoZSBwb3NpdGlvblxuICogQHBhcmFtIHtib29sZWFufSBbdXNlRmluYWxQb3NpdGlvbl0gLSB1c2UgdGhlIGVsZW1lbnQncyBhbmltYXRpb24gdGFyZ2V0IGluc3RlYWQgb2YgY3VycmVudCBwb3NpdGlvblxuICogQHBhcmFtIHtib29sZWFufSBbaW5jbHVkZUludmlzaWJsZV0gLSBpbmNsdWRlIGludmlzaWJsZSBwb2ludHMgdGhhdCBhcmUgb3V0c2lkZSBvZiB0aGUgY2hhcnQgYXJlYVxuICogQHJldHVybiB7SW50ZXJhY3Rpb25JdGVtW119IHRoZSBuZWFyZXN0IGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSkge1xuICBpZiAoIWluY2x1ZGVJbnZpc2libGUgJiYgIWNoYXJ0LmlzUG9pbnRJbkFyZWEocG9zaXRpb24pKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgcmV0dXJuIGF4aXMgPT09ICdyJyAmJiAhaW50ZXJzZWN0XG4gICAgPyBnZXROZWFyZXN0UmFkaWFsSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uKVxuICAgIDogZ2V0TmVhcmVzdENhcnRlc2lhbkl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBpdGVtcyBtYXRjaGluZyBhbG9uZyB0aGUgZ2l2ZW4gWCBvciBZIGF4aXNcbiAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHRvIGxvb2sgYXQgZWxlbWVudHMgZnJvbVxuICogQHBhcmFtIHtQb2ludH0gcG9zaXRpb24gLSB0aGUgcG9pbnQgdG8gYmUgbmVhcmVzdCB0bywgaW4gcmVsYXRpdmUgY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBheGlzIC0gdGhlIGF4aXMgdG8gbWF0Y2hcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ludGVyc2VjdF0gLSBpZiB0cnVlLCBvbmx5IGNvbnNpZGVyIGl0ZW1zIHRoYXQgaW50ZXJzZWN0IHRoZSBwb3NpdGlvblxuICogQHBhcmFtIHtib29sZWFufSBbdXNlRmluYWxQb3NpdGlvbl0gLSB1c2UgdGhlIGVsZW1lbnQncyBhbmltYXRpb24gdGFyZ2V0IGluc3RlYWQgb2YgY3VycmVudCBwb3NpdGlvblxuICogQHJldHVybiB7SW50ZXJhY3Rpb25JdGVtW119IHRoZSBuZWFyZXN0IGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIGdldEF4aXNJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbikge1xuICBjb25zdCBpdGVtcyA9IFtdO1xuICBjb25zdCByYW5nZU1ldGhvZCA9IGF4aXMgPT09ICd4JyA/ICdpblhSYW5nZScgOiAnaW5ZUmFuZ2UnO1xuICBsZXQgaW50ZXJzZWN0c0l0ZW0gPSBmYWxzZTtcblxuICBldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMoY2hhcnQsIGF4aXMsIHBvc2l0aW9uLCAoZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkgPT4ge1xuICAgIGlmIChlbGVtZW50W3JhbmdlTWV0aG9kXSAmJiBlbGVtZW50W3JhbmdlTWV0aG9kXShwb3NpdGlvbltheGlzXSwgdXNlRmluYWxQb3NpdGlvbikpIHtcbiAgICAgIGl0ZW1zLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9KTtcbiAgICAgIGludGVyc2VjdHNJdGVtID0gaW50ZXJzZWN0c0l0ZW0gfHwgZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gSWYgd2Ugd2FudCB0byB0cmlnZ2VyIG9uIGFuIGludGVyc2VjdCBhbmQgd2UgZG9uJ3QgaGF2ZSBhbnkgaXRlbXNcbiAgLy8gdGhhdCBpbnRlcnNlY3QgdGhlIHBvc2l0aW9uLCByZXR1cm4gbm90aGluZ1xuICBpZiAoaW50ZXJzZWN0ICYmICFpbnRlcnNlY3RzSXRlbSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4gaXRlbXM7XG59XG5cbi8qKlxuICogQ29udGFpbnMgaW50ZXJhY3Rpb24gcmVsYXRlZCBmdW5jdGlvbnNcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuSW50ZXJhY3Rpb25cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICAvLyBQYXJ0IG9mIHRoZSBwdWJsaWMgQVBJIHRvIGZhY2lsaXRhdGUgZGV2ZWxvcGVycyBjcmVhdGluZyB0aGVpciBvd24gbW9kZXNcbiAgZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zLFxuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiBmb3IgZGlmZmVyZW50IG1vZGVzXG4gIG1vZGVzOiB7XG4gICAgLyoqXG5cdFx0ICogUmV0dXJucyBpdGVtcyBhdCB0aGUgc2FtZSBpbmRleC4gSWYgdGhlIG9wdGlvbnMuaW50ZXJzZWN0IHBhcmFtZXRlciBpcyB0cnVlLCB3ZSBvbmx5IHJldHVybiBpdGVtcyBpZiB3ZSBpbnRlcnNlY3Qgc29tZXRoaW5nXG5cdFx0ICogSWYgdGhlIG9wdGlvbnMuaW50ZXJzZWN0IG1vZGUgaXMgZmFsc2UsIHdlIGZpbmQgdGhlIG5lYXJlc3QgaXRlbSBhbmQgcmV0dXJuIHRoZSBpdGVtcyBhdCB0aGUgc2FtZSBpbmRleCBhcyB0aGF0IGl0ZW1cblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMuaW5kZXhcblx0XHQgKiBAc2luY2UgdjIuNC4wXG5cdFx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXG5cdFx0ICogQHBhcmFtIHtFdmVudH0gZSAtIHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcblx0XHQgKiBAcGFyYW0ge0ludGVyYWN0aW9uT3B0aW9uc30gb3B0aW9ucyAtIG9wdGlvbnMgdG8gdXNlXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbdXNlRmluYWxQb3NpdGlvbl0gLSB1c2UgZmluYWwgZWxlbWVudCBwb3NpdGlvbiAoYW5pbWF0aW9uIHRhcmdldClcblx0XHQgKiBAcmV0dXJuIHtJbnRlcmFjdGlvbkl0ZW1bXX0gLSBpdGVtcyB0aGF0IGFyZSBmb3VuZFxuXHRcdCAqL1xuICAgIGluZGV4KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgLy8gRGVmYXVsdCBheGlzIGZvciBpbmRleCBtb2RlIGlzICd4JyB0byBtYXRjaCBvbGQgYmVoYXZpb3VyXG4gICAgICBjb25zdCBheGlzID0gb3B0aW9ucy5heGlzIHx8ICd4JztcbiAgICAgIGNvbnN0IGluY2x1ZGVJbnZpc2libGUgPSBvcHRpb25zLmluY2x1ZGVJbnZpc2libGUgfHwgZmFsc2U7XG4gICAgICBjb25zdCBpdGVtcyA9IG9wdGlvbnMuaW50ZXJzZWN0XG4gICAgICAgID8gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKVxuICAgICAgICA6IGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGZhbHNlLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKTtcbiAgICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG5cbiAgICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpLmZvckVhY2goKG1ldGEpID0+IHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBpdGVtc1swXS5pbmRleDtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IG1ldGEuZGF0YVtpbmRleF07XG5cbiAgICAgICAgLy8gZG9uJ3QgY291bnQgaXRlbXMgdGhhdCBhcmUgc2tpcHBlZCAobnVsbCBkYXRhKVxuICAgICAgICBpZiAoZWxlbWVudCAmJiAhZWxlbWVudC5za2lwKSB7XG4gICAgICAgICAgZWxlbWVudHMucHVzaCh7ZWxlbWVudCwgZGF0YXNldEluZGV4OiBtZXRhLmluZGV4LCBpbmRleH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgIH0sXG5cbiAgICAvKipcblx0XHQgKiBSZXR1cm5zIGl0ZW1zIGluIHRoZSBzYW1lIGRhdGFzZXQuIElmIHRoZSBvcHRpb25zLmludGVyc2VjdCBwYXJhbWV0ZXIgaXMgdHJ1ZSwgd2Ugb25seSByZXR1cm4gaXRlbXMgaWYgd2UgaW50ZXJzZWN0IHNvbWV0aGluZ1xuXHRcdCAqIElmIHRoZSBvcHRpb25zLmludGVyc2VjdCBpcyBmYWxzZSwgd2UgZmluZCB0aGUgbmVhcmVzdCBpdGVtIGFuZCByZXR1cm4gdGhlIGl0ZW1zIGluIHRoYXQgZGF0YXNldFxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy5kYXRhc2V0XG5cdFx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXG5cdFx0ICogQHBhcmFtIHtFdmVudH0gZSAtIHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcblx0XHQgKiBAcGFyYW0ge0ludGVyYWN0aW9uT3B0aW9uc30gb3B0aW9ucyAtIG9wdGlvbnMgdG8gdXNlXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbdXNlRmluYWxQb3NpdGlvbl0gLSB1c2UgZmluYWwgZWxlbWVudCBwb3NpdGlvbiAoYW5pbWF0aW9uIHRhcmdldClcblx0XHQgKiBAcmV0dXJuIHtJbnRlcmFjdGlvbkl0ZW1bXX0gLSBpdGVtcyB0aGF0IGFyZSBmb3VuZFxuXHRcdCAqL1xuICAgIGRhdGFzZXQoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICBjb25zdCBheGlzID0gb3B0aW9ucy5heGlzIHx8ICd4eSc7XG4gICAgICBjb25zdCBpbmNsdWRlSW52aXNpYmxlID0gb3B0aW9ucy5pbmNsdWRlSW52aXNpYmxlIHx8IGZhbHNlO1xuICAgICAgbGV0IGl0ZW1zID0gb3B0aW9ucy5pbnRlcnNlY3RcbiAgICAgICAgPyBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpIDpcbiAgICAgICAgZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgZmFsc2UsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpO1xuXG4gICAgICBpZiAoaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBkYXRhc2V0SW5kZXggPSBpdGVtc1swXS5kYXRhc2V0SW5kZXg7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpLmRhdGE7XG4gICAgICAgIGl0ZW1zID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGl0ZW1zLnB1c2goe2VsZW1lbnQ6IGRhdGFbaV0sIGRhdGFzZXRJbmRleCwgaW5kZXg6IGl9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXRlbXM7XG4gICAgfSxcblxuICAgIC8qKlxuXHRcdCAqIFBvaW50IG1vZGUgcmV0dXJucyBhbGwgZWxlbWVudHMgdGhhdCBoaXQgdGVzdCBiYXNlZCBvbiB0aGUgZXZlbnQgcG9zaXRpb25cblx0XHQgKiBvZiB0aGUgZXZlbnRcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMuaW50ZXJzZWN0XG5cdFx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXG5cdFx0ICogQHBhcmFtIHtFdmVudH0gZSAtIHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcblx0XHQgKiBAcGFyYW0ge0ludGVyYWN0aW9uT3B0aW9uc30gb3B0aW9ucyAtIG9wdGlvbnMgdG8gdXNlXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbdXNlRmluYWxQb3NpdGlvbl0gLSB1c2UgZmluYWwgZWxlbWVudCBwb3NpdGlvbiAoYW5pbWF0aW9uIHRhcmdldClcblx0XHQgKiBAcmV0dXJuIHtJbnRlcmFjdGlvbkl0ZW1bXX0gLSBpdGVtcyB0aGF0IGFyZSBmb3VuZFxuXHRcdCAqL1xuICAgIHBvaW50KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneHknO1xuICAgICAgY29uc3QgaW5jbHVkZUludmlzaWJsZSA9IG9wdGlvbnMuaW5jbHVkZUludmlzaWJsZSB8fCBmYWxzZTtcbiAgICAgIHJldHVybiBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpO1xuICAgIH0sXG5cbiAgICAvKipcblx0XHQgKiBuZWFyZXN0IG1vZGUgcmV0dXJucyB0aGUgZWxlbWVudCBjbG9zZXN0IHRvIHRoZSBwb2ludFxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy5pbnRlcnNlY3Rcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEBwYXJhbSB7SW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyB0byB1c2Vcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSBmaW5hbCBlbGVtZW50IHBvc2l0aW9uIChhbmltYXRpb24gdGFyZ2V0KVxuXHRcdCAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSAtIGl0ZW1zIHRoYXQgYXJlIGZvdW5kXG5cdFx0ICovXG4gICAgbmVhcmVzdChjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgIGNvbnN0IGF4aXMgPSBvcHRpb25zLmF4aXMgfHwgJ3h5JztcbiAgICAgIGNvbnN0IGluY2x1ZGVJbnZpc2libGUgPSBvcHRpb25zLmluY2x1ZGVJbnZpc2libGUgfHwgZmFsc2U7XG4gICAgICByZXR1cm4gZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgb3B0aW9ucy5pbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpO1xuICAgIH0sXG5cbiAgICAvKipcblx0XHQgKiB4IG1vZGUgcmV0dXJucyB0aGUgZWxlbWVudHMgdGhhdCBoaXQtdGVzdCBhdCB0aGUgY3VycmVudCB4IGNvb3JkaW5hdGVcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMueFxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0ICogQHBhcmFtIHtJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBvcHRpb25zIHRvIHVzZVxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIGZpbmFsIGVsZW1lbnQgcG9zaXRpb24gKGFuaW1hdGlvbiB0YXJnZXQpXG5cdFx0ICogQHJldHVybiB7SW50ZXJhY3Rpb25JdGVtW119IC0gaXRlbXMgdGhhdCBhcmUgZm91bmRcblx0XHQgKi9cbiAgICB4KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgcmV0dXJuIGdldEF4aXNJdGVtcyhjaGFydCwgcG9zaXRpb24sICd4Jywgb3B0aW9ucy5pbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIH0sXG5cbiAgICAvKipcblx0XHQgKiB5IG1vZGUgcmV0dXJucyB0aGUgZWxlbWVudHMgdGhhdCBoaXQtdGVzdCBhdCB0aGUgY3VycmVudCB5IGNvb3JkaW5hdGVcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMueVxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0ICogQHBhcmFtIHtJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBvcHRpb25zIHRvIHVzZVxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIGZpbmFsIGVsZW1lbnQgcG9zaXRpb24gKGFuaW1hdGlvbiB0YXJnZXQpXG5cdFx0ICogQHJldHVybiB7SW50ZXJhY3Rpb25JdGVtW119IC0gaXRlbXMgdGhhdCBhcmUgZm91bmRcblx0XHQgKi9cbiAgICB5KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgcmV0dXJuIGdldEF4aXNJdGVtcyhjaGFydCwgcG9zaXRpb24sICd5Jywgb3B0aW9ucy5pbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIH1cbiAgfVxufTtcbiIsImltcG9ydCB7ZGVmaW5lZCwgZWFjaCwgaXNPYmplY3R9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7dG9QYWRkaW5nfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMub3B0aW9ucy5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4vY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKi9cblxuY29uc3QgU1RBVElDX1BPU0lUSU9OUyA9IFsnbGVmdCcsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJ107XG5cbmZ1bmN0aW9uIGZpbHRlckJ5UG9zaXRpb24oYXJyYXksIHBvc2l0aW9uKSB7XG4gIHJldHVybiBhcnJheS5maWx0ZXIodiA9PiB2LnBvcyA9PT0gcG9zaXRpb24pO1xufVxuXG5mdW5jdGlvbiBmaWx0ZXJEeW5hbWljUG9zaXRpb25CeUF4aXMoYXJyYXksIGF4aXMpIHtcbiAgcmV0dXJuIGFycmF5LmZpbHRlcih2ID0+IFNUQVRJQ19QT1NJVElPTlMuaW5kZXhPZih2LnBvcykgPT09IC0xICYmIHYuYm94LmF4aXMgPT09IGF4aXMpO1xufVxuXG5mdW5jdGlvbiBzb3J0QnlXZWlnaHQoYXJyYXksIHJldmVyc2UpIHtcbiAgcmV0dXJuIGFycmF5LnNvcnQoKGEsIGIpID0+IHtcbiAgICBjb25zdCB2MCA9IHJldmVyc2UgPyBiIDogYTtcbiAgICBjb25zdCB2MSA9IHJldmVyc2UgPyBhIDogYjtcbiAgICByZXR1cm4gdjAud2VpZ2h0ID09PSB2MS53ZWlnaHQgP1xuICAgICAgdjAuaW5kZXggLSB2MS5pbmRleCA6XG4gICAgICB2MC53ZWlnaHQgLSB2MS53ZWlnaHQ7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB3cmFwQm94ZXMoYm94ZXMpIHtcbiAgY29uc3QgbGF5b3V0Qm94ZXMgPSBbXTtcbiAgbGV0IGksIGlsZW4sIGJveCwgcG9zLCBzdGFjaywgc3RhY2tXZWlnaHQ7XG5cbiAgZm9yIChpID0gMCwgaWxlbiA9IChib3hlcyB8fCBbXSkubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgYm94ID0gYm94ZXNbaV07XG4gICAgKHtwb3NpdGlvbjogcG9zLCBvcHRpb25zOiB7c3RhY2ssIHN0YWNrV2VpZ2h0ID0gMX19ID0gYm94KTtcbiAgICBsYXlvdXRCb3hlcy5wdXNoKHtcbiAgICAgIGluZGV4OiBpLFxuICAgICAgYm94LFxuICAgICAgcG9zLFxuICAgICAgaG9yaXpvbnRhbDogYm94LmlzSG9yaXpvbnRhbCgpLFxuICAgICAgd2VpZ2h0OiBib3gud2VpZ2h0LFxuICAgICAgc3RhY2s6IHN0YWNrICYmIChwb3MgKyBzdGFjayksXG4gICAgICBzdGFja1dlaWdodFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBsYXlvdXRCb3hlcztcbn1cblxuZnVuY3Rpb24gYnVpbGRTdGFja3MobGF5b3V0cykge1xuICBjb25zdCBzdGFja3MgPSB7fTtcbiAgZm9yIChjb25zdCB3cmFwIG9mIGxheW91dHMpIHtcbiAgICBjb25zdCB7c3RhY2ssIHBvcywgc3RhY2tXZWlnaHR9ID0gd3JhcDtcbiAgICBpZiAoIXN0YWNrIHx8ICFTVEFUSUNfUE9TSVRJT05TLmluY2x1ZGVzKHBvcykpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBfc3RhY2sgPSBzdGFja3Nbc3RhY2tdIHx8IChzdGFja3Nbc3RhY2tdID0ge2NvdW50OiAwLCBwbGFjZWQ6IDAsIHdlaWdodDogMCwgc2l6ZTogMH0pO1xuICAgIF9zdGFjay5jb3VudCsrO1xuICAgIF9zdGFjay53ZWlnaHQgKz0gc3RhY2tXZWlnaHQ7XG4gIH1cbiAgcmV0dXJuIHN0YWNrcztcbn1cblxuLyoqXG4gKiBzdG9yZSBkaW1lbnNpb25zIHVzZWQgaW5zdGVhZCBvZiBhdmFpbGFibGUgY2hhcnRBcmVhIGluIGZpdEJveGVzXG4gKiovXG5mdW5jdGlvbiBzZXRMYXlvdXREaW1zKGxheW91dHMsIHBhcmFtcykge1xuICBjb25zdCBzdGFja3MgPSBidWlsZFN0YWNrcyhsYXlvdXRzKTtcbiAgY29uc3Qge3ZCb3hNYXhXaWR0aCwgaEJveE1heEhlaWdodH0gPSBwYXJhbXM7XG4gIGxldCBpLCBpbGVuLCBsYXlvdXQ7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBsYXlvdXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGxheW91dCA9IGxheW91dHNbaV07XG4gICAgY29uc3Qge2Z1bGxTaXplfSA9IGxheW91dC5ib3g7XG4gICAgY29uc3Qgc3RhY2sgPSBzdGFja3NbbGF5b3V0LnN0YWNrXTtcbiAgICBjb25zdCBmYWN0b3IgPSBzdGFjayAmJiBsYXlvdXQuc3RhY2tXZWlnaHQgLyBzdGFjay53ZWlnaHQ7XG4gICAgaWYgKGxheW91dC5ob3Jpem9udGFsKSB7XG4gICAgICBsYXlvdXQud2lkdGggPSBmYWN0b3IgPyBmYWN0b3IgKiB2Qm94TWF4V2lkdGggOiBmdWxsU2l6ZSAmJiBwYXJhbXMuYXZhaWxhYmxlV2lkdGg7XG4gICAgICBsYXlvdXQuaGVpZ2h0ID0gaEJveE1heEhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGF5b3V0LndpZHRoID0gdkJveE1heFdpZHRoO1xuICAgICAgbGF5b3V0LmhlaWdodCA9IGZhY3RvciA/IGZhY3RvciAqIGhCb3hNYXhIZWlnaHQgOiBmdWxsU2l6ZSAmJiBwYXJhbXMuYXZhaWxhYmxlSGVpZ2h0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RhY2tzO1xufVxuXG5mdW5jdGlvbiBidWlsZExheW91dEJveGVzKGJveGVzKSB7XG4gIGNvbnN0IGxheW91dEJveGVzID0gd3JhcEJveGVzKGJveGVzKTtcbiAgY29uc3QgZnVsbFNpemUgPSBzb3J0QnlXZWlnaHQobGF5b3V0Qm94ZXMuZmlsdGVyKHdyYXAgPT4gd3JhcC5ib3guZnVsbFNpemUpLCB0cnVlKTtcbiAgY29uc3QgbGVmdCA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAnbGVmdCcpLCB0cnVlKTtcbiAgY29uc3QgcmlnaHQgPSBzb3J0QnlXZWlnaHQoZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ3JpZ2h0JykpO1xuICBjb25zdCB0b3AgPSBzb3J0QnlXZWlnaHQoZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ3RvcCcpLCB0cnVlKTtcbiAgY29uc3QgYm90dG9tID0gc29ydEJ5V2VpZ2h0KGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdib3R0b20nKSk7XG4gIGNvbnN0IGNlbnRlckhvcml6b250YWwgPSBmaWx0ZXJEeW5hbWljUG9zaXRpb25CeUF4aXMobGF5b3V0Qm94ZXMsICd4Jyk7XG4gIGNvbnN0IGNlbnRlclZlcnRpY2FsID0gZmlsdGVyRHluYW1pY1Bvc2l0aW9uQnlBeGlzKGxheW91dEJveGVzLCAneScpO1xuXG4gIHJldHVybiB7XG4gICAgZnVsbFNpemUsXG4gICAgbGVmdEFuZFRvcDogbGVmdC5jb25jYXQodG9wKSxcbiAgICByaWdodEFuZEJvdHRvbTogcmlnaHQuY29uY2F0KGNlbnRlclZlcnRpY2FsKS5jb25jYXQoYm90dG9tKS5jb25jYXQoY2VudGVySG9yaXpvbnRhbCksXG4gICAgY2hhcnRBcmVhOiBmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAnY2hhcnRBcmVhJyksXG4gICAgdmVydGljYWw6IGxlZnQuY29uY2F0KHJpZ2h0KS5jb25jYXQoY2VudGVyVmVydGljYWwpLFxuICAgIGhvcml6b250YWw6IHRvcC5jb25jYXQoYm90dG9tKS5jb25jYXQoY2VudGVySG9yaXpvbnRhbClcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29tYmluZWRNYXgobWF4UGFkZGluZywgY2hhcnRBcmVhLCBhLCBiKSB7XG4gIHJldHVybiBNYXRoLm1heChtYXhQYWRkaW5nW2FdLCBjaGFydEFyZWFbYV0pICsgTWF0aC5tYXgobWF4UGFkZGluZ1tiXSwgY2hhcnRBcmVhW2JdKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTWF4UGFkZGluZyhtYXhQYWRkaW5nLCBib3hQYWRkaW5nKSB7XG4gIG1heFBhZGRpbmcudG9wID0gTWF0aC5tYXgobWF4UGFkZGluZy50b3AsIGJveFBhZGRpbmcudG9wKTtcbiAgbWF4UGFkZGluZy5sZWZ0ID0gTWF0aC5tYXgobWF4UGFkZGluZy5sZWZ0LCBib3hQYWRkaW5nLmxlZnQpO1xuICBtYXhQYWRkaW5nLmJvdHRvbSA9IE1hdGgubWF4KG1heFBhZGRpbmcuYm90dG9tLCBib3hQYWRkaW5nLmJvdHRvbSk7XG4gIG1heFBhZGRpbmcucmlnaHQgPSBNYXRoLm1heChtYXhQYWRkaW5nLnJpZ2h0LCBib3hQYWRkaW5nLnJpZ2h0KTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRGltcyhjaGFydEFyZWEsIHBhcmFtcywgbGF5b3V0LCBzdGFja3MpIHtcbiAgY29uc3Qge3BvcywgYm94fSA9IGxheW91dDtcbiAgY29uc3QgbWF4UGFkZGluZyA9IGNoYXJ0QXJlYS5tYXhQYWRkaW5nO1xuXG4gIC8vIGR5bmFtaWNhbGx5IHBsYWNlZCBib3hlcyBzaXplIGlzIG5vdCBjb25zaWRlcmVkXG4gIGlmICghaXNPYmplY3QocG9zKSkge1xuICAgIGlmIChsYXlvdXQuc2l6ZSkge1xuICAgICAgLy8gdGhpcyBsYXlvdXQgd2FzIGFscmVhZHkgY291bnRlZCBmb3IsIGxldHMgZmlyc3QgcmVkdWNlIG9sZCBzaXplXG4gICAgICBjaGFydEFyZWFbcG9zXSAtPSBsYXlvdXQuc2l6ZTtcbiAgICB9XG4gICAgY29uc3Qgc3RhY2sgPSBzdGFja3NbbGF5b3V0LnN0YWNrXSB8fCB7c2l6ZTogMCwgY291bnQ6IDF9O1xuICAgIHN0YWNrLnNpemUgPSBNYXRoLm1heChzdGFjay5zaXplLCBsYXlvdXQuaG9yaXpvbnRhbCA/IGJveC5oZWlnaHQgOiBib3gud2lkdGgpO1xuICAgIGxheW91dC5zaXplID0gc3RhY2suc2l6ZSAvIHN0YWNrLmNvdW50O1xuICAgIGNoYXJ0QXJlYVtwb3NdICs9IGxheW91dC5zaXplO1xuICB9XG5cbiAgaWYgKGJveC5nZXRQYWRkaW5nKSB7XG4gICAgdXBkYXRlTWF4UGFkZGluZyhtYXhQYWRkaW5nLCBib3guZ2V0UGFkZGluZygpKTtcbiAgfVxuXG4gIGNvbnN0IG5ld1dpZHRoID0gTWF0aC5tYXgoMCwgcGFyYW1zLm91dGVyV2lkdGggLSBnZXRDb21iaW5lZE1heChtYXhQYWRkaW5nLCBjaGFydEFyZWEsICdsZWZ0JywgJ3JpZ2h0JykpO1xuICBjb25zdCBuZXdIZWlnaHQgPSBNYXRoLm1heCgwLCBwYXJhbXMub3V0ZXJIZWlnaHQgLSBnZXRDb21iaW5lZE1heChtYXhQYWRkaW5nLCBjaGFydEFyZWEsICd0b3AnLCAnYm90dG9tJykpO1xuICBjb25zdCB3aWR0aENoYW5nZWQgPSBuZXdXaWR0aCAhPT0gY2hhcnRBcmVhLnc7XG4gIGNvbnN0IGhlaWdodENoYW5nZWQgPSBuZXdIZWlnaHQgIT09IGNoYXJ0QXJlYS5oO1xuICBjaGFydEFyZWEudyA9IG5ld1dpZHRoO1xuICBjaGFydEFyZWEuaCA9IG5ld0hlaWdodDtcblxuICAvLyByZXR1cm4gYm9vbGVhbnMgb24gdGhlIGNoYW5nZXMgcGVyIGRpcmVjdGlvblxuICByZXR1cm4gbGF5b3V0Lmhvcml6b250YWxcbiAgICA/IHtzYW1lOiB3aWR0aENoYW5nZWQsIG90aGVyOiBoZWlnaHRDaGFuZ2VkfVxuICAgIDoge3NhbWU6IGhlaWdodENoYW5nZWQsIG90aGVyOiB3aWR0aENoYW5nZWR9O1xufVxuXG5mdW5jdGlvbiBoYW5kbGVNYXhQYWRkaW5nKGNoYXJ0QXJlYSkge1xuICBjb25zdCBtYXhQYWRkaW5nID0gY2hhcnRBcmVhLm1heFBhZGRpbmc7XG5cbiAgZnVuY3Rpb24gdXBkYXRlUG9zKHBvcykge1xuICAgIGNvbnN0IGNoYW5nZSA9IE1hdGgubWF4KG1heFBhZGRpbmdbcG9zXSAtIGNoYXJ0QXJlYVtwb3NdLCAwKTtcbiAgICBjaGFydEFyZWFbcG9zXSArPSBjaGFuZ2U7XG4gICAgcmV0dXJuIGNoYW5nZTtcbiAgfVxuICBjaGFydEFyZWEueSArPSB1cGRhdGVQb3MoJ3RvcCcpO1xuICBjaGFydEFyZWEueCArPSB1cGRhdGVQb3MoJ2xlZnQnKTtcbiAgdXBkYXRlUG9zKCdyaWdodCcpO1xuICB1cGRhdGVQb3MoJ2JvdHRvbScpO1xufVxuXG5mdW5jdGlvbiBnZXRNYXJnaW5zKGhvcml6b250YWwsIGNoYXJ0QXJlYSkge1xuICBjb25zdCBtYXhQYWRkaW5nID0gY2hhcnRBcmVhLm1heFBhZGRpbmc7XG5cbiAgZnVuY3Rpb24gbWFyZ2luRm9yUG9zaXRpb25zKHBvc2l0aW9ucykge1xuICAgIGNvbnN0IG1hcmdpbiA9IHtsZWZ0OiAwLCB0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDB9O1xuICAgIHBvc2l0aW9ucy5mb3JFYWNoKChwb3MpID0+IHtcbiAgICAgIG1hcmdpbltwb3NdID0gTWF0aC5tYXgoY2hhcnRBcmVhW3Bvc10sIG1heFBhZGRpbmdbcG9zXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG1hcmdpbjtcbiAgfVxuXG4gIHJldHVybiBob3Jpem9udGFsXG4gICAgPyBtYXJnaW5Gb3JQb3NpdGlvbnMoWydsZWZ0JywgJ3JpZ2h0J10pXG4gICAgOiBtYXJnaW5Gb3JQb3NpdGlvbnMoWyd0b3AnLCAnYm90dG9tJ10pO1xufVxuXG5mdW5jdGlvbiBmaXRCb3hlcyhib3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcykge1xuICBjb25zdCByZWZpdEJveGVzID0gW107XG4gIGxldCBpLCBpbGVuLCBsYXlvdXQsIGJveCwgcmVmaXQsIGNoYW5nZWQ7XG5cbiAgZm9yIChpID0gMCwgaWxlbiA9IGJveGVzLmxlbmd0aCwgcmVmaXQgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgbGF5b3V0ID0gYm94ZXNbaV07XG4gICAgYm94ID0gbGF5b3V0LmJveDtcblxuICAgIGJveC51cGRhdGUoXG4gICAgICBsYXlvdXQud2lkdGggfHwgY2hhcnRBcmVhLncsXG4gICAgICBsYXlvdXQuaGVpZ2h0IHx8IGNoYXJ0QXJlYS5oLFxuICAgICAgZ2V0TWFyZ2lucyhsYXlvdXQuaG9yaXpvbnRhbCwgY2hhcnRBcmVhKVxuICAgICk7XG4gICAgY29uc3Qge3NhbWUsIG90aGVyfSA9IHVwZGF0ZURpbXMoY2hhcnRBcmVhLCBwYXJhbXMsIGxheW91dCwgc3RhY2tzKTtcblxuICAgIC8vIERpbWVuc2lvbnMgY2hhbmdlZCBhbmQgdGhlcmUgd2VyZSBub24gZnVsbCB3aWR0aCBib3hlcyBiZWZvcmUgdGhpc1xuICAgIC8vIC0+IHdlIGhhdmUgdG8gcmVmaXQgdGhvc2VcbiAgICByZWZpdCB8PSBzYW1lICYmIHJlZml0Qm94ZXMubGVuZ3RoO1xuXG4gICAgLy8gQ2hhcnQgYXJlYSBjaGFuZ2VkIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb25cbiAgICBjaGFuZ2VkID0gY2hhbmdlZCB8fCBvdGhlcjtcblxuICAgIGlmICghYm94LmZ1bGxTaXplKSB7IC8vIGZ1bGxTaXplIGJveGVzIGRvbid0IG5lZWQgdG8gYmUgcmUtZml0dGVkIGluIGFueSBjYXNlXG4gICAgICByZWZpdEJveGVzLnB1c2gobGF5b3V0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVmaXQgJiYgZml0Qm94ZXMocmVmaXRCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcykgfHwgY2hhbmdlZDtcbn1cblxuZnVuY3Rpb24gc2V0Qm94RGltcyhib3gsIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCkge1xuICBib3gudG9wID0gdG9wO1xuICBib3gubGVmdCA9IGxlZnQ7XG4gIGJveC5yaWdodCA9IGxlZnQgKyB3aWR0aDtcbiAgYm94LmJvdHRvbSA9IHRvcCArIGhlaWdodDtcbiAgYm94LndpZHRoID0gd2lkdGg7XG4gIGJveC5oZWlnaHQgPSBoZWlnaHQ7XG59XG5cbmZ1bmN0aW9uIHBsYWNlQm94ZXMoYm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpIHtcbiAgY29uc3QgdXNlclBhZGRpbmcgPSBwYXJhbXMucGFkZGluZztcbiAgbGV0IHt4LCB5fSA9IGNoYXJ0QXJlYTtcblxuICBmb3IgKGNvbnN0IGxheW91dCBvZiBib3hlcykge1xuICAgIGNvbnN0IGJveCA9IGxheW91dC5ib3g7XG4gICAgY29uc3Qgc3RhY2sgPSBzdGFja3NbbGF5b3V0LnN0YWNrXSB8fCB7Y291bnQ6IDEsIHBsYWNlZDogMCwgd2VpZ2h0OiAxfTtcbiAgICBjb25zdCB3ZWlnaHQgPSAobGF5b3V0LnN0YWNrV2VpZ2h0IC8gc3RhY2sud2VpZ2h0KSB8fCAxO1xuICAgIGlmIChsYXlvdXQuaG9yaXpvbnRhbCkge1xuICAgICAgY29uc3Qgd2lkdGggPSBjaGFydEFyZWEudyAqIHdlaWdodDtcbiAgICAgIGNvbnN0IGhlaWdodCA9IHN0YWNrLnNpemUgfHwgYm94LmhlaWdodDtcbiAgICAgIGlmIChkZWZpbmVkKHN0YWNrLnN0YXJ0KSkge1xuICAgICAgICB5ID0gc3RhY2suc3RhcnQ7XG4gICAgICB9XG4gICAgICBpZiAoYm94LmZ1bGxTaXplKSB7XG4gICAgICAgIHNldEJveERpbXMoYm94LCB1c2VyUGFkZGluZy5sZWZ0LCB5LCBwYXJhbXMub3V0ZXJXaWR0aCAtIHVzZXJQYWRkaW5nLnJpZ2h0IC0gdXNlclBhZGRpbmcubGVmdCwgaGVpZ2h0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldEJveERpbXMoYm94LCBjaGFydEFyZWEubGVmdCArIHN0YWNrLnBsYWNlZCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB9XG4gICAgICBzdGFjay5zdGFydCA9IHk7XG4gICAgICBzdGFjay5wbGFjZWQgKz0gd2lkdGg7XG4gICAgICB5ID0gYm94LmJvdHRvbTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaGVpZ2h0ID0gY2hhcnRBcmVhLmggKiB3ZWlnaHQ7XG4gICAgICBjb25zdCB3aWR0aCA9IHN0YWNrLnNpemUgfHwgYm94LndpZHRoO1xuICAgICAgaWYgKGRlZmluZWQoc3RhY2suc3RhcnQpKSB7XG4gICAgICAgIHggPSBzdGFjay5zdGFydDtcbiAgICAgIH1cbiAgICAgIGlmIChib3guZnVsbFNpemUpIHtcbiAgICAgICAgc2V0Qm94RGltcyhib3gsIHgsIHVzZXJQYWRkaW5nLnRvcCwgd2lkdGgsIHBhcmFtcy5vdXRlckhlaWdodCAtIHVzZXJQYWRkaW5nLmJvdHRvbSAtIHVzZXJQYWRkaW5nLnRvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRCb3hEaW1zKGJveCwgeCwgY2hhcnRBcmVhLnRvcCArIHN0YWNrLnBsYWNlZCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB9XG4gICAgICBzdGFjay5zdGFydCA9IHg7XG4gICAgICBzdGFjay5wbGFjZWQgKz0gaGVpZ2h0O1xuICAgICAgeCA9IGJveC5yaWdodDtcbiAgICB9XG4gIH1cblxuICBjaGFydEFyZWEueCA9IHg7XG4gIGNoYXJ0QXJlYS55ID0geTtcbn1cblxuLyoqXG4gKiBAaW50ZXJmYWNlIExheW91dEl0ZW1cbiAqIEB0eXBlZGVmIHtvYmplY3R9IExheW91dEl0ZW1cbiAqIEBwcm9wIHtzdHJpbmd9IHBvc2l0aW9uIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBpdGVtIGluIHRoZSBjaGFydCBsYXlvdXQuIFBvc3NpYmxlIHZhbHVlcyBhcmVcbiAqICdsZWZ0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCBhbmQgJ2NoYXJ0QXJlYSdcbiAqIEBwcm9wIHtudW1iZXJ9IHdlaWdodCAtIFRoZSB3ZWlnaHQgdXNlZCB0byBzb3J0IHRoZSBpdGVtLiBIaWdoZXIgd2VpZ2h0cyBhcmUgZnVydGhlciBhd2F5IGZyb20gdGhlIGNoYXJ0IGFyZWFcbiAqIEBwcm9wIHtib29sZWFufSBmdWxsU2l6ZSAtIGlmIHRydWUsIGFuZCB0aGUgaXRlbSBpcyBob3Jpem9udGFsLCB0aGVuIHB1c2ggdmVydGljYWwgYm94ZXMgZG93blxuICogQHByb3Age2Z1bmN0aW9ufSBpc0hvcml6b250YWwgLSByZXR1cm5zIHRydWUgaWYgdGhlIGxheW91dCBpdGVtIGlzIGhvcml6b250YWwgKGllLiB0b3Agb3IgYm90dG9tKVxuICogQHByb3Age2Z1bmN0aW9ufSB1cGRhdGUgLSBUYWtlcyB0d28gcGFyYW1ldGVyczogd2lkdGggYW5kIGhlaWdodC4gUmV0dXJucyBzaXplIG9mIGl0ZW1cbiAqIEBwcm9wIHtmdW5jdGlvbn0gZHJhdyAtIERyYXdzIHRoZSBlbGVtZW50XG4gKiBAcHJvcCB7ZnVuY3Rpb259IFtnZXRQYWRkaW5nXSAtICBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHBhZGRpbmcgb24gdGhlIGVkZ2VzXG4gKiBAcHJvcCB7bnVtYmVyfSB3aWR0aCAtIFdpZHRoIG9mIGl0ZW0uIE11c3QgYmUgdmFsaWQgYWZ0ZXIgdXBkYXRlKClcbiAqIEBwcm9wIHtudW1iZXJ9IGhlaWdodCAtIEhlaWdodCBvZiBpdGVtLiBNdXN0IGJlIHZhbGlkIGFmdGVyIHVwZGF0ZSgpXG4gKiBAcHJvcCB7bnVtYmVyfSBsZWZ0IC0gTGVmdCBlZGdlIG9mIHRoZSBpdGVtLiBTZXQgYnkgbGF5b3V0IHN5c3RlbSBhbmQgY2Fubm90IGJlIHVzZWQgaW4gdXBkYXRlXG4gKiBAcHJvcCB7bnVtYmVyfSB0b3AgLSBUb3AgZWRnZSBvZiB0aGUgaXRlbS4gU2V0IGJ5IGxheW91dCBzeXN0ZW0gYW5kIGNhbm5vdCBiZSB1c2VkIGluIHVwZGF0ZVxuICogQHByb3Age251bWJlcn0gcmlnaHQgLSBSaWdodCBlZGdlIG9mIHRoZSBpdGVtLiBTZXQgYnkgbGF5b3V0IHN5c3RlbSBhbmQgY2Fubm90IGJlIHVzZWQgaW4gdXBkYXRlXG4gKiBAcHJvcCB7bnVtYmVyfSBib3R0b20gLSBCb3R0b20gZWRnZSBvZiB0aGUgaXRlbS4gU2V0IGJ5IGxheW91dCBzeXN0ZW0gYW5kIGNhbm5vdCBiZSB1c2VkIGluIHVwZGF0ZVxuICovXG5cbi8vIFRoZSBsYXlvdXQgc2VydmljZSBpcyB2ZXJ5IHNlbGYgZXhwbGFuYXRvcnkuICBJdCdzIHJlc3BvbnNpYmxlIGZvciB0aGUgbGF5b3V0IHdpdGhpbiBhIGNoYXJ0LlxuLy8gU2NhbGVzLCBMZWdlbmRzIGFuZCBQbHVnaW5zIGFsbCByZWx5IG9uIHRoZSBsYXlvdXQgc2VydmljZSBhbmQgY2FuIGVhc2lseSByZWdpc3RlciB0byBiZSBwbGFjZWQgYW55d2hlcmUgdGhleSBuZWVkXG4vLyBJdCBpcyB0aGlzIHNlcnZpY2UncyByZXNwb25zaWJpbGl0eSBvZiBjYXJyeWluZyBvdXQgdGhhdCBsYXlvdXQuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgLyoqXG5cdCAqIFJlZ2lzdGVyIGEgYm94IHRvIGEgY2hhcnQuXG5cdCAqIEEgYm94IGlzIHNpbXBseSBhIHJlZmVyZW5jZSB0byBhbiBvYmplY3QgdGhhdCByZXF1aXJlcyBsYXlvdXQuIGVnLiBTY2FsZXMsIExlZ2VuZCwgVGl0bGUuXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHRvIHVzZVxuXHQgKiBAcGFyYW0ge0xheW91dEl0ZW19IGl0ZW0gLSB0aGUgaXRlbSB0byBhZGQgdG8gYmUgbGFpZCBvdXRcblx0ICovXG4gIGFkZEJveChjaGFydCwgaXRlbSkge1xuICAgIGlmICghY2hhcnQuYm94ZXMpIHtcbiAgICAgIGNoYXJ0LmJveGVzID0gW107XG4gICAgfVxuXG4gICAgLy8gaW5pdGlhbGl6ZSBpdGVtIHdpdGggZGVmYXVsdCB2YWx1ZXNcbiAgICBpdGVtLmZ1bGxTaXplID0gaXRlbS5mdWxsU2l6ZSB8fCBmYWxzZTtcbiAgICBpdGVtLnBvc2l0aW9uID0gaXRlbS5wb3NpdGlvbiB8fCAndG9wJztcbiAgICBpdGVtLndlaWdodCA9IGl0ZW0ud2VpZ2h0IHx8IDA7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGl0ZW0uX2xheWVycyA9IGl0ZW0uX2xheWVycyB8fCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBbe1xuICAgICAgICB6OiAwLFxuICAgICAgICBkcmF3KGNoYXJ0QXJlYSkge1xuICAgICAgICAgIGl0ZW0uZHJhdyhjaGFydEFyZWEpO1xuICAgICAgICB9XG4gICAgICB9XTtcbiAgICB9O1xuXG4gICAgY2hhcnQuYm94ZXMucHVzaChpdGVtKTtcbiAgfSxcblxuICAvKipcblx0ICogUmVtb3ZlIGEgbGF5b3V0SXRlbSBmcm9tIGEgY2hhcnRcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgdG8gcmVtb3ZlIHRoZSBib3ggZnJvbVxuXHQgKiBAcGFyYW0ge0xheW91dEl0ZW19IGxheW91dEl0ZW0gLSB0aGUgaXRlbSB0byByZW1vdmUgZnJvbSB0aGUgbGF5b3V0XG5cdCAqL1xuICByZW1vdmVCb3goY2hhcnQsIGxheW91dEl0ZW0pIHtcbiAgICBjb25zdCBpbmRleCA9IGNoYXJ0LmJveGVzID8gY2hhcnQuYm94ZXMuaW5kZXhPZihsYXlvdXRJdGVtKSA6IC0xO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIGNoYXJ0LmJveGVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuXHQgKiBTZXRzIChvciB1cGRhdGVzKSBvcHRpb25zIG9uIHRoZSBnaXZlbiBgaXRlbWAuXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IGluIHdoaWNoIHRoZSBpdGVtIGxpdmVzIChvciB3aWxsIGJlIGFkZGVkIHRvKVxuXHQgKiBAcGFyYW0ge0xheW91dEl0ZW19IGl0ZW0gLSB0aGUgaXRlbSB0byBjb25maWd1cmUgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9uc1xuXHQgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIHRoZSBuZXcgaXRlbSBvcHRpb25zLlxuXHQgKi9cbiAgY29uZmlndXJlKGNoYXJ0LCBpdGVtLCBvcHRpb25zKSB7XG4gICAgaXRlbS5mdWxsU2l6ZSA9IG9wdGlvbnMuZnVsbFNpemU7XG4gICAgaXRlbS5wb3NpdGlvbiA9IG9wdGlvbnMucG9zaXRpb247XG4gICAgaXRlbS53ZWlnaHQgPSBvcHRpb25zLndlaWdodDtcbiAgfSxcblxuICAvKipcblx0ICogRml0cyBib3hlcyBvZiB0aGUgZ2l2ZW4gY2hhcnQgaW50byB0aGUgZ2l2ZW4gc2l6ZSBieSBoYXZpbmcgZWFjaCBib3ggbWVhc3VyZSBpdHNlbGZcblx0ICogdGhlbiBydW5uaW5nIGEgZml0dGluZyBhbGdvcml0aG1cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnRcblx0ICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gdGhlIHdpZHRoIHRvIGZpdCBpbnRvXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSB0aGUgaGVpZ2h0IHRvIGZpdCBpbnRvXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5QYWRkaW5nIC0gbWluaW11bSBwYWRkaW5nIHJlcXVpcmVkIGZvciBlYWNoIHNpZGUgb2YgY2hhcnQgYXJlYVxuXHQgKi9cbiAgdXBkYXRlKGNoYXJ0LCB3aWR0aCwgaGVpZ2h0LCBtaW5QYWRkaW5nKSB7XG4gICAgaWYgKCFjaGFydCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcoY2hhcnQub3B0aW9ucy5sYXlvdXQucGFkZGluZyk7XG4gICAgY29uc3QgYXZhaWxhYmxlV2lkdGggPSBNYXRoLm1heCh3aWR0aCAtIHBhZGRpbmcud2lkdGgsIDApO1xuICAgIGNvbnN0IGF2YWlsYWJsZUhlaWdodCA9IE1hdGgubWF4KGhlaWdodCAtIHBhZGRpbmcuaGVpZ2h0LCAwKTtcbiAgICBjb25zdCBib3hlcyA9IGJ1aWxkTGF5b3V0Qm94ZXMoY2hhcnQuYm94ZXMpO1xuICAgIGNvbnN0IHZlcnRpY2FsQm94ZXMgPSBib3hlcy52ZXJ0aWNhbDtcbiAgICBjb25zdCBob3Jpem9udGFsQm94ZXMgPSBib3hlcy5ob3Jpem9udGFsO1xuXG4gICAgLy8gQmVmb3JlIGFueSBjaGFuZ2VzIGFyZSBtYWRlLCBub3RpZnkgYm94ZXMgdGhhdCBhbiB1cGRhdGUgaXMgYWJvdXQgdG8gYmVpbmdcbiAgICAvLyBUaGlzIGlzIHVzZWQgdG8gY2xlYXIgYW55IGNhY2hlZCBkYXRhIChlLmcuIHNjYWxlIGxpbWl0cylcbiAgICBlYWNoKGNoYXJ0LmJveGVzLCBib3ggPT4ge1xuICAgICAgaWYgKHR5cGVvZiBib3guYmVmb3JlTGF5b3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGJveC5iZWZvcmVMYXlvdXQoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEVzc2VudGlhbGx5IHdlIG5vdyBoYXZlIGFueSBudW1iZXIgb2YgYm94ZXMgb24gZWFjaCBvZiB0aGUgNCBzaWRlcy5cbiAgICAvLyBPdXIgY2FudmFzIGxvb2tzIGxpa2UgdGhlIGZvbGxvd2luZy5cbiAgICAvLyBUaGUgYXJlYXMgTDEgYW5kIEwyIGFyZSB0aGUgbGVmdCBheGVzLiBSMSBpcyB0aGUgcmlnaHQgYXhpcywgVDEgaXMgdGhlIHRvcCBheGlzIGFuZFxuICAgIC8vIEIxIGlzIHRoZSBib3R0b20gYXhpc1xuICAgIC8vIFRoZXJlIGFyZSBhbHNvIDQgcXVhZHJhbnQtbGlrZSBsb2NhdGlvbnMgKGxlZnQgdG8gcmlnaHQgaW5zdGVhZCBvZiBjbG9ja3dpc2UpIHJlc2VydmVkIGZvciBjaGFydCBvdmVybGF5c1xuICAgIC8vIFRoZXNlIGxvY2F0aW9ucyBhcmUgc2luZ2xlLWJveCBsb2NhdGlvbnMgb25seSwgd2hlbiB0cnlpbmcgdG8gcmVnaXN0ZXIgYSBjaGFydEFyZWEgbG9jYXRpb24gdGhhdCBpcyBhbHJlYWR5IHRha2VuLFxuICAgIC8vIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICAgIC8vXG4gICAgLy8gfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gICAgLy8gfCAgICAgICAgICAgICAgICAgIFQxIChGdWxsIFdpZHRoKSAgICAgICAgICAgICAgICAgICB8XG4gICAgLy8gfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gICAgLy8gfCAgICB8ICAgIHwgICAgICAgICAgICAgICAgIFQyICAgICAgICAgICAgICAgICAgfCAgICB8XG4gICAgLy8gfCAgICB8LS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS18XG4gICAgLy8gfCAgICB8ICAgIHwgQzEgfCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgQzIgfCAgICB8XG4gICAgLy8gfCAgICB8ICAgIHwtLS0tfCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwtLS0tfCAgICB8XG4gICAgLy8gfCAgICB8ICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICB8XG4gICAgLy8gfCBMMSB8IEwyIHwgICAgICAgICAgIENoYXJ0QXJlYSAoQzApICAgICAgICAgICAgfCBSMSB8XG4gICAgLy8gfCAgICB8ICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICB8XG4gICAgLy8gfCAgICB8ICAgIHwtLS0tfCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwtLS0tfCAgICB8XG4gICAgLy8gfCAgICB8ICAgIHwgQzMgfCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgQzQgfCAgICB8XG4gICAgLy8gfCAgICB8LS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS18XG4gICAgLy8gfCAgICB8ICAgIHwgICAgICAgICAgICAgICAgIEIxICAgICAgICAgICAgICAgICAgfCAgICB8XG4gICAgLy8gfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gICAgLy8gfCAgICAgICAgICAgICAgICAgIEIyIChGdWxsIFdpZHRoKSAgICAgICAgICAgICAgICAgICB8XG4gICAgLy8gfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gICAgLy9cblxuICAgIGNvbnN0IHZpc2libGVWZXJ0aWNhbEJveENvdW50ID0gdmVydGljYWxCb3hlcy5yZWR1Y2UoKHRvdGFsLCB3cmFwKSA9PlxuICAgICAgd3JhcC5ib3gub3B0aW9ucyAmJiB3cmFwLmJveC5vcHRpb25zLmRpc3BsYXkgPT09IGZhbHNlID8gdG90YWwgOiB0b3RhbCArIDEsIDApIHx8IDE7XG5cbiAgICBjb25zdCBwYXJhbXMgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgIG91dGVyV2lkdGg6IHdpZHRoLFxuICAgICAgb3V0ZXJIZWlnaHQ6IGhlaWdodCxcbiAgICAgIHBhZGRpbmcsXG4gICAgICBhdmFpbGFibGVXaWR0aCxcbiAgICAgIGF2YWlsYWJsZUhlaWdodCxcbiAgICAgIHZCb3hNYXhXaWR0aDogYXZhaWxhYmxlV2lkdGggLyAyIC8gdmlzaWJsZVZlcnRpY2FsQm94Q291bnQsXG4gICAgICBoQm94TWF4SGVpZ2h0OiBhdmFpbGFibGVIZWlnaHQgLyAyXG4gICAgfSk7XG4gICAgY29uc3QgbWF4UGFkZGluZyA9IE9iamVjdC5hc3NpZ24oe30sIHBhZGRpbmcpO1xuICAgIHVwZGF0ZU1heFBhZGRpbmcobWF4UGFkZGluZywgdG9QYWRkaW5nKG1pblBhZGRpbmcpKTtcbiAgICBjb25zdCBjaGFydEFyZWEgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIG1heFBhZGRpbmcsXG4gICAgICB3OiBhdmFpbGFibGVXaWR0aCxcbiAgICAgIGg6IGF2YWlsYWJsZUhlaWdodCxcbiAgICAgIHg6IHBhZGRpbmcubGVmdCxcbiAgICAgIHk6IHBhZGRpbmcudG9wXG4gICAgfSwgcGFkZGluZyk7XG5cbiAgICBjb25zdCBzdGFja3MgPSBzZXRMYXlvdXREaW1zKHZlcnRpY2FsQm94ZXMuY29uY2F0KGhvcml6b250YWxCb3hlcyksIHBhcmFtcyk7XG5cbiAgICAvLyBGaXJzdCBmaXQgdGhlIGZ1bGxTaXplIGJveGVzLCB0byByZWR1Y2UgcHJvYmFiaWxpdHkgb2YgcmUtZml0dGluZy5cbiAgICBmaXRCb3hlcyhib3hlcy5mdWxsU2l6ZSwgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG5cbiAgICAvLyBUaGVuIGZpdCB2ZXJ0aWNhbCBib3hlc1xuICAgIGZpdEJveGVzKHZlcnRpY2FsQm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xuXG4gICAgLy8gVGhlbiBmaXQgaG9yaXpvbnRhbCBib3hlc1xuICAgIGlmIChmaXRCb3hlcyhob3Jpem9udGFsQm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpKSB7XG4gICAgICAvLyBpZiB0aGUgYXJlYSBjaGFuZ2VkLCByZS1maXQgdmVydGljYWwgYm94ZXNcbiAgICAgIGZpdEJveGVzKHZlcnRpY2FsQm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xuICAgIH1cblxuICAgIGhhbmRsZU1heFBhZGRpbmcoY2hhcnRBcmVhKTtcblxuICAgIC8vIEZpbmFsbHkgcGxhY2UgdGhlIGJveGVzIHRvIGNvcnJlY3QgY29vcmRpbmF0ZXNcbiAgICBwbGFjZUJveGVzKGJveGVzLmxlZnRBbmRUb3AsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xuXG4gICAgLy8gTW92ZSB0byBvcHBvc2l0ZSBzaWRlIG9mIGNoYXJ0XG4gICAgY2hhcnRBcmVhLnggKz0gY2hhcnRBcmVhLnc7XG4gICAgY2hhcnRBcmVhLnkgKz0gY2hhcnRBcmVhLmg7XG5cbiAgICBwbGFjZUJveGVzKGJveGVzLnJpZ2h0QW5kQm90dG9tLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKTtcblxuICAgIGNoYXJ0LmNoYXJ0QXJlYSA9IHtcbiAgICAgIGxlZnQ6IGNoYXJ0QXJlYS5sZWZ0LFxuICAgICAgdG9wOiBjaGFydEFyZWEudG9wLFxuICAgICAgcmlnaHQ6IGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLncsXG4gICAgICBib3R0b206IGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuaCxcbiAgICAgIGhlaWdodDogY2hhcnRBcmVhLmgsXG4gICAgICB3aWR0aDogY2hhcnRBcmVhLncsXG4gICAgfTtcblxuICAgIC8vIEZpbmFsbHkgdXBkYXRlIGJveGVzIGluIGNoYXJ0QXJlYSAocmFkaWFsIHNjYWxlIGZvciBleGFtcGxlKVxuICAgIGVhY2goYm94ZXMuY2hhcnRBcmVhLCAobGF5b3V0KSA9PiB7XG4gICAgICBjb25zdCBib3ggPSBsYXlvdXQuYm94O1xuICAgICAgT2JqZWN0LmFzc2lnbihib3gsIGNoYXJ0LmNoYXJ0QXJlYSk7XG4gICAgICBib3gudXBkYXRlKGNoYXJ0QXJlYS53LCBjaGFydEFyZWEuaCwge2xlZnQ6IDAsIHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMH0pO1xuICAgIH0pO1xuICB9XG59O1xuIiwiXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9jb3JlL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICovXG5cbi8qKlxuICogQWJzdHJhY3QgY2xhc3MgdGhhdCBhbGxvd3MgYWJzdHJhY3RpbmcgcGxhdGZvcm0gZGVwZW5kZW5jaWVzIGF3YXkgZnJvbSB0aGUgY2hhcnQuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2VQbGF0Zm9ybSB7XG4gIC8qKlxuXHQgKiBDYWxsZWQgYXQgY2hhcnQgY29uc3RydWN0aW9uIHRpbWUsIHJldHVybnMgYSBjb250ZXh0MmQgaW5zdGFuY2UgaW1wbGVtZW50aW5nXG5cdCAqIHRoZSBbVzNDIENhbnZhcyAyRCBDb250ZXh0IEFQSSBzdGFuZGFyZF17QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSLzJkY29udGV4dC99LlxuXHQgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgLSBUaGUgY2FudmFzIGZyb20gd2hpY2ggdG8gYWNxdWlyZSBjb250ZXh0IChwbGF0Zm9ybSBzcGVjaWZpYylcblx0ICogQHBhcmFtIHtudW1iZXJ9IFthc3BlY3RSYXRpb10gLSBUaGUgY2hhcnQgb3B0aW9uc1xuXHQgKi9cbiAgYWNxdWlyZUNvbnRleHQoY2FudmFzLCBhc3BlY3RSYXRpbykge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gIC8qKlxuXHQgKiBDYWxsZWQgYXQgY2hhcnQgZGVzdHJ1Y3Rpb24gdGltZSwgcmVsZWFzZXMgYW55IHJlc291cmNlcyBhc3NvY2lhdGVkIHRvIHRoZSBjb250ZXh0XG5cdCAqIHByZXZpb3VzbHkgcmV0dXJuZWQgYnkgdGhlIGFjcXVpcmVDb250ZXh0KCkgbWV0aG9kLlxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAtIFRoZSBjb250ZXh0MmQgaW5zdGFuY2Vcblx0ICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIG1ldGhvZCBzdWNjZWVkZWQsIGVsc2UgZmFsc2Vcblx0ICovXG4gIHJlbGVhc2VDb250ZXh0KGNvbnRleHQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZWdpc3RlcnMgdGhlIHNwZWNpZmllZCBsaXN0ZW5lciBvbiB0aGUgZ2l2ZW4gY2hhcnQuXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gQ2hhcnQgZnJvbSB3aGljaCB0byBsaXN0ZW4gZm9yIGV2ZW50XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlICh7QGxpbmsgQ2hhcnRFdmVudH0pIHR5cGUgdG8gbGlzdGVuIGZvclxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciAtIFJlY2VpdmVzIGEgbm90aWZpY2F0aW9uIChhbiBvYmplY3QgdGhhdCBpbXBsZW1lbnRzXG5cdCAqIHRoZSB7QGxpbmsgQ2hhcnRFdmVudH0gaW50ZXJmYWNlKSB3aGVuIGFuIGV2ZW50IG9mIHRoZSBzcGVjaWZpZWQgdHlwZSBvY2N1cnMuXG5cdCAqL1xuICBhZGRFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gIC8qKlxuXHQgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgbGlzdGVuZXIgcHJldmlvdXNseSByZWdpc3RlcmVkIHdpdGggYWRkRXZlbnRMaXN0ZW5lci5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSBDaGFydCBmcm9tIHdoaWNoIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXJcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgKHtAbGluayBDaGFydEV2ZW50fSkgdHlwZSB0byByZW1vdmVcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgLSBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gdG8gcmVtb3ZlIGZyb20gdGhlIGV2ZW50IHRhcmdldC5cblx0ICovXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgLyoqXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSBjdXJyZW50IGRldmljZVBpeGVsUmF0aW8gb2YgdGhlIGRldmljZSB0aGlzIHBsYXRmb3JtIGlzIGNvbm5lY3RlZCB0by5cblx0ICovXG4gIGdldERldmljZVBpeGVsUmF0aW8oKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgbWF4aW11bSBzaXplIGluIHBpeGVscyBvZiBnaXZlbiBjYW52YXMgZWxlbWVudC5cblx0ICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gZWxlbWVudFxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoXSAtIGNvbnRlbnQgd2lkdGggb2YgcGFyZW50IGVsZW1lbnRcblx0ICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHRdIC0gY29udGVudCBoZWlnaHQgb2YgcGFyZW50IGVsZW1lbnRcblx0ICogQHBhcmFtIHtudW1iZXJ9IFthc3BlY3RSYXRpb10gLSBhc3BlY3QgcmF0aW8gdG8gbWFpbnRhaW5cblx0ICovXG4gIGdldE1heGltdW1TaXplKGVsZW1lbnQsIHdpZHRoLCBoZWlnaHQsIGFzcGVjdFJhdGlvKSB7XG4gICAgd2lkdGggPSBNYXRoLm1heCgwLCB3aWR0aCB8fCBlbGVtZW50LndpZHRoKTtcbiAgICBoZWlnaHQgPSBoZWlnaHQgfHwgZWxlbWVudC5oZWlnaHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0OiBNYXRoLm1heCgwLCBhc3BlY3RSYXRpbyA/IE1hdGguZmxvb3Iod2lkdGggLyBhc3BlY3RSYXRpbykgOiBoZWlnaHQpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXNcblx0ICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIGNhbnZhcyBpcyBhdHRhY2hlZCB0byB0aGUgcGxhdGZvcm0sIGZhbHNlIGlmIG5vdC5cblx0ICovXG4gIGlzQXR0YWNoZWQoY2FudmFzKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGNvbmZpZyB3aXRoIHBsYXRmb3JtIHNwZWNpZmljIHJlcXVpcmVtZW50c1xuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vY29yZS9jb3JlLmNvbmZpZy5qcycpLmRlZmF1bHR9IGNvbmZpZ1xuICAgKi9cbiAgdXBkYXRlQ29uZmlnKGNvbmZpZykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgLy8gbm8tb3BcbiAgfVxufVxuIiwiLyoqXG4gKiBQbGF0Zm9ybSBmYWxsYmFjayBpbXBsZW1lbnRhdGlvbiAobWluaW1hbCkuXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL3B1bGwvNDU5MSNpc3N1ZWNvbW1lbnQtMzE5NTc1OTM5XG4gKi9cblxuaW1wb3J0IEJhc2VQbGF0Zm9ybSBmcm9tICcuL3BsYXRmb3JtLmJhc2UuanMnO1xuXG4vKipcbiAqIFBsYXRmb3JtIGNsYXNzIGZvciBjaGFydHMgd2l0aG91dCBhY2Nlc3MgdG8gdGhlIERPTSBvciB0byBtYW55IGVsZW1lbnQgcHJvcGVydGllc1xuICogVGhpcyBwbGF0Zm9ybSBpcyB1c2VkIGJ5IGRlZmF1bHQgZm9yIGFueSBjaGFydCBwYXNzZWQgYW4gT2Zmc2NyZWVuQ2FudmFzLlxuICogQGV4dGVuZHMgQmFzZVBsYXRmb3JtXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2ljUGxhdGZvcm0gZXh0ZW5kcyBCYXNlUGxhdGZvcm0ge1xuICBhY3F1aXJlQ29udGV4dChpdGVtKSB7XG4gICAgLy8gVG8gcHJldmVudCBjYW52YXMgZmluZ2VycHJpbnRpbmcsIHNvbWUgYWRkLW9ucyB1bmRlZmluZSB0aGUgZ2V0Q29udGV4dFxuICAgIC8vIG1ldGhvZCwgZm9yIGV4YW1wbGU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ra2Fwc25lci9DYW52YXNCbG9ja2VyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzI4MDdcbiAgICByZXR1cm4gaXRlbSAmJiBpdGVtLmdldENvbnRleHQgJiYgaXRlbS5nZXRDb250ZXh0KCcyZCcpIHx8IG51bGw7XG4gIH1cbiAgdXBkYXRlQ29uZmlnKGNvbmZpZykge1xuICAgIGNvbmZpZy5vcHRpb25zLmFuaW1hdGlvbiA9IGZhbHNlO1xuICB9XG59XG4iLCIvKipcbiAqIENoYXJ0LlBsYXRmb3JtIGltcGxlbWVudGF0aW9uIGZvciB0YXJnZXRpbmcgYSB3ZWIgYnJvd3NlclxuICovXG5cbmltcG9ydCBCYXNlUGxhdGZvcm0gZnJvbSAnLi9wbGF0Zm9ybS5iYXNlLmpzJztcbmltcG9ydCB7X2dldFBhcmVudE5vZGUsIGdldFJlbGF0aXZlUG9zaXRpb24sIHN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMsIHJlYWRVc2VkU2l6ZSwgZ2V0TWF4aW11bVNpemV9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5kb20uanMnO1xuaW1wb3J0IHt0aHJvdHRsZWR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5leHRyYXMuanMnO1xuaW1wb3J0IHtpc051bGxPclVuZGVmfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL2NvcmUvY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKi9cblxuY29uc3QgRVhQQU5ET19LRVkgPSAnJGNoYXJ0anMnO1xuXG4vKipcbiAqIERPTSBldmVudCB0eXBlcyAtPiBDaGFydC5qcyBldmVudCB0eXBlcy5cbiAqIE5vdGU6IG9ubHkgZXZlbnRzIHdpdGggZGlmZmVyZW50IHR5cGVzIGFyZSBtYXBwZWQuXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0V2ZW50c1xuICovXG5jb25zdCBFVkVOVF9UWVBFUyA9IHtcbiAgdG91Y2hzdGFydDogJ21vdXNlZG93bicsXG4gIHRvdWNobW92ZTogJ21vdXNlbW92ZScsXG4gIHRvdWNoZW5kOiAnbW91c2V1cCcsXG4gIHBvaW50ZXJlbnRlcjogJ21vdXNlZW50ZXInLFxuICBwb2ludGVyZG93bjogJ21vdXNlZG93bicsXG4gIHBvaW50ZXJtb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgcG9pbnRlcnVwOiAnbW91c2V1cCcsXG4gIHBvaW50ZXJsZWF2ZTogJ21vdXNlb3V0JyxcbiAgcG9pbnRlcm91dDogJ21vdXNlb3V0J1xufTtcblxuY29uc3QgaXNOdWxsT3JFbXB0eSA9IHZhbHVlID0+IHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSAnJztcbi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIGNhbnZhcyBzdHlsZSBhbmQgcmVuZGVyIHNpemUgd2l0aG91dCBtb2RpZnlpbmcgdGhlIGNhbnZhcyBkaXNwbGF5IHNpemUsXG4gKiBzaW5jZSByZXNwb25zaXZlbmVzcyBpcyBoYW5kbGVkIGJ5IHRoZSBjb250cm9sbGVyLnJlc2l6ZSgpIG1ldGhvZC4gVGhlIGNvbmZpZyBpcyB1c2VkXG4gKiB0byBkZXRlcm1pbmUgdGhlIGFzcGVjdCByYXRpbyB0byBhcHBseSBpbiBjYXNlIG5vIGV4cGxpY2l0IGhlaWdodCBoYXMgYmVlbiBzcGVjaWZpZWQuXG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXNwZWN0UmF0aW9dXG4gKi9cbmZ1bmN0aW9uIGluaXRDYW52YXMoY2FudmFzLCBhc3BlY3RSYXRpbykge1xuICBjb25zdCBzdHlsZSA9IGNhbnZhcy5zdHlsZTtcblxuICAvLyBOT1RFKFNCKSBjYW52YXMuZ2V0QXR0cmlidXRlKCd3aWR0aCcpICE9PSBjYW52YXMud2lkdGg6IGluIHRoZSBmaXJzdCBjYXNlIGl0XG4gIC8vIHJldHVybnMgbnVsbCBvciAnJyBpZiBubyBleHBsaWNpdCB2YWx1ZSBoYXMgYmVlbiBzZXQgdG8gdGhlIGNhbnZhcyBhdHRyaWJ1dGUuXG4gIGNvbnN0IHJlbmRlckhlaWdodCA9IGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpO1xuICBjb25zdCByZW5kZXJXaWR0aCA9IGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyk7XG5cbiAgLy8gQ2hhcnQuanMgbW9kaWZpZXMgc29tZSBjYW52YXMgdmFsdWVzIHRoYXQgd2Ugd2FudCB0byByZXN0b3JlIG9uIGRlc3Ryb3lcbiAgY2FudmFzW0VYUEFORE9fS0VZXSA9IHtcbiAgICBpbml0aWFsOiB7XG4gICAgICBoZWlnaHQ6IHJlbmRlckhlaWdodCxcbiAgICAgIHdpZHRoOiByZW5kZXJXaWR0aCxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGRpc3BsYXk6IHN0eWxlLmRpc3BsYXksXG4gICAgICAgIGhlaWdodDogc3R5bGUuaGVpZ2h0LFxuICAgICAgICB3aWR0aDogc3R5bGUud2lkdGhcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gRm9yY2UgY2FudmFzIHRvIGRpc3BsYXkgYXMgYmxvY2sgdG8gYXZvaWQgZXh0cmEgc3BhY2UgY2F1c2VkIGJ5IGlubGluZVxuICAvLyBlbGVtZW50cywgd2hpY2ggd291bGQgaW50ZXJmZXJlIHdpdGggdGhlIHJlc3BvbnNpdmUgcmVzaXplIHByb2Nlc3MuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yNTM4XG4gIHN0eWxlLmRpc3BsYXkgPSBzdHlsZS5kaXNwbGF5IHx8ICdibG9jayc7XG4gIC8vIEluY2x1ZGUgcG9zc2libGUgYm9yZGVycyBpbiB0aGUgc2l6ZVxuICBzdHlsZS5ib3hTaXppbmcgPSBzdHlsZS5ib3hTaXppbmcgfHwgJ2JvcmRlci1ib3gnO1xuXG4gIGlmIChpc051bGxPckVtcHR5KHJlbmRlcldpZHRoKSkge1xuICAgIGNvbnN0IGRpc3BsYXlXaWR0aCA9IHJlYWRVc2VkU2l6ZShjYW52YXMsICd3aWR0aCcpO1xuICAgIGlmIChkaXNwbGF5V2lkdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2FudmFzLndpZHRoID0gZGlzcGxheVdpZHRoO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc051bGxPckVtcHR5KHJlbmRlckhlaWdodCkpIHtcbiAgICBpZiAoY2FudmFzLnN0eWxlLmhlaWdodCA9PT0gJycpIHtcbiAgICAgIC8vIElmIG5vIGV4cGxpY2l0IHJlbmRlciBoZWlnaHQgYW5kIHN0eWxlIGhlaWdodCwgbGV0J3MgYXBwbHkgdGhlIGFzcGVjdCByYXRpbyxcbiAgICAgIC8vIHdoaWNoIG9uZSBjYW4gYmUgc3BlY2lmaWVkIGJ5IHRoZSB1c2VyIGJ1dCBhbHNvIGJ5IGNoYXJ0cyBhcyBkZWZhdWx0IG9wdGlvblxuICAgICAgLy8gKGkuZS4gb3B0aW9ucy5hc3BlY3RSYXRpbykuIElmIG5vdCBzcGVjaWZpZWQsIHVzZSBjYW52YXMgYXNwZWN0IHJhdGlvIG9mIDIuXG4gICAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzLndpZHRoIC8gKGFzcGVjdFJhdGlvIHx8IDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBkaXNwbGF5SGVpZ2h0ID0gcmVhZFVzZWRTaXplKGNhbnZhcywgJ2hlaWdodCcpO1xuICAgICAgaWYgKGRpc3BsYXlIZWlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gZGlzcGxheUhlaWdodDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2FudmFzO1xufVxuXG4vLyBEZWZhdWx0IHBhc3NpdmUgdG8gdHJ1ZSBhcyBleHBlY3RlZCBieSBDaHJvbWUgZm9yICd0b3VjaHN0YXJ0JyBhbmQgJ3RvdWNoZW5kJyBldmVudHMuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNDI4N1xuY29uc3QgZXZlbnRMaXN0ZW5lck9wdGlvbnMgPSBzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zID8ge3Bhc3NpdmU6IHRydWV9IDogZmFsc2U7XG5cbmZ1bmN0aW9uIGFkZExpc3RlbmVyKG5vZGUsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmIChub2RlKSB7XG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBldmVudExpc3RlbmVyT3B0aW9ucyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmIChjaGFydCAmJiBjaGFydC5jYW52YXMpIHtcbiAgICBjaGFydC5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgZXZlbnRMaXN0ZW5lck9wdGlvbnMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZyb21OYXRpdmVFdmVudChldmVudCwgY2hhcnQpIHtcbiAgY29uc3QgdHlwZSA9IEVWRU5UX1RZUEVTW2V2ZW50LnR5cGVdIHx8IGV2ZW50LnR5cGU7XG4gIGNvbnN0IHt4LCB5fSA9IGdldFJlbGF0aXZlUG9zaXRpb24oZXZlbnQsIGNoYXJ0KTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlLFxuICAgIGNoYXJ0LFxuICAgIG5hdGl2ZTogZXZlbnQsXG4gICAgeDogeCAhPT0gdW5kZWZpbmVkID8geCA6IG51bGwsXG4gICAgeTogeSAhPT0gdW5kZWZpbmVkID8geSA6IG51bGwsXG4gIH07XG59XG5cbmZ1bmN0aW9uIG5vZGVMaXN0Q29udGFpbnMobm9kZUxpc3QsIGNhbnZhcykge1xuICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZUxpc3QpIHtcbiAgICBpZiAobm9kZSA9PT0gY2FudmFzIHx8IG5vZGUuY29udGFpbnMoY2FudmFzKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUF0dGFjaE9ic2VydmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuICBjb25zdCBjYW52YXMgPSBjaGFydC5jYW52YXM7XG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgbGV0IHRyaWdnZXIgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgIHRyaWdnZXIgPSB0cmlnZ2VyIHx8IG5vZGVMaXN0Q29udGFpbnMoZW50cnkuYWRkZWROb2RlcywgY2FudmFzKTtcbiAgICAgIHRyaWdnZXIgPSB0cmlnZ2VyICYmICFub2RlTGlzdENvbnRhaW5zKGVudHJ5LnJlbW92ZWROb2RlcywgY2FudmFzKTtcbiAgICB9XG4gICAgaWYgKHRyaWdnZXIpIHtcbiAgICAgIGxpc3RlbmVyKCk7XG4gICAgfVxuICB9KTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudCwge2NoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZX0pO1xuICByZXR1cm4gb2JzZXJ2ZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURldGFjaE9ic2VydmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuICBjb25zdCBjYW52YXMgPSBjaGFydC5jYW52YXM7XG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgbGV0IHRyaWdnZXIgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgIHRyaWdnZXIgPSB0cmlnZ2VyIHx8IG5vZGVMaXN0Q29udGFpbnMoZW50cnkucmVtb3ZlZE5vZGVzLCBjYW52YXMpO1xuICAgICAgdHJpZ2dlciA9IHRyaWdnZXIgJiYgIW5vZGVMaXN0Q29udGFpbnMoZW50cnkuYWRkZWROb2RlcywgY2FudmFzKTtcbiAgICB9XG4gICAgaWYgKHRyaWdnZXIpIHtcbiAgICAgIGxpc3RlbmVyKCk7XG4gICAgfVxuICB9KTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudCwge2NoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZX0pO1xuICByZXR1cm4gb2JzZXJ2ZXI7XG59XG5cbmNvbnN0IGRycExpc3RlbmluZ0NoYXJ0cyA9IG5ldyBNYXAoKTtcbmxldCBvbGREZXZpY2VQaXhlbFJhdGlvID0gMDtcblxuZnVuY3Rpb24gb25XaW5kb3dSZXNpemUoKSB7XG4gIGNvbnN0IGRwciA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICBpZiAoZHByID09PSBvbGREZXZpY2VQaXhlbFJhdGlvKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIG9sZERldmljZVBpeGVsUmF0aW8gPSBkcHI7XG4gIGRycExpc3RlbmluZ0NoYXJ0cy5mb3JFYWNoKChyZXNpemUsIGNoYXJ0KSA9PiB7XG4gICAgaWYgKGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvICE9PSBkcHIpIHtcbiAgICAgIHJlc2l6ZSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0LCByZXNpemUpIHtcbiAgaWYgKCFkcnBMaXN0ZW5pbmdDaGFydHMuc2l6ZSkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvbldpbmRvd1Jlc2l6ZSk7XG4gIH1cbiAgZHJwTGlzdGVuaW5nQ2hhcnRzLnNldChjaGFydCwgcmVzaXplKTtcbn1cblxuZnVuY3Rpb24gdW5saXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyhjaGFydCkge1xuICBkcnBMaXN0ZW5pbmdDaGFydHMuZGVsZXRlKGNoYXJ0KTtcbiAgaWYgKCFkcnBMaXN0ZW5pbmdDaGFydHMuc2l6ZSkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvbldpbmRvd1Jlc2l6ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlUmVzaXplT2JzZXJ2ZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgY29uc3QgY29udGFpbmVyID0gY2FudmFzICYmIF9nZXRQYXJlbnROb2RlKGNhbnZhcyk7XG4gIGlmICghY29udGFpbmVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHJlc2l6ZSA9IHRocm90dGxlZCgod2lkdGgsIGhlaWdodCkgPT4ge1xuICAgIGNvbnN0IHcgPSBjb250YWluZXIuY2xpZW50V2lkdGg7XG4gICAgbGlzdGVuZXIod2lkdGgsIGhlaWdodCk7XG4gICAgaWYgKHcgPCBjb250YWluZXIuY2xpZW50V2lkdGgpIHtcbiAgICAgIC8vIElmIHRoZSBjb250YWluZXIgc2l6ZSBzaHJhbmsgZHVyaW5nIGNoYXJ0IHJlc2l6ZSwgbGV0J3MgYXNzdW1lXG4gICAgICAvLyBzY3JvbGxiYXIgYXBwZWFyZWQuIFNvIHdlIHJlc2l6ZSBhZ2FpbiB3aXRoIHRoZSBzY3JvbGxiYXIgdmlzaWJsZSAtXG4gICAgICAvLyBlZmZlY3RpdmVseSBtYWtpbmcgY2hhcnQgc21hbGxlciBhbmQgdGhlIHNjcm9sbGJhciBoaWRkZW4gYWdhaW4uXG4gICAgICAvLyBCZWNhdXNlIHdlIGFyZSBpbnNpZGUgYHRocm90dGxlZGAsIGFuZCBjdXJyZW50bHkgYHRpY2tpbmdgLCBzY3JvbGxcbiAgICAgIC8vIGV2ZW50cyBhcmUgaWdub3JlZCBkdXJpbmcgdGhpcyB3aG9sZSAyIHJlc2l6ZSBwcm9jZXNzLlxuICAgICAgLy8gSWYgd2UgYXNzdW1lZCB3cm9uZyBhbmQgc29tZXRoaW5nIGVsc2UgaGFwcGVuZWQsIHdlIGFyZSByZXNpemluZ1xuICAgICAgLy8gdHdpY2UgaW4gYSBmcmFtZSAocG90ZW50aWFsIHBlcmZvcm1hbmNlIGlzc3VlKVxuICAgICAgbGlzdGVuZXIoKTtcbiAgICB9XG4gIH0sIHdpbmRvdyk7XG5cbiAgLy8gQHRzLWlnbm9yZSB1bnRpbCBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzM3ODYxIGltcGxlbWVudGVkXG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgIGNvbnN0IGVudHJ5ID0gZW50cmllc1swXTtcbiAgICBjb25zdCB3aWR0aCA9IGVudHJ5LmNvbnRlbnRSZWN0LndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IGVudHJ5LmNvbnRlbnRSZWN0LmhlaWdodDtcbiAgICAvLyBXaGVuIGl0cyBjb250YWluZXIncyBkaXNwbGF5IGlzIHNldCB0byAnbm9uZScgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHdpdGggYVxuICAgIC8vIHNpemUgb2YgKDAsIDApLCB3aGljaCB3aWxsIGNhdXNlIHRoZSBjaGFydCB0byBsb3NlIGl0cyBvcmlnaW5hbCBoZWlnaHQsIHNvIHNraXBcbiAgICAvLyByZXNpemluZyBpbiBzdWNoIGNhc2UuXG4gICAgaWYgKHdpZHRoID09PSAwICYmIGhlaWdodCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXNpemUod2lkdGgsIGhlaWdodCk7XG4gIH0pO1xuICBvYnNlcnZlci5vYnNlcnZlKGNvbnRhaW5lcik7XG4gIGxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0LCByZXNpemUpO1xuXG4gIHJldHVybiBvYnNlcnZlcjtcbn1cblxuZnVuY3Rpb24gcmVsZWFzZU9ic2VydmVyKGNoYXJ0LCB0eXBlLCBvYnNlcnZlcikge1xuICBpZiAob2JzZXJ2ZXIpIHtcbiAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdyZXNpemUnKSB7XG4gICAgdW5saXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyhjaGFydCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlUHJveHlBbmRMaXN0ZW4oY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgY29uc3QgcHJveHkgPSB0aHJvdHRsZWQoKGV2ZW50KSA9PiB7XG4gICAgLy8gVGhpcyBjYXNlIGNhbiBvY2N1ciBpZiB0aGUgY2hhcnQgaXMgZGVzdHJveWVkIHdoaWxlIHdhaXRpbmdcbiAgICAvLyBmb3IgdGhlIHRocm90dGxlZCBmdW5jdGlvbiB0byBvY2N1ci4gV2UgcHJldmVudCBjcmFzaGVzIGJ5IGNoZWNraW5nXG4gICAgLy8gZm9yIGEgZGVzdHJveWVkIGNoYXJ0XG4gICAgaWYgKGNoYXJ0LmN0eCAhPT0gbnVsbCkge1xuICAgICAgbGlzdGVuZXIoZnJvbU5hdGl2ZUV2ZW50KGV2ZW50LCBjaGFydCkpO1xuICAgIH1cbiAgfSwgY2hhcnQpO1xuXG4gIGFkZExpc3RlbmVyKGNhbnZhcywgdHlwZSwgcHJveHkpO1xuXG4gIHJldHVybiBwcm94eTtcbn1cblxuLyoqXG4gKiBQbGF0Zm9ybSBjbGFzcyBmb3IgY2hhcnRzIHRoYXQgY2FuIGFjY2VzcyB0aGUgRE9NIGFuZCBnbG9iYWwgd2luZG93L2RvY3VtZW50IHByb3BlcnRpZXNcbiAqIEBleHRlbmRzIEJhc2VQbGF0Zm9ybVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEb21QbGF0Zm9ybSBleHRlbmRzIEJhc2VQbGF0Zm9ybSB7XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gW2FzcGVjdFJhdGlvXVxuXHQgKiBAcmV0dXJuIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR8bnVsbH1cblx0ICovXG4gIGFjcXVpcmVDb250ZXh0KGNhbnZhcywgYXNwZWN0UmF0aW8pIHtcbiAgICAvLyBUbyBwcmV2ZW50IGNhbnZhcyBmaW5nZXJwcmludGluZywgc29tZSBhZGQtb25zIHVuZGVmaW5lIHRoZSBnZXRDb250ZXh0XG4gICAgLy8gbWV0aG9kLCBmb3IgZXhhbXBsZTogaHR0cHM6Ly9naXRodWIuY29tL2trYXBzbmVyL0NhbnZhc0Jsb2NrZXJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjgwN1xuICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMgJiYgY2FudmFzLmdldENvbnRleHQgJiYgY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAvLyBgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudC9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkRgIGZhaWxzIHdoZW4gdGhlIGNhbnZhcyBpc1xuICAgIC8vIGluc2lkZSBhbiBpZnJhbWUgb3Igd2hlbiBydW5uaW5nIGluIGEgcHJvdGVjdGVkIGVudmlyb25tZW50LiBXZSBjb3VsZCBndWVzcyB0aGVcbiAgICAvLyB0eXBlcyBmcm9tIHRoZWlyIHRvU3RyaW5nKCkgdmFsdWUgYnV0IGxldCdzIGtlZXAgdGhpbmdzIGZsZXhpYmxlIGFuZCBhc3N1bWUgaXQnc1xuICAgIC8vIGEgc3VmZmljaWVudCBjb25kaXRpb24gaWYgdGhlIGNhbnZhcyBoYXMgYSBjb250ZXh0MkQgd2hpY2ggaGFzIGNhbnZhcyBhcyBgY2FudmFzYC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMzg4N1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy80MTAyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzQxNTJcbiAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0LmNhbnZhcyA9PT0gY2FudmFzKSB7XG4gICAgICAvLyBMb2FkIHBsYXRmb3JtIHJlc291cmNlcyBvbiBmaXJzdCBjaGFydCBjcmVhdGlvbiwgdG8gbWFrZSBpdCBwb3NzaWJsZSB0b1xuICAgICAgLy8gaW1wb3J0IHRoZSBsaWJyYXJ5IGJlZm9yZSBzZXR0aW5nIHBsYXRmb3JtIG9wdGlvbnMuXG4gICAgICBpbml0Q2FudmFzKGNhbnZhcywgYXNwZWN0UmF0aW8pO1xuICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHRcblx0ICovXG4gIHJlbGVhc2VDb250ZXh0KGNvbnRleHQpIHtcbiAgICBjb25zdCBjYW52YXMgPSBjb250ZXh0LmNhbnZhcztcbiAgICBpZiAoIWNhbnZhc1tFWFBBTkRPX0tFWV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBpbml0aWFsID0gY2FudmFzW0VYUEFORE9fS0VZXS5pbml0aWFsO1xuICAgIFsnaGVpZ2h0JywgJ3dpZHRoJ10uZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBpbml0aWFsW3Byb3BdO1xuICAgICAgaWYgKGlzTnVsbE9yVW5kZWYodmFsdWUpKSB7XG4gICAgICAgIGNhbnZhcy5yZW1vdmVBdHRyaWJ1dGUocHJvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYW52YXMuc2V0QXR0cmlidXRlKHByb3AsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHN0eWxlID0gaW5pdGlhbC5zdHlsZSB8fCB7fTtcbiAgICBPYmplY3Qua2V5cyhzdHlsZSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBjYW52YXMuc3R5bGVba2V5XSA9IHN0eWxlW2tleV07XG4gICAgfSk7XG5cbiAgICAvLyBUaGUgY2FudmFzIHJlbmRlciBzaXplIG1pZ2h0IGhhdmUgYmVlbiBjaGFuZ2VkIChhbmQgdGh1cyB0aGUgc3RhdGUgc3RhY2sgZGlzY2FyZGVkKSxcbiAgICAvLyB3ZSBjYW4ndCB1c2Ugc2F2ZSgpIGFuZCByZXN0b3JlKCkgdG8gcmVzdG9yZSB0aGUgaW5pdGlhbCBzdGF0ZS4gU28gbWFrZSBzdXJlIHRoYXQgYXRcbiAgICAvLyBsZWFzdCB0aGUgY2FudmFzIGNvbnRleHQgaXMgcmVzZXQgdG8gdGhlIGRlZmF1bHQgc3RhdGUgYnkgc2V0dGluZyB0aGUgY2FudmFzIHdpZHRoLlxuICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDExL1dELWh0bWw1LTIwMTEwNTI1L3RoZS1jYW52YXMtZWxlbWVudC5odG1sXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtYXNzaWduXG4gICAgY2FudmFzLndpZHRoID0gY2FudmFzLndpZHRoO1xuXG4gICAgZGVsZXRlIGNhbnZhc1tFWFBBTkRPX0tFWV07XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcblx0ICpcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXJcblx0ICovXG4gIGFkZEV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgLy8gQ2FuIGhhdmUgb25seSBvbmUgbGlzdGVuZXIgcGVyIHR5cGUsIHNvIG1ha2Ugc3VyZSBwcmV2aW91cyBpcyByZW1vdmVkXG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlKTtcblxuICAgIGNvbnN0IHByb3hpZXMgPSBjaGFydC4kcHJveGllcyB8fCAoY2hhcnQuJHByb3hpZXMgPSB7fSk7XG4gICAgY29uc3QgaGFuZGxlcnMgPSB7XG4gICAgICBhdHRhY2g6IGNyZWF0ZUF0dGFjaE9ic2VydmVyLFxuICAgICAgZGV0YWNoOiBjcmVhdGVEZXRhY2hPYnNlcnZlcixcbiAgICAgIHJlc2l6ZTogY3JlYXRlUmVzaXplT2JzZXJ2ZXJcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZXIgPSBoYW5kbGVyc1t0eXBlXSB8fCBjcmVhdGVQcm94eUFuZExpc3RlbjtcbiAgICBwcm94aWVzW3R5cGVdID0gaGFuZGxlcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cblxuICAvKipcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcblx0ICovXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUpIHtcbiAgICBjb25zdCBwcm94aWVzID0gY2hhcnQuJHByb3hpZXMgfHwgKGNoYXJ0LiRwcm94aWVzID0ge30pO1xuICAgIGNvbnN0IHByb3h5ID0gcHJveGllc1t0eXBlXTtcblxuICAgIGlmICghcHJveHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBoYW5kbGVycyA9IHtcbiAgICAgIGF0dGFjaDogcmVsZWFzZU9ic2VydmVyLFxuICAgICAgZGV0YWNoOiByZWxlYXNlT2JzZXJ2ZXIsXG4gICAgICByZXNpemU6IHJlbGVhc2VPYnNlcnZlclxuICAgIH07XG4gICAgY29uc3QgaGFuZGxlciA9IGhhbmRsZXJzW3R5cGVdIHx8IHJlbW92ZUxpc3RlbmVyO1xuICAgIGhhbmRsZXIoY2hhcnQsIHR5cGUsIHByb3h5KTtcbiAgICBwcm94aWVzW3R5cGVdID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgZ2V0RGV2aWNlUGl4ZWxSYXRpbygpIHtcbiAgICByZXR1cm4gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbd2lkdGhdIC0gY29udGVudCB3aWR0aCBvZiBwYXJlbnQgZWxlbWVudFxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2hlaWdodF0gLSBjb250ZW50IGhlaWdodCBvZiBwYXJlbnQgZWxlbWVudFxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2FzcGVjdFJhdGlvXSAtIGFzcGVjdCByYXRpbyB0byBtYWludGFpblxuXHQgKi9cbiAgZ2V0TWF4aW11bVNpemUoY2FudmFzLCB3aWR0aCwgaGVpZ2h0LCBhc3BlY3RSYXRpbykge1xuICAgIHJldHVybiBnZXRNYXhpbXVtU2l6ZShjYW52YXMsIHdpZHRoLCBoZWlnaHQsIGFzcGVjdFJhdGlvKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXNcblx0ICovXG4gIGlzQXR0YWNoZWQoY2FudmFzKSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gY2FudmFzICYmIF9nZXRQYXJlbnROb2RlKGNhbnZhcyk7XG4gICAgcmV0dXJuICEhKGNvbnRhaW5lciAmJiBjb250YWluZXIuaXNDb25uZWN0ZWQpO1xuICB9XG59XG4iLCJpbXBvcnQge19pc0RvbVN1cHBvcnRlZH0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQgQmFzZVBsYXRmb3JtIGZyb20gJy4vcGxhdGZvcm0uYmFzZS5qcyc7XG5pbXBvcnQgQmFzaWNQbGF0Zm9ybSBmcm9tICcuL3BsYXRmb3JtLmJhc2ljLmpzJztcbmltcG9ydCBEb21QbGF0Zm9ybSBmcm9tICcuL3BsYXRmb3JtLmRvbS5qcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBfZGV0ZWN0UGxhdGZvcm0oY2FudmFzKSB7XG4gIGlmICghX2lzRG9tU3VwcG9ydGVkKCkgfHwgKHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnICYmIGNhbnZhcyBpbnN0YW5jZW9mIE9mZnNjcmVlbkNhbnZhcykpIHtcbiAgICByZXR1cm4gQmFzaWNQbGF0Zm9ybTtcbiAgfVxuICByZXR1cm4gRG9tUGxhdGZvcm07XG59XG5cbmV4cG9ydCB7QmFzZVBsYXRmb3JtLCBCYXNpY1BsYXRmb3JtLCBEb21QbGF0Zm9ybX07XG4iLCJpbXBvcnQgdHlwZSB7QW55T2JqZWN0fSBmcm9tICcuLi90eXBlcy9iYXNpYy5qcyc7XG5pbXBvcnQgdHlwZSB7UG9pbnR9IGZyb20gJy4uL3R5cGVzL2dlb21ldHJpYy5qcyc7XG5pbXBvcnQgdHlwZSB7QW5pbWF0aW9ufSBmcm9tICcuLi90eXBlcy9hbmltYXRpb24uanMnO1xuaW1wb3J0IHtpc051bWJlcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbGVtZW50PFQgPSBBbnlPYmplY3QsIE8gPSBBbnlPYmplY3Q+IHtcblxuICBzdGF0aWMgZGVmYXVsdHMgPSB7fTtcbiAgc3RhdGljIGRlZmF1bHRSb3V0ZXMgPSB1bmRlZmluZWQ7XG5cbiAgeDogbnVtYmVyO1xuICB5OiBudW1iZXI7XG4gIGFjdGl2ZSA9IGZhbHNlO1xuICBvcHRpb25zOiBPO1xuICAkYW5pbWF0aW9uczogUmVjb3JkPGtleW9mIFQsIEFuaW1hdGlvbj47XG5cbiAgdG9vbHRpcFBvc2l0aW9uKHVzZUZpbmFsUG9zaXRpb246IGJvb2xlYW4pOiBQb2ludCB7XG4gICAgY29uc3Qge3gsIHl9ID0gdGhpcy5nZXRQcm9wcyhbJ3gnLCAneSddLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICByZXR1cm4ge3gsIHl9IGFzIFBvaW50O1xuICB9XG5cbiAgaGFzVmFsdWUoKSB7XG4gICAgcmV0dXJuIGlzTnVtYmVyKHRoaXMueCkgJiYgaXNOdW1iZXIodGhpcy55KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IG9yIGZpbmFsIHZhbHVlIG9mIGVhY2ggcHJvcC4gQ2FuIHJldHVybiBleHRyYSBwcm9wZXJ0aWVzICh3aG9sZSBvYmplY3QpLlxuICAgKiBAcGFyYW0gcHJvcHMgLSBwcm9wZXJ0aWVzIHRvIGdldFxuICAgKiBAcGFyYW0gW2ZpbmFsXSAtIGdldCB0aGUgZmluYWwgdmFsdWUgKGFuaW1hdGlvbiB0YXJnZXQpXG4gICAqL1xuICBnZXRQcm9wczxQIGV4dGVuZHMgKGtleW9mIFQpW10+KHByb3BzOiBQLCBmaW5hbD86IGJvb2xlYW4pOiBQaWNrPFQsIFBbbnVtYmVyXT47XG4gIGdldFByb3BzPFAgZXh0ZW5kcyBzdHJpbmc+KHByb3BzOiBQW10sIGZpbmFsPzogYm9vbGVhbik6IFBhcnRpYWw8UmVjb3JkPFAsIHVua25vd24+PjtcbiAgZ2V0UHJvcHMocHJvcHM6IHN0cmluZ1tdLCBmaW5hbD86IGJvb2xlYW4pOiBQYXJ0aWFsPFJlY29yZDxzdHJpbmcsIHVua25vd24+PiB7XG4gICAgY29uc3QgYW5pbXMgPSB0aGlzLiRhbmltYXRpb25zO1xuICAgIGlmICghZmluYWwgfHwgIWFuaW1zKSB7XG4gICAgICAvLyBsZXQncyBub3QgY3JlYXRlIGFuIG9iamVjdCwgaWYgbm90IG5lZWRlZFxuICAgICAgcmV0dXJuIHRoaXMgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gICAgfVxuICAgIGNvbnN0IHJldDogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPSB7fTtcbiAgICBwcm9wcy5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICByZXRbcHJvcF0gPSBhbmltc1twcm9wXSAmJiBhbmltc1twcm9wXS5hY3RpdmUoKSA/IGFuaW1zW3Byb3BdLl90byA6IHRoaXNbcHJvcCBhcyBzdHJpbmddO1xuICAgIH0pO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbn1cbiIsImltcG9ydCB7aXNOdWxsT3JVbmRlZiwgdmFsdWVPckRlZmF1bHR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7X2ZhY3Rvcml6ZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4vY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKiBAdHlwZWRlZiB7e3ZhbHVlOm51bWJlciB8IHN0cmluZywgbGFiZWw/OnN0cmluZywgbWFqb3I/OmJvb2xlYW4sICRjb250ZXh0Pzphbnl9fSBUaWNrXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIGEgc3Vic2V0IG9mIHRpY2tzIHRvIGJlIHBsb3R0ZWQgdG8gYXZvaWQgb3ZlcmxhcHBpbmcgbGFiZWxzLlxuICogQHBhcmFtIHtpbXBvcnQoJy4vY29yZS5zY2FsZS5qcycpLmRlZmF1bHR9IHNjYWxlXG4gKiBAcGFyYW0ge1RpY2tbXX0gdGlja3NcbiAqIEByZXR1cm4ge1RpY2tbXX1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhdXRvU2tpcChzY2FsZSwgdGlja3MpIHtcbiAgY29uc3QgdGlja09wdHMgPSBzY2FsZS5vcHRpb25zLnRpY2tzO1xuICBjb25zdCBkZXRlcm1pbmVkTWF4VGlja3MgPSBkZXRlcm1pbmVNYXhUaWNrcyhzY2FsZSk7XG4gIGNvbnN0IHRpY2tzTGltaXQgPSBNYXRoLm1pbih0aWNrT3B0cy5tYXhUaWNrc0xpbWl0IHx8IGRldGVybWluZWRNYXhUaWNrcywgZGV0ZXJtaW5lZE1heFRpY2tzKTtcbiAgY29uc3QgbWFqb3JJbmRpY2VzID0gdGlja09wdHMubWFqb3IuZW5hYmxlZCA/IGdldE1ham9ySW5kaWNlcyh0aWNrcykgOiBbXTtcbiAgY29uc3QgbnVtTWFqb3JJbmRpY2VzID0gbWFqb3JJbmRpY2VzLmxlbmd0aDtcbiAgY29uc3QgZmlyc3QgPSBtYWpvckluZGljZXNbMF07XG4gIGNvbnN0IGxhc3QgPSBtYWpvckluZGljZXNbbnVtTWFqb3JJbmRpY2VzIC0gMV07XG4gIGNvbnN0IG5ld1RpY2tzID0gW107XG5cbiAgLy8gSWYgdGhlcmUgYXJlIHRvbyBtYW55IG1ham9yIHRpY2tzIHRvIGRpc3BsYXkgdGhlbSBhbGxcbiAgaWYgKG51bU1ham9ySW5kaWNlcyA+IHRpY2tzTGltaXQpIHtcbiAgICBza2lwTWFqb3JzKHRpY2tzLCBuZXdUaWNrcywgbWFqb3JJbmRpY2VzLCBudW1NYWpvckluZGljZXMgLyB0aWNrc0xpbWl0KTtcbiAgICByZXR1cm4gbmV3VGlja3M7XG4gIH1cblxuICBjb25zdCBzcGFjaW5nID0gY2FsY3VsYXRlU3BhY2luZyhtYWpvckluZGljZXMsIHRpY2tzLCB0aWNrc0xpbWl0KTtcblxuICBpZiAobnVtTWFqb3JJbmRpY2VzID4gMCkge1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGNvbnN0IGF2Z01ham9yU3BhY2luZyA9IG51bU1ham9ySW5kaWNlcyA+IDEgPyBNYXRoLnJvdW5kKChsYXN0IC0gZmlyc3QpIC8gKG51bU1ham9ySW5kaWNlcyAtIDEpKSA6IG51bGw7XG4gICAgc2tpcCh0aWNrcywgbmV3VGlja3MsIHNwYWNpbmcsIGlzTnVsbE9yVW5kZWYoYXZnTWFqb3JTcGFjaW5nKSA/IDAgOiBmaXJzdCAtIGF2Z01ham9yU3BhY2luZywgZmlyc3QpO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBudW1NYWpvckluZGljZXMgLSAxOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZywgbWFqb3JJbmRpY2VzW2ldLCBtYWpvckluZGljZXNbaSArIDFdKTtcbiAgICB9XG4gICAgc2tpcCh0aWNrcywgbmV3VGlja3MsIHNwYWNpbmcsIGxhc3QsIGlzTnVsbE9yVW5kZWYoYXZnTWFqb3JTcGFjaW5nKSA/IHRpY2tzLmxlbmd0aCA6IGxhc3QgKyBhdmdNYWpvclNwYWNpbmcpO1xuICAgIHJldHVybiBuZXdUaWNrcztcbiAgfVxuICBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZyk7XG4gIHJldHVybiBuZXdUaWNrcztcbn1cblxuZnVuY3Rpb24gZGV0ZXJtaW5lTWF4VGlja3Moc2NhbGUpIHtcbiAgY29uc3Qgb2Zmc2V0ID0gc2NhbGUub3B0aW9ucy5vZmZzZXQ7XG4gIGNvbnN0IHRpY2tMZW5ndGggPSBzY2FsZS5fdGlja1NpemUoKTtcbiAgY29uc3QgbWF4U2NhbGUgPSBzY2FsZS5fbGVuZ3RoIC8gdGlja0xlbmd0aCArIChvZmZzZXQgPyAwIDogMSk7XG4gIGNvbnN0IG1heENoYXJ0ID0gc2NhbGUuX21heExlbmd0aCAvIHRpY2tMZW5ndGg7XG4gIHJldHVybiBNYXRoLmZsb29yKE1hdGgubWluKG1heFNjYWxlLCBtYXhDaGFydCkpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyW119IG1ham9ySW5kaWNlc1xuICogQHBhcmFtIHtUaWNrW119IHRpY2tzXG4gKiBAcGFyYW0ge251bWJlcn0gdGlja3NMaW1pdFxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVTcGFjaW5nKG1ham9ySW5kaWNlcywgdGlja3MsIHRpY2tzTGltaXQpIHtcbiAgY29uc3QgZXZlbk1ham9yU3BhY2luZyA9IGdldEV2ZW5TcGFjaW5nKG1ham9ySW5kaWNlcyk7XG4gIGNvbnN0IHNwYWNpbmcgPSB0aWNrcy5sZW5ndGggLyB0aWNrc0xpbWl0O1xuXG4gIC8vIElmIHRoZSBtYWpvciB0aWNrcyBhcmUgZXZlbmx5IHNwYWNlZCBhcGFydCwgcGxhY2UgdGhlIG1pbm9yIHRpY2tzXG4gIC8vIHNvIHRoYXQgdGhleSBkaXZpZGUgdGhlIG1ham9yIHRpY2tzIGludG8gZXZlbiBjaHVua3NcbiAgaWYgKCFldmVuTWFqb3JTcGFjaW5nKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KHNwYWNpbmcsIDEpO1xuICB9XG5cbiAgY29uc3QgZmFjdG9ycyA9IF9mYWN0b3JpemUoZXZlbk1ham9yU3BhY2luZyk7XG4gIGZvciAobGV0IGkgPSAwLCBpbGVuID0gZmFjdG9ycy5sZW5ndGggLSAxOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgY29uc3QgZmFjdG9yID0gZmFjdG9yc1tpXTtcbiAgICBpZiAoZmFjdG9yID4gc3BhY2luZykge1xuICAgICAgcmV0dXJuIGZhY3RvcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIE1hdGgubWF4KHNwYWNpbmcsIDEpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VGlja1tdfSB0aWNrc1xuICovXG5mdW5jdGlvbiBnZXRNYWpvckluZGljZXModGlja3MpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBpLCBpbGVuO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgaWYgKHRpY2tzW2ldLm1ham9yKSB7XG4gICAgICByZXN1bHQucHVzaChpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RpY2tbXX0gdGlja3NcbiAqIEBwYXJhbSB7VGlja1tdfSBuZXdUaWNrc1xuICogQHBhcmFtIHtudW1iZXJbXX0gbWFqb3JJbmRpY2VzXG4gKiBAcGFyYW0ge251bWJlcn0gc3BhY2luZ1xuICovXG5mdW5jdGlvbiBza2lwTWFqb3JzKHRpY2tzLCBuZXdUaWNrcywgbWFqb3JJbmRpY2VzLCBzcGFjaW5nKSB7XG4gIGxldCBjb3VudCA9IDA7XG4gIGxldCBuZXh0ID0gbWFqb3JJbmRpY2VzWzBdO1xuICBsZXQgaTtcblxuICBzcGFjaW5nID0gTWF0aC5jZWlsKHNwYWNpbmcpO1xuICBmb3IgKGkgPSAwOyBpIDwgdGlja3MubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaSA9PT0gbmV4dCkge1xuICAgICAgbmV3VGlja3MucHVzaCh0aWNrc1tpXSk7XG4gICAgICBjb3VudCsrO1xuICAgICAgbmV4dCA9IG1ham9ySW5kaWNlc1tjb3VudCAqIHNwYWNpbmddO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VGlja1tdfSB0aWNrc1xuICogQHBhcmFtIHtUaWNrW119IG5ld1RpY2tzXG4gKiBAcGFyYW0ge251bWJlcn0gc3BhY2luZ1xuICogQHBhcmFtIHtudW1iZXJ9IFttYWpvclN0YXJ0XVxuICogQHBhcmFtIHtudW1iZXJ9IFttYWpvckVuZF1cbiAqL1xuZnVuY3Rpb24gc2tpcCh0aWNrcywgbmV3VGlja3MsIHNwYWNpbmcsIG1ham9yU3RhcnQsIG1ham9yRW5kKSB7XG4gIGNvbnN0IHN0YXJ0ID0gdmFsdWVPckRlZmF1bHQobWFqb3JTdGFydCwgMCk7XG4gIGNvbnN0IGVuZCA9IE1hdGgubWluKHZhbHVlT3JEZWZhdWx0KG1ham9yRW5kLCB0aWNrcy5sZW5ndGgpLCB0aWNrcy5sZW5ndGgpO1xuICBsZXQgY291bnQgPSAwO1xuICBsZXQgbGVuZ3RoLCBpLCBuZXh0O1xuXG4gIHNwYWNpbmcgPSBNYXRoLmNlaWwoc3BhY2luZyk7XG4gIGlmIChtYWpvckVuZCkge1xuICAgIGxlbmd0aCA9IG1ham9yRW5kIC0gbWFqb3JTdGFydDtcbiAgICBzcGFjaW5nID0gbGVuZ3RoIC8gTWF0aC5mbG9vcihsZW5ndGggLyBzcGFjaW5nKTtcbiAgfVxuXG4gIG5leHQgPSBzdGFydDtcblxuICB3aGlsZSAobmV4dCA8IDApIHtcbiAgICBjb3VudCsrO1xuICAgIG5leHQgPSBNYXRoLnJvdW5kKHN0YXJ0ICsgY291bnQgKiBzcGFjaW5nKTtcbiAgfVxuXG4gIGZvciAoaSA9IE1hdGgubWF4KHN0YXJ0LCAwKTsgaSA8IGVuZDsgaSsrKSB7XG4gICAgaWYgKGkgPT09IG5leHQpIHtcbiAgICAgIG5ld1RpY2tzLnB1c2godGlja3NbaV0pO1xuICAgICAgY291bnQrKztcbiAgICAgIG5leHQgPSBNYXRoLnJvdW5kKHN0YXJ0ICsgY291bnQgKiBzcGFjaW5nKTtcbiAgICB9XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyW119IGFyclxuICovXG5mdW5jdGlvbiBnZXRFdmVuU3BhY2luZyhhcnIpIHtcbiAgY29uc3QgbGVuID0gYXJyLmxlbmd0aDtcbiAgbGV0IGksIGRpZmY7XG5cbiAgaWYgKGxlbiA8IDIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKGRpZmYgPSBhcnJbMF0sIGkgPSAxOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYXJyW2ldIC0gYXJyW2kgLSAxXSAhPT0gZGlmZikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGlmZjtcbn1cbiIsImltcG9ydCBFbGVtZW50IGZyb20gJy4vY29yZS5lbGVtZW50LmpzJztcbmltcG9ydCB7X2FsaWduUGl4ZWwsIF9tZWFzdXJlVGV4dCwgcmVuZGVyVGV4dCwgY2xpcEFyZWEsIHVuY2xpcEFyZWF9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jYW52YXMuanMnO1xuaW1wb3J0IHtjYWxsYmFjayBhcyBjYWxsLCBlYWNoLCBmaW5pdGVPckRlZmF1bHQsIGlzQXJyYXksIGlzRmluaXRlLCBpc051bGxPclVuZGVmLCBpc09iamVjdCwgdmFsdWVPckRlZmF1bHR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7dG9EZWdyZWVzLCB0b1JhZGlhbnMsIF9pbnQxNlJhbmdlLCBfbGltaXRWYWx1ZSwgSEFMRl9QSX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IHtfYWxpZ25TdGFydEVuZCwgX3RvTGVmdFJpZ2h0Q2VudGVyfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuZXh0cmFzLmpzJztcbmltcG9ydCB7Y3JlYXRlQ29udGV4dCwgdG9Gb250LCB0b1BhZGRpbmcsIF9hZGRHcmFjZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm9wdGlvbnMuanMnO1xuaW1wb3J0IHthdXRvU2tpcH0gZnJvbSAnLi9jb3JlLnNjYWxlLmF1dG9za2lwLmpzJztcblxuY29uc3QgcmV2ZXJzZUFsaWduID0gKGFsaWduKSA9PiBhbGlnbiA9PT0gJ2xlZnQnID8gJ3JpZ2h0JyA6IGFsaWduID09PSAncmlnaHQnID8gJ2xlZnQnIDogYWxpZ247XG5jb25zdCBvZmZzZXRGcm9tRWRnZSA9IChzY2FsZSwgZWRnZSwgb2Zmc2V0KSA9PiBlZGdlID09PSAndG9wJyB8fCBlZGdlID09PSAnbGVmdCcgPyBzY2FsZVtlZGdlXSArIG9mZnNldCA6IHNjYWxlW2VkZ2VdIC0gb2Zmc2V0O1xuY29uc3QgZ2V0VGlja3NMaW1pdCA9ICh0aWNrc0xlbmd0aCwgbWF4VGlja3NMaW1pdCkgPT4gTWF0aC5taW4obWF4VGlja3NMaW1pdCB8fCB0aWNrc0xlbmd0aCwgdGlja3NMZW5ndGgpO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi90eXBlcy9pbmRleC5qcycpLkNoYXJ0IH0gQ2hhcnRcbiAqIEB0eXBlZGVmIHt7dmFsdWU6bnVtYmVyIHwgc3RyaW5nLCBsYWJlbD86c3RyaW5nLCBtYWpvcj86Ym9vbGVhbiwgJGNvbnRleHQ/OmFueX19IFRpY2tcbiAqL1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgYXJyYXkgY29udGFpbmluZyBudW1JdGVtcyBmcm9tIGFyclxuICogQHBhcmFtIHthbnlbXX0gYXJyXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtSXRlbXNcbiAqL1xuZnVuY3Rpb24gc2FtcGxlKGFyciwgbnVtSXRlbXMpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IGluY3JlbWVudCA9IGFyci5sZW5ndGggLyBudW1JdGVtcztcbiAgY29uc3QgbGVuID0gYXJyLmxlbmd0aDtcbiAgbGV0IGkgPSAwO1xuXG4gIGZvciAoOyBpIDwgbGVuOyBpICs9IGluY3JlbWVudCkge1xuICAgIHJlc3VsdC5wdXNoKGFycltNYXRoLmZsb29yKGkpXSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1NjYWxlfSBzY2FsZVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9mZnNldEdyaWRMaW5lc1xuICovXG5mdW5jdGlvbiBnZXRQaXhlbEZvckdyaWRMaW5lKHNjYWxlLCBpbmRleCwgb2Zmc2V0R3JpZExpbmVzKSB7XG4gIGNvbnN0IGxlbmd0aCA9IHNjYWxlLnRpY2tzLmxlbmd0aDtcbiAgY29uc3QgdmFsaWRJbmRleCA9IE1hdGgubWluKGluZGV4LCBsZW5ndGggLSAxKTtcbiAgY29uc3Qgc3RhcnQgPSBzY2FsZS5fc3RhcnRQaXhlbDtcbiAgY29uc3QgZW5kID0gc2NhbGUuX2VuZFBpeGVsO1xuICBjb25zdCBlcHNpbG9uID0gMWUtNjsgLy8gMWUtNiBpcyBtYXJnaW4gaW4gcGl4ZWxzIGZvciBhY2N1bXVsYXRlZCBlcnJvci5cbiAgbGV0IGxpbmVWYWx1ZSA9IHNjYWxlLmdldFBpeGVsRm9yVGljayh2YWxpZEluZGV4KTtcbiAgbGV0IG9mZnNldDtcblxuICBpZiAob2Zmc2V0R3JpZExpbmVzKSB7XG4gICAgaWYgKGxlbmd0aCA9PT0gMSkge1xuICAgICAgb2Zmc2V0ID0gTWF0aC5tYXgobGluZVZhbHVlIC0gc3RhcnQsIGVuZCAtIGxpbmVWYWx1ZSk7XG4gICAgfSBlbHNlIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgb2Zmc2V0ID0gKHNjYWxlLmdldFBpeGVsRm9yVGljaygxKSAtIGxpbmVWYWx1ZSkgLyAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBvZmZzZXQgPSAobGluZVZhbHVlIC0gc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKHZhbGlkSW5kZXggLSAxKSkgLyAyO1xuICAgIH1cbiAgICBsaW5lVmFsdWUgKz0gdmFsaWRJbmRleCA8IGluZGV4ID8gb2Zmc2V0IDogLW9mZnNldDtcblxuICAgIC8vIFJldHVybiB1bmRlZmluZWQgaWYgdGhlIHBpeGVsIGlzIG91dCBvZiB0aGUgcmFuZ2VcbiAgICBpZiAobGluZVZhbHVlIDwgc3RhcnQgLSBlcHNpbG9uIHx8IGxpbmVWYWx1ZSA+IGVuZCArIGVwc2lsb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxpbmVWYWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gY2FjaGVzXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXG4gKi9cbmZ1bmN0aW9uIGdhcmJhZ2VDb2xsZWN0KGNhY2hlcywgbGVuZ3RoKSB7XG4gIGVhY2goY2FjaGVzLCAoY2FjaGUpID0+IHtcbiAgICBjb25zdCBnYyA9IGNhY2hlLmdjO1xuICAgIGNvbnN0IGdjTGVuID0gZ2MubGVuZ3RoIC8gMjtcbiAgICBsZXQgaTtcbiAgICBpZiAoZ2NMZW4gPiBsZW5ndGgpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBnY0xlbjsgKytpKSB7XG4gICAgICAgIGRlbGV0ZSBjYWNoZS5kYXRhW2djW2ldXTtcbiAgICAgIH1cbiAgICAgIGdjLnNwbGljZSgwLCBnY0xlbik7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBnZXRUaWNrTWFya0xlbmd0aChvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLmRyYXdUaWNrcyA/IG9wdGlvbnMudGlja0xlbmd0aCA6IDA7XG59XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gZ2V0VGl0bGVIZWlnaHQob3B0aW9ucywgZmFsbGJhY2spIHtcbiAgaWYgKCFvcHRpb25zLmRpc3BsYXkpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGNvbnN0IGZvbnQgPSB0b0ZvbnQob3B0aW9ucy5mb250LCBmYWxsYmFjayk7XG4gIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcbiAgY29uc3QgbGluZXMgPSBpc0FycmF5KG9wdGlvbnMudGV4dCkgPyBvcHRpb25zLnRleHQubGVuZ3RoIDogMTtcblxuICByZXR1cm4gKGxpbmVzICogZm9udC5saW5lSGVpZ2h0KSArIHBhZGRpbmcuaGVpZ2h0O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTY2FsZUNvbnRleHQocGFyZW50LCBzY2FsZSkge1xuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsIHtcbiAgICBzY2FsZSxcbiAgICB0eXBlOiAnc2NhbGUnXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUaWNrQ29udGV4dChwYXJlbnQsIGluZGV4LCB0aWNrKSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xuICAgIHRpY2ssXG4gICAgaW5kZXgsXG4gICAgdHlwZTogJ3RpY2snXG4gIH0pO1xufVxuXG5mdW5jdGlvbiB0aXRsZUFsaWduKGFsaWduLCBwb3NpdGlvbiwgcmV2ZXJzZSkge1xuICAvKiogQHR5cGUge0NhbnZhc1RleHRBbGlnbn0gKi9cbiAgbGV0IHJldCA9IF90b0xlZnRSaWdodENlbnRlcihhbGlnbik7XG4gIGlmICgocmV2ZXJzZSAmJiBwb3NpdGlvbiAhPT0gJ3JpZ2h0JykgfHwgKCFyZXZlcnNlICYmIHBvc2l0aW9uID09PSAncmlnaHQnKSkge1xuICAgIHJldCA9IHJldmVyc2VBbGlnbihyZXQpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIHRpdGxlQXJncyhzY2FsZSwgb2Zmc2V0LCBwb3NpdGlvbiwgYWxpZ24pIHtcbiAgY29uc3Qge3RvcCwgbGVmdCwgYm90dG9tLCByaWdodCwgY2hhcnR9ID0gc2NhbGU7XG4gIGNvbnN0IHtjaGFydEFyZWEsIHNjYWxlc30gPSBjaGFydDtcbiAgbGV0IHJvdGF0aW9uID0gMDtcbiAgbGV0IG1heFdpZHRoLCB0aXRsZVgsIHRpdGxlWTtcbiAgY29uc3QgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuICBjb25zdCB3aWR0aCA9IHJpZ2h0IC0gbGVmdDtcblxuICBpZiAoc2NhbGUuaXNIb3Jpem9udGFsKCkpIHtcbiAgICB0aXRsZVggPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgbGVmdCwgcmlnaHQpO1xuXG4gICAgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgIHRpdGxlWSA9IHNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkgKyBoZWlnaHQgLSBvZmZzZXQ7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIHRpdGxlWSA9IChjaGFydEFyZWEuYm90dG9tICsgY2hhcnRBcmVhLnRvcCkgLyAyICsgaGVpZ2h0IC0gb2Zmc2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aXRsZVkgPSBvZmZzZXRGcm9tRWRnZShzY2FsZSwgcG9zaXRpb24sIG9mZnNldCk7XG4gICAgfVxuICAgIG1heFdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICB9IGVsc2Uge1xuICAgIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICB0aXRsZVggPSBzY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpIC0gd2lkdGggKyBvZmZzZXQ7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIHRpdGxlWCA9IChjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS5yaWdodCkgLyAyIC0gd2lkdGggKyBvZmZzZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpdGxlWCA9IG9mZnNldEZyb21FZGdlKHNjYWxlLCBwb3NpdGlvbiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgdGl0bGVZID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIGJvdHRvbSwgdG9wKTtcbiAgICByb3RhdGlvbiA9IHBvc2l0aW9uID09PSAnbGVmdCcgPyAtSEFMRl9QSSA6IEhBTEZfUEk7XG4gIH1cbiAgcmV0dXJuIHt0aXRsZVgsIHRpdGxlWSwgbWF4V2lkdGgsIHJvdGF0aW9ufTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2NhbGUgZXh0ZW5kcyBFbGVtZW50IHtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXN0YXRlbWVudHNcbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIHRoaXMuaWQgPSBjZmcuaWQ7XG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgdGhpcy50eXBlID0gY2ZnLnR5cGU7XG4gICAgLyoqIEB0eXBlIHthbnl9ICovXG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSAqL1xuICAgIHRoaXMuY3R4ID0gY2ZnLmN0eDtcbiAgICAvKiogQHR5cGUge0NoYXJ0fSAqL1xuICAgIHRoaXMuY2hhcnQgPSBjZmcuY2hhcnQ7XG5cbiAgICAvLyBpbXBsZW1lbnRzIGJveFxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMudG9wID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuYm90dG9tID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMubGVmdCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLnJpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fbWFyZ2lucyA9IHtcbiAgICAgIGxlZnQ6IDAsXG4gICAgICByaWdodDogMCxcbiAgICAgIHRvcDogMCxcbiAgICAgIGJvdHRvbTogMFxuICAgIH07XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5tYXhXaWR0aCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLm1heEhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLnBhZGRpbmdUb3AgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5wYWRkaW5nQm90dG9tID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMucGFkZGluZ0xlZnQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5wYWRkaW5nUmlnaHQgPSB1bmRlZmluZWQ7XG5cbiAgICAvLyBzY2FsZS1zcGVjaWZpYyBwcm9wZXJ0aWVzXG4gICAgLyoqIEB0eXBlIHtzdHJpbmc9fSAqL1xuICAgIHRoaXMuYXhpcyA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcj19ICovXG4gICAgdGhpcy5sYWJlbFJvdGF0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWluID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWF4ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3JhbmdlID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7VGlja1tdfSAqL1xuICAgIHRoaXMudGlja3MgPSBbXTtcbiAgICAvKiogQHR5cGUge29iamVjdFtdfG51bGx9ICovXG4gICAgdGhpcy5fZ3JpZExpbmVJdGVtcyA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtvYmplY3RbXXxudWxsfSAqL1xuICAgIHRoaXMuX2xhYmVsSXRlbXMgPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7b2JqZWN0fG51bGx9ICovXG4gICAgdGhpcy5fbGFiZWxTaXplcyA9IG51bGw7XG4gICAgdGhpcy5fbGVuZ3RoID0gMDtcbiAgICB0aGlzLl9tYXhMZW5ndGggPSAwO1xuICAgIHRoaXMuX2xvbmdlc3RUZXh0Q2FjaGUgPSB7fTtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLl9zdGFydFBpeGVsID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuX2VuZFBpeGVsID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3JldmVyc2VQaXhlbHMgPSBmYWxzZTtcbiAgICB0aGlzLl91c2VyTWF4ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3VzZXJNaW4gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3VnZ2VzdGVkTWF4ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3N1Z2dlc3RlZE1pbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl90aWNrc0xlbmd0aCA9IDA7XG4gICAgdGhpcy5fYm9yZGVyVmFsdWUgPSAwO1xuICAgIHRoaXMuX2NhY2hlID0ge307XG4gICAgdGhpcy5fZGF0YUxpbWl0c0NhY2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHthbnl9IG9wdGlvbnNcblx0ICogQHNpbmNlIDMuMFxuXHQgKi9cbiAgaW5pdChvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKTtcblxuICAgIHRoaXMuYXhpcyA9IG9wdGlvbnMuYXhpcztcblxuICAgIC8vIHBhcnNlIG1pbi9tYXggdmFsdWUsIHNvIHdlIGNhbiBwcm9wZXJseSBkZXRlcm1pbmUgbWluL21heCBmb3Igb3RoZXIgc2NhbGVzXG4gICAgdGhpcy5fdXNlck1pbiA9IHRoaXMucGFyc2Uob3B0aW9ucy5taW4pO1xuICAgIHRoaXMuX3VzZXJNYXggPSB0aGlzLnBhcnNlKG9wdGlvbnMubWF4KTtcbiAgICB0aGlzLl9zdWdnZXN0ZWRNaW4gPSB0aGlzLnBhcnNlKG9wdGlvbnMuc3VnZ2VzdGVkTWluKTtcbiAgICB0aGlzLl9zdWdnZXN0ZWRNYXggPSB0aGlzLnBhcnNlKG9wdGlvbnMuc3VnZ2VzdGVkTWF4KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBQYXJzZSBhIHN1cHBvcnRlZCBpbnB1dCB2YWx1ZSB0byBpbnRlcm5hbCByZXByZXNlbnRhdGlvbi5cblx0ICogQHBhcmFtIHsqfSByYXdcblx0ICogQHBhcmFtIHtudW1iZXJ9IFtpbmRleF1cblx0ICogQHNpbmNlIDMuMFxuXHQgKi9cbiAgcGFyc2UocmF3LCBpbmRleCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgcmV0dXJuIHJhdztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHt7bWluOiBudW1iZXIsIG1heDogbnVtYmVyLCBtaW5EZWZpbmVkOiBib29sZWFuLCBtYXhEZWZpbmVkOiBib29sZWFufX1cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc2luY2UgMy4wXG5cdCAqL1xuICBnZXRVc2VyQm91bmRzKCkge1xuICAgIGxldCB7X3VzZXJNaW4sIF91c2VyTWF4LCBfc3VnZ2VzdGVkTWluLCBfc3VnZ2VzdGVkTWF4fSA9IHRoaXM7XG4gICAgX3VzZXJNaW4gPSBmaW5pdGVPckRlZmF1bHQoX3VzZXJNaW4sIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgX3VzZXJNYXggPSBmaW5pdGVPckRlZmF1bHQoX3VzZXJNYXgsIE51bWJlci5ORUdBVElWRV9JTkZJTklUWSk7XG4gICAgX3N1Z2dlc3RlZE1pbiA9IGZpbml0ZU9yRGVmYXVsdChfc3VnZ2VzdGVkTWluLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgIF9zdWdnZXN0ZWRNYXggPSBmaW5pdGVPckRlZmF1bHQoX3N1Z2dlc3RlZE1heCwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKTtcbiAgICByZXR1cm4ge1xuICAgICAgbWluOiBmaW5pdGVPckRlZmF1bHQoX3VzZXJNaW4sIF9zdWdnZXN0ZWRNaW4pLFxuICAgICAgbWF4OiBmaW5pdGVPckRlZmF1bHQoX3VzZXJNYXgsIF9zdWdnZXN0ZWRNYXgpLFxuICAgICAgbWluRGVmaW5lZDogaXNGaW5pdGUoX3VzZXJNaW4pLFxuICAgICAgbWF4RGVmaW5lZDogaXNGaW5pdGUoX3VzZXJNYXgpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGNhblN0YWNrXG5cdCAqIEByZXR1cm4ge3ttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzaW5jZSAzLjBcblx0ICovXG4gIGdldE1pbk1heChjYW5TdGFjaykge1xuICAgIGxldCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG4gICAgbGV0IHJhbmdlO1xuXG4gICAgaWYgKG1pbkRlZmluZWQgJiYgbWF4RGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHttaW4sIG1heH07XG4gICAgfVxuXG4gICAgY29uc3QgbWV0YXMgPSB0aGlzLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSBtZXRhcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHJhbmdlID0gbWV0YXNbaV0uY29udHJvbGxlci5nZXRNaW5NYXgodGhpcywgY2FuU3RhY2spO1xuICAgICAgaWYgKCFtaW5EZWZpbmVkKSB7XG4gICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgcmFuZ2UubWluKTtcbiAgICAgIH1cbiAgICAgIGlmICghbWF4RGVmaW5lZCkge1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIHJhbmdlLm1heCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIG1pbiA8PSBtYXggd2hlbiBvbmx5IG1pbiBvciBtYXggaXMgZGVmaW5lZCBieSB1c2VyIGFuZCB0aGUgZGF0YSBpcyBvdXRzaWRlIHRoYXQgcmFuZ2VcbiAgICBtaW4gPSBtYXhEZWZpbmVkICYmIG1pbiA+IG1heCA/IG1heCA6IG1pbjtcbiAgICBtYXggPSBtaW5EZWZpbmVkICYmIG1pbiA+IG1heCA/IG1pbiA6IG1heDtcblxuICAgIHJldHVybiB7XG4gICAgICBtaW46IGZpbml0ZU9yRGVmYXVsdChtaW4sIGZpbml0ZU9yRGVmYXVsdChtYXgsIG1pbikpLFxuICAgICAgbWF4OiBmaW5pdGVPckRlZmF1bHQobWF4LCBmaW5pdGVPckRlZmF1bHQobWluLCBtYXgpKVxuICAgIH07XG4gIH1cblxuICAvKipcblx0ICogR2V0IHRoZSBwYWRkaW5nIG5lZWRlZCBmb3IgdGhlIHNjYWxlXG5cdCAqIEByZXR1cm4ge3t0b3A6IG51bWJlciwgbGVmdDogbnVtYmVyLCBib3R0b206IG51bWJlciwgcmlnaHQ6IG51bWJlcn19IHRoZSBuZWNlc3NhcnkgcGFkZGluZ1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgZ2V0UGFkZGluZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogdGhpcy5wYWRkaW5nTGVmdCB8fCAwLFxuICAgICAgdG9wOiB0aGlzLnBhZGRpbmdUb3AgfHwgMCxcbiAgICAgIHJpZ2h0OiB0aGlzLnBhZGRpbmdSaWdodCB8fCAwLFxuICAgICAgYm90dG9tOiB0aGlzLnBhZGRpbmdCb3R0b20gfHwgMFxuICAgIH07XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgc2NhbGUgdGljayBvYmplY3RzXG5cdCAqIEByZXR1cm4ge1RpY2tbXX1cblx0ICogQHNpbmNlIDIuN1xuXHQgKi9cbiAgZ2V0VGlja3MoKSB7XG4gICAgcmV0dXJuIHRoaXMudGlja3M7XG4gIH1cblxuICAvKipcblx0ICogQHJldHVybiB7c3RyaW5nW119XG5cdCAqL1xuICBnZXRMYWJlbHMoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuY2hhcnQuZGF0YTtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmxhYmVscyB8fCAodGhpcy5pc0hvcml6b250YWwoKSA/IGRhdGEueExhYmVscyA6IGRhdGEueUxhYmVscykgfHwgZGF0YS5sYWJlbHMgfHwgW107XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7aW1wb3J0KCcuLi90eXBlcy5qcycpLkxhYmVsSXRlbVtdfVxuICAgKi9cbiAgZ2V0TGFiZWxJdGVtcyhjaGFydEFyZWEgPSB0aGlzLmNoYXJ0LmNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5fbGFiZWxJdGVtcyB8fCAodGhpcy5fbGFiZWxJdGVtcyA9IHRoaXMuX2NvbXB1dGVMYWJlbEl0ZW1zKGNoYXJ0QXJlYSkpO1xuICAgIHJldHVybiBpdGVtcztcbiAgfVxuXG4gIC8vIFdoZW4gYSBuZXcgbGF5b3V0IGlzIGNyZWF0ZWQsIHJlc2V0IHRoZSBkYXRhIGxpbWl0cyBjYWNoZVxuICBiZWZvcmVMYXlvdXQoKSB7XG4gICAgdGhpcy5fY2FjaGUgPSB7fTtcbiAgICB0aGlzLl9kYXRhTGltaXRzQ2FjaGVkID0gZmFsc2U7XG4gIH1cblxuICAvLyBUaGVzZSBtZXRob2RzIGFyZSBvcmRlcmVkIGJ5IGxpZmVjeWNsZS4gVXRpbGl0aWVzIHRoZW4gZm9sbG93LlxuICAvLyBBbnkgZnVuY3Rpb24gZGVmaW5lZCBoZXJlIGlzIGluaGVyaXRlZCBieSBhbGwgc2NhbGUgdHlwZXMuXG4gIC8vIEFueSBmdW5jdGlvbiBjYW4gYmUgZXh0ZW5kZWQgYnkgdGhlIHNjYWxlIHR5cGVcblxuICBiZWZvcmVVcGRhdGUoKSB7XG4gICAgY2FsbCh0aGlzLm9wdGlvbnMuYmVmb3JlVXBkYXRlLCBbdGhpc10pO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtYXhXaWR0aCAtIHRoZSBtYXggd2lkdGggaW4gcGl4ZWxzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtYXhIZWlnaHQgLSB0aGUgbWF4IGhlaWdodCBpbiBwaXhlbHNcblx0ICogQHBhcmFtIHt7dG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlciwgYm90dG9tOiBudW1iZXIsIHJpZ2h0OiBudW1iZXJ9fSBtYXJnaW5zIC0gdGhlIHNwYWNlIGJldHdlZW4gdGhlIGVkZ2Ugb2YgdGhlIG90aGVyIHNjYWxlcyBhbmQgZWRnZSBvZiB0aGUgY2hhcnRcblx0ICogICBUaGlzIHNwYWNlIGNvbWVzIGZyb20gdHdvIHNvdXJjZXM6XG5cdCAqICAgICAtIHBhZGRpbmcgLSBzcGFjZSB0aGF0J3MgcmVxdWlyZWQgdG8gc2hvdyB0aGUgbGFiZWxzIGF0IHRoZSBlZGdlcyBvZiB0aGUgc2NhbGVcblx0ICogICAgIC0gdGhpY2tuZXNzIG9mIHNjYWxlcyBvciBsZWdlbmRzIGluIGFub3RoZXIgb3JpZW50YXRpb25cblx0ICovXG4gIHVwZGF0ZShtYXhXaWR0aCwgbWF4SGVpZ2h0LCBtYXJnaW5zKSB7XG4gICAgY29uc3Qge2JlZ2luQXRaZXJvLCBncmFjZSwgdGlja3M6IHRpY2tPcHRzfSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBzYW1wbGVTaXplID0gdGlja09wdHMuc2FtcGxlU2l6ZTtcblxuICAgIC8vIFVwZGF0ZSBMaWZlY3ljbGUgLSBQcm9iYWJseSBkb24ndCB3YW50IHRvIGV2ZXIgZXh0ZW5kIG9yIG92ZXJ3cml0ZSB0aGlzIGZ1bmN0aW9uIDspXG4gICAgdGhpcy5iZWZvcmVVcGRhdGUoKTtcblxuICAgIC8vIEFic29yYiB0aGUgbWFzdGVyIG1lYXN1cmVtZW50c1xuICAgIHRoaXMubWF4V2lkdGggPSBtYXhXaWR0aDtcbiAgICB0aGlzLm1heEhlaWdodCA9IG1heEhlaWdodDtcbiAgICB0aGlzLl9tYXJnaW5zID0gbWFyZ2lucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgYm90dG9tOiAwXG4gICAgfSwgbWFyZ2lucyk7XG5cbiAgICB0aGlzLnRpY2tzID0gbnVsbDtcbiAgICB0aGlzLl9sYWJlbFNpemVzID0gbnVsbDtcbiAgICB0aGlzLl9ncmlkTGluZUl0ZW1zID0gbnVsbDtcbiAgICB0aGlzLl9sYWJlbEl0ZW1zID0gbnVsbDtcblxuICAgIC8vIERpbWVuc2lvbnNcbiAgICB0aGlzLmJlZm9yZVNldERpbWVuc2lvbnMoKTtcbiAgICB0aGlzLnNldERpbWVuc2lvbnMoKTtcbiAgICB0aGlzLmFmdGVyU2V0RGltZW5zaW9ucygpO1xuXG4gICAgdGhpcy5fbWF4TGVuZ3RoID0gdGhpcy5pc0hvcml6b250YWwoKVxuICAgICAgPyB0aGlzLndpZHRoICsgbWFyZ2lucy5sZWZ0ICsgbWFyZ2lucy5yaWdodFxuICAgICAgOiB0aGlzLmhlaWdodCArIG1hcmdpbnMudG9wICsgbWFyZ2lucy5ib3R0b207XG5cbiAgICAvLyBEYXRhIG1pbi9tYXhcbiAgICBpZiAoIXRoaXMuX2RhdGFMaW1pdHNDYWNoZWQpIHtcbiAgICAgIHRoaXMuYmVmb3JlRGF0YUxpbWl0cygpO1xuICAgICAgdGhpcy5kZXRlcm1pbmVEYXRhTGltaXRzKCk7XG4gICAgICB0aGlzLmFmdGVyRGF0YUxpbWl0cygpO1xuICAgICAgdGhpcy5fcmFuZ2UgPSBfYWRkR3JhY2UodGhpcywgZ3JhY2UsIGJlZ2luQXRaZXJvKTtcbiAgICAgIHRoaXMuX2RhdGFMaW1pdHNDYWNoZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuYmVmb3JlQnVpbGRUaWNrcygpO1xuXG4gICAgdGhpcy50aWNrcyA9IHRoaXMuYnVpbGRUaWNrcygpIHx8IFtdO1xuXG4gICAgLy8gQWxsb3cgbW9kaWZpY2F0aW9uIG9mIHRpY2tzIGluIGNhbGxiYWNrLlxuICAgIHRoaXMuYWZ0ZXJCdWlsZFRpY2tzKCk7XG5cbiAgICAvLyBDb21wdXRlIHRpY2sgcm90YXRpb24gYW5kIGZpdCB1c2luZyBhIHNhbXBsZWQgc3Vic2V0IG9mIGxhYmVsc1xuICAgIC8vIFdlIGdlbmVyYWxseSBkb24ndCBuZWVkIHRvIGNvbXB1dGUgdGhlIHNpemUgb2YgZXZlcnkgc2luZ2xlIGxhYmVsIGZvciBkZXRlcm1pbmluZyBzY2FsZSBzaXplXG4gICAgY29uc3Qgc2FtcGxpbmdFbmFibGVkID0gc2FtcGxlU2l6ZSA8IHRoaXMudGlja3MubGVuZ3RoO1xuICAgIHRoaXMuX2NvbnZlcnRUaWNrc1RvTGFiZWxzKHNhbXBsaW5nRW5hYmxlZCA/IHNhbXBsZSh0aGlzLnRpY2tzLCBzYW1wbGVTaXplKSA6IHRoaXMudGlja3MpO1xuXG4gICAgLy8gY29uZmlndXJlIGlzIGNhbGxlZCB0d2ljZSwgb25jZSBoZXJlLCBvbmNlIGZyb20gY29yZS5jb250cm9sbGVyLnVwZGF0ZUxheW91dC5cbiAgICAvLyBIZXJlIHdlIGhhdmVuJ3QgYmVlbiBwb3NpdGlvbmVkIHlldCwgYnV0IGRpbWVuc2lvbnMgYXJlIGNvcnJlY3QuXG4gICAgLy8gVmFyaWFibGVzIHNldCBpbiBjb25maWd1cmUgYXJlIG5lZWRlZCBmb3IgY2FsY3VsYXRlTGFiZWxSb3RhdGlvbiwgYW5kXG4gICAgLy8gaXQncyBvayB0aGF0IGNvb3JkaW5hdGVzIGFyZSBub3QgY29ycmVjdCB0aGVyZSwgb25seSBkaW1lbnNpb25zIG1hdHRlci5cbiAgICB0aGlzLmNvbmZpZ3VyZSgpO1xuXG4gICAgLy8gVGljayBSb3RhdGlvblxuICAgIHRoaXMuYmVmb3JlQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpO1xuICAgIHRoaXMuY2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpOyAvLyBQcmVjb25kaXRpb25zOiBudW1iZXIgb2YgdGlja3MgYW5kIHNpemVzIG9mIGxhcmdlc3QgbGFiZWxzIG11c3QgYmUgY2FsY3VsYXRlZCBiZWZvcmVoYW5kXG4gICAgdGhpcy5hZnRlckNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKTtcblxuICAgIC8vIEF1dG8tc2tpcFxuICAgIGlmICh0aWNrT3B0cy5kaXNwbGF5ICYmICh0aWNrT3B0cy5hdXRvU2tpcCB8fCB0aWNrT3B0cy5zb3VyY2UgPT09ICdhdXRvJykpIHtcbiAgICAgIHRoaXMudGlja3MgPSBhdXRvU2tpcCh0aGlzLCB0aGlzLnRpY2tzKTtcbiAgICAgIHRoaXMuX2xhYmVsU2l6ZXMgPSBudWxsO1xuICAgICAgdGhpcy5hZnRlckF1dG9Ta2lwKCk7XG4gICAgfVxuXG4gICAgaWYgKHNhbXBsaW5nRW5hYmxlZCkge1xuICAgICAgLy8gR2VuZXJhdGUgbGFiZWxzIHVzaW5nIGFsbCBub24tc2tpcHBlZCB0aWNrc1xuICAgICAgdGhpcy5fY29udmVydFRpY2tzVG9MYWJlbHModGhpcy50aWNrcyk7XG4gICAgfVxuXG4gICAgdGhpcy5iZWZvcmVGaXQoKTtcbiAgICB0aGlzLmZpdCgpOyAvLyBQcmVjb25kaXRpb25zOiBsYWJlbCByb3RhdGlvbiBhbmQgbGFiZWwgc2l6ZXMgbXVzdCBiZSBjYWxjdWxhdGVkIGJlZm9yZWhhbmRcbiAgICB0aGlzLmFmdGVyRml0KCk7XG5cbiAgICAvLyBJTVBPUlRBTlQ6IGFmdGVyIHRoaXMgcG9pbnQsIHdlIGNvbnNpZGVyIHRoYXQgYHRoaXMudGlja3NgIHdpbGwgTkVWRVIgY2hhbmdlIVxuXG4gICAgdGhpcy5hZnRlclVwZGF0ZSgpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBsZXQgcmV2ZXJzZVBpeGVscyA9IHRoaXMub3B0aW9ucy5yZXZlcnNlO1xuICAgIGxldCBzdGFydFBpeGVsLCBlbmRQaXhlbDtcblxuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICBzdGFydFBpeGVsID0gdGhpcy5sZWZ0O1xuICAgICAgZW5kUGl4ZWwgPSB0aGlzLnJpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFBpeGVsID0gdGhpcy50b3A7XG4gICAgICBlbmRQaXhlbCA9IHRoaXMuYm90dG9tO1xuICAgICAgLy8gYnkgZGVmYXVsdCB2ZXJ0aWNhbCBzY2FsZXMgYXJlIGZyb20gYm90dG9tIHRvIHRvcCwgc28gcGl4ZWxzIGFyZSByZXZlcnNlZFxuICAgICAgcmV2ZXJzZVBpeGVscyA9ICFyZXZlcnNlUGl4ZWxzO1xuICAgIH1cbiAgICB0aGlzLl9zdGFydFBpeGVsID0gc3RhcnRQaXhlbDtcbiAgICB0aGlzLl9lbmRQaXhlbCA9IGVuZFBpeGVsO1xuICAgIHRoaXMuX3JldmVyc2VQaXhlbHMgPSByZXZlcnNlUGl4ZWxzO1xuICAgIHRoaXMuX2xlbmd0aCA9IGVuZFBpeGVsIC0gc3RhcnRQaXhlbDtcbiAgICB0aGlzLl9hbGlnblRvUGl4ZWxzID0gdGhpcy5vcHRpb25zLmFsaWduVG9QaXhlbHM7XG4gIH1cblxuICBhZnRlclVwZGF0ZSgpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5hZnRlclVwZGF0ZSwgW3RoaXNdKTtcbiAgfVxuXG4gIC8vXG5cbiAgYmVmb3JlU2V0RGltZW5zaW9ucygpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5iZWZvcmVTZXREaW1lbnNpb25zLCBbdGhpc10pO1xuICB9XG4gIHNldERpbWVuc2lvbnMoKSB7XG4gICAgLy8gU2V0IHRoZSB1bmNvbnN0cmFpbmVkIGRpbWVuc2lvbiBiZWZvcmUgbGFiZWwgcm90YXRpb25cbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgLy8gUmVzZXQgcG9zaXRpb24gYmVmb3JlIGNhbGN1bGF0aW5nIHJvdGF0aW9uXG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5tYXhXaWR0aDtcbiAgICAgIHRoaXMubGVmdCA9IDA7XG4gICAgICB0aGlzLnJpZ2h0ID0gdGhpcy53aWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLm1heEhlaWdodDtcblxuICAgICAgLy8gUmVzZXQgcG9zaXRpb24gYmVmb3JlIGNhbGN1bGF0aW5nIHJvdGF0aW9uXG4gICAgICB0aGlzLnRvcCA9IDA7XG4gICAgICB0aGlzLmJvdHRvbSA9IHRoaXMuaGVpZ2h0O1xuICAgIH1cblxuICAgIC8vIFJlc2V0IHBhZGRpbmdcbiAgICB0aGlzLnBhZGRpbmdMZWZ0ID0gMDtcbiAgICB0aGlzLnBhZGRpbmdUb3AgPSAwO1xuICAgIHRoaXMucGFkZGluZ1JpZ2h0ID0gMDtcbiAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSAwO1xuICB9XG4gIGFmdGVyU2V0RGltZW5zaW9ucygpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5hZnRlclNldERpbWVuc2lvbnMsIFt0aGlzXSk7XG4gIH1cblxuICBfY2FsbEhvb2tzKG5hbWUpIHtcbiAgICB0aGlzLmNoYXJ0Lm5vdGlmeVBsdWdpbnMobmFtZSwgdGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNhbGwodGhpcy5vcHRpb25zW25hbWVdLCBbdGhpc10pO1xuICB9XG5cbiAgLy8gRGF0YSBsaW1pdHNcbiAgYmVmb3JlRGF0YUxpbWl0cygpIHtcbiAgICB0aGlzLl9jYWxsSG9va3MoJ2JlZm9yZURhdGFMaW1pdHMnKTtcbiAgfVxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge31cbiAgYWZ0ZXJEYXRhTGltaXRzKCkge1xuICAgIHRoaXMuX2NhbGxIb29rcygnYWZ0ZXJEYXRhTGltaXRzJyk7XG4gIH1cblxuICAvL1xuICBiZWZvcmVCdWlsZFRpY2tzKCkge1xuICAgIHRoaXMuX2NhbGxIb29rcygnYmVmb3JlQnVpbGRUaWNrcycpO1xuICB9XG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtvYmplY3RbXX0gdGhlIHRpY2tzXG5cdCAqL1xuICBidWlsZFRpY2tzKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBhZnRlckJ1aWxkVGlja3MoKSB7XG4gICAgdGhpcy5fY2FsbEhvb2tzKCdhZnRlckJ1aWxkVGlja3MnKTtcbiAgfVxuXG4gIGJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbigpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5iZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24sIFt0aGlzXSk7XG4gIH1cbiAgLyoqXG5cdCAqIENvbnZlcnQgdGlja3MgdG8gbGFiZWwgc3RyaW5nc1xuXHQgKiBAcGFyYW0ge1RpY2tbXX0gdGlja3Ncblx0ICovXG4gIGdlbmVyYXRlVGlja0xhYmVscyh0aWNrcykge1xuICAgIGNvbnN0IHRpY2tPcHRzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuICAgIGxldCBpLCBpbGVuLCB0aWNrO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIHRpY2sgPSB0aWNrc1tpXTtcbiAgICAgIHRpY2subGFiZWwgPSBjYWxsKHRpY2tPcHRzLmNhbGxiYWNrLCBbdGljay52YWx1ZSwgaSwgdGlja3NdLCB0aGlzKTtcbiAgICB9XG4gIH1cbiAgYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24oKSB7XG4gICAgY2FsbCh0aGlzLm9wdGlvbnMuYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24sIFt0aGlzXSk7XG4gIH1cblxuICAvL1xuXG4gIGJlZm9yZUNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKSB7XG4gICAgY2FsbCh0aGlzLm9wdGlvbnMuYmVmb3JlQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbiwgW3RoaXNdKTtcbiAgfVxuICBjYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGlja09wdHMgPSBvcHRpb25zLnRpY2tzO1xuICAgIGNvbnN0IG51bVRpY2tzID0gZ2V0VGlja3NMaW1pdCh0aGlzLnRpY2tzLmxlbmd0aCwgb3B0aW9ucy50aWNrcy5tYXhUaWNrc0xpbWl0KTtcbiAgICBjb25zdCBtaW5Sb3RhdGlvbiA9IHRpY2tPcHRzLm1pblJvdGF0aW9uIHx8IDA7XG4gICAgY29uc3QgbWF4Um90YXRpb24gPSB0aWNrT3B0cy5tYXhSb3RhdGlvbjtcbiAgICBsZXQgbGFiZWxSb3RhdGlvbiA9IG1pblJvdGF0aW9uO1xuICAgIGxldCB0aWNrV2lkdGgsIG1heEhlaWdodCwgbWF4TGFiZWxEaWFnb25hbDtcblxuICAgIGlmICghdGhpcy5faXNWaXNpYmxlKCkgfHwgIXRpY2tPcHRzLmRpc3BsYXkgfHwgbWluUm90YXRpb24gPj0gbWF4Um90YXRpb24gfHwgbnVtVGlja3MgPD0gMSB8fCAhdGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgdGhpcy5sYWJlbFJvdGF0aW9uID0gbWluUm90YXRpb247XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbGFiZWxTaXplcyA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcbiAgICBjb25zdCBtYXhMYWJlbFdpZHRoID0gbGFiZWxTaXplcy53aWRlc3Qud2lkdGg7XG4gICAgY29uc3QgbWF4TGFiZWxIZWlnaHQgPSBsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0O1xuXG4gICAgLy8gRXN0aW1hdGUgdGhlIHdpZHRoIG9mIGVhY2ggZ3JpZCBiYXNlZCBvbiB0aGUgY2FudmFzIHdpZHRoLCB0aGUgbWF4aW11bVxuICAgIC8vIGxhYmVsIHdpZHRoIGFuZCB0aGUgbnVtYmVyIG9mIHRpY2sgaW50ZXJ2YWxzXG4gICAgY29uc3QgbWF4V2lkdGggPSBfbGltaXRWYWx1ZSh0aGlzLmNoYXJ0LndpZHRoIC0gbWF4TGFiZWxXaWR0aCwgMCwgdGhpcy5tYXhXaWR0aCk7XG4gICAgdGlja1dpZHRoID0gb3B0aW9ucy5vZmZzZXQgPyB0aGlzLm1heFdpZHRoIC8gbnVtVGlja3MgOiBtYXhXaWR0aCAvIChudW1UaWNrcyAtIDEpO1xuXG4gICAgLy8gQWxsb3cgMyBwaXhlbHMgeDIgcGFkZGluZyBlaXRoZXIgc2lkZSBmb3IgbGFiZWwgcmVhZGFiaWxpdHlcbiAgICBpZiAobWF4TGFiZWxXaWR0aCArIDYgPiB0aWNrV2lkdGgpIHtcbiAgICAgIHRpY2tXaWR0aCA9IG1heFdpZHRoIC8gKG51bVRpY2tzIC0gKG9wdGlvbnMub2Zmc2V0ID8gMC41IDogMSkpO1xuICAgICAgbWF4SGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQgLSBnZXRUaWNrTWFya0xlbmd0aChvcHRpb25zLmdyaWQpXG5cdFx0XHRcdC0gdGlja09wdHMucGFkZGluZyAtIGdldFRpdGxlSGVpZ2h0KG9wdGlvbnMudGl0bGUsIHRoaXMuY2hhcnQub3B0aW9ucy5mb250KTtcbiAgICAgIG1heExhYmVsRGlhZ29uYWwgPSBNYXRoLnNxcnQobWF4TGFiZWxXaWR0aCAqIG1heExhYmVsV2lkdGggKyBtYXhMYWJlbEhlaWdodCAqIG1heExhYmVsSGVpZ2h0KTtcbiAgICAgIGxhYmVsUm90YXRpb24gPSB0b0RlZ3JlZXMoTWF0aC5taW4oXG4gICAgICAgIE1hdGguYXNpbihfbGltaXRWYWx1ZSgobGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCArIDYpIC8gdGlja1dpZHRoLCAtMSwgMSkpLFxuICAgICAgICBNYXRoLmFzaW4oX2xpbWl0VmFsdWUobWF4SGVpZ2h0IC8gbWF4TGFiZWxEaWFnb25hbCwgLTEsIDEpKSAtIE1hdGguYXNpbihfbGltaXRWYWx1ZShtYXhMYWJlbEhlaWdodCAvIG1heExhYmVsRGlhZ29uYWwsIC0xLCAxKSlcbiAgICAgICkpO1xuICAgICAgbGFiZWxSb3RhdGlvbiA9IE1hdGgubWF4KG1pblJvdGF0aW9uLCBNYXRoLm1pbihtYXhSb3RhdGlvbiwgbGFiZWxSb3RhdGlvbikpO1xuICAgIH1cblxuICAgIHRoaXMubGFiZWxSb3RhdGlvbiA9IGxhYmVsUm90YXRpb247XG4gIH1cbiAgYWZ0ZXJDYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCkge1xuICAgIGNhbGwodGhpcy5vcHRpb25zLmFmdGVyQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbiwgW3RoaXNdKTtcbiAgfVxuICBhZnRlckF1dG9Ta2lwKCkge31cblxuICAvL1xuXG4gIGJlZm9yZUZpdCgpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5iZWZvcmVGaXQsIFt0aGlzXSk7XG4gIH1cbiAgZml0KCkge1xuICAgIC8vIFJlc2V0XG4gICAgY29uc3QgbWluU2l6ZSA9IHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwXG4gICAgfTtcblxuICAgIGNvbnN0IHtjaGFydCwgb3B0aW9uczoge3RpY2tzOiB0aWNrT3B0cywgdGl0bGU6IHRpdGxlT3B0cywgZ3JpZDogZ3JpZE9wdHN9fSA9IHRoaXM7XG4gICAgY29uc3QgZGlzcGxheSA9IHRoaXMuX2lzVmlzaWJsZSgpO1xuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHRoaXMuaXNIb3Jpem9udGFsKCk7XG5cbiAgICBpZiAoZGlzcGxheSkge1xuICAgICAgY29uc3QgdGl0bGVIZWlnaHQgPSBnZXRUaXRsZUhlaWdodCh0aXRsZU9wdHMsIGNoYXJ0Lm9wdGlvbnMuZm9udCk7XG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIG1pblNpemUud2lkdGggPSB0aGlzLm1heFdpZHRoO1xuICAgICAgICBtaW5TaXplLmhlaWdodCA9IGdldFRpY2tNYXJrTGVuZ3RoKGdyaWRPcHRzKSArIHRpdGxlSGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWluU2l6ZS5oZWlnaHQgPSB0aGlzLm1heEhlaWdodDsgLy8gZmlsbCBhbGwgdGhlIGhlaWdodFxuICAgICAgICBtaW5TaXplLndpZHRoID0gZ2V0VGlja01hcmtMZW5ndGgoZ3JpZE9wdHMpICsgdGl0bGVIZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIC8vIERvbid0IGJvdGhlciBmaXR0aW5nIHRoZSB0aWNrcyBpZiB3ZSBhcmUgbm90IHNob3dpbmcgdGhlIGxhYmVsc1xuICAgICAgaWYgKHRpY2tPcHRzLmRpc3BsYXkgJiYgdGhpcy50aWNrcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3Qge2ZpcnN0LCBsYXN0LCB3aWRlc3QsIGhpZ2hlc3R9ID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgICAgICBjb25zdCB0aWNrUGFkZGluZyA9IHRpY2tPcHRzLnBhZGRpbmcgKiAyO1xuICAgICAgICBjb25zdCBhbmdsZVJhZGlhbnMgPSB0b1JhZGlhbnModGhpcy5sYWJlbFJvdGF0aW9uKTtcbiAgICAgICAgY29uc3QgY29zID0gTWF0aC5jb3MoYW5nbGVSYWRpYW5zKTtcbiAgICAgICAgY29uc3Qgc2luID0gTWF0aC5zaW4oYW5nbGVSYWRpYW5zKTtcblxuICAgICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIC8vIEEgaG9yaXpvbnRhbCBheGlzIGlzIG1vcmUgY29uc3RyYWluZWQgYnkgdGhlIGhlaWdodC5cbiAgICAgICAgICBjb25zdCBsYWJlbEhlaWdodCA9IHRpY2tPcHRzLm1pcnJvciA/IDAgOiBzaW4gKiB3aWRlc3Qud2lkdGggKyBjb3MgKiBoaWdoZXN0LmhlaWdodDtcbiAgICAgICAgICBtaW5TaXplLmhlaWdodCA9IE1hdGgubWluKHRoaXMubWF4SGVpZ2h0LCBtaW5TaXplLmhlaWdodCArIGxhYmVsSGVpZ2h0ICsgdGlja1BhZGRpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBIHZlcnRpY2FsIGF4aXMgaXMgbW9yZSBjb25zdHJhaW5lZCBieSB0aGUgd2lkdGguIExhYmVscyBhcmUgdGhlXG4gICAgICAgIC8vIGRvbWluYW50IGZhY3RvciBoZXJlLCBzbyBnZXQgdGhhdCBsZW5ndGggZmlyc3QgYW5kIGFjY291bnQgZm9yIHBhZGRpbmdcbiAgICAgICAgICBjb25zdCBsYWJlbFdpZHRoID0gdGlja09wdHMubWlycm9yID8gMCA6IGNvcyAqIHdpZGVzdC53aWR0aCArIHNpbiAqIGhpZ2hlc3QuaGVpZ2h0O1xuXG4gICAgICAgICAgbWluU2l6ZS53aWR0aCA9IE1hdGgubWluKHRoaXMubWF4V2lkdGgsIG1pblNpemUud2lkdGggKyBsYWJlbFdpZHRoICsgdGlja1BhZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NhbGN1bGF0ZVBhZGRpbmcoZmlyc3QsIGxhc3QsIHNpbiwgY29zKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9oYW5kbGVNYXJnaW5zKCk7XG5cbiAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5fbGVuZ3RoID0gY2hhcnQud2lkdGggLSB0aGlzLl9tYXJnaW5zLmxlZnQgLSB0aGlzLl9tYXJnaW5zLnJpZ2h0O1xuICAgICAgdGhpcy5oZWlnaHQgPSBtaW5TaXplLmhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53aWR0aCA9IG1pblNpemUud2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMuX2xlbmd0aCA9IGNoYXJ0LmhlaWdodCAtIHRoaXMuX21hcmdpbnMudG9wIC0gdGhpcy5fbWFyZ2lucy5ib3R0b207XG4gICAgfVxuICB9XG5cbiAgX2NhbGN1bGF0ZVBhZGRpbmcoZmlyc3QsIGxhc3QsIHNpbiwgY29zKSB7XG4gICAgY29uc3Qge3RpY2tzOiB7YWxpZ24sIHBhZGRpbmd9LCBwb3NpdGlvbn0gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgaXNSb3RhdGVkID0gdGhpcy5sYWJlbFJvdGF0aW9uICE9PSAwO1xuICAgIGNvbnN0IGxhYmVsc0JlbG93VGlja3MgPSBwb3NpdGlvbiAhPT0gJ3RvcCcgJiYgdGhpcy5heGlzID09PSAneCc7XG5cbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgY29uc3Qgb2Zmc2V0TGVmdCA9IHRoaXMuZ2V0UGl4ZWxGb3JUaWNrKDApIC0gdGhpcy5sZWZ0O1xuICAgICAgY29uc3Qgb2Zmc2V0UmlnaHQgPSB0aGlzLnJpZ2h0IC0gdGhpcy5nZXRQaXhlbEZvclRpY2sodGhpcy50aWNrcy5sZW5ndGggLSAxKTtcbiAgICAgIGxldCBwYWRkaW5nTGVmdCA9IDA7XG4gICAgICBsZXQgcGFkZGluZ1JpZ2h0ID0gMDtcblxuICAgICAgLy8gRW5zdXJlIHRoYXQgb3VyIHRpY2tzIGFyZSBhbHdheXMgaW5zaWRlIHRoZSBjYW52YXMuIFdoZW4gcm90YXRlZCwgdGlja3MgYXJlIHJpZ2h0IGFsaWduZWRcbiAgICAgIC8vIHdoaWNoIG1lYW5zIHRoYXQgdGhlIHJpZ2h0IHBhZGRpbmcgaXMgZG9taW5hdGVkIGJ5IHRoZSBmb250IGhlaWdodFxuICAgICAgaWYgKGlzUm90YXRlZCkge1xuICAgICAgICBpZiAobGFiZWxzQmVsb3dUaWNrcykge1xuICAgICAgICAgIHBhZGRpbmdMZWZ0ID0gY29zICogZmlyc3Qud2lkdGg7XG4gICAgICAgICAgcGFkZGluZ1JpZ2h0ID0gc2luICogbGFzdC5oZWlnaHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFkZGluZ0xlZnQgPSBzaW4gKiBmaXJzdC5oZWlnaHQ7XG4gICAgICAgICAgcGFkZGluZ1JpZ2h0ID0gY29zICogbGFzdC53aWR0aDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICBwYWRkaW5nUmlnaHQgPSBsYXN0LndpZHRoO1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgcGFkZGluZ0xlZnQgPSBmaXJzdC53aWR0aDtcbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gIT09ICdpbm5lcicpIHtcbiAgICAgICAgcGFkZGluZ0xlZnQgPSBmaXJzdC53aWR0aCAvIDI7XG4gICAgICAgIHBhZGRpbmdSaWdodCA9IGxhc3Qud2lkdGggLyAyO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGp1c3QgcGFkZGluZyB0YWtpbmcgaW50byBhY2NvdW50IGNoYW5nZXMgaW4gb2Zmc2V0c1xuICAgICAgdGhpcy5wYWRkaW5nTGVmdCA9IE1hdGgubWF4KChwYWRkaW5nTGVmdCAtIG9mZnNldExlZnQgKyBwYWRkaW5nKSAqIHRoaXMud2lkdGggLyAodGhpcy53aWR0aCAtIG9mZnNldExlZnQpLCAwKTtcbiAgICAgIHRoaXMucGFkZGluZ1JpZ2h0ID0gTWF0aC5tYXgoKHBhZGRpbmdSaWdodCAtIG9mZnNldFJpZ2h0ICsgcGFkZGluZykgKiB0aGlzLndpZHRoIC8gKHRoaXMud2lkdGggLSBvZmZzZXRSaWdodCksIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcGFkZGluZ1RvcCA9IGxhc3QuaGVpZ2h0IC8gMjtcbiAgICAgIGxldCBwYWRkaW5nQm90dG9tID0gZmlyc3QuaGVpZ2h0IC8gMjtcblxuICAgICAgaWYgKGFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICAgIHBhZGRpbmdUb3AgPSAwO1xuICAgICAgICBwYWRkaW5nQm90dG9tID0gZmlyc3QuaGVpZ2h0O1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgcGFkZGluZ1RvcCA9IGxhc3QuaGVpZ2h0O1xuICAgICAgICBwYWRkaW5nQm90dG9tID0gMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wYWRkaW5nVG9wID0gcGFkZGluZ1RvcCArIHBhZGRpbmc7XG4gICAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSBwYWRkaW5nQm90dG9tICsgcGFkZGluZztcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogSGFuZGxlIG1hcmdpbnMgYW5kIHBhZGRpbmcgaW50ZXJhY3Rpb25zXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfaGFuZGxlTWFyZ2lucygpIHtcbiAgICBpZiAodGhpcy5fbWFyZ2lucykge1xuICAgICAgdGhpcy5fbWFyZ2lucy5sZWZ0ID0gTWF0aC5tYXgodGhpcy5wYWRkaW5nTGVmdCwgdGhpcy5fbWFyZ2lucy5sZWZ0KTtcbiAgICAgIHRoaXMuX21hcmdpbnMudG9wID0gTWF0aC5tYXgodGhpcy5wYWRkaW5nVG9wLCB0aGlzLl9tYXJnaW5zLnRvcCk7XG4gICAgICB0aGlzLl9tYXJnaW5zLnJpZ2h0ID0gTWF0aC5tYXgodGhpcy5wYWRkaW5nUmlnaHQsIHRoaXMuX21hcmdpbnMucmlnaHQpO1xuICAgICAgdGhpcy5fbWFyZ2lucy5ib3R0b20gPSBNYXRoLm1heCh0aGlzLnBhZGRpbmdCb3R0b20sIHRoaXMuX21hcmdpbnMuYm90dG9tKTtcbiAgICB9XG4gIH1cblxuICBhZnRlckZpdCgpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5hZnRlckZpdCwgW3RoaXNdKTtcbiAgfVxuXG4gIC8vIFNoYXJlZCBNZXRob2RzXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cbiAgaXNIb3Jpem9udGFsKCkge1xuICAgIGNvbnN0IHtheGlzLCBwb3NpdGlvbn0gPSB0aGlzLm9wdGlvbnM7XG4gICAgcmV0dXJuIHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbScgfHwgYXhpcyA9PT0gJ3gnO1xuICB9XG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cbiAgaXNGdWxsU2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmZ1bGxTaXplO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7VGlja1tdfSB0aWNrc1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2NvbnZlcnRUaWNrc1RvTGFiZWxzKHRpY2tzKSB7XG4gICAgdGhpcy5iZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24oKTtcblxuICAgIHRoaXMuZ2VuZXJhdGVUaWNrTGFiZWxzKHRpY2tzKTtcblxuICAgIC8vIFRpY2tzIHNob3VsZCBiZSBza2lwcGVkIHdoZW4gY2FsbGJhY2sgcmV0dXJucyBudWxsIG9yIHVuZGVmLCBzbyBsZXRzIHJlbW92ZSB0aG9zZS5cbiAgICBsZXQgaSwgaWxlbjtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICBpZiAoaXNOdWxsT3JVbmRlZih0aWNrc1tpXS5sYWJlbCkpIHtcbiAgICAgICAgdGlja3Muc3BsaWNlKGksIDEpO1xuICAgICAgICBpbGVuLS07XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uKCk7XG4gIH1cblxuICAvKipcblx0ICogQHJldHVybiB7eyBmaXJzdDogb2JqZWN0LCBsYXN0OiBvYmplY3QsIHdpZGVzdDogb2JqZWN0LCBoaWdoZXN0OiBvYmplY3QsIHdpZHRoczogQXJyYXksIGhlaWdodHM6IGFycmF5IH19XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0TGFiZWxTaXplcygpIHtcbiAgICBsZXQgbGFiZWxTaXplcyA9IHRoaXMuX2xhYmVsU2l6ZXM7XG5cbiAgICBpZiAoIWxhYmVsU2l6ZXMpIHtcbiAgICAgIGNvbnN0IHNhbXBsZVNpemUgPSB0aGlzLm9wdGlvbnMudGlja3Muc2FtcGxlU2l6ZTtcbiAgICAgIGxldCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgICBpZiAoc2FtcGxlU2l6ZSA8IHRpY2tzLmxlbmd0aCkge1xuICAgICAgICB0aWNrcyA9IHNhbXBsZSh0aWNrcywgc2FtcGxlU2l6ZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2xhYmVsU2l6ZXMgPSBsYWJlbFNpemVzID0gdGhpcy5fY29tcHV0ZUxhYmVsU2l6ZXModGlja3MsIHRpY2tzLmxlbmd0aCwgdGhpcy5vcHRpb25zLnRpY2tzLm1heFRpY2tzTGltaXQpO1xuICAgIH1cblxuICAgIHJldHVybiBsYWJlbFNpemVzO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMge3dpZHRoLCBoZWlnaHQsIG9mZnNldH0gb2JqZWN0cyBmb3IgdGhlIGZpcnN0LCBsYXN0LCB3aWRlc3QsIGhpZ2hlc3QgdGlja1xuXHQgKiBsYWJlbHMgd2hlcmUgb2Zmc2V0IGluZGljYXRlcyB0aGUgYW5jaG9yIHBvaW50IG9mZnNldCBmcm9tIHRoZSB0b3AgaW4gcGl4ZWxzLlxuXHQgKiBAcmV0dXJuIHt7IGZpcnN0OiBvYmplY3QsIGxhc3Q6IG9iamVjdCwgd2lkZXN0OiBvYmplY3QsIGhpZ2hlc3Q6IG9iamVjdCwgd2lkdGhzOiBBcnJheSwgaGVpZ2h0czogYXJyYXkgfX1cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9jb21wdXRlTGFiZWxTaXplcyh0aWNrcywgbGVuZ3RoLCBtYXhUaWNrc0xpbWl0KSB7XG4gICAgY29uc3Qge2N0eCwgX2xvbmdlc3RUZXh0Q2FjaGU6IGNhY2hlc30gPSB0aGlzO1xuICAgIGNvbnN0IHdpZHRocyA9IFtdO1xuICAgIGNvbnN0IGhlaWdodHMgPSBbXTtcbiAgICBjb25zdCBpbmNyZW1lbnQgPSBNYXRoLmZsb29yKGxlbmd0aCAvIGdldFRpY2tzTGltaXQobGVuZ3RoLCBtYXhUaWNrc0xpbWl0KSk7XG4gICAgbGV0IHdpZGVzdExhYmVsU2l6ZSA9IDA7XG4gICAgbGV0IGhpZ2hlc3RMYWJlbFNpemUgPSAwO1xuICAgIGxldCBpLCBqLCBqbGVuLCBsYWJlbCwgdGlja0ZvbnQsIGZvbnRTdHJpbmcsIGNhY2hlLCBsaW5lSGVpZ2h0LCB3aWR0aCwgaGVpZ2h0LCBuZXN0ZWRMYWJlbDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gaW5jcmVtZW50KSB7XG4gICAgICBsYWJlbCA9IHRpY2tzW2ldLmxhYmVsO1xuICAgICAgdGlja0ZvbnQgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKGkpO1xuICAgICAgY3R4LmZvbnQgPSBmb250U3RyaW5nID0gdGlja0ZvbnQuc3RyaW5nO1xuICAgICAgY2FjaGUgPSBjYWNoZXNbZm9udFN0cmluZ10gPSBjYWNoZXNbZm9udFN0cmluZ10gfHwge2RhdGE6IHt9LCBnYzogW119O1xuICAgICAgbGluZUhlaWdodCA9IHRpY2tGb250LmxpbmVIZWlnaHQ7XG4gICAgICB3aWR0aCA9IGhlaWdodCA9IDA7XG4gICAgICAvLyBVbmRlZmluZWQgbGFiZWxzIGFuZCBhcnJheXMgc2hvdWxkIG5vdCBiZSBtZWFzdXJlZFxuICAgICAgaWYgKCFpc051bGxPclVuZGVmKGxhYmVsKSAmJiAhaXNBcnJheShsYWJlbCkpIHtcbiAgICAgICAgd2lkdGggPSBfbWVhc3VyZVRleHQoY3R4LCBjYWNoZS5kYXRhLCBjYWNoZS5nYywgd2lkdGgsIGxhYmVsKTtcbiAgICAgICAgaGVpZ2h0ID0gbGluZUhlaWdodDtcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShsYWJlbCkpIHtcbiAgICAgICAgLy8gaWYgaXQgaXMgYW4gYXJyYXkgbGV0J3MgbWVhc3VyZSBlYWNoIGVsZW1lbnRcbiAgICAgICAgZm9yIChqID0gMCwgamxlbiA9IGxhYmVsLmxlbmd0aDsgaiA8IGpsZW47ICsraikge1xuICAgICAgICAgIG5lc3RlZExhYmVsID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovIChsYWJlbFtqXSk7XG4gICAgICAgICAgLy8gVW5kZWZpbmVkIGxhYmVscyBhbmQgYXJyYXlzIHNob3VsZCBub3QgYmUgbWVhc3VyZWRcbiAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWYobmVzdGVkTGFiZWwpICYmICFpc0FycmF5KG5lc3RlZExhYmVsKSkge1xuICAgICAgICAgICAgd2lkdGggPSBfbWVhc3VyZVRleHQoY3R4LCBjYWNoZS5kYXRhLCBjYWNoZS5nYywgd2lkdGgsIG5lc3RlZExhYmVsKTtcbiAgICAgICAgICAgIGhlaWdodCArPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2lkdGhzLnB1c2god2lkdGgpO1xuICAgICAgaGVpZ2h0cy5wdXNoKGhlaWdodCk7XG4gICAgICB3aWRlc3RMYWJlbFNpemUgPSBNYXRoLm1heCh3aWR0aCwgd2lkZXN0TGFiZWxTaXplKTtcbiAgICAgIGhpZ2hlc3RMYWJlbFNpemUgPSBNYXRoLm1heChoZWlnaHQsIGhpZ2hlc3RMYWJlbFNpemUpO1xuICAgIH1cbiAgICBnYXJiYWdlQ29sbGVjdChjYWNoZXMsIGxlbmd0aCk7XG5cbiAgICBjb25zdCB3aWRlc3QgPSB3aWR0aHMuaW5kZXhPZih3aWRlc3RMYWJlbFNpemUpO1xuICAgIGNvbnN0IGhpZ2hlc3QgPSBoZWlnaHRzLmluZGV4T2YoaGlnaGVzdExhYmVsU2l6ZSk7XG5cbiAgICBjb25zdCB2YWx1ZUF0ID0gKGlkeCkgPT4gKHt3aWR0aDogd2lkdGhzW2lkeF0gfHwgMCwgaGVpZ2h0OiBoZWlnaHRzW2lkeF0gfHwgMH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGZpcnN0OiB2YWx1ZUF0KDApLFxuICAgICAgbGFzdDogdmFsdWVBdChsZW5ndGggLSAxKSxcbiAgICAgIHdpZGVzdDogdmFsdWVBdCh3aWRlc3QpLFxuICAgICAgaGlnaGVzdDogdmFsdWVBdChoaWdoZXN0KSxcbiAgICAgIHdpZHRocyxcbiAgICAgIGhlaWdodHMsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVc2VkIHRvIGdldCB0aGUgbGFiZWwgdG8gZGlzcGxheSBpbiB0aGUgdG9vbHRpcCBmb3IgdGhlIGdpdmVuIHZhbHVlXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWVcblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBsb2NhdGlvbiBvZiB0aGUgZ2l2ZW4gZGF0YSBwb2ludC4gVmFsdWUgY2FuIGVpdGhlciBiZSBhbiBpbmRleCBvciBhIG51bWVyaWNhbCB2YWx1ZVxuXHQgKiBUaGUgY29vcmRpbmF0ZSAoMCwgMCkgaXMgYXQgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXNcblx0ICogQHBhcmFtIHsqfSB2YWx1ZVxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2luZGV4XVxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlLCBpbmRleCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgcmV0dXJuIE5hTjtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVc2VkIHRvIGdldCB0aGUgZGF0YSB2YWx1ZSBmcm9tIGEgZ2l2ZW4gcGl4ZWwuIFRoaXMgaXMgdGhlIGludmVyc2Ugb2YgZ2V0UGl4ZWxGb3JWYWx1ZVxuXHQgKiBUaGUgY29vcmRpbmF0ZSAoMCwgMCkgaXMgYXQgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXNcblx0ICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsXG5cdCAqIEByZXR1cm4geyp9XG5cdCAqL1xuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIGxvY2F0aW9uIG9mIHRoZSB0aWNrIGF0IHRoZSBnaXZlbiBpbmRleFxuXHQgKiBUaGUgY29vcmRpbmF0ZSAoMCwgMCkgaXMgYXQgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXNcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldFBpeGVsRm9yVGljayhpbmRleCkge1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gdGlja3MubGVuZ3RoIC0gMSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGlja3NbaW5kZXhdLnZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVdGlsaXR5IGZvciBnZXR0aW5nIHRoZSBwaXhlbCBsb2NhdGlvbiBvZiBhIHBlcmNlbnRhZ2Ugb2Ygc2NhbGVcblx0ICogVGhlIGNvb3JkaW5hdGUgKDAsIDApIGlzIGF0IHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgY2FudmFzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkZWNpbWFsXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldFBpeGVsRm9yRGVjaW1hbChkZWNpbWFsKSB7XG4gICAgaWYgKHRoaXMuX3JldmVyc2VQaXhlbHMpIHtcbiAgICAgIGRlY2ltYWwgPSAxIC0gZGVjaW1hbDtcbiAgICB9XG5cbiAgICBjb25zdCBwaXhlbCA9IHRoaXMuX3N0YXJ0UGl4ZWwgKyBkZWNpbWFsICogdGhpcy5fbGVuZ3RoO1xuICAgIHJldHVybiBfaW50MTZSYW5nZSh0aGlzLl9hbGlnblRvUGl4ZWxzID8gX2FsaWduUGl4ZWwodGhpcy5jaGFydCwgcGl4ZWwsIDApIDogcGl4ZWwpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICBjb25zdCBkZWNpbWFsID0gKHBpeGVsIC0gdGhpcy5fc3RhcnRQaXhlbCkgLyB0aGlzLl9sZW5ndGg7XG4gICAgcmV0dXJuIHRoaXMuX3JldmVyc2VQaXhlbHMgPyAxIC0gZGVjaW1hbCA6IGRlY2ltYWw7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgcGl4ZWwgZm9yIHRoZSBtaW5pbXVtIGNoYXJ0IHZhbHVlXG5cdCAqIFRoZSBjb29yZGluYXRlICgwLCAwKSBpcyBhdCB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhc1xuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXRCYXNlUGl4ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aGlzLmdldEJhc2VWYWx1ZSgpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXRCYXNlVmFsdWUoKSB7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXM7XG5cbiAgICByZXR1cm4gbWluIDwgMCAmJiBtYXggPCAwID8gbWF4IDpcbiAgICAgIG1pbiA+IDAgJiYgbWF4ID4gMCA/IG1pbiA6XG4gICAgICAwO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldENvbnRleHQoaW5kZXgpIHtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3MgfHwgW107XG5cbiAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRpY2tzLmxlbmd0aCkge1xuICAgICAgY29uc3QgdGljayA9IHRpY2tzW2luZGV4XTtcbiAgICAgIHJldHVybiB0aWNrLiRjb250ZXh0IHx8XG5cdFx0XHRcdCh0aWNrLiRjb250ZXh0ID0gY3JlYXRlVGlja0NvbnRleHQodGhpcy5nZXRDb250ZXh0KCksIGluZGV4LCB0aWNrKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiRjb250ZXh0IHx8XG5cdFx0XHQodGhpcy4kY29udGV4dCA9IGNyZWF0ZVNjYWxlQ29udGV4dCh0aGlzLmNoYXJ0LmdldENvbnRleHQoKSwgdGhpcykpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF90aWNrU2l6ZSgpIHtcbiAgICBjb25zdCBvcHRpb25UaWNrcyA9IHRoaXMub3B0aW9ucy50aWNrcztcblxuICAgIC8vIENhbGN1bGF0ZSBzcGFjZSBuZWVkZWQgYnkgbGFiZWwgaW4gYXhpcyBkaXJlY3Rpb24uXG4gICAgY29uc3Qgcm90ID0gdG9SYWRpYW5zKHRoaXMubGFiZWxSb3RhdGlvbik7XG4gICAgY29uc3QgY29zID0gTWF0aC5hYnMoTWF0aC5jb3Mocm90KSk7XG4gICAgY29uc3Qgc2luID0gTWF0aC5hYnMoTWF0aC5zaW4ocm90KSk7XG5cbiAgICBjb25zdCBsYWJlbFNpemVzID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgIGNvbnN0IHBhZGRpbmcgPSBvcHRpb25UaWNrcy5hdXRvU2tpcFBhZGRpbmcgfHwgMDtcbiAgICBjb25zdCB3ID0gbGFiZWxTaXplcyA/IGxhYmVsU2l6ZXMud2lkZXN0LndpZHRoICsgcGFkZGluZyA6IDA7XG4gICAgY29uc3QgaCA9IGxhYmVsU2l6ZXMgPyBsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0ICsgcGFkZGluZyA6IDA7XG5cbiAgICAvLyBDYWxjdWxhdGUgc3BhY2UgbmVlZGVkIGZvciAxIHRpY2sgaW4gYXhpcyBkaXJlY3Rpb24uXG4gICAgcmV0dXJuIHRoaXMuaXNIb3Jpem9udGFsKClcbiAgICAgID8gaCAqIGNvcyA+IHcgKiBzaW4gPyB3IC8gY29zIDogaCAvIHNpblxuICAgICAgOiBoICogc2luIDwgdyAqIGNvcyA/IGggLyBjb3MgOiB3IC8gc2luO1xuICB9XG5cbiAgLyoqXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfaXNWaXNpYmxlKCkge1xuICAgIGNvbnN0IGRpc3BsYXkgPSB0aGlzLm9wdGlvbnMuZGlzcGxheTtcblxuICAgIGlmIChkaXNwbGF5ICE9PSAnYXV0bycpIHtcbiAgICAgIHJldHVybiAhIWRpc3BsYXk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoKS5sZW5ndGggPiAwO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY29tcHV0ZUdyaWRMaW5lSXRlbXMoY2hhcnRBcmVhKSB7XG4gICAgY29uc3QgYXhpcyA9IHRoaXMuYXhpcztcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7Z3JpZCwgcG9zaXRpb24sIGJvcmRlcn0gPSBvcHRpb25zO1xuICAgIGNvbnN0IG9mZnNldCA9IGdyaWQub2Zmc2V0O1xuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHRoaXMuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGNvbnN0IHRpY2tzTGVuZ3RoID0gdGlja3MubGVuZ3RoICsgKG9mZnNldCA/IDEgOiAwKTtcbiAgICBjb25zdCB0bCA9IGdldFRpY2tNYXJrTGVuZ3RoKGdyaWQpO1xuICAgIGNvbnN0IGl0ZW1zID0gW107XG5cbiAgICBjb25zdCBib3JkZXJPcHRzID0gYm9yZGVyLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNvbnN0IGF4aXNXaWR0aCA9IGJvcmRlck9wdHMuZGlzcGxheSA/IGJvcmRlck9wdHMud2lkdGggOiAwO1xuICAgIGNvbnN0IGF4aXNIYWxmV2lkdGggPSBheGlzV2lkdGggLyAyO1xuICAgIGNvbnN0IGFsaWduQm9yZGVyVmFsdWUgPSBmdW5jdGlvbihwaXhlbCkge1xuICAgICAgcmV0dXJuIF9hbGlnblBpeGVsKGNoYXJ0LCBwaXhlbCwgYXhpc1dpZHRoKTtcbiAgICB9O1xuICAgIGxldCBib3JkZXJWYWx1ZSwgaSwgbGluZVZhbHVlLCBhbGlnbmVkTGluZVZhbHVlO1xuICAgIGxldCB0eDEsIHR5MSwgdHgyLCB0eTIsIHgxLCB5MSwgeDIsIHkyO1xuXG4gICAgaWYgKHBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMuYm90dG9tKTtcbiAgICAgIHR5MSA9IHRoaXMuYm90dG9tIC0gdGw7XG4gICAgICB0eTIgPSBib3JkZXJWYWx1ZSAtIGF4aXNIYWxmV2lkdGg7XG4gICAgICB5MSA9IGFsaWduQm9yZGVyVmFsdWUoY2hhcnRBcmVhLnRvcCkgKyBheGlzSGFsZldpZHRoO1xuICAgICAgeTIgPSBjaGFydEFyZWEuYm90dG9tO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy50b3ApO1xuICAgICAgeTEgPSBjaGFydEFyZWEudG9wO1xuICAgICAgeTIgPSBhbGlnbkJvcmRlclZhbHVlKGNoYXJ0QXJlYS5ib3R0b20pIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR5MSA9IGJvcmRlclZhbHVlICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR5MiA9IHRoaXMudG9wICsgdGw7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy5yaWdodCk7XG4gICAgICB0eDEgPSB0aGlzLnJpZ2h0IC0gdGw7XG4gICAgICB0eDIgPSBib3JkZXJWYWx1ZSAtIGF4aXNIYWxmV2lkdGg7XG4gICAgICB4MSA9IGFsaWduQm9yZGVyVmFsdWUoY2hhcnRBcmVhLmxlZnQpICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgIHgyID0gY2hhcnRBcmVhLnJpZ2h0O1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLmxlZnQpO1xuICAgICAgeDEgPSBjaGFydEFyZWEubGVmdDtcbiAgICAgIHgyID0gYWxpZ25Cb3JkZXJWYWx1ZShjaGFydEFyZWEucmlnaHQpIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR4MSA9IGJvcmRlclZhbHVlICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR4MiA9IHRoaXMubGVmdCArIHRsO1xuICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gJ3gnKSB7XG4gICAgICBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSgoY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5ib3R0b20pIC8gMiArIDAuNSk7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLmNoYXJ0LnNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkpO1xuICAgICAgfVxuXG4gICAgICB5MSA9IGNoYXJ0QXJlYS50b3A7XG4gICAgICB5MiA9IGNoYXJ0QXJlYS5ib3R0b207XG4gICAgICB0eTEgPSBib3JkZXJWYWx1ZSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eTIgPSB0eTEgKyB0bDtcbiAgICB9IGVsc2UgaWYgKGF4aXMgPT09ICd5Jykge1xuICAgICAgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUoKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDIpO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy5jaGFydC5zY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpKTtcbiAgICAgIH1cblxuICAgICAgdHgxID0gYm9yZGVyVmFsdWUgLSBheGlzSGFsZldpZHRoO1xuICAgICAgdHgyID0gdHgxIC0gdGw7XG4gICAgICB4MSA9IGNoYXJ0QXJlYS5sZWZ0O1xuICAgICAgeDIgPSBjaGFydEFyZWEucmlnaHQ7XG4gICAgfVxuXG4gICAgY29uc3QgbGltaXQgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLnRpY2tzLm1heFRpY2tzTGltaXQsIHRpY2tzTGVuZ3RoKTtcbiAgICBjb25zdCBzdGVwID0gTWF0aC5tYXgoMSwgTWF0aC5jZWlsKHRpY2tzTGVuZ3RoIC8gbGltaXQpKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGlja3NMZW5ndGg7IGkgKz0gc3RlcCkge1xuICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuZ2V0Q29udGV4dChpKTtcbiAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gZ3JpZC5zZXRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgY29uc3Qgb3B0c0F0SW5kZXhCb3JkZXIgPSBib3JkZXIuc2V0Q29udGV4dChjb250ZXh0KTtcblxuICAgICAgY29uc3QgbGluZVdpZHRoID0gb3B0c0F0SW5kZXgubGluZVdpZHRoO1xuICAgICAgY29uc3QgbGluZUNvbG9yID0gb3B0c0F0SW5kZXguY29sb3I7XG4gICAgICBjb25zdCBib3JkZXJEYXNoID0gb3B0c0F0SW5kZXhCb3JkZXIuZGFzaCB8fCBbXTtcbiAgICAgIGNvbnN0IGJvcmRlckRhc2hPZmZzZXQgPSBvcHRzQXRJbmRleEJvcmRlci5kYXNoT2Zmc2V0O1xuXG4gICAgICBjb25zdCB0aWNrV2lkdGggPSBvcHRzQXRJbmRleC50aWNrV2lkdGg7XG4gICAgICBjb25zdCB0aWNrQ29sb3IgPSBvcHRzQXRJbmRleC50aWNrQ29sb3I7XG4gICAgICBjb25zdCB0aWNrQm9yZGVyRGFzaCA9IG9wdHNBdEluZGV4LnRpY2tCb3JkZXJEYXNoIHx8IFtdO1xuICAgICAgY29uc3QgdGlja0JvcmRlckRhc2hPZmZzZXQgPSBvcHRzQXRJbmRleC50aWNrQm9yZGVyRGFzaE9mZnNldDtcblxuICAgICAgbGluZVZhbHVlID0gZ2V0UGl4ZWxGb3JHcmlkTGluZSh0aGlzLCBpLCBvZmZzZXQpO1xuXG4gICAgICAvLyBTa2lwIGlmIHRoZSBwaXhlbCBpcyBvdXQgb2YgdGhlIHJhbmdlXG4gICAgICBpZiAobGluZVZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGFsaWduZWRMaW5lVmFsdWUgPSBfYWxpZ25QaXhlbChjaGFydCwgbGluZVZhbHVlLCBsaW5lV2lkdGgpO1xuXG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIHR4MSA9IHR4MiA9IHgxID0geDIgPSBhbGlnbmVkTGluZVZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHkxID0gdHkyID0geTEgPSB5MiA9IGFsaWduZWRMaW5lVmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICB0eDEsXG4gICAgICAgIHR5MSxcbiAgICAgICAgdHgyLFxuICAgICAgICB0eTIsXG4gICAgICAgIHgxLFxuICAgICAgICB5MSxcbiAgICAgICAgeDIsXG4gICAgICAgIHkyLFxuICAgICAgICB3aWR0aDogbGluZVdpZHRoLFxuICAgICAgICBjb2xvcjogbGluZUNvbG9yLFxuICAgICAgICBib3JkZXJEYXNoLFxuICAgICAgICBib3JkZXJEYXNoT2Zmc2V0LFxuICAgICAgICB0aWNrV2lkdGgsXG4gICAgICAgIHRpY2tDb2xvcixcbiAgICAgICAgdGlja0JvcmRlckRhc2gsXG4gICAgICAgIHRpY2tCb3JkZXJEYXNoT2Zmc2V0LFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5fdGlja3NMZW5ndGggPSB0aWNrc0xlbmd0aDtcbiAgICB0aGlzLl9ib3JkZXJWYWx1ZSA9IGJvcmRlclZhbHVlO1xuXG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY29tcHV0ZUxhYmVsSXRlbXMoY2hhcnRBcmVhKSB7XG4gICAgY29uc3QgYXhpcyA9IHRoaXMuYXhpcztcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHtwb3NpdGlvbiwgdGlja3M6IG9wdGlvblRpY2tzfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gdGhpcy5pc0hvcml6b250YWwoKTtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgY29uc3Qge2FsaWduLCBjcm9zc0FsaWduLCBwYWRkaW5nLCBtaXJyb3J9ID0gb3B0aW9uVGlja3M7XG4gICAgY29uc3QgdGwgPSBnZXRUaWNrTWFya0xlbmd0aChvcHRpb25zLmdyaWQpO1xuICAgIGNvbnN0IHRpY2tBbmRQYWRkaW5nID0gdGwgKyBwYWRkaW5nO1xuICAgIGNvbnN0IGhUaWNrQW5kUGFkZGluZyA9IG1pcnJvciA/IC1wYWRkaW5nIDogdGlja0FuZFBhZGRpbmc7XG4gICAgY29uc3Qgcm90YXRpb24gPSAtdG9SYWRpYW5zKHRoaXMubGFiZWxSb3RhdGlvbik7XG4gICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICBsZXQgaSwgaWxlbiwgdGljaywgbGFiZWwsIHgsIHksIHRleHRBbGlnbiwgcGl4ZWwsIGZvbnQsIGxpbmVIZWlnaHQsIGxpbmVDb3VudCwgdGV4dE9mZnNldDtcbiAgICBsZXQgdGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cbiAgICBpZiAocG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICB5ID0gdGhpcy5ib3R0b20gLSBoVGlja0FuZFBhZGRpbmc7XG4gICAgICB0ZXh0QWxpZ24gPSB0aGlzLl9nZXRYQXhpc0xhYmVsQWxpZ25tZW50KCk7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIHkgPSB0aGlzLnRvcCArIGhUaWNrQW5kUGFkZGluZztcbiAgICAgIHRleHRBbGlnbiA9IHRoaXMuX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQoKTtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgIGNvbnN0IHJldCA9IHRoaXMuX2dldFlBeGlzTGFiZWxBbGlnbm1lbnQodGwpO1xuICAgICAgdGV4dEFsaWduID0gcmV0LnRleHRBbGlnbjtcbiAgICAgIHggPSByZXQueDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICBjb25zdCByZXQgPSB0aGlzLl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHRsKTtcbiAgICAgIHRleHRBbGlnbiA9IHJldC50ZXh0QWxpZ247XG4gICAgICB4ID0gcmV0Lng7XG4gICAgfSBlbHNlIGlmIChheGlzID09PSAneCcpIHtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgeSA9ICgoY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5ib3R0b20pIC8gMikgKyB0aWNrQW5kUGFkZGluZztcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgICAgeSA9IHRoaXMuY2hhcnQuc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSArIHRpY2tBbmRQYWRkaW5nO1xuICAgICAgfVxuICAgICAgdGV4dEFsaWduID0gdGhpcy5fZ2V0WEF4aXNMYWJlbEFsaWdubWVudCgpO1xuICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gJ3knKSB7XG4gICAgICBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHggPSAoKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDIpIC0gdGlja0FuZFBhZGRpbmc7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICAgIHggPSB0aGlzLmNoYXJ0LnNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICB0ZXh0QWxpZ24gPSB0aGlzLl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHRsKS50ZXh0QWxpZ247XG4gICAgfVxuXG4gICAgaWYgKGF4aXMgPT09ICd5Jykge1xuICAgICAgaWYgKGFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICAgIHRleHRCYXNlbGluZSA9ICd0b3AnO1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgdGV4dEJhc2VsaW5lID0gJ2JvdHRvbSc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbGFiZWxTaXplcyA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aWNrID0gdGlja3NbaV07XG4gICAgICBsYWJlbCA9IHRpY2subGFiZWw7XG5cbiAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gb3B0aW9uVGlja3Muc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoaSkpO1xuICAgICAgcGl4ZWwgPSB0aGlzLmdldFBpeGVsRm9yVGljayhpKSArIG9wdGlvblRpY2tzLmxhYmVsT2Zmc2V0O1xuICAgICAgZm9udCA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoaSk7XG4gICAgICBsaW5lSGVpZ2h0ID0gZm9udC5saW5lSGVpZ2h0O1xuICAgICAgbGluZUNvdW50ID0gaXNBcnJheShsYWJlbCkgPyBsYWJlbC5sZW5ndGggOiAxO1xuICAgICAgY29uc3QgaGFsZkNvdW50ID0gbGluZUNvdW50IC8gMjtcbiAgICAgIGNvbnN0IGNvbG9yID0gb3B0c0F0SW5kZXguY29sb3I7XG4gICAgICBjb25zdCBzdHJva2VDb2xvciA9IG9wdHNBdEluZGV4LnRleHRTdHJva2VDb2xvcjtcbiAgICAgIGNvbnN0IHN0cm9rZVdpZHRoID0gb3B0c0F0SW5kZXgudGV4dFN0cm9rZVdpZHRoO1xuICAgICAgbGV0IHRpY2tUZXh0QWxpZ24gPSB0ZXh0QWxpZ247XG5cbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgeCA9IHBpeGVsO1xuXG4gICAgICAgIGlmICh0ZXh0QWxpZ24gPT09ICdpbm5lcicpIHtcbiAgICAgICAgICBpZiAoaSA9PT0gaWxlbiAtIDEpIHtcbiAgICAgICAgICAgIHRpY2tUZXh0QWxpZ24gPSAhdGhpcy5vcHRpb25zLnJldmVyc2UgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgdGlja1RleHRBbGlnbiA9ICF0aGlzLm9wdGlvbnMucmV2ZXJzZSA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpY2tUZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJyB8fCByb3RhdGlvbiAhPT0gMCkge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IC1saW5lQ291bnQgKiBsaW5lSGVpZ2h0ICsgbGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IC1sYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0IC8gMiAtIGhhbGZDb3VudCAqIGxpbmVIZWlnaHQgKyBsaW5lSGVpZ2h0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gLWxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgKyBsaW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvbmVseS1pZlxuICAgICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicgfHwgcm90YXRpb24gIT09IDApIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSBsaW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCAvIDIgLSBoYWxmQ291bnQgKiBsaW5lSGVpZ2h0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCAtIGxpbmVDb3VudCAqIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtaXJyb3IpIHtcbiAgICAgICAgICB0ZXh0T2Zmc2V0ICo9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyb3RhdGlvbiAhPT0gMCAmJiAhb3B0c0F0SW5kZXguc2hvd0xhYmVsQmFja2Ryb3ApIHtcbiAgICAgICAgICB4ICs9IChsaW5lSGVpZ2h0IC8gMikgKiBNYXRoLnNpbihyb3RhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHkgPSBwaXhlbDtcbiAgICAgICAgdGV4dE9mZnNldCA9ICgxIC0gbGluZUNvdW50KSAqIGxpbmVIZWlnaHQgLyAyO1xuICAgICAgfVxuXG4gICAgICBsZXQgYmFja2Ryb3A7XG5cbiAgICAgIGlmIChvcHRzQXRJbmRleC5zaG93TGFiZWxCYWNrZHJvcCkge1xuICAgICAgICBjb25zdCBsYWJlbFBhZGRpbmcgPSB0b1BhZGRpbmcob3B0c0F0SW5kZXguYmFja2Ryb3BQYWRkaW5nKTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gbGFiZWxTaXplcy5oZWlnaHRzW2ldO1xuICAgICAgICBjb25zdCB3aWR0aCA9IGxhYmVsU2l6ZXMud2lkdGhzW2ldO1xuXG4gICAgICAgIGxldCB0b3AgPSB0ZXh0T2Zmc2V0IC0gbGFiZWxQYWRkaW5nLnRvcDtcbiAgICAgICAgbGV0IGxlZnQgPSAwIC0gbGFiZWxQYWRkaW5nLmxlZnQ7XG5cbiAgICAgICAgc3dpdGNoICh0ZXh0QmFzZWxpbmUpIHtcbiAgICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgICB0b3AgLT0gaGVpZ2h0IC8gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICB0b3AgLT0gaGVpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoICh0ZXh0QWxpZ24pIHtcbiAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICBsZWZ0IC09IHdpZHRoIC8gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2lubmVyJzpcbiAgICAgICAgICBpZiAoaSA9PT0gaWxlbiAtIDEpIHtcbiAgICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XG4gICAgICAgICAgfSBlbHNlIGlmIChpID4gMCkge1xuICAgICAgICAgICAgbGVmdCAtPSB3aWR0aCAvIDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgYmFja2Ryb3AgPSB7XG4gICAgICAgICAgbGVmdCxcbiAgICAgICAgICB0b3AsXG4gICAgICAgICAgd2lkdGg6IHdpZHRoICsgbGFiZWxQYWRkaW5nLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0ICsgbGFiZWxQYWRkaW5nLmhlaWdodCxcblxuICAgICAgICAgIGNvbG9yOiBvcHRzQXRJbmRleC5iYWNrZHJvcENvbG9yLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIGZvbnQsXG4gICAgICAgIHRleHRPZmZzZXQsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICByb3RhdGlvbixcbiAgICAgICAgICBjb2xvcixcbiAgICAgICAgICBzdHJva2VDb2xvcixcbiAgICAgICAgICBzdHJva2VXaWR0aCxcbiAgICAgICAgICB0ZXh0QWxpZ246IHRpY2tUZXh0QWxpZ24sXG4gICAgICAgICAgdGV4dEJhc2VsaW5lLFxuICAgICAgICAgIHRyYW5zbGF0aW9uOiBbeCwgeV0sXG4gICAgICAgICAgYmFja2Ryb3AsXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBpdGVtcztcbiAgfVxuXG4gIF9nZXRYQXhpc0xhYmVsQWxpZ25tZW50KCkge1xuICAgIGNvbnN0IHtwb3NpdGlvbiwgdGlja3N9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHJvdGF0aW9uID0gLXRvUmFkaWFucyh0aGlzLmxhYmVsUm90YXRpb24pO1xuXG4gICAgaWYgKHJvdGF0aW9uKSB7XG4gICAgICByZXR1cm4gcG9zaXRpb24gPT09ICd0b3AnID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICB9XG5cbiAgICBsZXQgYWxpZ24gPSAnY2VudGVyJztcblxuICAgIGlmICh0aWNrcy5hbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgYWxpZ24gPSAnbGVmdCc7XG4gICAgfSBlbHNlIGlmICh0aWNrcy5hbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgIGFsaWduID0gJ3JpZ2h0JztcbiAgICB9IGVsc2UgaWYgKHRpY2tzLmFsaWduID09PSAnaW5uZXInKSB7XG4gICAgICBhbGlnbiA9ICdpbm5lcic7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFsaWduO1xuICB9XG5cbiAgX2dldFlBeGlzTGFiZWxBbGlnbm1lbnQodGwpIHtcbiAgICBjb25zdCB7cG9zaXRpb24sIHRpY2tzOiB7Y3Jvc3NBbGlnbiwgbWlycm9yLCBwYWRkaW5nfX0gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbGFiZWxTaXplcyA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcbiAgICBjb25zdCB0aWNrQW5kUGFkZGluZyA9IHRsICsgcGFkZGluZztcbiAgICBjb25zdCB3aWRlc3QgPSBsYWJlbFNpemVzLndpZGVzdC53aWR0aDtcblxuICAgIGxldCB0ZXh0QWxpZ247XG4gICAgbGV0IHg7XG5cbiAgICBpZiAocG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgaWYgKG1pcnJvcikge1xuICAgICAgICB4ID0gdGhpcy5yaWdodCArIHBhZGRpbmc7XG5cbiAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgIHggKz0gKHdpZGVzdCAvIDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgeCArPSB3aWRlc3Q7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSB0aGlzLnJpZ2h0IC0gdGlja0FuZFBhZGRpbmc7XG5cbiAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB4IC09ICh3aWRlc3QgLyAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgeCA9IHRoaXMubGVmdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgIGlmIChtaXJyb3IpIHtcbiAgICAgICAgeCA9IHRoaXMubGVmdCArIHBhZGRpbmc7XG5cbiAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB4IC09ICh3aWRlc3QgLyAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgeCAtPSB3aWRlc3Q7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSB0aGlzLmxlZnQgKyB0aWNrQW5kUGFkZGluZztcblxuICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgeCArPSB3aWRlc3QgLyAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgeCA9IHRoaXMucmlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICB9XG5cbiAgICByZXR1cm4ge3RleHRBbGlnbiwgeH07XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9jb21wdXRlTGFiZWxBcmVhKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudGlja3MubWlycm9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xuXG4gICAgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcgfHwgcG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgIHJldHVybiB7dG9wOiAwLCBsZWZ0OiB0aGlzLmxlZnQsIGJvdHRvbTogY2hhcnQuaGVpZ2h0LCByaWdodDogdGhpcy5yaWdodH07XG4gICAgfSBpZiAocG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgcmV0dXJuIHt0b3A6IHRoaXMudG9wLCBsZWZ0OiAwLCBib3R0b206IHRoaXMuYm90dG9tLCByaWdodDogY2hhcnQud2lkdGh9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBkcmF3QmFja2dyb3VuZCgpIHtcbiAgICBjb25zdCB7Y3R4LCBvcHRpb25zOiB7YmFja2dyb3VuZENvbG9yfSwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0fSA9IHRoaXM7XG4gICAgaWYgKGJhY2tncm91bmRDb2xvcikge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgICBjdHguZmlsbFJlY3QobGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0TGluZVdpZHRoRm9yVmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBncmlkID0gdGhpcy5vcHRpb25zLmdyaWQ7XG4gICAgaWYgKCF0aGlzLl9pc1Zpc2libGUoKSB8fCAhZ3JpZC5kaXNwbGF5KSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGNvbnN0IGluZGV4ID0gdGlja3MuZmluZEluZGV4KHQgPT4gdC52YWx1ZSA9PT0gdmFsdWUpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICBjb25zdCBvcHRzID0gZ3JpZC5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChpbmRleCkpO1xuICAgICAgcmV0dXJuIG9wdHMubGluZVdpZHRoO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3R3JpZChjaGFydEFyZWEpIHtcbiAgICBjb25zdCBncmlkID0gdGhpcy5vcHRpb25zLmdyaWQ7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLl9ncmlkTGluZUl0ZW1zIHx8ICh0aGlzLl9ncmlkTGluZUl0ZW1zID0gdGhpcy5fY29tcHV0ZUdyaWRMaW5lSXRlbXMoY2hhcnRBcmVhKSk7XG4gICAgbGV0IGksIGlsZW47XG5cbiAgICBjb25zdCBkcmF3TGluZSA9IChwMSwgcDIsIHN0eWxlKSA9PiB7XG4gICAgICBpZiAoIXN0eWxlLndpZHRoIHx8ICFzdHlsZS5jb2xvcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IHN0eWxlLndpZHRoO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3R5bGUuY29sb3I7XG4gICAgICBjdHguc2V0TGluZURhc2goc3R5bGUuYm9yZGVyRGFzaCB8fCBbXSk7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBzdHlsZS5ib3JkZXJEYXNoT2Zmc2V0O1xuXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKHAxLngsIHAxLnkpO1xuICAgICAgY3R4LmxpbmVUbyhwMi54LCBwMi55KTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfTtcblxuICAgIGlmIChncmlkLmRpc3BsYXkpIHtcbiAgICAgIGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xuXG4gICAgICAgIGlmIChncmlkLmRyYXdPbkNoYXJ0QXJlYSkge1xuICAgICAgICAgIGRyYXdMaW5lKFxuICAgICAgICAgICAge3g6IGl0ZW0ueDEsIHk6IGl0ZW0ueTF9LFxuICAgICAgICAgICAge3g6IGl0ZW0ueDIsIHk6IGl0ZW0ueTJ9LFxuICAgICAgICAgICAgaXRlbVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ3JpZC5kcmF3VGlja3MpIHtcbiAgICAgICAgICBkcmF3TGluZShcbiAgICAgICAgICAgIHt4OiBpdGVtLnR4MSwgeTogaXRlbS50eTF9LFxuICAgICAgICAgICAge3g6IGl0ZW0udHgyLCB5OiBpdGVtLnR5Mn0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbG9yOiBpdGVtLnRpY2tDb2xvcixcbiAgICAgICAgICAgICAgd2lkdGg6IGl0ZW0udGlja1dpZHRoLFxuICAgICAgICAgICAgICBib3JkZXJEYXNoOiBpdGVtLnRpY2tCb3JkZXJEYXNoLFxuICAgICAgICAgICAgICBib3JkZXJEYXNoT2Zmc2V0OiBpdGVtLnRpY2tCb3JkZXJEYXNoT2Zmc2V0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3Qm9yZGVyKCkge1xuICAgIGNvbnN0IHtjaGFydCwgY3R4LCBvcHRpb25zOiB7Ym9yZGVyLCBncmlkfX0gPSB0aGlzO1xuICAgIGNvbnN0IGJvcmRlck9wdHMgPSBib3JkZXIuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY29uc3QgYXhpc1dpZHRoID0gYm9yZGVyLmRpc3BsYXkgPyBib3JkZXJPcHRzLndpZHRoIDogMDtcbiAgICBpZiAoIWF4aXNXaWR0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsYXN0TGluZVdpZHRoID0gZ3JpZC5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgwKSkubGluZVdpZHRoO1xuICAgIGNvbnN0IGJvcmRlclZhbHVlID0gdGhpcy5fYm9yZGVyVmFsdWU7XG4gICAgbGV0IHgxLCB4MiwgeTEsIHkyO1xuXG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHgxID0gX2FsaWduUGl4ZWwoY2hhcnQsIHRoaXMubGVmdCwgYXhpc1dpZHRoKSAtIGF4aXNXaWR0aCAvIDI7XG4gICAgICB4MiA9IF9hbGlnblBpeGVsKGNoYXJ0LCB0aGlzLnJpZ2h0LCBsYXN0TGluZVdpZHRoKSArIGxhc3RMaW5lV2lkdGggLyAyO1xuICAgICAgeTEgPSB5MiA9IGJvcmRlclZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB5MSA9IF9hbGlnblBpeGVsKGNoYXJ0LCB0aGlzLnRvcCwgYXhpc1dpZHRoKSAtIGF4aXNXaWR0aCAvIDI7XG4gICAgICB5MiA9IF9hbGlnblBpeGVsKGNoYXJ0LCB0aGlzLmJvdHRvbSwgbGFzdExpbmVXaWR0aCkgKyBsYXN0TGluZVdpZHRoIC8gMjtcbiAgICAgIHgxID0geDIgPSBib3JkZXJWYWx1ZTtcbiAgICB9XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHgubGluZVdpZHRoID0gYm9yZGVyT3B0cy53aWR0aDtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBib3JkZXJPcHRzLmNvbG9yO1xuXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcbiAgICBjdHgubGluZVRvKHgyLCB5Mik7XG4gICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3TGFiZWxzKGNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IG9wdGlvblRpY2tzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuXG4gICAgaWYgKCFvcHRpb25UaWNrcy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG5cbiAgICBjb25zdCBhcmVhID0gdGhpcy5fY29tcHV0ZUxhYmVsQXJlYSgpO1xuICAgIGlmIChhcmVhKSB7XG4gICAgICBjbGlwQXJlYShjdHgsIGFyZWEpO1xuICAgIH1cblxuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5nZXRMYWJlbEl0ZW1zKGNoYXJ0QXJlYSk7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICBjb25zdCByZW5kZXJUZXh0T3B0aW9ucyA9IGl0ZW0ub3B0aW9ucztcbiAgICAgIGNvbnN0IHRpY2tGb250ID0gaXRlbS5mb250O1xuICAgICAgY29uc3QgbGFiZWwgPSBpdGVtLmxhYmVsO1xuICAgICAgY29uc3QgeSA9IGl0ZW0udGV4dE9mZnNldDtcbiAgICAgIHJlbmRlclRleHQoY3R4LCBsYWJlbCwgMCwgeSwgdGlja0ZvbnQsIHJlbmRlclRleHRPcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAoYXJlYSkge1xuICAgICAgdW5jbGlwQXJlYShjdHgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3VGl0bGUoKSB7XG4gICAgY29uc3Qge2N0eCwgb3B0aW9uczoge3Bvc2l0aW9uLCB0aXRsZSwgcmV2ZXJzZX19ID0gdGhpcztcblxuICAgIGlmICghdGl0bGUuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGZvbnQgPSB0b0ZvbnQodGl0bGUuZm9udCk7XG4gICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyh0aXRsZS5wYWRkaW5nKTtcbiAgICBjb25zdCBhbGlnbiA9IHRpdGxlLmFsaWduO1xuICAgIGxldCBvZmZzZXQgPSBmb250LmxpbmVIZWlnaHQgLyAyO1xuXG4gICAgaWYgKHBvc2l0aW9uID09PSAnYm90dG9tJyB8fCBwb3NpdGlvbiA9PT0gJ2NlbnRlcicgfHwgaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICBvZmZzZXQgKz0gcGFkZGluZy5ib3R0b207XG4gICAgICBpZiAoaXNBcnJheSh0aXRsZS50ZXh0KSkge1xuICAgICAgICBvZmZzZXQgKz0gZm9udC5saW5lSGVpZ2h0ICogKHRpdGxlLnRleHQubGVuZ3RoIC0gMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldCArPSBwYWRkaW5nLnRvcDtcbiAgICB9XG5cbiAgICBjb25zdCB7dGl0bGVYLCB0aXRsZVksIG1heFdpZHRoLCByb3RhdGlvbn0gPSB0aXRsZUFyZ3ModGhpcywgb2Zmc2V0LCBwb3NpdGlvbiwgYWxpZ24pO1xuXG4gICAgcmVuZGVyVGV4dChjdHgsIHRpdGxlLnRleHQsIDAsIDAsIGZvbnQsIHtcbiAgICAgIGNvbG9yOiB0aXRsZS5jb2xvcixcbiAgICAgIG1heFdpZHRoLFxuICAgICAgcm90YXRpb24sXG4gICAgICB0ZXh0QWxpZ246IHRpdGxlQWxpZ24oYWxpZ24sIHBvc2l0aW9uLCByZXZlcnNlKSxcbiAgICAgIHRleHRCYXNlbGluZTogJ21pZGRsZScsXG4gICAgICB0cmFuc2xhdGlvbjogW3RpdGxlWCwgdGl0bGVZXSxcbiAgICB9KTtcbiAgfVxuXG4gIGRyYXcoY2hhcnRBcmVhKSB7XG4gICAgaWYgKCF0aGlzLl9pc1Zpc2libGUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZHJhd0JhY2tncm91bmQoKTtcbiAgICB0aGlzLmRyYXdHcmlkKGNoYXJ0QXJlYSk7XG4gICAgdGhpcy5kcmF3Qm9yZGVyKCk7XG4gICAgdGhpcy5kcmF3VGl0bGUoKTtcbiAgICB0aGlzLmRyYXdMYWJlbHMoY2hhcnRBcmVhKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtvYmplY3RbXX1cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9sYXllcnMoKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0eiA9IG9wdHMudGlja3MgJiYgb3B0cy50aWNrcy56IHx8IDA7XG4gICAgY29uc3QgZ3ogPSB2YWx1ZU9yRGVmYXVsdChvcHRzLmdyaWQgJiYgb3B0cy5ncmlkLnosIC0xKTtcbiAgICBjb25zdCBieiA9IHZhbHVlT3JEZWZhdWx0KG9wdHMuYm9yZGVyICYmIG9wdHMuYm9yZGVyLnosIDApO1xuXG4gICAgaWYgKCF0aGlzLl9pc1Zpc2libGUoKSB8fCB0aGlzLmRyYXcgIT09IFNjYWxlLnByb3RvdHlwZS5kcmF3KSB7XG4gICAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5OiBkcmF3IGhhcyBiZWVuIG92ZXJyaWRkZW4gYnkgY3VzdG9tIHNjYWxlXG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgejogdHosXG4gICAgICAgIGRyYXc6IChjaGFydEFyZWEpID0+IHtcbiAgICAgICAgICB0aGlzLmRyYXcoY2hhcnRBcmVhKTtcbiAgICAgICAgfVxuICAgICAgfV07XG4gICAgfVxuXG4gICAgcmV0dXJuIFt7XG4gICAgICB6OiBneixcbiAgICAgIGRyYXc6IChjaGFydEFyZWEpID0+IHtcbiAgICAgICAgdGhpcy5kcmF3QmFja2dyb3VuZCgpO1xuICAgICAgICB0aGlzLmRyYXdHcmlkKGNoYXJ0QXJlYSk7XG4gICAgICAgIHRoaXMuZHJhd1RpdGxlKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgejogYnosXG4gICAgICBkcmF3OiAoKSA9PiB7XG4gICAgICAgIHRoaXMuZHJhd0JvcmRlcigpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHo6IHR6LFxuICAgICAgZHJhdzogKGNoYXJ0QXJlYSkgPT4ge1xuICAgICAgICB0aGlzLmRyYXdMYWJlbHMoY2hhcnRBcmVhKTtcbiAgICAgIH1cbiAgICB9XTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHZpc2libGUgZGF0YXNldCBtZXRhcyB0aGF0IGFyZSBhdHRhY2hlZCB0byB0aGlzIHNjYWxlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZV0gLSBpZiBzcGVjaWZpZWQsIGFsc28gZmlsdGVyIGJ5IGRhdGFzZXQgdHlwZVxuXHQgKiBAcmV0dXJuIHtvYmplY3RbXX1cblx0ICovXG4gIGdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKHR5cGUpIHtcbiAgICBjb25zdCBtZXRhcyA9IHRoaXMuY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgIGNvbnN0IGF4aXNJRCA9IHRoaXMuYXhpcyArICdBeGlzSUQnO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBpLCBpbGVuO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IG1ldGFzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY29uc3QgbWV0YSA9IG1ldGFzW2ldO1xuICAgICAgaWYgKG1ldGFbYXhpc0lEXSA9PT0gdGhpcy5pZCAmJiAoIXR5cGUgfHwgbWV0YS50eXBlID09PSB0eXBlKSkge1xuICAgICAgICByZXN1bHQucHVzaChtZXRhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcblx0ICogQHJldHVybiB7b2JqZWN0fVxuXHQgKiBAcHJvdGVjdGVkXG4gXHQgKi9cbiAgX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoaW5kZXgpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zLnRpY2tzLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGluZGV4KSk7XG4gICAgcmV0dXJuIHRvRm9udChvcHRzLmZvbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9tYXhEaWdpdHMoKSB7XG4gICAgY29uc3QgZm9udFNpemUgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKDApLmxpbmVIZWlnaHQ7XG4gICAgcmV0dXJuICh0aGlzLmlzSG9yaXpvbnRhbCgpID8gdGhpcy53aWR0aCA6IHRoaXMuaGVpZ2h0KSAvIGZvbnRTaXplO1xuICB9XG59XG4iLCJpbXBvcnQge21lcmdlfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCBkZWZhdWx0cywge292ZXJyaWRlc30gZnJvbSAnLi9jb3JlLmRlZmF1bHRzLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7e2lkOiBzdHJpbmcsIGRlZmF1bHRzOiBhbnksIG92ZXJyaWRlcz86IGFueSwgZGVmYXVsdFJvdXRlczogYW55fX0gSUNoYXJ0Q29tcG9uZW50XG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHlwZWRSZWdpc3RyeSB7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIHNjb3BlLCBvdmVycmlkZSkge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgIHRoaXMub3ZlcnJpZGUgPSBvdmVycmlkZTtcbiAgICB0aGlzLml0ZW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuXG4gIGlzRm9yVHlwZSh0eXBlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZi5jYWxsKHRoaXMudHlwZS5wcm90b3R5cGUsIHR5cGUucHJvdG90eXBlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0lDaGFydENvbXBvbmVudH0gaXRlbVxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgc2NvcGUgd2hlcmUgaXRlbXMgZGVmYXVsdHMgd2VyZSByZWdpc3RlcmVkIHRvLlxuXHQgKi9cbiAgcmVnaXN0ZXIoaXRlbSkge1xuICAgIGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGl0ZW0pO1xuICAgIGxldCBwYXJlbnRTY29wZTtcblxuICAgIGlmIChpc0lDaGFydENvbXBvbmVudChwcm90bykpIHtcbiAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgcGFyZW50IGlzIHJlZ2lzdGVyZWQgYW5kIG5vdGUgdGhlIHNjb3BlIHdoZXJlIGl0cyBkZWZhdWx0cyBhcmUuXG4gICAgICBwYXJlbnRTY29wZSA9IHRoaXMucmVnaXN0ZXIocHJvdG8pO1xuICAgIH1cblxuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5pdGVtcztcbiAgICBjb25zdCBpZCA9IGl0ZW0uaWQ7XG4gICAgY29uc3Qgc2NvcGUgPSB0aGlzLnNjb3BlICsgJy4nICsgaWQ7XG5cbiAgICBpZiAoIWlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsYXNzIGRvZXMgbm90IGhhdmUgaWQ6ICcgKyBpdGVtKTtcbiAgICB9XG5cbiAgICBpZiAoaWQgaW4gaXRlbXMpIHtcbiAgICAgIC8vIGFscmVhZHkgcmVnaXN0ZXJlZFxuICAgICAgcmV0dXJuIHNjb3BlO1xuICAgIH1cblxuICAgIGl0ZW1zW2lkXSA9IGl0ZW07XG4gICAgcmVnaXN0ZXJEZWZhdWx0cyhpdGVtLCBzY29wZSwgcGFyZW50U2NvcGUpO1xuICAgIGlmICh0aGlzLm92ZXJyaWRlKSB7XG4gICAgICBkZWZhdWx0cy5vdmVycmlkZShpdGVtLmlkLCBpdGVtLm92ZXJyaWRlcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjb3BlO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuXHQgKiBAcmV0dXJucyB7b2JqZWN0P31cblx0ICovXG4gIGdldChpZCkge1xuICAgIHJldHVybiB0aGlzLml0ZW1zW2lkXTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0lDaGFydENvbXBvbmVudH0gaXRlbVxuXHQgKi9cbiAgdW5yZWdpc3RlcihpdGVtKSB7XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLml0ZW1zO1xuICAgIGNvbnN0IGlkID0gaXRlbS5pZDtcbiAgICBjb25zdCBzY29wZSA9IHRoaXMuc2NvcGU7XG5cbiAgICBpZiAoaWQgaW4gaXRlbXMpIHtcbiAgICAgIGRlbGV0ZSBpdGVtc1tpZF07XG4gICAgfVxuXG4gICAgaWYgKHNjb3BlICYmIGlkIGluIGRlZmF1bHRzW3Njb3BlXSkge1xuICAgICAgZGVsZXRlIGRlZmF1bHRzW3Njb3BlXVtpZF07XG4gICAgICBpZiAodGhpcy5vdmVycmlkZSkge1xuICAgICAgICBkZWxldGUgb3ZlcnJpZGVzW2lkXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJEZWZhdWx0cyhpdGVtLCBzY29wZSwgcGFyZW50U2NvcGUpIHtcbiAgLy8gSW5oZXJpdCB0aGUgcGFyZW50J3MgZGVmYXVsdHMgYW5kIGtlZXAgZXhpc3RpbmcgZGVmYXVsdHNcbiAgY29uc3QgaXRlbURlZmF1bHRzID0gbWVyZ2UoT2JqZWN0LmNyZWF0ZShudWxsKSwgW1xuICAgIHBhcmVudFNjb3BlID8gZGVmYXVsdHMuZ2V0KHBhcmVudFNjb3BlKSA6IHt9LFxuICAgIGRlZmF1bHRzLmdldChzY29wZSksXG4gICAgaXRlbS5kZWZhdWx0c1xuICBdKTtcblxuICBkZWZhdWx0cy5zZXQoc2NvcGUsIGl0ZW1EZWZhdWx0cyk7XG5cbiAgaWYgKGl0ZW0uZGVmYXVsdFJvdXRlcykge1xuICAgIHJvdXRlRGVmYXVsdHMoc2NvcGUsIGl0ZW0uZGVmYXVsdFJvdXRlcyk7XG4gIH1cblxuICBpZiAoaXRlbS5kZXNjcmlwdG9ycykge1xuICAgIGRlZmF1bHRzLmRlc2NyaWJlKHNjb3BlLCBpdGVtLmRlc2NyaXB0b3JzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByb3V0ZURlZmF1bHRzKHNjb3BlLCByb3V0ZXMpIHtcbiAgT2JqZWN0LmtleXMocm91dGVzKS5mb3JFYWNoKHByb3BlcnR5ID0+IHtcbiAgICBjb25zdCBwcm9wZXJ0eVBhcnRzID0gcHJvcGVydHkuc3BsaXQoJy4nKTtcbiAgICBjb25zdCBzb3VyY2VOYW1lID0gcHJvcGVydHlQYXJ0cy5wb3AoKTtcbiAgICBjb25zdCBzb3VyY2VTY29wZSA9IFtzY29wZV0uY29uY2F0KHByb3BlcnR5UGFydHMpLmpvaW4oJy4nKTtcbiAgICBjb25zdCBwYXJ0cyA9IHJvdXRlc1twcm9wZXJ0eV0uc3BsaXQoJy4nKTtcbiAgICBjb25zdCB0YXJnZXROYW1lID0gcGFydHMucG9wKCk7XG4gICAgY29uc3QgdGFyZ2V0U2NvcGUgPSBwYXJ0cy5qb2luKCcuJyk7XG4gICAgZGVmYXVsdHMucm91dGUoc291cmNlU2NvcGUsIHNvdXJjZU5hbWUsIHRhcmdldFNjb3BlLCB0YXJnZXROYW1lKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGlzSUNoYXJ0Q29tcG9uZW50KHByb3RvKSB7XG4gIHJldHVybiAnaWQnIGluIHByb3RvICYmICdkZWZhdWx0cycgaW4gcHJvdG87XG59XG4iLCJpbXBvcnQgRGF0YXNldENvbnRyb2xsZXIgZnJvbSAnLi9jb3JlLmRhdGFzZXRDb250cm9sbGVyLmpzJztcbmltcG9ydCBFbGVtZW50IGZyb20gJy4vY29yZS5lbGVtZW50LmpzJztcbmltcG9ydCBTY2FsZSBmcm9tICcuL2NvcmUuc2NhbGUuanMnO1xuaW1wb3J0IFR5cGVkUmVnaXN0cnkgZnJvbSAnLi9jb3JlLnR5cGVkUmVnaXN0cnkuanMnO1xuaW1wb3J0IHtlYWNoLCBjYWxsYmFjayBhcyBjYWxsLCBfY2FwaXRhbGl6ZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuXG4vKipcbiAqIFBsZWFzZSB1c2UgdGhlIG1vZHVsZSdzIGRlZmF1bHQgZXhwb3J0IHdoaWNoIHByb3ZpZGVzIGEgc2luZ2xldG9uIGluc3RhbmNlXG4gKiBOb3RlOiBjbGFzcyBpcyBleHBvcnRlZCBmb3IgdHlwZWRvY1xuICovXG5leHBvcnQgY2xhc3MgUmVnaXN0cnkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNvbnRyb2xsZXJzID0gbmV3IFR5cGVkUmVnaXN0cnkoRGF0YXNldENvbnRyb2xsZXIsICdkYXRhc2V0cycsIHRydWUpO1xuICAgIHRoaXMuZWxlbWVudHMgPSBuZXcgVHlwZWRSZWdpc3RyeShFbGVtZW50LCAnZWxlbWVudHMnKTtcbiAgICB0aGlzLnBsdWdpbnMgPSBuZXcgVHlwZWRSZWdpc3RyeShPYmplY3QsICdwbHVnaW5zJyk7XG4gICAgdGhpcy5zY2FsZXMgPSBuZXcgVHlwZWRSZWdpc3RyeShTY2FsZSwgJ3NjYWxlcycpO1xuICAgIC8vIE9yZGVyIGlzIGltcG9ydGFudCwgU2NhbGUgaGFzIEVsZW1lbnQgaW4gcHJvdG90eXBlIGNoYWluLFxuICAgIC8vIHNvIFNjYWxlcyBtdXN0IGJlIGJlZm9yZSBFbGVtZW50cy4gUGx1Z2lucyBhcmUgYSBmYWxsYmFjaywgc28gbm90IGxpc3RlZCBoZXJlLlxuICAgIHRoaXMuX3R5cGVkUmVnaXN0cmllcyA9IFt0aGlzLmNvbnRyb2xsZXJzLCB0aGlzLnNjYWxlcywgdGhpcy5lbGVtZW50c107XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtICB7Li4uYW55fSBhcmdzXG5cdCAqL1xuICBhZGQoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3JlZ2lzdGVyJywgYXJncyk7XG4gIH1cblxuICByZW1vdmUoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0gIHsuLi50eXBlb2YgRGF0YXNldENvbnRyb2xsZXJ9IGFyZ3Ncblx0ICovXG4gIGFkZENvbnRyb2xsZXJzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MsIHRoaXMuY29udHJvbGxlcnMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLnR5cGVvZiBFbGVtZW50fSBhcmdzXG5cdCAqL1xuICBhZGRFbGVtZW50cyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzLCB0aGlzLmVsZW1lbnRzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3Ncblx0ICovXG4gIGFkZFBsdWdpbnMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3JlZ2lzdGVyJywgYXJncywgdGhpcy5wbHVnaW5zKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0gIHsuLi50eXBlb2YgU2NhbGV9IGFyZ3Ncblx0ICovXG4gIGFkZFNjYWxlcyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzLCB0aGlzLnNjYWxlcyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkXG5cdCAqIEByZXR1cm5zIHt0eXBlb2YgRGF0YXNldENvbnRyb2xsZXJ9XG5cdCAqL1xuICBnZXRDb250cm9sbGVyKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldChpZCwgdGhpcy5jb250cm9sbGVycywgJ2NvbnRyb2xsZXInKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWRcblx0ICogQHJldHVybnMge3R5cGVvZiBFbGVtZW50fVxuXHQgKi9cbiAgZ2V0RWxlbWVudChpZCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQoaWQsIHRoaXMuZWxlbWVudHMsICdlbGVtZW50Jyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9XG5cdCAqL1xuICBnZXRQbHVnaW4oaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KGlkLCB0aGlzLnBsdWdpbnMsICdwbHVnaW4nKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWRcblx0ICogQHJldHVybnMge3R5cGVvZiBTY2FsZX1cblx0ICovXG4gIGdldFNjYWxlKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldChpZCwgdGhpcy5zY2FsZXMsICdzY2FsZScpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLnR5cGVvZiBEYXRhc2V0Q29udHJvbGxlcn0gYXJnc1xuXHQgKi9cbiAgcmVtb3ZlQ29udHJvbGxlcnMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzLCB0aGlzLmNvbnRyb2xsZXJzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0gIHsuLi50eXBlb2YgRWxlbWVudH0gYXJnc1xuXHQgKi9cbiAgcmVtb3ZlRWxlbWVudHMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzLCB0aGlzLmVsZW1lbnRzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3Ncblx0ICovXG4gIHJlbW92ZVBsdWdpbnMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzLCB0aGlzLnBsdWdpbnMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLnR5cGVvZiBTY2FsZX0gYXJnc1xuXHQgKi9cbiAgcmVtb3ZlU2NhbGVzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCd1bnJlZ2lzdGVyJywgYXJncywgdGhpcy5zY2FsZXMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZWFjaChtZXRob2QsIGFyZ3MsIHR5cGVkUmVnaXN0cnkpIHtcbiAgICBbLi4uYXJnc10uZm9yRWFjaChhcmcgPT4ge1xuICAgICAgY29uc3QgcmVnID0gdHlwZWRSZWdpc3RyeSB8fCB0aGlzLl9nZXRSZWdpc3RyeUZvclR5cGUoYXJnKTtcbiAgICAgIGlmICh0eXBlZFJlZ2lzdHJ5IHx8IHJlZy5pc0ZvclR5cGUoYXJnKSB8fCAocmVnID09PSB0aGlzLnBsdWdpbnMgJiYgYXJnLmlkKSkge1xuICAgICAgICB0aGlzLl9leGVjKG1ldGhvZCwgcmVnLCBhcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSGFuZGxlIGxvb3BhYmxlIGFyZ3NcbiAgICAgICAgLy8gVXNlIGNhc2U6XG4gICAgICAgIC8vICBpbXBvcnQgKiBhcyBwbHVnaW5zIGZyb20gJy4vcGx1Z2lucy5qcyc7XG4gICAgICAgIC8vICBDaGFydC5yZWdpc3RlcihwbHVnaW5zKTtcbiAgICAgICAgZWFjaChhcmcsIGl0ZW0gPT4ge1xuICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBtaXhlZCB0eXBlcyBpbiB0aGUgbG9vcGFibGUsIG1ha2Ugc3VyZSB0aG9zZSBhcmVcbiAgICAgICAgICAvLyByZWdpc3RlcmVkIGluIGNvcnJlY3QgcmVnaXN0cnlcbiAgICAgICAgICAvLyBVc2UgY2FzZTogKHRyZWVtYXAgZXhwb3J0aW5nIGNvbnRyb2xsZXIsIGVsZW1lbnRzIGV0YylcbiAgICAgICAgICAvLyAgaW1wb3J0ICogYXMgdHJlZW1hcCBmcm9tICdjaGFydGpzLWNoYXJ0LXRyZWVtYXAuanMnO1xuICAgICAgICAgIC8vICBDaGFydC5yZWdpc3Rlcih0cmVlbWFwKTtcblxuICAgICAgICAgIGNvbnN0IGl0ZW1SZWcgPSB0eXBlZFJlZ2lzdHJ5IHx8IHRoaXMuX2dldFJlZ2lzdHJ5Rm9yVHlwZShpdGVtKTtcbiAgICAgICAgICB0aGlzLl9leGVjKG1ldGhvZCwgaXRlbVJlZywgaXRlbSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZXhlYyhtZXRob2QsIHJlZ2lzdHJ5LCBjb21wb25lbnQpIHtcbiAgICBjb25zdCBjYW1lbE1ldGhvZCA9IF9jYXBpdGFsaXplKG1ldGhvZCk7XG4gICAgY2FsbChjb21wb25lbnRbJ2JlZm9yZScgKyBjYW1lbE1ldGhvZF0sIFtdLCBjb21wb25lbnQpOyAvLyBiZWZvcmVSZWdpc3RlciAvIGJlZm9yZVVucmVnaXN0ZXJcbiAgICByZWdpc3RyeVttZXRob2RdKGNvbXBvbmVudCk7XG4gICAgY2FsbChjb21wb25lbnRbJ2FmdGVyJyArIGNhbWVsTWV0aG9kXSwgW10sIGNvbXBvbmVudCk7IC8vIGFmdGVyUmVnaXN0ZXIgLyBhZnRlclVucmVnaXN0ZXJcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldFJlZ2lzdHJ5Rm9yVHlwZSh0eXBlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl90eXBlZFJlZ2lzdHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHJlZyA9IHRoaXMuX3R5cGVkUmVnaXN0cmllc1tpXTtcbiAgICAgIGlmIChyZWcuaXNGb3JUeXBlKHR5cGUpKSB7XG4gICAgICAgIHJldHVybiByZWc7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHBsdWdpbnMgaXMgdGhlIGZhbGxiYWNrIHJlZ2lzdHJ5XG4gICAgcmV0dXJuIHRoaXMucGx1Z2lucztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldChpZCwgdHlwZWRSZWdpc3RyeSwgdHlwZSkge1xuICAgIGNvbnN0IGl0ZW0gPSB0eXBlZFJlZ2lzdHJ5LmdldChpZCk7XG4gICAgaWYgKGl0ZW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBpZCArICdcIiBpcyBub3QgYSByZWdpc3RlcmVkICcgKyB0eXBlICsgJy4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cblxufVxuXG4vLyBzaW5nbGV0b24gaW5zdGFuY2VcbmV4cG9ydCBkZWZhdWx0IC8qICNfX1BVUkVfXyAqLyBuZXcgUmVnaXN0cnkoKTtcbiIsImltcG9ydCByZWdpc3RyeSBmcm9tICcuL2NvcmUucmVnaXN0cnkuanMnO1xuaW1wb3J0IHtjYWxsYmFjayBhcyBjYWxsQ2FsbGJhY2ssIGlzTnVsbE9yVW5kZWYsIHZhbHVlT3JEZWZhdWx0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4vY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5DaGFydEV2ZW50IH0gQ2hhcnRFdmVudFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3BsdWdpbnMvcGx1Z2luLnRvb2x0aXAuanMnKS5kZWZhdWx0IH0gVG9vbHRpcFxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIGZpbHRlckNhbGxiYWNrXG4gKiBAcGFyYW0ge3twbHVnaW46IG9iamVjdCwgb3B0aW9uczogb2JqZWN0fX0gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbaW5kZXhdXG4gKiBAcGFyYW0ge2FycmF5fSBbYXJyYXldXG4gKiBAcGFyYW0ge29iamVjdH0gW3RoaXNBcmddXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGx1Z2luU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2luaXQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcblx0ICogQ2FsbHMgZW5hYmxlZCBwbHVnaW5zIGZvciBgY2hhcnRgIG9uIHRoZSBzcGVjaWZpZWQgaG9vayBhbmQgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cblx0ICogVGhpcyBtZXRob2QgaW1tZWRpYXRlbHkgcmV0dXJucyBhcyBzb29uIGFzIGEgcGx1Z2luIGV4cGxpY2l0bHkgcmV0dXJucyBmYWxzZS4gVGhlXG5cdCAqIHJldHVybmVkIHZhbHVlIGNhbiBiZSB1c2VkLCBmb3IgaW5zdGFuY2UsIHRvIGludGVycnVwdCB0aGUgY3VycmVudCBhY3Rpb24uXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gVGhlIGNoYXJ0IGluc3RhbmNlIGZvciB3aGljaCBwbHVnaW5zIHNob3VsZCBiZSBjYWxsZWQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBob29rIC0gVGhlIG5hbWUgb2YgdGhlIHBsdWdpbiBtZXRob2QgdG8gY2FsbCAoZS5nLiAnYmVmb3JlVXBkYXRlJykuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbYXJnc10gLSBFeHRyYSBhcmd1bWVudHMgdG8gYXBwbHkgdG8gdGhlIGhvb2sgY2FsbC5cbiAgICogQHBhcmFtIHtmaWx0ZXJDYWxsYmFja30gW2ZpbHRlcl0gLSBGaWx0ZXJpbmcgZnVuY3Rpb24gZm9yIGxpbWl0aW5nIHdoaWNoIHBsdWdpbnMgYXJlIG5vdGlmaWVkXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBmYWxzZSBpZiBhbnkgb2YgdGhlIHBsdWdpbnMgcmV0dXJuIGZhbHNlLCBlbHNlIHJldHVybnMgdHJ1ZS5cblx0ICovXG4gIG5vdGlmeShjaGFydCwgaG9vaywgYXJncywgZmlsdGVyKSB7XG4gICAgaWYgKGhvb2sgPT09ICdiZWZvcmVJbml0Jykge1xuICAgICAgdGhpcy5faW5pdCA9IHRoaXMuX2NyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0LCB0cnVlKTtcbiAgICAgIHRoaXMuX25vdGlmeSh0aGlzLl9pbml0LCBjaGFydCwgJ2luc3RhbGwnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faW5pdCA9PT0gdW5kZWZpbmVkKSB7IC8vIERvIG5vdCB0cmlnZ2VyIGV2ZW50cyBiZWZvcmUgaW5zdGFsbFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGRlc2NyaXB0b3JzID0gZmlsdGVyID8gdGhpcy5fZGVzY3JpcHRvcnMoY2hhcnQpLmZpbHRlcihmaWx0ZXIpIDogdGhpcy5fZGVzY3JpcHRvcnMoY2hhcnQpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX25vdGlmeShkZXNjcmlwdG9ycywgY2hhcnQsIGhvb2ssIGFyZ3MpO1xuXG4gICAgaWYgKGhvb2sgPT09ICdhZnRlckRlc3Ryb3knKSB7XG4gICAgICB0aGlzLl9ub3RpZnkoZGVzY3JpcHRvcnMsIGNoYXJ0LCAnc3RvcCcpO1xuICAgICAgdGhpcy5fbm90aWZ5KHRoaXMuX2luaXQsIGNoYXJ0LCAndW5pbnN0YWxsJyk7XG4gICAgICB0aGlzLl9pbml0ID0gdW5kZWZpbmVkOyAvLyBEbyBub3QgdHJpZ2dlciBldmVudHMgYWZ0ZXIgdW5pbnN0YWxsXG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9ub3RpZnkoZGVzY3JpcHRvcnMsIGNoYXJ0LCBob29rLCBhcmdzKSB7XG4gICAgYXJncyA9IGFyZ3MgfHwge307XG4gICAgZm9yIChjb25zdCBkZXNjcmlwdG9yIG9mIGRlc2NyaXB0b3JzKSB7XG4gICAgICBjb25zdCBwbHVnaW4gPSBkZXNjcmlwdG9yLnBsdWdpbjtcbiAgICAgIGNvbnN0IG1ldGhvZCA9IHBsdWdpbltob29rXTtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IFtjaGFydCwgYXJncywgZGVzY3JpcHRvci5vcHRpb25zXTtcbiAgICAgIGlmIChjYWxsQ2FsbGJhY2sobWV0aG9kLCBwYXJhbXMsIHBsdWdpbikgPT09IGZhbHNlICYmIGFyZ3MuY2FuY2VsYWJsZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpbnZhbGlkYXRlKCkge1xuICAgIC8vIFdoZW4gcGx1Z2lucyBhcmUgcmVnaXN0ZXJlZCwgdGhlcmUgaXMgdGhlIHBvc3NpYmlsaXR5IG9mIGEgZG91YmxlXG4gICAgLy8gaW52YWxpZGF0ZSBzaXR1YXRpb24uIEluIHRoaXMgY2FzZSwgd2Ugb25seSB3YW50IHRvIGludmFsaWRhdGUgb25jZS5cbiAgICAvLyBJZiB3ZSBpbnZhbGlkYXRlIG11bHRpcGxlIHRpbWVzLCB0aGUgYF9vbGRDYWNoZWAgaXMgbG9zdCBhbmQgYWxsIG9mIHRoZVxuICAgIC8vIHBsdWdpbnMgYXJlIHJlc3RhcnRlZCB3aXRob3V0IGJlaW5nIGNvcnJlY3RseSBzdG9wcGVkLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvODE0N1xuICAgIGlmICghaXNOdWxsT3JVbmRlZih0aGlzLl9jYWNoZSkpIHtcbiAgICAgIHRoaXMuX29sZENhY2hlID0gdGhpcy5fY2FjaGU7XG4gICAgICB0aGlzLl9jYWNoZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9kZXNjcmlwdG9ycyhjaGFydCkge1xuICAgIGlmICh0aGlzLl9jYWNoZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlO1xuICAgIH1cblxuICAgIGNvbnN0IGRlc2NyaXB0b3JzID0gdGhpcy5fY2FjaGUgPSB0aGlzLl9jcmVhdGVEZXNjcmlwdG9ycyhjaGFydCk7XG5cbiAgICB0aGlzLl9ub3RpZnlTdGF0ZUNoYW5nZXMoY2hhcnQpO1xuXG4gICAgcmV0dXJuIGRlc2NyaXB0b3JzO1xuICB9XG5cbiAgX2NyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0LCBhbGwpIHtcbiAgICBjb25zdCBjb25maWcgPSBjaGFydCAmJiBjaGFydC5jb25maWc7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHZhbHVlT3JEZWZhdWx0KGNvbmZpZy5vcHRpb25zICYmIGNvbmZpZy5vcHRpb25zLnBsdWdpbnMsIHt9KTtcbiAgICBjb25zdCBwbHVnaW5zID0gYWxsUGx1Z2lucyhjb25maWcpO1xuICAgIC8vIG9wdGlvbnMgPT09IGZhbHNlID0+IGFsbCBwbHVnaW5zIGFyZSBkaXNhYmxlZFxuICAgIHJldHVybiBvcHRpb25zID09PSBmYWxzZSAmJiAhYWxsID8gW10gOiBjcmVhdGVEZXNjcmlwdG9ycyhjaGFydCwgcGx1Z2lucywgb3B0aW9ucywgYWxsKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX25vdGlmeVN0YXRlQ2hhbmdlcyhjaGFydCkge1xuICAgIGNvbnN0IHByZXZpb3VzRGVzY3JpcHRvcnMgPSB0aGlzLl9vbGRDYWNoZSB8fCBbXTtcbiAgICBjb25zdCBkZXNjcmlwdG9ycyA9IHRoaXMuX2NhY2hlO1xuICAgIGNvbnN0IGRpZmYgPSAoYSwgYikgPT4gYS5maWx0ZXIoeCA9PiAhYi5zb21lKHkgPT4geC5wbHVnaW4uaWQgPT09IHkucGx1Z2luLmlkKSk7XG4gICAgdGhpcy5fbm90aWZ5KGRpZmYocHJldmlvdXNEZXNjcmlwdG9ycywgZGVzY3JpcHRvcnMpLCBjaGFydCwgJ3N0b3AnKTtcbiAgICB0aGlzLl9ub3RpZnkoZGlmZihkZXNjcmlwdG9ycywgcHJldmlvdXNEZXNjcmlwdG9ycyksIGNoYXJ0LCAnc3RhcnQnKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2NvcmUuY29uZmlnLmpzJykuZGVmYXVsdH0gY29uZmlnXG4gKi9cbmZ1bmN0aW9uIGFsbFBsdWdpbnMoY29uZmlnKSB7XG4gIGNvbnN0IGxvY2FsSWRzID0ge307XG4gIGNvbnN0IHBsdWdpbnMgPSBbXTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHJlZ2lzdHJ5LnBsdWdpbnMuaXRlbXMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBwbHVnaW5zLnB1c2gocmVnaXN0cnkuZ2V0UGx1Z2luKGtleXNbaV0pKTtcbiAgfVxuXG4gIGNvbnN0IGxvY2FsID0gY29uZmlnLnBsdWdpbnMgfHwgW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYWwubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwbHVnaW4gPSBsb2NhbFtpXTtcblxuICAgIGlmIChwbHVnaW5zLmluZGV4T2YocGx1Z2luKSA9PT0gLTEpIHtcbiAgICAgIHBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgICAgbG9jYWxJZHNbcGx1Z2luLmlkXSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtwbHVnaW5zLCBsb2NhbElkc307XG59XG5cbmZ1bmN0aW9uIGdldE9wdHMob3B0aW9ucywgYWxsKSB7XG4gIGlmICghYWxsICYmIG9wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKG9wdGlvbnMgPT09IHRydWUpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0LCB7cGx1Z2lucywgbG9jYWxJZHN9LCBvcHRpb25zLCBhbGwpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IGNvbnRleHQgPSBjaGFydC5nZXRDb250ZXh0KCk7XG5cbiAgZm9yIChjb25zdCBwbHVnaW4gb2YgcGx1Z2lucykge1xuICAgIGNvbnN0IGlkID0gcGx1Z2luLmlkO1xuICAgIGNvbnN0IG9wdHMgPSBnZXRPcHRzKG9wdGlvbnNbaWRdLCBhbGwpO1xuICAgIGlmIChvcHRzID09PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2goe1xuICAgICAgcGx1Z2luLFxuICAgICAgb3B0aW9uczogcGx1Z2luT3B0cyhjaGFydC5jb25maWcsIHtwbHVnaW4sIGxvY2FsOiBsb2NhbElkc1tpZF19LCBvcHRzLCBjb250ZXh0KVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcGx1Z2luT3B0cyhjb25maWcsIHtwbHVnaW4sIGxvY2FsfSwgb3B0cywgY29udGV4dCkge1xuICBjb25zdCBrZXlzID0gY29uZmlnLnBsdWdpblNjb3BlS2V5cyhwbHVnaW4pO1xuICBjb25zdCBzY29wZXMgPSBjb25maWcuZ2V0T3B0aW9uU2NvcGVzKG9wdHMsIGtleXMpO1xuICBpZiAobG9jYWwgJiYgcGx1Z2luLmRlZmF1bHRzKSB7XG4gICAgLy8gbWFrZSBzdXJlIHBsdWdpbiBkZWZhdWx0cyBhcmUgaW4gc2NvcGVzIGZvciBsb2NhbCAobm90IHJlZ2lzdGVyZWQpIHBsdWdpbnNcbiAgICBzY29wZXMucHVzaChwbHVnaW4uZGVmYXVsdHMpO1xuICB9XG4gIHJldHVybiBjb25maWcuY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCBjb250ZXh0LCBbJyddLCB7XG4gICAgLy8gVGhlc2UgYXJlIGp1c3QgZGVmYXVsdHMgdGhhdCBwbHVnaW5zIGNhbiBvdmVycmlkZVxuICAgIHNjcmlwdGFibGU6IGZhbHNlLFxuICAgIGluZGV4YWJsZTogZmFsc2UsXG4gICAgYWxsS2V5czogdHJ1ZVxuICB9KTtcbn1cbiIsImltcG9ydCBkZWZhdWx0cywge292ZXJyaWRlcywgZGVzY3JpcHRvcnN9IGZyb20gJy4vY29yZS5kZWZhdWx0cy5qcyc7XG5pbXBvcnQge21lcmdlSWYsIHJlc29sdmVPYmplY3RLZXksIGlzQXJyYXksIGlzRnVuY3Rpb24sIHZhbHVlT3JEZWZhdWx0LCBpc09iamVjdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHtfYXR0YWNoQ29udGV4dCwgX2NyZWF0ZVJlc29sdmVyLCBfZGVzY3JpcHRvcnN9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb25maWcuanMnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW5kZXhBeGlzKHR5cGUsIG9wdGlvbnMpIHtcbiAgY29uc3QgZGF0YXNldERlZmF1bHRzID0gZGVmYXVsdHMuZGF0YXNldHNbdHlwZV0gfHwge307XG4gIGNvbnN0IGRhdGFzZXRPcHRpb25zID0gKG9wdGlvbnMuZGF0YXNldHMgfHwge30pW3R5cGVdIHx8IHt9O1xuICByZXR1cm4gZGF0YXNldE9wdGlvbnMuaW5kZXhBeGlzIHx8IG9wdGlvbnMuaW5kZXhBeGlzIHx8IGRhdGFzZXREZWZhdWx0cy5pbmRleEF4aXMgfHwgJ3gnO1xufVxuXG5mdW5jdGlvbiBnZXRBeGlzRnJvbURlZmF1bHRTY2FsZUlEKGlkLCBpbmRleEF4aXMpIHtcbiAgbGV0IGF4aXMgPSBpZDtcbiAgaWYgKGlkID09PSAnX2luZGV4XycpIHtcbiAgICBheGlzID0gaW5kZXhBeGlzO1xuICB9IGVsc2UgaWYgKGlkID09PSAnX3ZhbHVlXycpIHtcbiAgICBheGlzID0gaW5kZXhBeGlzID09PSAneCcgPyAneScgOiAneCc7XG4gIH1cbiAgcmV0dXJuIGF4aXM7XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRTY2FsZUlERnJvbUF4aXMoYXhpcywgaW5kZXhBeGlzKSB7XG4gIHJldHVybiBheGlzID09PSBpbmRleEF4aXMgPyAnX2luZGV4XycgOiAnX3ZhbHVlXyc7XG59XG5cbmZ1bmN0aW9uIGlkTWF0Y2hlc0F4aXMoaWQpIHtcbiAgaWYgKGlkID09PSAneCcgfHwgaWQgPT09ICd5JyB8fCBpZCA9PT0gJ3InKSB7XG4gICAgcmV0dXJuIGlkO1xuICB9XG59XG5cbmZ1bmN0aW9uIGF4aXNGcm9tUG9zaXRpb24ocG9zaXRpb24pIHtcbiAgaWYgKHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICByZXR1cm4gJ3gnO1xuICB9XG4gIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnIHx8IHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgcmV0dXJuICd5JztcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGV0ZXJtaW5lQXhpcyhpZCwgLi4uc2NhbGVPcHRpb25zKSB7XG4gIGlmIChpZE1hdGNoZXNBeGlzKGlkKSkge1xuICAgIHJldHVybiBpZDtcbiAgfVxuICBmb3IgKGNvbnN0IG9wdHMgb2Ygc2NhbGVPcHRpb25zKSB7XG4gICAgY29uc3QgYXhpcyA9IG9wdHMuYXhpc1xuICAgICAgfHwgYXhpc0Zyb21Qb3NpdGlvbihvcHRzLnBvc2l0aW9uKVxuICAgICAgfHwgaWQubGVuZ3RoID4gMSAmJiBpZE1hdGNoZXNBeGlzKGlkWzBdLnRvTG93ZXJDYXNlKCkpO1xuICAgIGlmIChheGlzKSB7XG4gICAgICByZXR1cm4gYXhpcztcbiAgICB9XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZGV0ZXJtaW5lIHR5cGUgb2YgJyR7aWR9JyBheGlzLiBQbGVhc2UgcHJvdmlkZSAnYXhpcycgb3IgJ3Bvc2l0aW9uJyBvcHRpb24uYCk7XG59XG5cbmZ1bmN0aW9uIGdldEF4aXNGcm9tRGF0YXNldChpZCwgYXhpcywgZGF0YXNldCkge1xuICBpZiAoZGF0YXNldFtheGlzICsgJ0F4aXNJRCddID09PSBpZCkge1xuICAgIHJldHVybiB7YXhpc307XG4gIH1cbn1cblxuZnVuY3Rpb24gcmV0cmlldmVBeGlzRnJvbURhdGFzZXRzKGlkLCBjb25maWcpIHtcbiAgaWYgKGNvbmZpZy5kYXRhICYmIGNvbmZpZy5kYXRhLmRhdGFzZXRzKSB7XG4gICAgY29uc3QgYm91bmREcyA9IGNvbmZpZy5kYXRhLmRhdGFzZXRzLmZpbHRlcigoZCkgPT4gZC54QXhpc0lEID09PSBpZCB8fCBkLnlBeGlzSUQgPT09IGlkKTtcbiAgICBpZiAoYm91bmREcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBnZXRBeGlzRnJvbURhdGFzZXQoaWQsICd4JywgYm91bmREc1swXSkgfHwgZ2V0QXhpc0Zyb21EYXRhc2V0KGlkLCAneScsIGJvdW5kRHNbMF0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge307XG59XG5cbmZ1bmN0aW9uIG1lcmdlU2NhbGVDb25maWcoY29uZmlnLCBvcHRpb25zKSB7XG4gIGNvbnN0IGNoYXJ0RGVmYXVsdHMgPSBvdmVycmlkZXNbY29uZmlnLnR5cGVdIHx8IHtzY2FsZXM6IHt9fTtcbiAgY29uc3QgY29uZmlnU2NhbGVzID0gb3B0aW9ucy5zY2FsZXMgfHwge307XG4gIGNvbnN0IGNoYXJ0SW5kZXhBeGlzID0gZ2V0SW5kZXhBeGlzKGNvbmZpZy50eXBlLCBvcHRpb25zKTtcbiAgY29uc3Qgc2NhbGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAvLyBGaXJzdCBmaWd1cmUgb3V0IGZpcnN0IHNjYWxlIGlkJ3MgcGVyIGF4aXMuXG4gIE9iamVjdC5rZXlzKGNvbmZpZ1NjYWxlcykuZm9yRWFjaChpZCA9PiB7XG4gICAgY29uc3Qgc2NhbGVDb25mID0gY29uZmlnU2NhbGVzW2lkXTtcbiAgICBpZiAoIWlzT2JqZWN0KHNjYWxlQ29uZikpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKGBJbnZhbGlkIHNjYWxlIGNvbmZpZ3VyYXRpb24gZm9yIHNjYWxlOiAke2lkfWApO1xuICAgIH1cbiAgICBpZiAoc2NhbGVDb25mLl9wcm94eSkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUud2FybihgSWdub3JpbmcgcmVzb2x2ZXIgcGFzc2VkIGFzIG9wdGlvbnMgZm9yIHNjYWxlOiAke2lkfWApO1xuICAgIH1cbiAgICBjb25zdCBheGlzID0gZGV0ZXJtaW5lQXhpcyhpZCwgc2NhbGVDb25mLCByZXRyaWV2ZUF4aXNGcm9tRGF0YXNldHMoaWQsIGNvbmZpZyksIGRlZmF1bHRzLnNjYWxlc1tzY2FsZUNvbmYudHlwZV0pO1xuICAgIGNvbnN0IGRlZmF1bHRJZCA9IGdldERlZmF1bHRTY2FsZUlERnJvbUF4aXMoYXhpcywgY2hhcnRJbmRleEF4aXMpO1xuICAgIGNvbnN0IGRlZmF1bHRTY2FsZU9wdGlvbnMgPSBjaGFydERlZmF1bHRzLnNjYWxlcyB8fCB7fTtcbiAgICBzY2FsZXNbaWRdID0gbWVyZ2VJZihPYmplY3QuY3JlYXRlKG51bGwpLCBbe2F4aXN9LCBzY2FsZUNvbmYsIGRlZmF1bHRTY2FsZU9wdGlvbnNbYXhpc10sIGRlZmF1bHRTY2FsZU9wdGlvbnNbZGVmYXVsdElkXV0pO1xuICB9KTtcblxuICAvLyBUaGVuIG1lcmdlIGRhdGFzZXQgZGVmYXVsdHMgdG8gc2NhbGUgY29uZmlnc1xuICBjb25maWcuZGF0YS5kYXRhc2V0cy5mb3JFYWNoKGRhdGFzZXQgPT4ge1xuICAgIGNvbnN0IHR5cGUgPSBkYXRhc2V0LnR5cGUgfHwgY29uZmlnLnR5cGU7XG4gICAgY29uc3QgaW5kZXhBeGlzID0gZGF0YXNldC5pbmRleEF4aXMgfHwgZ2V0SW5kZXhBeGlzKHR5cGUsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGRhdGFzZXREZWZhdWx0cyA9IG92ZXJyaWRlc1t0eXBlXSB8fCB7fTtcbiAgICBjb25zdCBkZWZhdWx0U2NhbGVPcHRpb25zID0gZGF0YXNldERlZmF1bHRzLnNjYWxlcyB8fCB7fTtcbiAgICBPYmplY3Qua2V5cyhkZWZhdWx0U2NhbGVPcHRpb25zKS5mb3JFYWNoKGRlZmF1bHRJRCA9PiB7XG4gICAgICBjb25zdCBheGlzID0gZ2V0QXhpc0Zyb21EZWZhdWx0U2NhbGVJRChkZWZhdWx0SUQsIGluZGV4QXhpcyk7XG4gICAgICBjb25zdCBpZCA9IGRhdGFzZXRbYXhpcyArICdBeGlzSUQnXSB8fCBheGlzO1xuICAgICAgc2NhbGVzW2lkXSA9IHNjYWxlc1tpZF0gfHwgT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIG1lcmdlSWYoc2NhbGVzW2lkXSwgW3theGlzfSwgY29uZmlnU2NhbGVzW2lkXSwgZGVmYXVsdFNjYWxlT3B0aW9uc1tkZWZhdWx0SURdXSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIGFwcGx5IHNjYWxlIGRlZmF1bHRzLCBpZiBub3Qgb3ZlcnJpZGRlbiBieSBkYXRhc2V0IGRlZmF1bHRzXG4gIE9iamVjdC5rZXlzKHNjYWxlcykuZm9yRWFjaChrZXkgPT4ge1xuICAgIGNvbnN0IHNjYWxlID0gc2NhbGVzW2tleV07XG4gICAgbWVyZ2VJZihzY2FsZSwgW2RlZmF1bHRzLnNjYWxlc1tzY2FsZS50eXBlXSwgZGVmYXVsdHMuc2NhbGVdKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHNjYWxlcztcbn1cblxuZnVuY3Rpb24gaW5pdE9wdGlvbnMoY29uZmlnKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBjb25maWcub3B0aW9ucyB8fCAoY29uZmlnLm9wdGlvbnMgPSB7fSk7XG5cbiAgb3B0aW9ucy5wbHVnaW5zID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5wbHVnaW5zLCB7fSk7XG4gIG9wdGlvbnMuc2NhbGVzID0gbWVyZ2VTY2FsZUNvbmZpZyhjb25maWcsIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBpbml0RGF0YShkYXRhKSB7XG4gIGRhdGEgPSBkYXRhIHx8IHt9O1xuICBkYXRhLmRhdGFzZXRzID0gZGF0YS5kYXRhc2V0cyB8fCBbXTtcbiAgZGF0YS5sYWJlbHMgPSBkYXRhLmxhYmVscyB8fCBbXTtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIGluaXRDb25maWcoY29uZmlnKSB7XG4gIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgY29uZmlnLmRhdGEgPSBpbml0RGF0YShjb25maWcuZGF0YSk7XG5cbiAgaW5pdE9wdGlvbnMoY29uZmlnKTtcblxuICByZXR1cm4gY29uZmlnO1xufVxuXG5jb25zdCBrZXlDYWNoZSA9IG5ldyBNYXAoKTtcbmNvbnN0IGtleXNDYWNoZWQgPSBuZXcgU2V0KCk7XG5cbmZ1bmN0aW9uIGNhY2hlZEtleXMoY2FjaGVLZXksIGdlbmVyYXRlKSB7XG4gIGxldCBrZXlzID0ga2V5Q2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgaWYgKCFrZXlzKSB7XG4gICAga2V5cyA9IGdlbmVyYXRlKCk7XG4gICAga2V5Q2FjaGUuc2V0KGNhY2hlS2V5LCBrZXlzKTtcbiAgICBrZXlzQ2FjaGVkLmFkZChrZXlzKTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cblxuY29uc3QgYWRkSWZGb3VuZCA9IChzZXQsIG9iaiwga2V5KSA9PiB7XG4gIGNvbnN0IG9wdHMgPSByZXNvbHZlT2JqZWN0S2V5KG9iaiwga2V5KTtcbiAgaWYgKG9wdHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHNldC5hZGQob3B0cyk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbmZpZyB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHRoaXMuX2NvbmZpZyA9IGluaXRDb25maWcoY29uZmlnKTtcbiAgICB0aGlzLl9zY29wZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX3Jlc29sdmVyQ2FjaGUgPSBuZXcgTWFwKCk7XG4gIH1cblxuICBnZXQgcGxhdGZvcm0oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5wbGF0Zm9ybTtcbiAgfVxuXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcudHlwZTtcbiAgfVxuXG4gIHNldCB0eXBlKHR5cGUpIHtcbiAgICB0aGlzLl9jb25maWcudHlwZSA9IHR5cGU7XG4gIH1cblxuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLmRhdGE7XG4gIH1cblxuICBzZXQgZGF0YShkYXRhKSB7XG4gICAgdGhpcy5fY29uZmlnLmRhdGEgPSBpbml0RGF0YShkYXRhKTtcbiAgfVxuXG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcub3B0aW9ucztcbiAgfVxuXG4gIHNldCBvcHRpb25zKG9wdGlvbnMpIHtcbiAgICB0aGlzLl9jb25maWcub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cblxuICBnZXQgcGx1Z2lucygpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLnBsdWdpbnM7XG4gIH1cblxuICB1cGRhdGUoKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5fY29uZmlnO1xuICAgIHRoaXMuY2xlYXJDYWNoZSgpO1xuICAgIGluaXRPcHRpb25zKGNvbmZpZyk7XG4gIH1cblxuICBjbGVhckNhY2hlKCkge1xuICAgIHRoaXMuX3Njb3BlQ2FjaGUuY2xlYXIoKTtcbiAgICB0aGlzLl9yZXNvbHZlckNhY2hlLmNsZWFyKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3B0aW9uIHNjb3BlIGtleXMgZm9yIHJlc29sdmluZyBkYXRhc2V0IG9wdGlvbnMuXG4gICAqIFRoZXNlIGtleXMgZG8gbm90IGluY2x1ZGUgdGhlIGRhdGFzZXQgaXRzZWxmLCBiZWNhdXNlIGl0IGlzIG5vdCB1bmRlciBvcHRpb25zLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YXNldFR5cGVcbiAgICogQHJldHVybiB7c3RyaW5nW11bXX1cbiAgICovXG4gIGRhdGFzZXRTY29wZUtleXMoZGF0YXNldFR5cGUpIHtcbiAgICByZXR1cm4gY2FjaGVkS2V5cyhkYXRhc2V0VHlwZSxcbiAgICAgICgpID0+IFtbXG4gICAgICAgIGBkYXRhc2V0cy4ke2RhdGFzZXRUeXBlfWAsXG4gICAgICAgICcnXG4gICAgICBdXSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3B0aW9uIHNjb3BlIGtleXMgZm9yIHJlc29sdmluZyBkYXRhc2V0IGFuaW1hdGlvbiBvcHRpb25zLlxuICAgKiBUaGVzZSBrZXlzIGRvIG5vdCBpbmNsdWRlIHRoZSBkYXRhc2V0IGl0c2VsZiwgYmVjYXVzZSBpdCBpcyBub3QgdW5kZXIgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFzZXRUeXBlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0cmFuc2l0aW9uXG4gICAqIEByZXR1cm4ge3N0cmluZ1tdW119XG4gICAqL1xuICBkYXRhc2V0QW5pbWF0aW9uU2NvcGVLZXlzKGRhdGFzZXRUeXBlLCB0cmFuc2l0aW9uKSB7XG4gICAgcmV0dXJuIGNhY2hlZEtleXMoYCR7ZGF0YXNldFR5cGV9LnRyYW5zaXRpb24uJHt0cmFuc2l0aW9ufWAsXG4gICAgICAoKSA9PiBbXG4gICAgICAgIFtcbiAgICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX0udHJhbnNpdGlvbnMuJHt0cmFuc2l0aW9ufWAsXG4gICAgICAgICAgYHRyYW5zaXRpb25zLiR7dHJhbnNpdGlvbn1gLFxuICAgICAgICBdLFxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGFyZSB1c2VkIGZvciBsb29raW5nIHVwIHRoZSBgYW5pbWF0aW9uc2AgYW5kIGBhbmltYXRpb25gIGtleXNcbiAgICAgICAgW1xuICAgICAgICAgIGBkYXRhc2V0cy4ke2RhdGFzZXRUeXBlfWAsXG4gICAgICAgICAgJydcbiAgICAgICAgXVxuICAgICAgXSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3B0aW9ucyBzY29wZSBrZXlzIGZvciByZXNvbHZpbmcgZWxlbWVudCBvcHRpb25zIHRoYXQgYmVsb25nXG4gICAqIHRvIGFuIGRhdGFzZXQuIFRoZXNlIGtleXMgZG8gbm90IGluY2x1ZGUgdGhlIGRhdGFzZXQgaXRzZWxmLCBiZWNhdXNlIGl0XG4gICAqIGlzIG5vdCB1bmRlciBvcHRpb25zLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YXNldFR5cGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGVsZW1lbnRUeXBlXG4gICAqIEByZXR1cm4ge3N0cmluZ1tdW119XG4gICAqL1xuICBkYXRhc2V0RWxlbWVudFNjb3BlS2V5cyhkYXRhc2V0VHlwZSwgZWxlbWVudFR5cGUpIHtcbiAgICByZXR1cm4gY2FjaGVkS2V5cyhgJHtkYXRhc2V0VHlwZX0tJHtlbGVtZW50VHlwZX1gLFxuICAgICAgKCkgPT4gW1tcbiAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9LmVsZW1lbnRzLiR7ZWxlbWVudFR5cGV9YCxcbiAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9YCxcbiAgICAgICAgYGVsZW1lbnRzLiR7ZWxlbWVudFR5cGV9YCxcbiAgICAgICAgJydcbiAgICAgIF1dKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcHRpb25zIHNjb3BlIGtleXMgZm9yIHJlc29sdmluZyBwbHVnaW4gb3B0aW9ucy5cbiAgICogQHBhcmFtIHt7aWQ6IHN0cmluZywgYWRkaXRpb25hbE9wdGlvblNjb3Blcz86IHN0cmluZ1tdfX0gcGx1Z2luXG4gICAqIEByZXR1cm4ge3N0cmluZ1tdW119XG4gICAqL1xuICBwbHVnaW5TY29wZUtleXMocGx1Z2luKSB7XG4gICAgY29uc3QgaWQgPSBwbHVnaW4uaWQ7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMudHlwZTtcbiAgICByZXR1cm4gY2FjaGVkS2V5cyhgJHt0eXBlfS1wbHVnaW4tJHtpZH1gLFxuICAgICAgKCkgPT4gW1tcbiAgICAgICAgYHBsdWdpbnMuJHtpZH1gLFxuICAgICAgICAuLi5wbHVnaW4uYWRkaXRpb25hbE9wdGlvblNjb3BlcyB8fCBbXSxcbiAgICAgIF1dKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NhY2hlZFNjb3BlcyhtYWluU2NvcGUsIHJlc2V0Q2FjaGUpIHtcbiAgICBjb25zdCBfc2NvcGVDYWNoZSA9IHRoaXMuX3Njb3BlQ2FjaGU7XG4gICAgbGV0IGNhY2hlID0gX3Njb3BlQ2FjaGUuZ2V0KG1haW5TY29wZSk7XG4gICAgaWYgKCFjYWNoZSB8fCByZXNldENhY2hlKSB7XG4gICAgICBjYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgIF9zY29wZUNhY2hlLnNldChtYWluU2NvcGUsIGNhY2hlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc29sdmVzIHRoZSBvYmplY3RzIGZyb20gb3B0aW9ucyBhbmQgZGVmYXVsdHMgZm9yIG9wdGlvbiB2YWx1ZSByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbWFpblNjb3BlIC0gVGhlIG1haW4gc2NvcGUgb2JqZWN0IGZvciBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nW11bXX0ga2V5TGlzdHMgLSBUaGUgYXJyYXlzIG9mIGtleXMgaW4gcmVzb2x1dGlvbiBvcmRlclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXNldENhY2hlXSAtIHJlc2V0IHRoZSBjYWNoZSBmb3IgdGhpcyBtYWluU2NvcGVcbiAgICovXG4gIGdldE9wdGlvblNjb3BlcyhtYWluU2NvcGUsIGtleUxpc3RzLCByZXNldENhY2hlKSB7XG4gICAgY29uc3Qge29wdGlvbnMsIHR5cGV9ID0gdGhpcztcbiAgICBjb25zdCBjYWNoZSA9IHRoaXMuX2NhY2hlZFNjb3BlcyhtYWluU2NvcGUsIHJlc2V0Q2FjaGUpO1xuICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChrZXlMaXN0cyk7XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG5cbiAgICBjb25zdCBzY29wZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBrZXlMaXN0cy5mb3JFYWNoKGtleXMgPT4ge1xuICAgICAgaWYgKG1haW5TY29wZSkge1xuICAgICAgICBzY29wZXMuYWRkKG1haW5TY29wZSk7XG4gICAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gYWRkSWZGb3VuZChzY29wZXMsIG1haW5TY29wZSwga2V5KSk7XG4gICAgICB9XG4gICAgICBrZXlzLmZvckVhY2goa2V5ID0+IGFkZElmRm91bmQoc2NvcGVzLCBvcHRpb25zLCBrZXkpKTtcbiAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gYWRkSWZGb3VuZChzY29wZXMsIG92ZXJyaWRlc1t0eXBlXSB8fCB7fSwga2V5KSk7XG4gICAgICBrZXlzLmZvckVhY2goa2V5ID0+IGFkZElmRm91bmQoc2NvcGVzLCBkZWZhdWx0cywga2V5KSk7XG4gICAgICBrZXlzLmZvckVhY2goa2V5ID0+IGFkZElmRm91bmQoc2NvcGVzLCBkZXNjcmlwdG9ycywga2V5KSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBhcnJheSA9IEFycmF5LmZyb20oc2NvcGVzKTtcbiAgICBpZiAoYXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgICBhcnJheS5wdXNoKE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgIH1cbiAgICBpZiAoa2V5c0NhY2hlZC5oYXMoa2V5TGlzdHMpKSB7XG4gICAgICBjYWNoZS5zZXQoa2V5TGlzdHMsIGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9wdGlvbiBzY29wZXMgZm9yIHJlc29sdmluZyBjaGFydCBvcHRpb25zXG4gICAqIEByZXR1cm4ge29iamVjdFtdfVxuICAgKi9cbiAgY2hhcnRPcHRpb25TY29wZXMoKSB7XG4gICAgY29uc3Qge29wdGlvbnMsIHR5cGV9ID0gdGhpcztcblxuICAgIHJldHVybiBbXG4gICAgICBvcHRpb25zLFxuICAgICAgb3ZlcnJpZGVzW3R5cGVdIHx8IHt9LFxuICAgICAgZGVmYXVsdHMuZGF0YXNldHNbdHlwZV0gfHwge30sIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy84NTMxXG4gICAgICB7dHlwZX0sXG4gICAgICBkZWZhdWx0cyxcbiAgICAgIGRlc2NyaXB0b3JzXG4gICAgXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdFtdfSBzY29wZXNcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gbmFtZXNcbiAgICogQHBhcmFtIHtmdW5jdGlvbnxvYmplY3R9IGNvbnRleHRcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gW3ByZWZpeGVzXVxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqL1xuICByZXNvbHZlTmFtZWRPcHRpb25zKHNjb3BlcywgbmFtZXMsIGNvbnRleHQsIHByZWZpeGVzID0gWycnXSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHskc2hhcmVkOiB0cnVlfTtcbiAgICBjb25zdCB7cmVzb2x2ZXIsIHN1YlByZWZpeGVzfSA9IGdldFJlc29sdmVyKHRoaXMuX3Jlc29sdmVyQ2FjaGUsIHNjb3BlcywgcHJlZml4ZXMpO1xuICAgIGxldCBvcHRpb25zID0gcmVzb2x2ZXI7XG4gICAgaWYgKG5lZWRDb250ZXh0KHJlc29sdmVyLCBuYW1lcykpIHtcbiAgICAgIHJlc3VsdC4kc2hhcmVkID0gZmFsc2U7XG4gICAgICBjb250ZXh0ID0gaXNGdW5jdGlvbihjb250ZXh0KSA/IGNvbnRleHQoKSA6IGNvbnRleHQ7XG4gICAgICAvLyBzdWJSZXNvbHZlciBpcyBwYXNzZWQgdG8gc2NyaXB0YWJsZSBvcHRpb25zLiBJdCBzaG91bGQgbm90IHJlc29sdmUgdG8gaG92ZXIgb3B0aW9ucy5cbiAgICAgIGNvbnN0IHN1YlJlc29sdmVyID0gdGhpcy5jcmVhdGVSZXNvbHZlcihzY29wZXMsIGNvbnRleHQsIHN1YlByZWZpeGVzKTtcbiAgICAgIG9wdGlvbnMgPSBfYXR0YWNoQ29udGV4dChyZXNvbHZlciwgY29udGV4dCwgc3ViUmVzb2x2ZXIpO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgcHJvcCBvZiBuYW1lcykge1xuICAgICAgcmVzdWx0W3Byb3BdID0gb3B0aW9uc1twcm9wXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdFtdfSBzY29wZXNcbiAgICogQHBhcmFtIHtvYmplY3R9IFtjb250ZXh0XVxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBbcHJlZml4ZXNdXG4gICAqIEBwYXJhbSB7e3NjcmlwdGFibGU6IGJvb2xlYW4sIGluZGV4YWJsZTogYm9vbGVhbiwgYWxsS2V5cz86IGJvb2xlYW59fSBbZGVzY3JpcHRvckRlZmF1bHRzXVxuICAgKi9cbiAgY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCBjb250ZXh0LCBwcmVmaXhlcyA9IFsnJ10sIGRlc2NyaXB0b3JEZWZhdWx0cykge1xuICAgIGNvbnN0IHtyZXNvbHZlcn0gPSBnZXRSZXNvbHZlcih0aGlzLl9yZXNvbHZlckNhY2hlLCBzY29wZXMsIHByZWZpeGVzKTtcbiAgICByZXR1cm4gaXNPYmplY3QoY29udGV4dClcbiAgICAgID8gX2F0dGFjaENvbnRleHQocmVzb2x2ZXIsIGNvbnRleHQsIHVuZGVmaW5lZCwgZGVzY3JpcHRvckRlZmF1bHRzKVxuICAgICAgOiByZXNvbHZlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRSZXNvbHZlcihyZXNvbHZlckNhY2hlLCBzY29wZXMsIHByZWZpeGVzKSB7XG4gIGxldCBjYWNoZSA9IHJlc29sdmVyQ2FjaGUuZ2V0KHNjb3Blcyk7XG4gIGlmICghY2FjaGUpIHtcbiAgICBjYWNoZSA9IG5ldyBNYXAoKTtcbiAgICByZXNvbHZlckNhY2hlLnNldChzY29wZXMsIGNhY2hlKTtcbiAgfVxuICBjb25zdCBjYWNoZUtleSA9IHByZWZpeGVzLmpvaW4oKTtcbiAgbGV0IGNhY2hlZCA9IGNhY2hlLmdldChjYWNoZUtleSk7XG4gIGlmICghY2FjaGVkKSB7XG4gICAgY29uc3QgcmVzb2x2ZXIgPSBfY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCBwcmVmaXhlcyk7XG4gICAgY2FjaGVkID0ge1xuICAgICAgcmVzb2x2ZXIsXG4gICAgICBzdWJQcmVmaXhlczogcHJlZml4ZXMuZmlsdGVyKHAgPT4gIXAudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnaG92ZXInKSlcbiAgICB9O1xuICAgIGNhY2hlLnNldChjYWNoZUtleSwgY2FjaGVkKTtcbiAgfVxuICByZXR1cm4gY2FjaGVkO1xufVxuXG5jb25zdCBoYXNGdW5jdGlvbiA9IHZhbHVlID0+IGlzT2JqZWN0KHZhbHVlKVxuICAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSkuc29tZSgoa2V5KSA9PiBpc0Z1bmN0aW9uKHZhbHVlW2tleV0pKTtcblxuZnVuY3Rpb24gbmVlZENvbnRleHQocHJveHksIG5hbWVzKSB7XG4gIGNvbnN0IHtpc1NjcmlwdGFibGUsIGlzSW5kZXhhYmxlfSA9IF9kZXNjcmlwdG9ycyhwcm94eSk7XG5cbiAgZm9yIChjb25zdCBwcm9wIG9mIG5hbWVzKSB7XG4gICAgY29uc3Qgc2NyaXB0YWJsZSA9IGlzU2NyaXB0YWJsZShwcm9wKTtcbiAgICBjb25zdCBpbmRleGFibGUgPSBpc0luZGV4YWJsZShwcm9wKTtcbiAgICBjb25zdCB2YWx1ZSA9IChpbmRleGFibGUgfHwgc2NyaXB0YWJsZSkgJiYgcHJveHlbcHJvcF07XG4gICAgaWYgKChzY3JpcHRhYmxlICYmIChpc0Z1bmN0aW9uKHZhbHVlKSB8fCBoYXNGdW5jdGlvbih2YWx1ZSkpKVxuICAgICAgfHwgKGluZGV4YWJsZSAmJiBpc0FycmF5KHZhbHVlKSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG4iLCJpbXBvcnQgYW5pbWF0b3IgZnJvbSAnLi9jb3JlLmFuaW1hdG9yLmpzJztcbmltcG9ydCBkZWZhdWx0cywge292ZXJyaWRlc30gZnJvbSAnLi9jb3JlLmRlZmF1bHRzLmpzJztcbmltcG9ydCBJbnRlcmFjdGlvbiBmcm9tICcuL2NvcmUuaW50ZXJhY3Rpb24uanMnO1xuaW1wb3J0IGxheW91dHMgZnJvbSAnLi9jb3JlLmxheW91dHMuanMnO1xuaW1wb3J0IHtfZGV0ZWN0UGxhdGZvcm19IGZyb20gJy4uL3BsYXRmb3JtL2luZGV4LmpzJztcbmltcG9ydCBQbHVnaW5TZXJ2aWNlIGZyb20gJy4vY29yZS5wbHVnaW5zLmpzJztcbmltcG9ydCByZWdpc3RyeSBmcm9tICcuL2NvcmUucmVnaXN0cnkuanMnO1xuaW1wb3J0IENvbmZpZywge2RldGVybWluZUF4aXMsIGdldEluZGV4QXhpc30gZnJvbSAnLi9jb3JlLmNvbmZpZy5qcyc7XG5pbXBvcnQge2VhY2gsIGNhbGxiYWNrIGFzIGNhbGxDYWxsYmFjaywgdWlkLCB2YWx1ZU9yRGVmYXVsdCwgX2VsZW1lbnRzRXF1YWwsIGlzTnVsbE9yVW5kZWYsIHNldHNFcXVhbCwgZGVmaW5lZCwgaXNGdW5jdGlvbiwgX2lzQ2xpY2tFdmVudH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHtjbGVhckNhbnZhcywgY2xpcEFyZWEsIGNyZWF0ZUNvbnRleHQsIHVuY2xpcEFyZWEsIF9pc1BvaW50SW5BcmVhLCBfaXNEb21TdXBwb3J0ZWQsIHJldGluYVNjYWxlLCBnZXREYXRhc2V0Q2xpcEFyZWF9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuLy8gQHRzLWlnbm9yZVxuaW1wb3J0IHt2ZXJzaW9ufSBmcm9tICcuLi8uLi9wYWNrYWdlLmpzb24nO1xuaW1wb3J0IHtkZWJvdW5jZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmV4dHJhcy5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuQ2hhcnRFdmVudCB9IENoYXJ0RXZlbnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi90eXBlcy9pbmRleC5qcycpLlBvaW50IH0gUG9pbnRcbiAqL1xuXG5jb25zdCBLTk9XTl9QT1NJVElPTlMgPSBbJ3RvcCcsICdib3R0b20nLCAnbGVmdCcsICdyaWdodCcsICdjaGFydEFyZWEnXTtcbmZ1bmN0aW9uIHBvc2l0aW9uSXNIb3Jpem9udGFsKHBvc2l0aW9uLCBheGlzKSB7XG4gIHJldHVybiBwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcG9zaXRpb24gPT09ICdib3R0b20nIHx8IChLTk9XTl9QT1NJVElPTlMuaW5kZXhPZihwb3NpdGlvbikgPT09IC0xICYmIGF4aXMgPT09ICd4Jyk7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmUyTGV2ZWwobDEsIGwyKSB7XG4gIHJldHVybiBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGFbbDFdID09PSBiW2wxXVxuICAgICAgPyBhW2wyXSAtIGJbbDJdXG4gICAgICA6IGFbbDFdIC0gYltsMV07XG4gIH07XG59XG5cbmZ1bmN0aW9uIG9uQW5pbWF0aW9uc0NvbXBsZXRlKGNvbnRleHQpIHtcbiAgY29uc3QgY2hhcnQgPSBjb250ZXh0LmNoYXJ0O1xuICBjb25zdCBhbmltYXRpb25PcHRpb25zID0gY2hhcnQub3B0aW9ucy5hbmltYXRpb247XG5cbiAgY2hhcnQubm90aWZ5UGx1Z2lucygnYWZ0ZXJSZW5kZXInKTtcbiAgY2FsbENhbGxiYWNrKGFuaW1hdGlvbk9wdGlvbnMgJiYgYW5pbWF0aW9uT3B0aW9ucy5vbkNvbXBsZXRlLCBbY29udGV4dF0sIGNoYXJ0KTtcbn1cblxuZnVuY3Rpb24gb25BbmltYXRpb25Qcm9ncmVzcyhjb250ZXh0KSB7XG4gIGNvbnN0IGNoYXJ0ID0gY29udGV4dC5jaGFydDtcbiAgY29uc3QgYW5pbWF0aW9uT3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMuYW5pbWF0aW9uO1xuICBjYWxsQ2FsbGJhY2soYW5pbWF0aW9uT3B0aW9ucyAmJiBhbmltYXRpb25PcHRpb25zLm9uUHJvZ3Jlc3MsIFtjb250ZXh0XSwgY2hhcnQpO1xufVxuXG4vKipcbiAqIENoYXJ0LmpzIGNhbiB0YWtlIGEgc3RyaW5nIGlkIG9mIGEgY2FudmFzIGVsZW1lbnQsIGEgMmQgY29udGV4dCwgb3IgYSBjYW52YXMgZWxlbWVudCBpdHNlbGYuXG4gKiBBdHRlbXB0IHRvIHVud3JhcCB0aGUgaXRlbSBwYXNzZWQgaW50byB0aGUgY2hhcnQgY29uc3RydWN0b3Igc28gdGhhdCBpdCBpcyBhIGNhbnZhcyBlbGVtZW50IChpZiBwb3NzaWJsZSkuXG4gKi9cbmZ1bmN0aW9uIGdldENhbnZhcyhpdGVtKSB7XG4gIGlmIChfaXNEb21TdXBwb3J0ZWQoKSAmJiB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcbiAgICBpdGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaXRlbSk7XG4gIH0gZWxzZSBpZiAoaXRlbSAmJiBpdGVtLmxlbmd0aCkge1xuICAgIC8vIFN1cHBvcnQgZm9yIGFycmF5IGJhc2VkIHF1ZXJpZXMgKHN1Y2ggYXMgalF1ZXJ5KVxuICAgIGl0ZW0gPSBpdGVtWzBdO1xuICB9XG5cbiAgaWYgKGl0ZW0gJiYgaXRlbS5jYW52YXMpIHtcbiAgICAvLyBTdXBwb3J0IGZvciBhbnkgb2JqZWN0IGFzc29jaWF0ZWQgdG8gYSBjYW52YXMgKGluY2x1ZGluZyBhIGNvbnRleHQyZClcbiAgICBpdGVtID0gaXRlbS5jYW52YXM7XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59XG5cbmNvbnN0IGluc3RhbmNlcyA9IHt9O1xuY29uc3QgZ2V0Q2hhcnQgPSAoa2V5KSA9PiB7XG4gIGNvbnN0IGNhbnZhcyA9IGdldENhbnZhcyhrZXkpO1xuICByZXR1cm4gT2JqZWN0LnZhbHVlcyhpbnN0YW5jZXMpLmZpbHRlcigoYykgPT4gYy5jYW52YXMgPT09IGNhbnZhcykucG9wKCk7XG59O1xuXG5mdW5jdGlvbiBtb3ZlTnVtZXJpY0tleXMob2JqLCBzdGFydCwgbW92ZSkge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGNvbnN0IGludEtleSA9ICtrZXk7XG4gICAgaWYgKGludEtleSA+PSBzdGFydCkge1xuICAgICAgY29uc3QgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICAgIGlmIChtb3ZlID4gMCB8fCBpbnRLZXkgPiBzdGFydCkge1xuICAgICAgICBvYmpbaW50S2V5ICsgbW92ZV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NoYXJ0RXZlbnR9IGVcbiAqIEBwYXJhbSB7Q2hhcnRFdmVudHxudWxsfSBsYXN0RXZlbnRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5DaGFydEFyZWFcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNDbGlja1xuICogQHJldHVybnMge0NoYXJ0RXZlbnR8bnVsbH1cbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5lTGFzdEV2ZW50KGUsIGxhc3RFdmVudCwgaW5DaGFydEFyZWEsIGlzQ2xpY2spIHtcbiAgaWYgKCFpbkNoYXJ0QXJlYSB8fCBlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoaXNDbGljaykge1xuICAgIHJldHVybiBsYXN0RXZlbnQ7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5cbmNsYXNzIENoYXJ0IHtcblxuICBzdGF0aWMgZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgc3RhdGljIGluc3RhbmNlcyA9IGluc3RhbmNlcztcbiAgc3RhdGljIG92ZXJyaWRlcyA9IG92ZXJyaWRlcztcbiAgc3RhdGljIHJlZ2lzdHJ5ID0gcmVnaXN0cnk7XG4gIHN0YXRpYyB2ZXJzaW9uID0gdmVyc2lvbjtcbiAgc3RhdGljIGdldENoYXJ0ID0gZ2V0Q2hhcnQ7XG5cbiAgc3RhdGljIHJlZ2lzdGVyKC4uLml0ZW1zKSB7XG4gICAgcmVnaXN0cnkuYWRkKC4uLml0ZW1zKTtcbiAgICBpbnZhbGlkYXRlUGx1Z2lucygpO1xuICB9XG5cbiAgc3RhdGljIHVucmVnaXN0ZXIoLi4uaXRlbXMpIHtcbiAgICByZWdpc3RyeS5yZW1vdmUoLi4uaXRlbXMpO1xuICAgIGludmFsaWRhdGVQbHVnaW5zKCk7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXN0YXRlbWVudHNcbiAgY29uc3RydWN0b3IoaXRlbSwgdXNlckNvbmZpZykge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnID0gbmV3IENvbmZpZyh1c2VyQ29uZmlnKTtcbiAgICBjb25zdCBpbml0aWFsQ2FudmFzID0gZ2V0Q2FudmFzKGl0ZW0pO1xuICAgIGNvbnN0IGV4aXN0aW5nQ2hhcnQgPSBnZXRDaGFydChpbml0aWFsQ2FudmFzKTtcbiAgICBpZiAoZXhpc3RpbmdDaGFydCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnQ2FudmFzIGlzIGFscmVhZHkgaW4gdXNlLiBDaGFydCB3aXRoIElEIFxcJycgKyBleGlzdGluZ0NoYXJ0LmlkICsgJ1xcJycgK1xuXHRcdFx0XHQnIG11c3QgYmUgZGVzdHJveWVkIGJlZm9yZSB0aGUgY2FudmFzIHdpdGggSUQgXFwnJyArIGV4aXN0aW5nQ2hhcnQuY2FudmFzLmlkICsgJ1xcJyBjYW4gYmUgcmV1c2VkLidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0aW9ucyA9IGNvbmZpZy5jcmVhdGVSZXNvbHZlcihjb25maWcuY2hhcnRPcHRpb25TY29wZXMoKSwgdGhpcy5nZXRDb250ZXh0KCkpO1xuXG4gICAgdGhpcy5wbGF0Zm9ybSA9IG5ldyAoY29uZmlnLnBsYXRmb3JtIHx8IF9kZXRlY3RQbGF0Zm9ybShpbml0aWFsQ2FudmFzKSkoKTtcbiAgICB0aGlzLnBsYXRmb3JtLnVwZGF0ZUNvbmZpZyhjb25maWcpO1xuXG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMucGxhdGZvcm0uYWNxdWlyZUNvbnRleHQoaW5pdGlhbENhbnZhcywgb3B0aW9ucy5hc3BlY3RSYXRpbyk7XG4gICAgY29uc3QgY2FudmFzID0gY29udGV4dCAmJiBjb250ZXh0LmNhbnZhcztcbiAgICBjb25zdCBoZWlnaHQgPSBjYW52YXMgJiYgY2FudmFzLmhlaWdodDtcbiAgICBjb25zdCB3aWR0aCA9IGNhbnZhcyAmJiBjYW52YXMud2lkdGg7XG5cbiAgICB0aGlzLmlkID0gdWlkKCk7XG4gICAgdGhpcy5jdHggPSBjb250ZXh0O1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgICAvLyBTdG9yZSB0aGUgcHJldmlvdXNseSB1c2VkIGFzcGVjdCByYXRpbyB0byBkZXRlcm1pbmUgaWYgYSByZXNpemVcbiAgICAvLyBpcyBuZWVkZWQgZHVyaW5nIHVwZGF0ZXMuIERvIHRoaXMgYWZ0ZXIgX29wdGlvbnMgaXMgc2V0IHNpbmNlXG4gICAgLy8gYXNwZWN0UmF0aW8gdXNlcyBhIGdldHRlclxuICAgIHRoaXMuX2FzcGVjdFJhdGlvID0gdGhpcy5hc3BlY3RSYXRpbztcbiAgICB0aGlzLl9sYXllcnMgPSBbXTtcbiAgICB0aGlzLl9tZXRhc2V0cyA9IFtdO1xuICAgIHRoaXMuX3N0YWNrcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJveGVzID0gW107XG4gICAgdGhpcy5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNoYXJ0QXJlYSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9hY3RpdmUgPSBbXTtcbiAgICB0aGlzLl9sYXN0RXZlbnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gICAgLyoqIEB0eXBlIHs/e2F0dGFjaD86IGZ1bmN0aW9uLCBkZXRhY2g/OiBmdW5jdGlvbiwgcmVzaXplPzogZnVuY3Rpb259fSAqL1xuICAgIHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc29ydGVkTWV0YXNldHMgPSBbXTtcbiAgICB0aGlzLnNjYWxlcyA9IHt9O1xuICAgIHRoaXMuX3BsdWdpbnMgPSBuZXcgUGx1Z2luU2VydmljZSgpO1xuICAgIHRoaXMuJHByb3hpZXMgPSB7fTtcbiAgICB0aGlzLl9oaWRkZW5JbmRpY2VzID0ge307XG4gICAgdGhpcy5hdHRhY2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2FuaW1hdGlvbnNEaXNhYmxlZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2RvUmVzaXplID0gZGVib3VuY2UobW9kZSA9PiB0aGlzLnVwZGF0ZShtb2RlKSwgb3B0aW9ucy5yZXNpemVEZWxheSB8fCAwKTtcbiAgICB0aGlzLl9kYXRhQ2hhbmdlcyA9IFtdO1xuXG4gICAgLy8gQWRkIHRoZSBjaGFydCBpbnN0YW5jZSB0byB0aGUgZ2xvYmFsIG5hbWVzcGFjZVxuICAgIGluc3RhbmNlc1t0aGlzLmlkXSA9IHRoaXM7XG5cbiAgICBpZiAoIWNvbnRleHQgfHwgIWNhbnZhcykge1xuICAgICAgLy8gVGhlIGdpdmVuIGl0ZW0gaXMgbm90IGEgY29tcGF0aWJsZSBjb250ZXh0MmQgZWxlbWVudCwgbGV0J3MgcmV0dXJuIGJlZm9yZSBmaW5hbGl6aW5nXG4gICAgICAvLyB0aGUgY2hhcnQgaW5pdGlhbGl6YXRpb24gYnV0IGFmdGVyIHNldHRpbmcgYmFzaWMgY2hhcnQgLyBjb250cm9sbGVyIHByb3BlcnRpZXMgdGhhdFxuICAgICAgLy8gY2FuIGhlbHAgdG8gZmlndXJlIG91dCB0aGF0IHRoZSBjaGFydCBpcyBub3QgdmFsaWQgKGUuZyBjaGFydC5jYW52YXMgIT09IG51bGwpO1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzI4MDdcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gY3JlYXRlIGNoYXJ0OiBjYW4ndCBhY3F1aXJlIGNvbnRleHQgZnJvbSB0aGUgZ2l2ZW4gaXRlbVwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBhbmltYXRvci5saXN0ZW4odGhpcywgJ2NvbXBsZXRlJywgb25BbmltYXRpb25zQ29tcGxldGUpO1xuICAgIGFuaW1hdG9yLmxpc3Rlbih0aGlzLCAncHJvZ3Jlc3MnLCBvbkFuaW1hdGlvblByb2dyZXNzKTtcblxuICAgIHRoaXMuX2luaXRpYWxpemUoKTtcbiAgICBpZiAodGhpcy5hdHRhY2hlZCkge1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG4gIH1cblxuICBnZXQgYXNwZWN0UmF0aW8oKSB7XG4gICAgY29uc3Qge29wdGlvbnM6IHthc3BlY3RSYXRpbywgbWFpbnRhaW5Bc3BlY3RSYXRpb30sIHdpZHRoLCBoZWlnaHQsIF9hc3BlY3RSYXRpb30gPSB0aGlzO1xuICAgIGlmICghaXNOdWxsT3JVbmRlZihhc3BlY3RSYXRpbykpIHtcbiAgICAgIC8vIElmIGFzcGVjdFJhdGlvIGlzIGRlZmluZWQgaW4gb3B0aW9ucywgdXNlIHRoYXQuXG4gICAgICByZXR1cm4gYXNwZWN0UmF0aW87XG4gICAgfVxuXG4gICAgaWYgKG1haW50YWluQXNwZWN0UmF0aW8gJiYgX2FzcGVjdFJhdGlvKSB7XG4gICAgICAvLyBJZiBtYWludGFpbkFzcGVjdFJhdGlvIGlzIHRydXRobHkgYW5kIHdlIGhhZCBwcmV2aW91c2x5IGRldGVybWluZWQgX2FzcGVjdFJhdGlvLCB1c2UgdGhhdFxuICAgICAgcmV0dXJuIF9hc3BlY3RSYXRpbztcbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGVcbiAgICByZXR1cm4gaGVpZ2h0ID8gd2lkdGggLyBoZWlnaHQgOiBudWxsO1xuICB9XG5cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLmRhdGE7XG4gIH1cblxuICBzZXQgZGF0YShkYXRhKSB7XG4gICAgdGhpcy5jb25maWcuZGF0YSA9IGRhdGE7XG4gIH1cblxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9ucztcbiAgfVxuXG4gIHNldCBvcHRpb25zKG9wdGlvbnMpIHtcbiAgICB0aGlzLmNvbmZpZy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuXG4gIGdldCByZWdpc3RyeSgpIHtcbiAgICByZXR1cm4gcmVnaXN0cnk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9pbml0aWFsaXplKCkge1xuICAgIC8vIEJlZm9yZSBpbml0IHBsdWdpbiBub3RpZmljYXRpb25cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZUluaXQnKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMucmVzcG9uc2l2ZSkge1xuICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0aW5hU2NhbGUodGhpcywgdGhpcy5vcHRpb25zLmRldmljZVBpeGVsUmF0aW8pO1xuICAgIH1cblxuICAgIHRoaXMuYmluZEV2ZW50cygpO1xuXG4gICAgLy8gQWZ0ZXIgaW5pdCBwbHVnaW4gbm90aWZpY2F0aW9uXG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckluaXQnKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY2xlYXIoKSB7XG4gICAgY2xlYXJDYW52YXModGhpcy5jYW52YXMsIHRoaXMuY3R4KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgYW5pbWF0b3Iuc3RvcCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXNpemUgdGhlIGNoYXJ0IHRvIGl0cyBjb250YWluZXIgb3IgdG8gZXhwbGljaXQgZGltZW5zaW9ucy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aF1cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHRdXG5cdCAqL1xuICByZXNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGlmICghYW5pbWF0b3IucnVubmluZyh0aGlzKSkge1xuICAgICAgdGhpcy5fcmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZXNpemVCZWZvcmVEcmF3ID0ge3dpZHRoLCBoZWlnaHR9O1xuICAgIH1cbiAgfVxuXG4gIF9yZXNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgY29uc3QgYXNwZWN0UmF0aW8gPSBvcHRpb25zLm1haW50YWluQXNwZWN0UmF0aW8gJiYgdGhpcy5hc3BlY3RSYXRpbztcbiAgICBjb25zdCBuZXdTaXplID0gdGhpcy5wbGF0Zm9ybS5nZXRNYXhpbXVtU2l6ZShjYW52YXMsIHdpZHRoLCBoZWlnaHQsIGFzcGVjdFJhdGlvKTtcbiAgICBjb25zdCBuZXdSYXRpbyA9IG9wdGlvbnMuZGV2aWNlUGl4ZWxSYXRpbyB8fCB0aGlzLnBsYXRmb3JtLmdldERldmljZVBpeGVsUmF0aW8oKTtcbiAgICBjb25zdCBtb2RlID0gdGhpcy53aWR0aCA/ICdyZXNpemUnIDogJ2F0dGFjaCc7XG5cbiAgICB0aGlzLndpZHRoID0gbmV3U2l6ZS53aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IG5ld1NpemUuaGVpZ2h0O1xuICAgIHRoaXMuX2FzcGVjdFJhdGlvID0gdGhpcy5hc3BlY3RSYXRpbztcbiAgICBpZiAoIXJldGluYVNjYWxlKHRoaXMsIG5ld1JhdGlvLCB0cnVlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygncmVzaXplJywge3NpemU6IG5ld1NpemV9KTtcblxuICAgIGNhbGxDYWxsYmFjayhvcHRpb25zLm9uUmVzaXplLCBbdGhpcywgbmV3U2l6ZV0sIHRoaXMpO1xuXG4gICAgaWYgKHRoaXMuYXR0YWNoZWQpIHtcbiAgICAgIGlmICh0aGlzLl9kb1Jlc2l6ZShtb2RlKSkge1xuICAgICAgICAvLyBUaGUgcmVzaXplIHVwZGF0ZSBpcyBkZWxheWVkLCBvbmx5IGRyYXcgd2l0aG91dCB1cGRhdGluZy5cbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBlbnN1cmVTY2FsZXNIYXZlSURzKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qgc2NhbGVzT3B0aW9ucyA9IG9wdGlvbnMuc2NhbGVzIHx8IHt9O1xuXG4gICAgZWFjaChzY2FsZXNPcHRpb25zLCAoYXhpc09wdGlvbnMsIGF4aXNJRCkgPT4ge1xuICAgICAgYXhpc09wdGlvbnMuaWQgPSBheGlzSUQ7XG4gICAgfSk7XG4gIH1cblxuICAvKipcblx0ICogQnVpbGRzIGEgbWFwIG9mIHNjYWxlIElEIHRvIHNjYWxlIG9iamVjdCBmb3IgZnV0dXJlIGxvb2t1cC5cblx0ICovXG4gIGJ1aWxkT3JVcGRhdGVTY2FsZXMoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBzY2FsZU9wdHMgPSBvcHRpb25zLnNjYWxlcztcbiAgICBjb25zdCBzY2FsZXMgPSB0aGlzLnNjYWxlcztcbiAgICBjb25zdCB1cGRhdGVkID0gT2JqZWN0LmtleXMoc2NhbGVzKS5yZWR1Y2UoKG9iaiwgaWQpID0+IHtcbiAgICAgIG9ialtpZF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSwge30pO1xuICAgIGxldCBpdGVtcyA9IFtdO1xuXG4gICAgaWYgKHNjYWxlT3B0cykge1xuICAgICAgaXRlbXMgPSBpdGVtcy5jb25jYXQoXG4gICAgICAgIE9iamVjdC5rZXlzKHNjYWxlT3B0cykubWFwKChpZCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHNjYWxlT3B0aW9ucyA9IHNjYWxlT3B0c1tpZF07XG4gICAgICAgICAgY29uc3QgYXhpcyA9IGRldGVybWluZUF4aXMoaWQsIHNjYWxlT3B0aW9ucyk7XG4gICAgICAgICAgY29uc3QgaXNSYWRpYWwgPSBheGlzID09PSAncic7XG4gICAgICAgICAgY29uc3QgaXNIb3Jpem9udGFsID0gYXhpcyA9PT0gJ3gnO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvcHRpb25zOiBzY2FsZU9wdGlvbnMsXG4gICAgICAgICAgICBkcG9zaXRpb246IGlzUmFkaWFsID8gJ2NoYXJ0QXJlYScgOiBpc0hvcml6b250YWwgPyAnYm90dG9tJyA6ICdsZWZ0JyxcbiAgICAgICAgICAgIGR0eXBlOiBpc1JhZGlhbCA/ICdyYWRpYWxMaW5lYXInIDogaXNIb3Jpem9udGFsID8gJ2NhdGVnb3J5JyA6ICdsaW5lYXInXG4gICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZWFjaChpdGVtcywgKGl0ZW0pID0+IHtcbiAgICAgIGNvbnN0IHNjYWxlT3B0aW9ucyA9IGl0ZW0ub3B0aW9ucztcbiAgICAgIGNvbnN0IGlkID0gc2NhbGVPcHRpb25zLmlkO1xuICAgICAgY29uc3QgYXhpcyA9IGRldGVybWluZUF4aXMoaWQsIHNjYWxlT3B0aW9ucyk7XG4gICAgICBjb25zdCBzY2FsZVR5cGUgPSB2YWx1ZU9yRGVmYXVsdChzY2FsZU9wdGlvbnMudHlwZSwgaXRlbS5kdHlwZSk7XG5cbiAgICAgIGlmIChzY2FsZU9wdGlvbnMucG9zaXRpb24gPT09IHVuZGVmaW5lZCB8fCBwb3NpdGlvbklzSG9yaXpvbnRhbChzY2FsZU9wdGlvbnMucG9zaXRpb24sIGF4aXMpICE9PSBwb3NpdGlvbklzSG9yaXpvbnRhbChpdGVtLmRwb3NpdGlvbikpIHtcbiAgICAgICAgc2NhbGVPcHRpb25zLnBvc2l0aW9uID0gaXRlbS5kcG9zaXRpb247XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZWRbaWRdID0gdHJ1ZTtcbiAgICAgIGxldCBzY2FsZSA9IG51bGw7XG4gICAgICBpZiAoaWQgaW4gc2NhbGVzICYmIHNjYWxlc1tpZF0udHlwZSA9PT0gc2NhbGVUeXBlKSB7XG4gICAgICAgIHNjYWxlID0gc2NhbGVzW2lkXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHNjYWxlQ2xhc3MgPSByZWdpc3RyeS5nZXRTY2FsZShzY2FsZVR5cGUpO1xuICAgICAgICBzY2FsZSA9IG5ldyBzY2FsZUNsYXNzKHtcbiAgICAgICAgICBpZCxcbiAgICAgICAgICB0eXBlOiBzY2FsZVR5cGUsXG4gICAgICAgICAgY3R4OiB0aGlzLmN0eCxcbiAgICAgICAgICBjaGFydDogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgc2NhbGVzW3NjYWxlLmlkXSA9IHNjYWxlO1xuICAgICAgfVxuXG4gICAgICBzY2FsZS5pbml0KHNjYWxlT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgfSk7XG4gICAgLy8gY2xlYXIgdXAgZGlzY2FyZGVkIHNjYWxlc1xuICAgIGVhY2godXBkYXRlZCwgKGhhc1VwZGF0ZWQsIGlkKSA9PiB7XG4gICAgICBpZiAoIWhhc1VwZGF0ZWQpIHtcbiAgICAgICAgZGVsZXRlIHNjYWxlc1tpZF07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBlYWNoKHNjYWxlcywgKHNjYWxlKSA9PiB7XG4gICAgICBsYXlvdXRzLmNvbmZpZ3VyZSh0aGlzLCBzY2FsZSwgc2NhbGUub3B0aW9ucyk7XG4gICAgICBsYXlvdXRzLmFkZEJveCh0aGlzLCBzY2FsZSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF91cGRhdGVNZXRhc2V0cygpIHtcbiAgICBjb25zdCBtZXRhc2V0cyA9IHRoaXMuX21ldGFzZXRzO1xuICAgIGNvbnN0IG51bURhdGEgPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoO1xuICAgIGNvbnN0IG51bU1ldGEgPSBtZXRhc2V0cy5sZW5ndGg7XG5cbiAgICBtZXRhc2V0cy5zb3J0KChhLCBiKSA9PiBhLmluZGV4IC0gYi5pbmRleCk7XG4gICAgaWYgKG51bU1ldGEgPiBudW1EYXRhKSB7XG4gICAgICBmb3IgKGxldCBpID0gbnVtRGF0YTsgaSA8IG51bU1ldGE7ICsraSkge1xuICAgICAgICB0aGlzLl9kZXN0cm95RGF0YXNldE1ldGEoaSk7XG4gICAgICB9XG4gICAgICBtZXRhc2V0cy5zcGxpY2UobnVtRGF0YSwgbnVtTWV0YSAtIG51bURhdGEpO1xuICAgIH1cbiAgICB0aGlzLl9zb3J0ZWRNZXRhc2V0cyA9IG1ldGFzZXRzLnNsaWNlKDApLnNvcnQoY29tcGFyZTJMZXZlbCgnb3JkZXInLCAnaW5kZXgnKSk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9yZW1vdmVVbnJlZmVyZW5jZWRNZXRhc2V0cygpIHtcbiAgICBjb25zdCB7X21ldGFzZXRzOiBtZXRhc2V0cywgZGF0YToge2RhdGFzZXRzfX0gPSB0aGlzO1xuICAgIGlmIChtZXRhc2V0cy5sZW5ndGggPiBkYXRhc2V0cy5sZW5ndGgpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9zdGFja3M7XG4gICAgfVxuICAgIG1ldGFzZXRzLmZvckVhY2goKG1ldGEsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoZGF0YXNldHMuZmlsdGVyKHggPT4geCA9PT0gbWV0YS5fZGF0YXNldCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lEYXRhc2V0TWV0YShpbmRleCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBidWlsZE9yVXBkYXRlQ29udHJvbGxlcnMoKSB7XG4gICAgY29uc3QgbmV3Q29udHJvbGxlcnMgPSBbXTtcbiAgICBjb25zdCBkYXRhc2V0cyA9IHRoaXMuZGF0YS5kYXRhc2V0cztcbiAgICBsZXQgaSwgaWxlbjtcblxuICAgIHRoaXMuX3JlbW92ZVVucmVmZXJlbmNlZE1ldGFzZXRzKCk7XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBkYXRhc2V0ID0gZGF0YXNldHNbaV07XG4gICAgICBsZXQgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICBjb25zdCB0eXBlID0gZGF0YXNldC50eXBlIHx8IHRoaXMuY29uZmlnLnR5cGU7XG5cbiAgICAgIGlmIChtZXRhLnR5cGUgJiYgbWV0YS50eXBlICE9PSB0eXBlKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lEYXRhc2V0TWV0YShpKTtcbiAgICAgICAgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICB9XG4gICAgICBtZXRhLnR5cGUgPSB0eXBlO1xuICAgICAgbWV0YS5pbmRleEF4aXMgPSBkYXRhc2V0LmluZGV4QXhpcyB8fCBnZXRJbmRleEF4aXModHlwZSwgdGhpcy5vcHRpb25zKTtcbiAgICAgIG1ldGEub3JkZXIgPSBkYXRhc2V0Lm9yZGVyIHx8IDA7XG4gICAgICBtZXRhLmluZGV4ID0gaTtcbiAgICAgIG1ldGEubGFiZWwgPSAnJyArIGRhdGFzZXQubGFiZWw7XG4gICAgICBtZXRhLnZpc2libGUgPSB0aGlzLmlzRGF0YXNldFZpc2libGUoaSk7XG5cbiAgICAgIGlmIChtZXRhLmNvbnRyb2xsZXIpIHtcbiAgICAgICAgbWV0YS5jb250cm9sbGVyLnVwZGF0ZUluZGV4KGkpO1xuICAgICAgICBtZXRhLmNvbnRyb2xsZXIubGlua1NjYWxlcygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgQ29udHJvbGxlckNsYXNzID0gcmVnaXN0cnkuZ2V0Q29udHJvbGxlcih0eXBlKTtcbiAgICAgICAgY29uc3Qge2RhdGFzZXRFbGVtZW50VHlwZSwgZGF0YUVsZW1lbnRUeXBlfSA9IGRlZmF1bHRzLmRhdGFzZXRzW3R5cGVdO1xuICAgICAgICBPYmplY3QuYXNzaWduKENvbnRyb2xsZXJDbGFzcywge1xuICAgICAgICAgIGRhdGFFbGVtZW50VHlwZTogcmVnaXN0cnkuZ2V0RWxlbWVudChkYXRhRWxlbWVudFR5cGUpLFxuICAgICAgICAgIGRhdGFzZXRFbGVtZW50VHlwZTogZGF0YXNldEVsZW1lbnRUeXBlICYmIHJlZ2lzdHJ5LmdldEVsZW1lbnQoZGF0YXNldEVsZW1lbnRUeXBlKVxuICAgICAgICB9KTtcbiAgICAgICAgbWV0YS5jb250cm9sbGVyID0gbmV3IENvbnRyb2xsZXJDbGFzcyh0aGlzLCBpKTtcbiAgICAgICAgbmV3Q29udHJvbGxlcnMucHVzaChtZXRhLmNvbnRyb2xsZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZU1ldGFzZXRzKCk7XG4gICAgcmV0dXJuIG5ld0NvbnRyb2xsZXJzO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJlc2V0IHRoZSBlbGVtZW50cyBvZiBhbGwgZGF0YXNldHNcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9yZXNldEVsZW1lbnRzKCkge1xuICAgIGVhY2godGhpcy5kYXRhLmRhdGFzZXRzLCAoZGF0YXNldCwgZGF0YXNldEluZGV4KSA9PiB7XG4gICAgICB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuY29udHJvbGxlci5yZXNldCgpO1xuICAgIH0sIHRoaXMpO1xuICB9XG5cbiAgLyoqXG5cdCogUmVzZXRzIHRoZSBjaGFydCBiYWNrIHRvIGl0cyBzdGF0ZSBiZWZvcmUgdGhlIGluaXRpYWwgYW5pbWF0aW9uXG5cdCovXG4gIHJlc2V0KCkge1xuICAgIHRoaXMuX3Jlc2V0RWxlbWVudHMoKTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ3Jlc2V0Jyk7XG4gIH1cblxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuXG4gICAgY29uZmlnLnVwZGF0ZSgpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zID0gY29uZmlnLmNyZWF0ZVJlc29sdmVyKGNvbmZpZy5jaGFydE9wdGlvblNjb3BlcygpLCB0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY29uc3QgYW5pbXNEaXNhYmxlZCA9IHRoaXMuX2FuaW1hdGlvbnNEaXNhYmxlZCA9ICFvcHRpb25zLmFuaW1hdGlvbjtcblxuICAgIHRoaXMuX3VwZGF0ZVNjYWxlcygpO1xuICAgIHRoaXMuX2NoZWNrRXZlbnRCaW5kaW5ncygpO1xuICAgIHRoaXMuX3VwZGF0ZUhpZGRlbkluZGljZXMoKTtcblxuICAgIC8vIHBsdWdpbnMgb3B0aW9ucyByZWZlcmVuY2VzIG1pZ2h0IGhhdmUgY2hhbmdlLCBsZXQncyBpbnZhbGlkYXRlIHRoZSBjYWNoZVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy81MTExI2lzc3VlY29tbWVudC0zNTU5MzQxNjdcbiAgICB0aGlzLl9wbHVnaW5zLmludmFsaWRhdGUoKTtcblxuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZVVwZGF0ZScsIHttb2RlLCBjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIGRhdGFzZXQgY29udHJvbGxlcnMgYXJlIHVwZGF0ZWQgYW5kIG5ldyBjb250cm9sbGVycyBhcmUgcmVzZXRcbiAgICBjb25zdCBuZXdDb250cm9sbGVycyA9IHRoaXMuYnVpbGRPclVwZGF0ZUNvbnRyb2xsZXJzKCk7XG5cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZUVsZW1lbnRzVXBkYXRlJyk7XG5cbiAgICAvLyBNYWtlIHN1cmUgYWxsIGRhdGFzZXQgY29udHJvbGxlcnMgaGF2ZSBjb3JyZWN0IG1ldGEgZGF0YSBjb3VudHNcbiAgICBsZXQgbWluUGFkZGluZyA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICBjb25zdCB7Y29udHJvbGxlcn0gPSB0aGlzLmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgY29uc3QgcmVzZXQgPSAhYW5pbXNEaXNhYmxlZCAmJiBuZXdDb250cm9sbGVycy5pbmRleE9mKGNvbnRyb2xsZXIpID09PSAtMTtcbiAgICAgIC8vIE5ldyBjb250cm9sbGVycyB3aWxsIGJlIHJlc2V0IGFmdGVyIHRoZSBsYXlvdXQgcGFzcywgc28gd2Ugb25seSB3YW50IHRvIG1vZGlmeVxuICAgICAgLy8gZWxlbWVudHMgYWRkZWQgdG8gbmV3IGRhdGFzZXRzXG4gICAgICBjb250cm9sbGVyLmJ1aWxkT3JVcGRhdGVFbGVtZW50cyhyZXNldCk7XG4gICAgICBtaW5QYWRkaW5nID0gTWF0aC5tYXgoK2NvbnRyb2xsZXIuZ2V0TWF4T3ZlcmZsb3coKSwgbWluUGFkZGluZyk7XG4gICAgfVxuICAgIG1pblBhZGRpbmcgPSB0aGlzLl9taW5QYWRkaW5nID0gb3B0aW9ucy5sYXlvdXQuYXV0b1BhZGRpbmcgPyBtaW5QYWRkaW5nIDogMDtcbiAgICB0aGlzLl91cGRhdGVMYXlvdXQobWluUGFkZGluZyk7XG5cbiAgICAvLyBPbmx5IHJlc2V0IHRoZSBjb250cm9sbGVycyBpZiB3ZSBoYXZlIGFuaW1hdGlvbnNcbiAgICBpZiAoIWFuaW1zRGlzYWJsZWQpIHtcbiAgICAgIC8vIENhbiBvbmx5IHJlc2V0IHRoZSBuZXcgY29udHJvbGxlcnMgYWZ0ZXIgdGhlIHNjYWxlcyBoYXZlIGJlZW4gdXBkYXRlZFxuICAgICAgLy8gUmVzZXQgaXMgZG9uZSB0byBnZXQgdGhlIHN0YXJ0aW5nIHBvaW50IGZvciB0aGUgaW5pdGlhbCBhbmltYXRpb25cbiAgICAgIGVhY2gobmV3Q29udHJvbGxlcnMsIChjb250cm9sbGVyKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIucmVzZXQoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZURhdGFzZXRzKG1vZGUpO1xuXG4gICAgLy8gRG8gdGhpcyBiZWZvcmUgcmVuZGVyIHNvIHRoYXQgYW55IHBsdWdpbnMgdGhhdCBuZWVkIGZpbmFsIHNjYWxlIHVwZGF0ZXMgY2FuIHVzZSBpdFxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJVcGRhdGUnLCB7bW9kZX0pO1xuXG4gICAgdGhpcy5fbGF5ZXJzLnNvcnQoY29tcGFyZTJMZXZlbCgneicsICdfaWR4JykpO1xuXG4gICAgLy8gUmVwbGF5IGxhc3QgZXZlbnQgZnJvbSBiZWZvcmUgdXBkYXRlLCBvciBzZXQgaG92ZXIgc3R5bGVzIG9uIGFjdGl2ZSBlbGVtZW50c1xuICAgIGNvbnN0IHtfYWN0aXZlLCBfbGFzdEV2ZW50fSA9IHRoaXM7XG4gICAgaWYgKF9sYXN0RXZlbnQpIHtcbiAgICAgIHRoaXMuX2V2ZW50SGFuZGxlcihfbGFzdEV2ZW50LCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKF9hY3RpdmUubGVuZ3RoKSB7XG4gICAgICB0aGlzLl91cGRhdGVIb3ZlclN0eWxlcyhfYWN0aXZlLCBfYWN0aXZlLCB0cnVlKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXBkYXRlU2NhbGVzKCkge1xuICAgIGVhY2godGhpcy5zY2FsZXMsIChzY2FsZSkgPT4ge1xuICAgICAgbGF5b3V0cy5yZW1vdmVCb3godGhpcywgc2NhbGUpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5lbnN1cmVTY2FsZXNIYXZlSURzKCk7XG4gICAgdGhpcy5idWlsZE9yVXBkYXRlU2NhbGVzKCk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jaGVja0V2ZW50QmluZGluZ3MoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBleGlzdGluZ0V2ZW50cyA9IG5ldyBTZXQoT2JqZWN0LmtleXModGhpcy5fbGlzdGVuZXJzKSk7XG4gICAgY29uc3QgbmV3RXZlbnRzID0gbmV3IFNldChvcHRpb25zLmV2ZW50cyk7XG5cbiAgICBpZiAoIXNldHNFcXVhbChleGlzdGluZ0V2ZW50cywgbmV3RXZlbnRzKSB8fCAhIXRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgIT09IG9wdGlvbnMucmVzcG9uc2l2ZSkge1xuICAgICAgLy8gVGhlIGNvbmZpZ3VyZWQgZXZlbnRzIGhhdmUgY2hhbmdlZC4gUmViaW5kLlxuICAgICAgdGhpcy51bmJpbmRFdmVudHMoKTtcbiAgICAgIHRoaXMuYmluZEV2ZW50cygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3VwZGF0ZUhpZGRlbkluZGljZXMoKSB7XG4gICAgY29uc3Qge19oaWRkZW5JbmRpY2VzfSA9IHRoaXM7XG4gICAgY29uc3QgY2hhbmdlcyA9IHRoaXMuX2dldFVuaWZvcm1EYXRhQ2hhbmdlcygpIHx8IFtdO1xuICAgIGZvciAoY29uc3Qge21ldGhvZCwgc3RhcnQsIGNvdW50fSBvZiBjaGFuZ2VzKSB7XG4gICAgICBjb25zdCBtb3ZlID0gbWV0aG9kID09PSAnX3JlbW92ZUVsZW1lbnRzJyA/IC1jb3VudCA6IGNvdW50O1xuICAgICAgbW92ZU51bWVyaWNLZXlzKF9oaWRkZW5JbmRpY2VzLCBzdGFydCwgbW92ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0VW5pZm9ybURhdGFDaGFuZ2VzKCkge1xuICAgIGNvbnN0IF9kYXRhQ2hhbmdlcyA9IHRoaXMuX2RhdGFDaGFuZ2VzO1xuICAgIGlmICghX2RhdGFDaGFuZ2VzIHx8ICFfZGF0YUNoYW5nZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fZGF0YUNoYW5nZXMgPSBbXTtcbiAgICBjb25zdCBkYXRhc2V0Q291bnQgPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoO1xuICAgIGNvbnN0IG1ha2VTZXQgPSAoaWR4KSA9PiBuZXcgU2V0KFxuICAgICAgX2RhdGFDaGFuZ2VzXG4gICAgICAgIC5maWx0ZXIoYyA9PiBjWzBdID09PSBpZHgpXG4gICAgICAgIC5tYXAoKGMsIGkpID0+IGkgKyAnLCcgKyBjLnNwbGljZSgxKS5qb2luKCcsJykpXG4gICAgKTtcblxuICAgIGNvbnN0IGNoYW5nZVNldCA9IG1ha2VTZXQoMCk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBkYXRhc2V0Q291bnQ7IGkrKykge1xuICAgICAgaWYgKCFzZXRzRXF1YWwoY2hhbmdlU2V0LCBtYWtlU2V0KGkpKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5mcm9tKGNoYW5nZVNldClcbiAgICAgIC5tYXAoYyA9PiBjLnNwbGl0KCcsJykpXG4gICAgICAubWFwKGEgPT4gKHttZXRob2Q6IGFbMV0sIHN0YXJ0OiArYVsyXSwgY291bnQ6ICthWzNdfSkpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFVwZGF0ZXMgdGhlIGNoYXJ0IGxheW91dCB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlTGF5b3V0YFxuXHQgKiBob29rLCBpbiB3aGljaCBjYXNlLCBwbHVnaW5zIHdpbGwgbm90IGJlIGNhbGxlZCBvbiBgYWZ0ZXJMYXlvdXRgLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3VwZGF0ZUxheW91dChtaW5QYWRkaW5nKSB7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlTGF5b3V0Jywge2NhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsYXlvdXRzLnVwZGF0ZSh0aGlzLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgbWluUGFkZGluZyk7XG5cbiAgICBjb25zdCBhcmVhID0gdGhpcy5jaGFydEFyZWE7XG4gICAgY29uc3Qgbm9BcmVhID0gYXJlYS53aWR0aCA8PSAwIHx8IGFyZWEuaGVpZ2h0IDw9IDA7XG5cbiAgICB0aGlzLl9sYXllcnMgPSBbXTtcbiAgICBlYWNoKHRoaXMuYm94ZXMsIChib3gpID0+IHtcbiAgICAgIGlmIChub0FyZWEgJiYgYm94LnBvc2l0aW9uID09PSAnY2hhcnRBcmVhJykge1xuICAgICAgICAvLyBTa2lwIGRyYXdpbmcgYW5kIGNvbmZpZ3VyaW5nIGNoYXJ0QXJlYSBib3hlcyB3aGVuIGNoYXJ0QXJlYSBpcyB6ZXJvIG9yIG5lZ2F0aXZlXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gY29uZmlndXJlIGlzIGNhbGxlZCB0d2ljZSwgb25jZSBpbiBjb3JlLnNjYWxlLnVwZGF0ZSBhbmQgb25jZSBoZXJlLlxuICAgICAgLy8gSGVyZSB0aGUgYm94ZXMgYXJlIGZ1bGx5IHVwZGF0ZWQgYW5kIGF0IHRoZWlyIGZpbmFsIHBvc2l0aW9ucy5cbiAgICAgIGlmIChib3guY29uZmlndXJlKSB7XG4gICAgICAgIGJveC5jb25maWd1cmUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2xheWVycy5wdXNoKC4uLmJveC5fbGF5ZXJzKCkpO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy5fbGF5ZXJzLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICBpdGVtLl9pZHggPSBpbmRleDtcbiAgICB9KTtcblxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJMYXlvdXQnKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVcGRhdGVzIGFsbCBkYXRhc2V0cyB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlRGF0YXNldHNVcGRhdGVgXG5cdCAqIGhvb2ssIGluIHdoaWNoIGNhc2UsIHBsdWdpbnMgd2lsbCBub3QgYmUgY2FsbGVkIG9uIGBhZnRlckRhdGFzZXRzVXBkYXRlYC5cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF91cGRhdGVEYXRhc2V0cyhtb2RlKSB7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRGF0YXNldHNVcGRhdGUnLCB7bW9kZSwgY2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGhpcy5nZXREYXRhc2V0TWV0YShpKS5jb250cm9sbGVyLmNvbmZpZ3VyZSgpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGhpcy5fdXBkYXRlRGF0YXNldChpLCBpc0Z1bmN0aW9uKG1vZGUpID8gbW9kZSh7ZGF0YXNldEluZGV4OiBpfSkgOiBtb2RlKTtcbiAgICB9XG5cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGF0YXNldHNVcGRhdGUnLCB7bW9kZX0pO1xuICB9XG5cbiAgLyoqXG5cdCAqIFVwZGF0ZXMgZGF0YXNldCBhdCBpbmRleCB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlRGF0YXNldFVwZGF0ZWBcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyRGF0YXNldFVwZGF0ZWAuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfdXBkYXRlRGF0YXNldChpbmRleCwgbW9kZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGluZGV4KTtcbiAgICBjb25zdCBhcmdzID0ge21ldGEsIGluZGV4LCBtb2RlLCBjYW5jZWxhYmxlOiB0cnVlfTtcblxuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURhdGFzZXRVcGRhdGUnLCBhcmdzKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBtZXRhLmNvbnRyb2xsZXIuX3VwZGF0ZShtb2RlKTtcblxuICAgIGFyZ3MuY2FuY2VsYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEYXRhc2V0VXBkYXRlJywgYXJncyk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlUmVuZGVyJywge2NhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoYW5pbWF0b3IuaGFzKHRoaXMpKSB7XG4gICAgICBpZiAodGhpcy5hdHRhY2hlZCAmJiAhYW5pbWF0b3IucnVubmluZyh0aGlzKSkge1xuICAgICAgICBhbmltYXRvci5zdGFydCh0aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kcmF3KCk7XG4gICAgICBvbkFuaW1hdGlvbnNDb21wbGV0ZSh7Y2hhcnQ6IHRoaXN9KTtcbiAgICB9XG4gIH1cblxuICBkcmF3KCkge1xuICAgIGxldCBpO1xuICAgIGlmICh0aGlzLl9yZXNpemVCZWZvcmVEcmF3KSB7XG4gICAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSB0aGlzLl9yZXNpemVCZWZvcmVEcmF3O1xuICAgICAgLy8gVW5zZXQgcGVuZGluZyByZXNpemUgcmVxdWVzdCBub3cgdG8gYXZvaWQgcG9zc2libGUgcmVjdXJzaW9uIHdpdGhpbiBfcmVzaXplXG4gICAgICB0aGlzLl9yZXNpemVCZWZvcmVEcmF3ID0gbnVsbDtcbiAgICAgIHRoaXMuX3Jlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gICAgdGhpcy5jbGVhcigpO1xuXG4gICAgaWYgKHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRHJhdycsIHtjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQmVjYXVzZSBvZiBwbHVnaW4gaG9va3MgKGJlZm9yZS9hZnRlckRhdGFzZXRzRHJhdyksIGRhdGFzZXRzIGNhbid0XG4gICAgLy8gY3VycmVudGx5IGJlIHBhcnQgb2YgbGF5ZXJzLiBJbnN0ZWFkLCB3ZSBkcmF3XG4gICAgLy8gbGF5ZXJzIDw9IDAgYmVmb3JlKGRlZmF1bHQsIGJhY2t3YXJkIGNvbXBhdCksIGFuZCB0aGUgcmVzdCBhZnRlclxuICAgIGNvbnN0IGxheWVycyA9IHRoaXMuX2xheWVycztcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGF5ZXJzLmxlbmd0aCAmJiBsYXllcnNbaV0ueiA8PSAwOyArK2kpIHtcbiAgICAgIGxheWVyc1tpXS5kcmF3KHRoaXMuY2hhcnRBcmVhKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kcmF3RGF0YXNldHMoKTtcblxuICAgIC8vIFJlc3Qgb2YgbGF5ZXJzXG4gICAgZm9yICg7IGkgPCBsYXllcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxheWVyc1tpXS5kcmF3KHRoaXMuY2hhcnRBcmVhKTtcbiAgICB9XG5cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRHJhdycpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0U29ydGVkRGF0YXNldE1ldGFzKGZpbHRlclZpc2libGUpIHtcbiAgICBjb25zdCBtZXRhc2V0cyA9IHRoaXMuX3NvcnRlZE1ldGFzZXRzO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBpLCBpbGVuO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IG1ldGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY29uc3QgbWV0YSA9IG1ldGFzZXRzW2ldO1xuICAgICAgaWYgKCFmaWx0ZXJWaXNpYmxlIHx8IG1ldGEudmlzaWJsZSkge1xuICAgICAgICByZXN1bHQucHVzaChtZXRhKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG5cdCAqIEdldHMgdGhlIHZpc2libGUgZGF0YXNldCBtZXRhcyBpbiBkcmF3aW5nIG9yZGVyXG5cdCAqIEByZXR1cm4ge29iamVjdFtdfVxuXHQgKi9cbiAgZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0U29ydGVkRGF0YXNldE1ldGFzKHRydWUpO1xuICB9XG5cbiAgLyoqXG5cdCAqIERyYXdzIGFsbCBkYXRhc2V0cyB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlRGF0YXNldHNEcmF3YFxuXHQgKiBob29rLCBpbiB3aGljaCBjYXNlLCBwbHVnaW5zIHdpbGwgbm90IGJlIGNhbGxlZCBvbiBgYWZ0ZXJEYXRhc2V0c0RyYXdgLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2RyYXdEYXRhc2V0cygpIHtcbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEYXRhc2V0c0RyYXcnLCB7Y2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG1ldGFzZXRzID0gdGhpcy5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gICAgZm9yIChsZXQgaSA9IG1ldGFzZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0aGlzLl9kcmF3RGF0YXNldChtZXRhc2V0c1tpXSk7XG4gICAgfVxuXG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRhdGFzZXRzRHJhdycpO1xuICB9XG5cbiAgLyoqXG5cdCAqIERyYXdzIGRhdGFzZXQgYXQgaW5kZXggdW5sZXNzIGEgcGx1Z2luIHJldHVybnMgYGZhbHNlYCB0byB0aGUgYGJlZm9yZURhdGFzZXREcmF3YFxuXHQgKiBob29rLCBpbiB3aGljaCBjYXNlLCBwbHVnaW5zIHdpbGwgbm90IGJlIGNhbGxlZCBvbiBgYWZ0ZXJEYXRhc2V0RHJhd2AuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZHJhd0RhdGFzZXQobWV0YSkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICBtZXRhLFxuICAgICAgaW5kZXg6IG1ldGEuaW5kZXgsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgfTtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgY29uc3QgY2xpcCA9IGdldERhdGFzZXRDbGlwQXJlYSh0aGlzLCBtZXRhKTtcblxuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURhdGFzZXREcmF3JywgYXJncykgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGNsaXApIHtcbiAgICAgIGNsaXBBcmVhKGN0eCwgY2xpcCk7XG4gICAgfVxuXG4gICAgbWV0YS5jb250cm9sbGVyLmRyYXcoKTtcblxuICAgIGlmIChjbGlwKSB7XG4gICAgICB1bmNsaXBBcmVhKGN0eCk7XG4gICAgfVxuXG4gICAgYXJncy5jYW5jZWxhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRhdGFzZXREcmF3JywgYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHBvaW50IGlzIGluIHRoZSBjaGFydCBhcmVhLlxuICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludCAtIGluIHJlbGF0aXZlIGNvb3JkaW5hdGVzIChzZWUsIGUuZy4sIGdldFJlbGF0aXZlUG9zaXRpb24pXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgaXNQb2ludEluQXJlYShwb2ludCkge1xuICAgIHJldHVybiBfaXNQb2ludEluQXJlYShwb2ludCwgdGhpcy5jaGFydEFyZWEsIHRoaXMuX21pblBhZGRpbmcpO1xuICB9XG5cbiAgZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZShlLCBtb2RlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgY29uc3QgbWV0aG9kID0gSW50ZXJhY3Rpb24ubW9kZXNbbW9kZV07XG4gICAgaWYgKHR5cGVvZiBtZXRob2QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBtZXRob2QodGhpcywgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KSB7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xuICAgIGNvbnN0IG1ldGFzZXRzID0gdGhpcy5fbWV0YXNldHM7XG4gICAgbGV0IG1ldGEgPSBtZXRhc2V0cy5maWx0ZXIoeCA9PiB4ICYmIHguX2RhdGFzZXQgPT09IGRhdGFzZXQpLnBvcCgpO1xuXG4gICAgaWYgKCFtZXRhKSB7XG4gICAgICBtZXRhID0ge1xuICAgICAgICB0eXBlOiBudWxsLFxuICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgZGF0YXNldDogbnVsbCxcbiAgICAgICAgY29udHJvbGxlcjogbnVsbCxcbiAgICAgICAgaGlkZGVuOiBudWxsLFx0XHRcdC8vIFNlZSBpc0RhdGFzZXRWaXNpYmxlKCkgY29tbWVudFxuICAgICAgICB4QXhpc0lEOiBudWxsLFxuICAgICAgICB5QXhpc0lEOiBudWxsLFxuICAgICAgICBvcmRlcjogZGF0YXNldCAmJiBkYXRhc2V0Lm9yZGVyIHx8IDAsXG4gICAgICAgIGluZGV4OiBkYXRhc2V0SW5kZXgsXG4gICAgICAgIF9kYXRhc2V0OiBkYXRhc2V0LFxuICAgICAgICBfcGFyc2VkOiBbXSxcbiAgICAgICAgX3NvcnRlZDogZmFsc2VcbiAgICAgIH07XG4gICAgICBtZXRhc2V0cy5wdXNoKG1ldGEpO1xuICAgIH1cblxuICAgIHJldHVybiBtZXRhO1xuICB9XG5cbiAgZ2V0Q29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy4kY29udGV4dCB8fCAodGhpcy4kY29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCwge2NoYXJ0OiB0aGlzLCB0eXBlOiAnY2hhcnQnfSkpO1xuICB9XG5cbiAgZ2V0VmlzaWJsZURhdGFzZXRDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCkubGVuZ3RoO1xuICB9XG5cbiAgaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpIHtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF07XG4gICAgaWYgKCFkYXRhc2V0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcblxuICAgIC8vIG1ldGEuaGlkZGVuIGlzIGEgcGVyIGNoYXJ0IGRhdGFzZXQgaGlkZGVuIGZsYWcgb3ZlcnJpZGUgd2l0aCAzIHN0YXRlczogaWYgdHJ1ZSBvciBmYWxzZSxcbiAgICAvLyB0aGUgZGF0YXNldC5oaWRkZW4gdmFsdWUgaXMgaWdub3JlZCwgZWxzZSBpZiBudWxsLCB0aGUgZGF0YXNldCBoaWRkZW4gc3RhdGUgaXMgcmV0dXJuZWQuXG4gICAgcmV0dXJuIHR5cGVvZiBtZXRhLmhpZGRlbiA9PT0gJ2Jvb2xlYW4nID8gIW1ldGEuaGlkZGVuIDogIWRhdGFzZXQuaGlkZGVuO1xuICB9XG5cbiAgc2V0RGF0YXNldFZpc2liaWxpdHkoZGF0YXNldEluZGV4LCB2aXNpYmxlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICBtZXRhLmhpZGRlbiA9ICF2aXNpYmxlO1xuICB9XG5cbiAgdG9nZ2xlRGF0YVZpc2liaWxpdHkoaW5kZXgpIHtcbiAgICB0aGlzLl9oaWRkZW5JbmRpY2VzW2luZGV4XSA9ICF0aGlzLl9oaWRkZW5JbmRpY2VzW2luZGV4XTtcbiAgfVxuXG4gIGdldERhdGFWaXNpYmlsaXR5KGluZGV4KSB7XG4gICAgcmV0dXJuICF0aGlzLl9oaWRkZW5JbmRpY2VzW2luZGV4XTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3VwZGF0ZVZpc2liaWxpdHkoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgsIHZpc2libGUpIHtcbiAgICBjb25zdCBtb2RlID0gdmlzaWJsZSA/ICdzaG93JyA6ICdoaWRlJztcbiAgICBjb25zdCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgIGNvbnN0IGFuaW1zID0gbWV0YS5jb250cm9sbGVyLl9yZXNvbHZlQW5pbWF0aW9ucyh1bmRlZmluZWQsIG1vZGUpO1xuXG4gICAgaWYgKGRlZmluZWQoZGF0YUluZGV4KSkge1xuICAgICAgbWV0YS5kYXRhW2RhdGFJbmRleF0uaGlkZGVuID0gIXZpc2libGU7XG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldERhdGFzZXRWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgdmlzaWJsZSk7XG4gICAgICAvLyBBbmltYXRlIHZpc2libGUgc3RhdGUsIHNvIGhpZGUgYW5pbWF0aW9uIGNhbiBiZSBzZWVuLiBUaGlzIGNvdWxkIGJlIGhhbmRsZWQgYmV0dGVyIGlmIHVwZGF0ZSAvIHVwZGF0ZURhdGFzZXQgcmV0dXJuZWQgYSBQcm9taXNlLlxuICAgICAgYW5pbXMudXBkYXRlKG1ldGEsIHt2aXNpYmxlfSk7XG4gICAgICB0aGlzLnVwZGF0ZSgoY3R4KSA9PiBjdHguZGF0YXNldEluZGV4ID09PSBkYXRhc2V0SW5kZXggPyBtb2RlIDogdW5kZWZpbmVkKTtcbiAgICB9XG4gIH1cblxuICBoaWRlKGRhdGFzZXRJbmRleCwgZGF0YUluZGV4KSB7XG4gICAgdGhpcy5fdXBkYXRlVmlzaWJpbGl0eShkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCwgZmFsc2UpO1xuICB9XG5cbiAgc2hvdyhkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCkge1xuICAgIHRoaXMuX3VwZGF0ZVZpc2liaWxpdHkoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgsIHRydWUpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZGVzdHJveURhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9tZXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xuICAgIGlmIChtZXRhICYmIG1ldGEuY29udHJvbGxlcikge1xuICAgICAgbWV0YS5jb250cm9sbGVyLl9kZXN0cm95KCk7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLl9tZXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xuICB9XG5cbiAgX3N0b3AoKSB7XG4gICAgbGV0IGksIGlsZW47XG4gICAgdGhpcy5zdG9wKCk7XG4gICAgYW5pbWF0b3IucmVtb3ZlKHRoaXMpO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRoaXMuX2Rlc3Ryb3lEYXRhc2V0TWV0YShpKTtcbiAgICB9XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRGVzdHJveScpO1xuICAgIGNvbnN0IHtjYW52YXMsIGN0eH0gPSB0aGlzO1xuXG4gICAgdGhpcy5fc3RvcCgpO1xuICAgIHRoaXMuY29uZmlnLmNsZWFyQ2FjaGUoKTtcblxuICAgIGlmIChjYW52YXMpIHtcbiAgICAgIHRoaXMudW5iaW5kRXZlbnRzKCk7XG4gICAgICBjbGVhckNhbnZhcyhjYW52YXMsIGN0eCk7XG4gICAgICB0aGlzLnBsYXRmb3JtLnJlbGVhc2VDb250ZXh0KGN0eCk7XG4gICAgICB0aGlzLmNhbnZhcyA9IG51bGw7XG4gICAgICB0aGlzLmN0eCA9IG51bGw7XG4gICAgfVxuXG4gICAgZGVsZXRlIGluc3RhbmNlc1t0aGlzLmlkXTtcblxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEZXN0cm95Jyk7XG4gIH1cblxuICB0b0Jhc2U2NEltYWdlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5jYW52YXMudG9EYXRhVVJMKC4uLmFyZ3MpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBiaW5kRXZlbnRzKCkge1xuICAgIHRoaXMuYmluZFVzZXJFdmVudHMoKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnJlc3BvbnNpdmUpIHtcbiAgICAgIHRoaXMuYmluZFJlc3BvbnNpdmVFdmVudHMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hdHRhY2hlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBiaW5kVXNlckV2ZW50cygpIHtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgY29uc3QgcGxhdGZvcm0gPSB0aGlzLnBsYXRmb3JtO1xuXG4gICAgY29uc3QgX2FkZCA9ICh0eXBlLCBsaXN0ZW5lcikgPT4ge1xuICAgICAgcGxhdGZvcm0uYWRkRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgICBsaXN0ZW5lcnNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICB9O1xuXG4gICAgY29uc3QgbGlzdGVuZXIgPSAoZSwgeCwgeSkgPT4ge1xuICAgICAgZS5vZmZzZXRYID0geDtcbiAgICAgIGUub2Zmc2V0WSA9IHk7XG4gICAgICB0aGlzLl9ldmVudEhhbmRsZXIoZSk7XG4gICAgfTtcblxuICAgIGVhY2godGhpcy5vcHRpb25zLmV2ZW50cywgKHR5cGUpID0+IF9hZGQodHlwZSwgbGlzdGVuZXIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYmluZFJlc3BvbnNpdmVFdmVudHMoKSB7XG4gICAgaWYgKCF0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzKSB7XG4gICAgICB0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzID0ge307XG4gICAgfVxuICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnM7XG4gICAgY29uc3QgcGxhdGZvcm0gPSB0aGlzLnBsYXRmb3JtO1xuXG4gICAgY29uc3QgX2FkZCA9ICh0eXBlLCBsaXN0ZW5lcikgPT4ge1xuICAgICAgcGxhdGZvcm0uYWRkRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgICBsaXN0ZW5lcnNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICB9O1xuICAgIGNvbnN0IF9yZW1vdmUgPSAodHlwZSwgbGlzdGVuZXIpID0+IHtcbiAgICAgIGlmIChsaXN0ZW5lcnNbdHlwZV0pIHtcbiAgICAgICAgcGxhdGZvcm0ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgICAgIGRlbGV0ZSBsaXN0ZW5lcnNbdHlwZV07XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGxpc3RlbmVyID0gKHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICB0aGlzLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbGV0IGRldGFjaGVkOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByZWZlci1jb25zdFxuICAgIGNvbnN0IGF0dGFjaGVkID0gKCkgPT4ge1xuICAgICAgX3JlbW92ZSgnYXR0YWNoJywgYXR0YWNoZWQpO1xuXG4gICAgICB0aGlzLmF0dGFjaGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVzaXplKCk7XG5cbiAgICAgIF9hZGQoJ3Jlc2l6ZScsIGxpc3RlbmVyKTtcbiAgICAgIF9hZGQoJ2RldGFjaCcsIGRldGFjaGVkKTtcbiAgICB9O1xuXG4gICAgZGV0YWNoZWQgPSAoKSA9PiB7XG4gICAgICB0aGlzLmF0dGFjaGVkID0gZmFsc2U7XG5cbiAgICAgIF9yZW1vdmUoJ3Jlc2l6ZScsIGxpc3RlbmVyKTtcblxuICAgICAgLy8gU3RvcCBhbmltYXRpbmcgYW5kIHJlbW92ZSBtZXRhc2V0cywgc28gd2hlbiByZS1hdHRhY2hlZCwgdGhlIGFuaW1hdGlvbnMgc3RhcnQgZnJvbSBiZWdpbm5pbmcuXG4gICAgICB0aGlzLl9zdG9wKCk7XG4gICAgICB0aGlzLl9yZXNpemUoMCwgMCk7XG5cbiAgICAgIF9hZGQoJ2F0dGFjaCcsIGF0dGFjaGVkKTtcbiAgICB9O1xuXG4gICAgaWYgKHBsYXRmb3JtLmlzQXR0YWNoZWQodGhpcy5jYW52YXMpKSB7XG4gICAgICBhdHRhY2hlZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZXRhY2hlZCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgdW5iaW5kRXZlbnRzKCkge1xuICAgIGVhY2godGhpcy5fbGlzdGVuZXJzLCAobGlzdGVuZXIsIHR5cGUpID0+IHtcbiAgICAgIHRoaXMucGxhdGZvcm0ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgfSk7XG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG5cbiAgICBlYWNoKHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMsIChsaXN0ZW5lciwgdHlwZSkgPT4ge1xuICAgICAgdGhpcy5wbGF0Zm9ybS5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICB9KTtcbiAgICB0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgdXBkYXRlSG92ZXJTdHlsZShpdGVtcywgbW9kZSwgZW5hYmxlZCkge1xuICAgIGNvbnN0IHByZWZpeCA9IGVuYWJsZWQgPyAnc2V0JyA6ICdyZW1vdmUnO1xuICAgIGxldCBtZXRhLCBpdGVtLCBpLCBpbGVuO1xuXG4gICAgaWYgKG1vZGUgPT09ICdkYXRhc2V0Jykge1xuICAgICAgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoaXRlbXNbMF0uZGF0YXNldEluZGV4KTtcbiAgICAgIG1ldGEuY29udHJvbGxlclsnXycgKyBwcmVmaXggKyAnRGF0YXNldEhvdmVyU3R5bGUnXSgpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBpdGVtICYmIHRoaXMuZ2V0RGF0YXNldE1ldGEoaXRlbS5kYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXI7XG4gICAgICBpZiAoY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyW3ByZWZpeCArICdIb3ZlclN0eWxlJ10oaXRlbS5lbGVtZW50LCBpdGVtLmRhdGFzZXRJbmRleCwgaXRlbS5pbmRleCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEdldCBhY3RpdmUgKGhvdmVyZWQpIGVsZW1lbnRzXG5cdCAqIEByZXR1cm5zIGFycmF5XG5cdCAqL1xuICBnZXRBY3RpdmVFbGVtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlIHx8IFtdO1xuICB9XG5cbiAgLyoqXG5cdCAqIFNldCBhY3RpdmUgKGhvdmVyZWQpIGVsZW1lbnRzXG5cdCAqIEBwYXJhbSB7YXJyYXl9IGFjdGl2ZUVsZW1lbnRzIE5ldyBhY3RpdmUgZGF0YSBwb2ludHNcblx0ICovXG4gIHNldEFjdGl2ZUVsZW1lbnRzKGFjdGl2ZUVsZW1lbnRzKSB7XG4gICAgY29uc3QgbGFzdEFjdGl2ZSA9IHRoaXMuX2FjdGl2ZSB8fCBbXTtcbiAgICBjb25zdCBhY3RpdmUgPSBhY3RpdmVFbGVtZW50cy5tYXAoKHtkYXRhc2V0SW5kZXgsIGluZGV4fSkgPT4ge1xuICAgICAgY29uc3QgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICAgIGlmICghbWV0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGRhdGFzZXQgZm91bmQgYXQgaW5kZXggJyArIGRhdGFzZXRJbmRleCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGFzZXRJbmRleCxcbiAgICAgICAgZWxlbWVudDogbWV0YS5kYXRhW2luZGV4XSxcbiAgICAgICAgaW5kZXgsXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IGNoYW5nZWQgPSAhX2VsZW1lbnRzRXF1YWwoYWN0aXZlLCBsYXN0QWN0aXZlKTtcblxuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XG4gICAgICAvLyBNYWtlIHN1cmUgd2UgZG9uJ3QgdXNlIHRoZSBwcmV2aW91cyBtb3VzZSBldmVudCB0byBvdmVycmlkZSB0aGUgYWN0aXZlIGVsZW1lbnRzIGluIHVwZGF0ZS5cbiAgICAgIHRoaXMuX2xhc3RFdmVudCA9IG51bGw7XG4gICAgICB0aGlzLl91cGRhdGVIb3ZlclN0eWxlcyhhY3RpdmUsIGxhc3RBY3RpdmUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBDYWxscyBlbmFibGVkIHBsdWdpbnMgb24gdGhlIHNwZWNpZmllZCBob29rIGFuZCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxuXHQgKiBUaGlzIG1ldGhvZCBpbW1lZGlhdGVseSByZXR1cm5zIGFzIHNvb24gYXMgYSBwbHVnaW4gZXhwbGljaXRseSByZXR1cm5zIGZhbHNlLiBUaGVcblx0ICogcmV0dXJuZWQgdmFsdWUgY2FuIGJlIHVzZWQsIGZvciBpbnN0YW5jZSwgdG8gaW50ZXJydXB0IHRoZSBjdXJyZW50IGFjdGlvbi5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGhvb2sgLSBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luIG1ldGhvZCB0byBjYWxsIChlLmcuICdiZWZvcmVVcGRhdGUnKS5cblx0ICogQHBhcmFtIHtPYmplY3R9IFthcmdzXSAtIEV4dHJhIGFyZ3VtZW50cyB0byBhcHBseSB0byB0aGUgaG9vayBjYWxsLlxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi9jb3JlLnBsdWdpbnMuanMnKS5maWx0ZXJDYWxsYmFja30gW2ZpbHRlcl0gLSBGaWx0ZXJpbmcgZnVuY3Rpb24gZm9yIGxpbWl0aW5nIHdoaWNoIHBsdWdpbnMgYXJlIG5vdGlmaWVkXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBmYWxzZSBpZiBhbnkgb2YgdGhlIHBsdWdpbnMgcmV0dXJuIGZhbHNlLCBlbHNlIHJldHVybnMgdHJ1ZS5cblx0ICovXG4gIG5vdGlmeVBsdWdpbnMoaG9vaywgYXJncywgZmlsdGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BsdWdpbnMubm90aWZ5KHRoaXMsIGhvb2ssIGFyZ3MsIGZpbHRlcik7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBwbHVnaW4gd2l0aCB0aGUgc3BlY2lmaWMgSUQgaXMgcmVnaXN0ZXJlZCBhbmQgZW5hYmxlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGx1Z2luSWQgLSBUaGUgSUQgb2YgdGhlIHBsdWdpbiBvZiB3aGljaCB0byBjaGVjayBpZiBpdCBpcyBlbmFibGVkXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgaXNQbHVnaW5FbmFibGVkKHBsdWdpbklkKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BsdWdpbnMuX2NhY2hlLmZpbHRlcihwID0+IHAucGx1Z2luLmlkID09PSBwbHVnaW5JZCkubGVuZ3RoID09PSAxO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfdXBkYXRlSG92ZXJTdHlsZXMoYWN0aXZlLCBsYXN0QWN0aXZlLCByZXBsYXkpIHtcbiAgICBjb25zdCBob3Zlck9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuaG92ZXI7XG4gICAgY29uc3QgZGlmZiA9IChhLCBiKSA9PiBhLmZpbHRlcih4ID0+ICFiLnNvbWUoeSA9PiB4LmRhdGFzZXRJbmRleCA9PT0geS5kYXRhc2V0SW5kZXggJiYgeC5pbmRleCA9PT0geS5pbmRleCkpO1xuICAgIGNvbnN0IGRlYWN0aXZhdGVkID0gZGlmZihsYXN0QWN0aXZlLCBhY3RpdmUpO1xuICAgIGNvbnN0IGFjdGl2YXRlZCA9IHJlcGxheSA/IGFjdGl2ZSA6IGRpZmYoYWN0aXZlLCBsYXN0QWN0aXZlKTtcblxuICAgIGlmIChkZWFjdGl2YXRlZC5sZW5ndGgpIHtcbiAgICAgIHRoaXMudXBkYXRlSG92ZXJTdHlsZShkZWFjdGl2YXRlZCwgaG92ZXJPcHRpb25zLm1vZGUsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aXZhdGVkLmxlbmd0aCAmJiBob3Zlck9wdGlvbnMubW9kZSkge1xuICAgICAgdGhpcy51cGRhdGVIb3ZlclN0eWxlKGFjdGl2YXRlZCwgaG92ZXJPcHRpb25zLm1vZGUsIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2V2ZW50SGFuZGxlcihlLCByZXBsYXkpIHtcbiAgICBjb25zdCBhcmdzID0ge1xuICAgICAgZXZlbnQ6IGUsXG4gICAgICByZXBsYXksXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgaW5DaGFydEFyZWE6IHRoaXMuaXNQb2ludEluQXJlYShlKVxuICAgIH07XG4gICAgY29uc3QgZXZlbnRGaWx0ZXIgPSAocGx1Z2luKSA9PiAocGx1Z2luLm9wdGlvbnMuZXZlbnRzIHx8IHRoaXMub3B0aW9ucy5ldmVudHMpLmluY2x1ZGVzKGUubmF0aXZlLnR5cGUpO1xuXG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRXZlbnQnLCBhcmdzLCBldmVudEZpbHRlcikgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY2hhbmdlZCA9IHRoaXMuX2hhbmRsZUV2ZW50KGUsIHJlcGxheSwgYXJncy5pbkNoYXJ0QXJlYSk7XG5cbiAgICBhcmdzLmNhbmNlbGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRXZlbnQnLCBhcmdzLCBldmVudEZpbHRlcik7XG5cbiAgICBpZiAoY2hhbmdlZCB8fCBhcmdzLmNoYW5nZWQpIHtcbiAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcblx0ICogSGFuZGxlIGFuIGV2ZW50XG5cdCAqIEBwYXJhbSB7Q2hhcnRFdmVudH0gZSB0aGUgZXZlbnQgdG8gaGFuZGxlXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlcGxheV0gLSB0cnVlIGlmIHRoZSBldmVudCB3YXMgcmVwbGF5ZWQgYnkgYHVwZGF0ZWBcbiAgICogQHBhcmFtIHtib29sZWFufSBbaW5DaGFydEFyZWFdIC0gdHJ1ZSBpZiB0aGUgZXZlbnQgaXMgaW5zaWRlIGNoYXJ0QXJlYVxuXHQgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBjaGFydCBuZWVkcyB0byByZS1yZW5kZXJcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9oYW5kbGVFdmVudChlLCByZXBsYXksIGluQ2hhcnRBcmVhKSB7XG4gICAgY29uc3Qge19hY3RpdmU6IGxhc3RBY3RpdmUgPSBbXSwgb3B0aW9uc30gPSB0aGlzO1xuXG4gICAgLy8gSWYgdGhlIGV2ZW50IGlzIHJlcGxheWVkIGZyb20gYHVwZGF0ZWAsIHdlIHNob3VsZCBldmFsdWF0ZSB3aXRoIHRoZSBmaW5hbCBwb3NpdGlvbnMuXG4gICAgLy9cbiAgICAvLyBUaGUgYHJlcGxheWA6XG4gICAgLy8gSXQncyB0aGUgbGFzdCBldmVudCAoZXhjbHVkaW5nIGNsaWNrKSB0aGF0IGhhcyBvY2N1cnJlZCBiZWZvcmUgYHVwZGF0ZWAuXG4gICAgLy8gU28gbW91c2UgaGFzIG5vdCBtb3ZlZC4gSXQncyBhbHNvIG92ZXIgdGhlIGNoYXJ0LCBiZWNhdXNlIHRoZXJlIGlzIGEgYHJlcGxheWAuXG4gICAgLy9cbiAgICAvLyBUaGUgd2h5OlxuICAgIC8vIElmIGFuaW1hdGlvbnMgYXJlIGFjdGl2ZSwgdGhlIGVsZW1lbnRzIGhhdmVuJ3QgbW92ZWQgeWV0IGNvbXBhcmVkIHRvIHN0YXRlIGJlZm9yZSB1cGRhdGUuXG4gICAgLy8gQnV0IGlmIHRoZXkgd2lsbCwgd2UgYXJlIGFjdGl2YXRpbmcgdGhlIGVsZW1lbnRzIHRoYXQgd291bGQgYmUgYWN0aXZlLCBpZiB0aGlzIGNoZWNrXG4gICAgLy8gd2FzIGRvbmUgYWZ0ZXIgdGhlIGFuaW1hdGlvbnMgaGF2ZSBjb21wbGV0ZWQuID0+IFwiZmluYWwgcG9zaXRpb25zXCIuXG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gYW5pbWF0aW9ucywgdGhlIFwiZmluYWxcIiBhbmQgXCJjdXJyZW50XCIgcG9zaXRpb25zIGFyZSBlcXVhbC5cbiAgICAvLyBUaGlzIGlzIGRvbmUgc28gd2UgZG8gbm90IGhhdmUgdG8gZXZhbHVhdGUgdGhlIGFjdGl2ZSBlbGVtZW50cyBlYWNoIGFuaW1hdGlvbiBmcmFtZVxuICAgIC8vIC0gaXQgd291bGQgYmUgZXhwZW5zaXZlLlxuICAgIGNvbnN0IHVzZUZpbmFsUG9zaXRpb24gPSByZXBsYXk7XG4gICAgY29uc3QgYWN0aXZlID0gdGhpcy5fZ2V0QWN0aXZlRWxlbWVudHMoZSwgbGFzdEFjdGl2ZSwgaW5DaGFydEFyZWEsIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IGlzQ2xpY2sgPSBfaXNDbGlja0V2ZW50KGUpO1xuICAgIGNvbnN0IGxhc3RFdmVudCA9IGRldGVybWluZUxhc3RFdmVudChlLCB0aGlzLl9sYXN0RXZlbnQsIGluQ2hhcnRBcmVhLCBpc0NsaWNrKTtcblxuICAgIGlmIChpbkNoYXJ0QXJlYSkge1xuICAgICAgLy8gU2V0IF9sYXN0RXZlbnQgdG8gbnVsbCB3aGlsZSB3ZSBhcmUgcHJvY2Vzc2luZyB0aGUgZXZlbnQgaGFuZGxlcnMuXG4gICAgICAvLyBUaGlzIHByZXZlbnRzIHJlY3Vyc2lvbiBpZiB0aGUgaGFuZGxlciBjYWxscyBjaGFydC51cGRhdGUoKVxuICAgICAgdGhpcy5fbGFzdEV2ZW50ID0gbnVsbDtcblxuICAgICAgLy8gSW52b2tlIG9uSG92ZXIgaG9va1xuICAgICAgY2FsbENhbGxiYWNrKG9wdGlvbnMub25Ib3ZlciwgW2UsIGFjdGl2ZSwgdGhpc10sIHRoaXMpO1xuXG4gICAgICBpZiAoaXNDbGljaykge1xuICAgICAgICBjYWxsQ2FsbGJhY2sob3B0aW9ucy5vbkNsaWNrLCBbZSwgYWN0aXZlLCB0aGlzXSwgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgY2hhbmdlZCA9ICFfZWxlbWVudHNFcXVhbChhY3RpdmUsIGxhc3RBY3RpdmUpO1xuICAgIGlmIChjaGFuZ2VkIHx8IHJlcGxheSkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gYWN0aXZlO1xuICAgICAgdGhpcy5fdXBkYXRlSG92ZXJTdHlsZXMoYWN0aXZlLCBsYXN0QWN0aXZlLCByZXBsYXkpO1xuICAgIH1cblxuICAgIHRoaXMuX2xhc3RFdmVudCA9IGxhc3RFdmVudDtcblxuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q2hhcnRFdmVudH0gZSAtIFRoZSBldmVudFxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5BY3RpdmVFbGVtZW50W119IGxhc3RBY3RpdmUgLSBQcmV2aW91c2x5IGFjdGl2ZSBlbGVtZW50c1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGluQ2hhcnRBcmVhIC0gSXMgdGhlIGV2ZW50IGluc2lkZSBjaGFydEFyZWFcbiAgICogQHBhcmFtIHtib29sZWFufSB1c2VGaW5hbFBvc2l0aW9uIC0gU2hvdWxkIHRoZSBldmFsdWF0aW9uIGJlIGRvbmUgd2l0aCBjdXJyZW50IG9yIGZpbmFsIChhZnRlciBhbmltYXRpb24pIGVsZW1lbnQgcG9zaXRpb25zXG4gICAqIEByZXR1cm5zIHtpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuQWN0aXZlRWxlbWVudFtdfSAtIFRoZSBhY3RpdmUgZWxlbWVudHNcbiAgICogQHByYXZhdGVcbiAgICovXG4gIF9nZXRBY3RpdmVFbGVtZW50cyhlLCBsYXN0QWN0aXZlLCBpbkNoYXJ0QXJlYSwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBpZiAoIWluQ2hhcnRBcmVhKSB7XG4gICAgICAvLyBMZXQgdXNlciBjb250cm9sIHRoZSBhY3RpdmUgZWxlbWVudHMgb3V0c2lkZSBjaGFydEFyZWEuIEVnLiB1c2luZyBMZWdlbmQuXG4gICAgICByZXR1cm4gbGFzdEFjdGl2ZTtcbiAgICB9XG5cbiAgICBjb25zdCBob3Zlck9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuaG92ZXI7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZShlLCBob3Zlck9wdGlvbnMubW9kZSwgaG92ZXJPcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxufVxuXG4vLyBAdHMtaWdub3JlXG5mdW5jdGlvbiBpbnZhbGlkYXRlUGx1Z2lucygpIHtcbiAgcmV0dXJuIGVhY2goQ2hhcnQuaW5zdGFuY2VzLCAoY2hhcnQpID0+IGNoYXJ0Ll9wbHVnaW5zLmludmFsaWRhdGUoKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IENoYXJ0O1xuIiwiaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi4vY29yZS9jb3JlLmVsZW1lbnQuanMnO1xuaW1wb3J0IHtfYW5nbGVCZXR3ZWVuLCBnZXRBbmdsZUZyb21Qb2ludCwgVEFVLCBIQUxGX1BJLCB2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQge1BJLCBfYW5nbGVEaWZmLCBfbm9ybWFsaXplQW5nbGUsIF9pc0JldHdlZW4sIF9saW1pdFZhbHVlfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQge19yZWFkVmFsdWVUb1Byb3BzfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMub3B0aW9ucy5qcyc7XG5pbXBvcnQgdHlwZSB7QXJjT3B0aW9ucywgUG9pbnR9IGZyb20gJy4uL3R5cGVzL2luZGV4LmpzJztcblxuZnVuY3Rpb24gY2xpcFNlbGYoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGVsZW1lbnQ6IEFyY0VsZW1lbnQsIGVuZEFuZ2xlOiBudW1iZXIpIHtcbiAgY29uc3Qge3N0YXJ0QW5nbGUsIHgsIHksIG91dGVyUmFkaXVzLCBpbm5lclJhZGl1cywgb3B0aW9uc30gPSBlbGVtZW50O1xuICBjb25zdCB7Ym9yZGVyV2lkdGgsIGJvcmRlckpvaW5TdHlsZX0gPSBvcHRpb25zO1xuICBjb25zdCBvdXRlckFuZ2xlQ2xpcCA9IE1hdGgubWluKGJvcmRlcldpZHRoIC8gb3V0ZXJSYWRpdXMsIF9ub3JtYWxpemVBbmdsZShzdGFydEFuZ2xlIC0gZW5kQW5nbGUpKTtcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHguYXJjKHgsIHksIG91dGVyUmFkaXVzIC0gYm9yZGVyV2lkdGggLyAyLCBzdGFydEFuZ2xlICsgb3V0ZXJBbmdsZUNsaXAgLyAyLCBlbmRBbmdsZSAtIG91dGVyQW5nbGVDbGlwIC8gMik7XG5cbiAgaWYgKGlubmVyUmFkaXVzID4gMCkge1xuICAgIGNvbnN0IGlubmVyQW5nbGVDbGlwID0gTWF0aC5taW4oYm9yZGVyV2lkdGggLyBpbm5lclJhZGl1cywgX25vcm1hbGl6ZUFuZ2xlKHN0YXJ0QW5nbGUgLSBlbmRBbmdsZSkpO1xuICAgIGN0eC5hcmMoeCwgeSwgaW5uZXJSYWRpdXMgKyBib3JkZXJXaWR0aCAvIDIsIGVuZEFuZ2xlIC0gaW5uZXJBbmdsZUNsaXAgLyAyLCBzdGFydEFuZ2xlICsgaW5uZXJBbmdsZUNsaXAgLyAyLCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjbGlwV2lkdGggPSBNYXRoLm1pbihib3JkZXJXaWR0aCAvIDIsIG91dGVyUmFkaXVzICogX25vcm1hbGl6ZUFuZ2xlKHN0YXJ0QW5nbGUgLSBlbmRBbmdsZSkpO1xuXG4gICAgaWYgKGJvcmRlckpvaW5TdHlsZSA9PT0gJ3JvdW5kJykge1xuICAgICAgY3R4LmFyYyh4LCB5LCBjbGlwV2lkdGgsIGVuZEFuZ2xlIC0gUEkgLyAyLCBzdGFydEFuZ2xlICsgUEkgLyAyLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKGJvcmRlckpvaW5TdHlsZSA9PT0gJ2JldmVsJykge1xuICAgICAgY29uc3QgciA9IDIgKiBjbGlwV2lkdGggKiBjbGlwV2lkdGg7XG4gICAgICBjb25zdCBlbmRYID0gLXIgKiBNYXRoLmNvcyhlbmRBbmdsZSArIFBJIC8gMikgKyB4O1xuICAgICAgY29uc3QgZW5kWSA9IC1yICogTWF0aC5zaW4oZW5kQW5nbGUgKyBQSSAvIDIpICsgeTtcbiAgICAgIGNvbnN0IHN0YXJ0WCA9IHIgKiBNYXRoLmNvcyhzdGFydEFuZ2xlICsgUEkgLyAyKSArIHg7XG4gICAgICBjb25zdCBzdGFydFkgPSByICogTWF0aC5zaW4oc3RhcnRBbmdsZSArIFBJIC8gMikgKyB5O1xuICAgICAgY3R4LmxpbmVUbyhlbmRYLCBlbmRZKTtcbiAgICAgIGN0eC5saW5lVG8oc3RhcnRYLCBzdGFydFkpO1xuICAgIH1cbiAgfVxuICBjdHguY2xvc2VQYXRoKCk7XG5cbiAgY3R4Lm1vdmVUbygwLCAwKTtcbiAgY3R4LnJlY3QoMCwgMCwgY3R4LmNhbnZhcy53aWR0aCwgY3R4LmNhbnZhcy5oZWlnaHQpO1xuXG4gIGN0eC5jbGlwKCdldmVub2RkJyk7XG59XG5cblxuZnVuY3Rpb24gY2xpcEFyYyhjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgZWxlbWVudDogQXJjRWxlbWVudCwgZW5kQW5nbGU6IG51bWJlcikge1xuICBjb25zdCB7c3RhcnRBbmdsZSwgcGl4ZWxNYXJnaW4sIHgsIHksIG91dGVyUmFkaXVzLCBpbm5lclJhZGl1c30gPSBlbGVtZW50O1xuICBsZXQgYW5nbGVNYXJnaW4gPSBwaXhlbE1hcmdpbiAvIG91dGVyUmFkaXVzO1xuXG4gIC8vIERyYXcgYW4gaW5uZXIgYm9yZGVyIGJ5IGNsaXBwaW5nIHRoZSBhcmMgYW5kIGRyYXdpbmcgYSBkb3VibGUtd2lkdGggYm9yZGVyXG4gIC8vIEVubGFyZ2UgdGhlIGNsaXBwaW5nIGFyYyBieSAwLjMzIHBpeGVscyB0byBlbGltaW5hdGUgZ2xpdGNoZXMgYmV0d2VlbiBib3JkZXJzXG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LmFyYyh4LCB5LCBvdXRlclJhZGl1cywgc3RhcnRBbmdsZSAtIGFuZ2xlTWFyZ2luLCBlbmRBbmdsZSArIGFuZ2xlTWFyZ2luKTtcbiAgaWYgKGlubmVyUmFkaXVzID4gcGl4ZWxNYXJnaW4pIHtcbiAgICBhbmdsZU1hcmdpbiA9IHBpeGVsTWFyZ2luIC8gaW5uZXJSYWRpdXM7XG4gICAgY3R4LmFyYyh4LCB5LCBpbm5lclJhZGl1cywgZW5kQW5nbGUgKyBhbmdsZU1hcmdpbiwgc3RhcnRBbmdsZSAtIGFuZ2xlTWFyZ2luLCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBjdHguYXJjKHgsIHksIHBpeGVsTWFyZ2luLCBlbmRBbmdsZSArIEhBTEZfUEksIHN0YXJ0QW5nbGUgLSBIQUxGX1BJKTtcbiAgfVxuICBjdHguY2xvc2VQYXRoKCk7XG4gIGN0eC5jbGlwKCk7XG59XG5cbmZ1bmN0aW9uIHRvUmFkaXVzQ29ybmVycyh2YWx1ZSkge1xuICByZXR1cm4gX3JlYWRWYWx1ZVRvUHJvcHModmFsdWUsIFsnb3V0ZXJTdGFydCcsICdvdXRlckVuZCcsICdpbm5lclN0YXJ0JywgJ2lubmVyRW5kJ10pO1xufVxuXG4vKipcbiAqIFBhcnNlIGJvcmRlciByYWRpdXMgZnJvbSB0aGUgcHJvdmlkZWQgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBwYXJzZUJvcmRlclJhZGl1cyhhcmM6IEFyY0VsZW1lbnQsIGlubmVyUmFkaXVzOiBudW1iZXIsIG91dGVyUmFkaXVzOiBudW1iZXIsIGFuZ2xlRGVsdGE6IG51bWJlcikge1xuICBjb25zdCBvID0gdG9SYWRpdXNDb3JuZXJzKGFyYy5vcHRpb25zLmJvcmRlclJhZGl1cyk7XG4gIGNvbnN0IGhhbGZUaGlja25lc3MgPSAob3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cykgLyAyO1xuICBjb25zdCBpbm5lckxpbWl0ID0gTWF0aC5taW4oaGFsZlRoaWNrbmVzcywgYW5nbGVEZWx0YSAqIGlubmVyUmFkaXVzIC8gMik7XG5cbiAgLy8gT3V0ZXIgbGltaXRzIGFyZSBjb21wbGljYXRlZC4gV2Ugd2FudCB0byBjb21wdXRlIHRoZSBhdmFpbGFibGUgYW5ndWxhciBkaXN0YW5jZSBhdFxuICAvLyBhIHJhZGl1cyBvZiBvdXRlclJhZGl1cyAtIGJvcmRlclJhZGl1cyBiZWNhdXNlIGZvciBzbWFsbCBhbmd1bGFyIGRpc3RhbmNlcywgdGhpcyB0ZXJtIGxpbWl0cy5cbiAgLy8gV2UgY29tcHV0ZSBhdCByID0gb3V0ZXJSYWRpdXMgLSBib3JkZXJSYWRpdXMgYmVjYXVzZSB0aGlzIGNpcmNsZSBkZWZpbmVzIHRoZSBjZW50ZXIgb2YgdGhlIGJvcmRlciBjb3JuZXJzLlxuICAvL1xuICAvLyBJZiB0aGUgYm9yZGVyUmFkaXVzIGlzIGxhcmdlLCB0aGF0IHZhbHVlIGNhbiBiZWNvbWUgbmVnYXRpdmUuXG4gIC8vIFRoaXMgY2F1c2VzIHRoZSBvdXRlciBib3JkZXJzIHRvIGxvc2UgdGhlaXIgcmFkaXVzIGVudGlyZWx5LCB3aGljaCBpcyByYXRoZXIgdW5leHBlY3RlZC4gVG8gc29sdmUgdGhhdCwgaWYgYm9yZGVyUmFkaXVzID4gb3V0ZXJSYWRpdXNcbiAgLy8gd2Uga25vdyB0aGF0IHRoZSB0aGlja25lc3MgdGVybSB3aWxsIGRvbWluYXRlIGFuZCBjb21wdXRlIHRoZSBsaW1pdHMgYXQgdGhhdCBwb2ludFxuICBjb25zdCBjb21wdXRlT3V0ZXJMaW1pdCA9ICh2YWwpID0+IHtcbiAgICBjb25zdCBvdXRlckFyY0xpbWl0ID0gKG91dGVyUmFkaXVzIC0gTWF0aC5taW4oaGFsZlRoaWNrbmVzcywgdmFsKSkgKiBhbmdsZURlbHRhIC8gMjtcbiAgICByZXR1cm4gX2xpbWl0VmFsdWUodmFsLCAwLCBNYXRoLm1pbihoYWxmVGhpY2tuZXNzLCBvdXRlckFyY0xpbWl0KSk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBvdXRlclN0YXJ0OiBjb21wdXRlT3V0ZXJMaW1pdChvLm91dGVyU3RhcnQpLFxuICAgIG91dGVyRW5kOiBjb21wdXRlT3V0ZXJMaW1pdChvLm91dGVyRW5kKSxcbiAgICBpbm5lclN0YXJ0OiBfbGltaXRWYWx1ZShvLmlubmVyU3RhcnQsIDAsIGlubmVyTGltaXQpLFxuICAgIGlubmVyRW5kOiBfbGltaXRWYWx1ZShvLmlubmVyRW5kLCAwLCBpbm5lckxpbWl0KSxcbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IChyLCDwnZyDKSB0byAoeCwgeSlcbiAqL1xuZnVuY3Rpb24gclRoZXRhVG9YWShyOiBudW1iZXIsIHRoZXRhOiBudW1iZXIsIHg6IG51bWJlciwgeTogbnVtYmVyKSB7XG4gIHJldHVybiB7XG4gICAgeDogeCArIHIgKiBNYXRoLmNvcyh0aGV0YSksXG4gICAgeTogeSArIHIgKiBNYXRoLnNpbih0aGV0YSksXG4gIH07XG59XG5cblxuLyoqXG4gKiBQYXRoIHRoZSBhcmMsIHJlc3BlY3RpbmcgYm9yZGVyIHJhZGl1cyBieSBzZXBhcmF0aW5nIGludG8gbGVmdCBhbmQgcmlnaHQgaGFsdmVzLlxuICpcbiAqICAgU3RhcnQgICAgICBFbmRcbiAqXG4gKiAgICAxLS0tPmEtLS0+MiAgICBPdXRlclxuICogICAvICAgICAgICAgICBcXFxuICogICA4ICAgICAgICAgICAzXG4gKiAgIHwgICAgICAgICAgIHxcbiAqICAgfCAgICAgICAgICAgfFxuICogICA3ICAgICAgICAgICA0XG4gKiAgIFxcICAgICAgICAgICAvXG4gKiAgICA2PC0tLWI8LS0tNSAgICBJbm5lclxuICovXG5mdW5jdGlvbiBwYXRoQXJjKFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgZWxlbWVudDogQXJjRWxlbWVudCxcbiAgb2Zmc2V0OiBudW1iZXIsXG4gIHNwYWNpbmc6IG51bWJlcixcbiAgZW5kOiBudW1iZXIsXG4gIGNpcmN1bGFyOiBib29sZWFuLFxuKSB7XG4gIGNvbnN0IHt4LCB5LCBzdGFydEFuZ2xlOiBzdGFydCwgcGl4ZWxNYXJnaW4sIGlubmVyUmFkaXVzOiBpbm5lclJ9ID0gZWxlbWVudDtcblxuICBjb25zdCBvdXRlclJhZGl1cyA9IE1hdGgubWF4KGVsZW1lbnQub3V0ZXJSYWRpdXMgKyBzcGFjaW5nICsgb2Zmc2V0IC0gcGl4ZWxNYXJnaW4sIDApO1xuICBjb25zdCBpbm5lclJhZGl1cyA9IGlubmVyUiA+IDAgPyBpbm5lclIgKyBzcGFjaW5nICsgb2Zmc2V0ICsgcGl4ZWxNYXJnaW4gOiAwO1xuXG4gIGxldCBzcGFjaW5nT2Zmc2V0ID0gMDtcbiAgY29uc3QgYWxwaGEgPSBlbmQgLSBzdGFydDtcblxuICBpZiAoc3BhY2luZykge1xuICAgIC8vIFdoZW4gc3BhY2luZyBpcyBwcmVzZW50LCBpdCBpcyB0aGUgc2FtZSBmb3IgYWxsIGl0ZW1zXG4gICAgLy8gU28gd2UgYWRqdXN0IHRoZSBzdGFydCBhbmQgZW5kIGFuZ2xlIG9mIHRoZSBhcmMgc3VjaCB0aGF0XG4gICAgLy8gdGhlIGRpc3RhbmNlIGlzIHRoZSBzYW1lIGFzIGl0IHdvdWxkIGJlIHdpdGhvdXQgdGhlIHNwYWNpbmdcbiAgICBjb25zdCBub1NwYWNpbmdJbm5lclJhZGl1cyA9IGlubmVyUiA+IDAgPyBpbm5lclIgLSBzcGFjaW5nIDogMDtcbiAgICBjb25zdCBub1NwYWNpbmdPdXRlclJhZGl1cyA9IG91dGVyUmFkaXVzID4gMCA/IG91dGVyUmFkaXVzIC0gc3BhY2luZyA6IDA7XG4gICAgY29uc3QgYXZOb2dTcGFjaW5nUmFkaXVzID0gKG5vU3BhY2luZ0lubmVyUmFkaXVzICsgbm9TcGFjaW5nT3V0ZXJSYWRpdXMpIC8gMjtcbiAgICBjb25zdCBhZGp1c3RlZEFuZ2xlID0gYXZOb2dTcGFjaW5nUmFkaXVzICE9PSAwID8gKGFscGhhICogYXZOb2dTcGFjaW5nUmFkaXVzKSAvIChhdk5vZ1NwYWNpbmdSYWRpdXMgKyBzcGFjaW5nKSA6IGFscGhhO1xuICAgIHNwYWNpbmdPZmZzZXQgPSAoYWxwaGEgLSBhZGp1c3RlZEFuZ2xlKSAvIDI7XG4gIH1cblxuICBjb25zdCBiZXRhID0gTWF0aC5tYXgoMC4wMDEsIGFscGhhICogb3V0ZXJSYWRpdXMgLSBvZmZzZXQgLyBQSSkgLyBvdXRlclJhZGl1cztcbiAgY29uc3QgYW5nbGVPZmZzZXQgPSAoYWxwaGEgLSBiZXRhKSAvIDI7XG4gIGNvbnN0IHN0YXJ0QW5nbGUgPSBzdGFydCArIGFuZ2xlT2Zmc2V0ICsgc3BhY2luZ09mZnNldDtcbiAgY29uc3QgZW5kQW5nbGUgPSBlbmQgLSBhbmdsZU9mZnNldCAtIHNwYWNpbmdPZmZzZXQ7XG4gIGNvbnN0IHtvdXRlclN0YXJ0LCBvdXRlckVuZCwgaW5uZXJTdGFydCwgaW5uZXJFbmR9ID0gcGFyc2VCb3JkZXJSYWRpdXMoZWxlbWVudCwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCBlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpO1xuXG4gIGNvbnN0IG91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cyA9IG91dGVyUmFkaXVzIC0gb3V0ZXJTdGFydDtcbiAgY29uc3Qgb3V0ZXJFbmRBZGp1c3RlZFJhZGl1cyA9IG91dGVyUmFkaXVzIC0gb3V0ZXJFbmQ7XG4gIGNvbnN0IG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlID0gc3RhcnRBbmdsZSArIG91dGVyU3RhcnQgLyBvdXRlclN0YXJ0QWRqdXN0ZWRSYWRpdXM7XG4gIGNvbnN0IG91dGVyRW5kQWRqdXN0ZWRBbmdsZSA9IGVuZEFuZ2xlIC0gb3V0ZXJFbmQgLyBvdXRlckVuZEFkanVzdGVkUmFkaXVzO1xuXG4gIGNvbnN0IGlubmVyU3RhcnRBZGp1c3RlZFJhZGl1cyA9IGlubmVyUmFkaXVzICsgaW5uZXJTdGFydDtcbiAgY29uc3QgaW5uZXJFbmRBZGp1c3RlZFJhZGl1cyA9IGlubmVyUmFkaXVzICsgaW5uZXJFbmQ7XG4gIGNvbnN0IGlubmVyU3RhcnRBZGp1c3RlZEFuZ2xlID0gc3RhcnRBbmdsZSArIGlubmVyU3RhcnQgLyBpbm5lclN0YXJ0QWRqdXN0ZWRSYWRpdXM7XG4gIGNvbnN0IGlubmVyRW5kQWRqdXN0ZWRBbmdsZSA9IGVuZEFuZ2xlIC0gaW5uZXJFbmQgLyBpbm5lckVuZEFkanVzdGVkUmFkaXVzO1xuXG4gIGN0eC5iZWdpblBhdGgoKTtcblxuICBpZiAoY2lyY3VsYXIpIHtcbiAgICAvLyBUaGUgZmlyc3QgYXJjIHNlZ21lbnRzIGZyb20gcG9pbnQgMSB0byBwb2ludCBhIHRvIHBvaW50IDJcbiAgICBjb25zdCBvdXRlck1pZEFkanVzdGVkQW5nbGUgPSAob3V0ZXJTdGFydEFkanVzdGVkQW5nbGUgKyBvdXRlckVuZEFkanVzdGVkQW5nbGUpIC8gMjtcbiAgICBjdHguYXJjKHgsIHksIG91dGVyUmFkaXVzLCBvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSwgb3V0ZXJNaWRBZGp1c3RlZEFuZ2xlKTtcbiAgICBjdHguYXJjKHgsIHksIG91dGVyUmFkaXVzLCBvdXRlck1pZEFkanVzdGVkQW5nbGUsIG91dGVyRW5kQWRqdXN0ZWRBbmdsZSk7XG5cbiAgICAvLyBUaGUgY29ybmVyIHNlZ21lbnQgZnJvbSBwb2ludCAyIHRvIHBvaW50IDNcbiAgICBpZiAob3V0ZXJFbmQgPiAwKSB7XG4gICAgICBjb25zdCBwQ2VudGVyID0gclRoZXRhVG9YWShvdXRlckVuZEFkanVzdGVkUmFkaXVzLCBvdXRlckVuZEFkanVzdGVkQW5nbGUsIHgsIHkpO1xuICAgICAgY3R4LmFyYyhwQ2VudGVyLngsIHBDZW50ZXIueSwgb3V0ZXJFbmQsIG91dGVyRW5kQWRqdXN0ZWRBbmdsZSwgZW5kQW5nbGUgKyBIQUxGX1BJKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgbGluZSBmcm9tIHBvaW50IDMgdG8gcG9pbnQgNFxuICAgIGNvbnN0IHA0ID0gclRoZXRhVG9YWShpbm5lckVuZEFkanVzdGVkUmFkaXVzLCBlbmRBbmdsZSwgeCwgeSk7XG4gICAgY3R4LmxpbmVUbyhwNC54LCBwNC55KTtcblxuICAgIC8vIFRoZSBjb3JuZXIgc2VnbWVudCBmcm9tIHBvaW50IDQgdG8gcG9pbnQgNVxuICAgIGlmIChpbm5lckVuZCA+IDApIHtcbiAgICAgIGNvbnN0IHBDZW50ZXIgPSByVGhldGFUb1hZKGlubmVyRW5kQWRqdXN0ZWRSYWRpdXMsIGlubmVyRW5kQWRqdXN0ZWRBbmdsZSwgeCwgeSk7XG4gICAgICBjdHguYXJjKHBDZW50ZXIueCwgcENlbnRlci55LCBpbm5lckVuZCwgZW5kQW5nbGUgKyBIQUxGX1BJLCBpbm5lckVuZEFkanVzdGVkQW5nbGUgKyBNYXRoLlBJKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgaW5uZXIgYXJjIGZyb20gcG9pbnQgNSB0byBwb2ludCBiIHRvIHBvaW50IDZcbiAgICBjb25zdCBpbm5lck1pZEFkanVzdGVkQW5nbGUgPSAoKGVuZEFuZ2xlIC0gKGlubmVyRW5kIC8gaW5uZXJSYWRpdXMpKSArIChzdGFydEFuZ2xlICsgKGlubmVyU3RhcnQgLyBpbm5lclJhZGl1cykpKSAvIDI7XG4gICAgY3R4LmFyYyh4LCB5LCBpbm5lclJhZGl1cywgZW5kQW5nbGUgLSAoaW5uZXJFbmQgLyBpbm5lclJhZGl1cyksIGlubmVyTWlkQWRqdXN0ZWRBbmdsZSwgdHJ1ZSk7XG4gICAgY3R4LmFyYyh4LCB5LCBpbm5lclJhZGl1cywgaW5uZXJNaWRBZGp1c3RlZEFuZ2xlLCBzdGFydEFuZ2xlICsgKGlubmVyU3RhcnQgLyBpbm5lclJhZGl1cyksIHRydWUpO1xuXG4gICAgLy8gVGhlIGNvcm5lciBzZWdtZW50IGZyb20gcG9pbnQgNiB0byBwb2ludCA3XG4gICAgaWYgKGlubmVyU3RhcnQgPiAwKSB7XG4gICAgICBjb25zdCBwQ2VudGVyID0gclRoZXRhVG9YWShpbm5lclN0YXJ0QWRqdXN0ZWRSYWRpdXMsIGlubmVyU3RhcnRBZGp1c3RlZEFuZ2xlLCB4LCB5KTtcbiAgICAgIGN0eC5hcmMocENlbnRlci54LCBwQ2VudGVyLnksIGlubmVyU3RhcnQsIGlubmVyU3RhcnRBZGp1c3RlZEFuZ2xlICsgTWF0aC5QSSwgc3RhcnRBbmdsZSAtIEhBTEZfUEkpO1xuICAgIH1cblxuICAgIC8vIFRoZSBsaW5lIGZyb20gcG9pbnQgNyB0byBwb2ludCA4XG4gICAgY29uc3QgcDggPSByVGhldGFUb1hZKG91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cywgc3RhcnRBbmdsZSwgeCwgeSk7XG4gICAgY3R4LmxpbmVUbyhwOC54LCBwOC55KTtcblxuICAgIC8vIFRoZSBjb3JuZXIgc2VnbWVudCBmcm9tIHBvaW50IDggdG8gcG9pbnQgMVxuICAgIGlmIChvdXRlclN0YXJ0ID4gMCkge1xuICAgICAgY29uc3QgcENlbnRlciA9IHJUaGV0YVRvWFkob3V0ZXJTdGFydEFkanVzdGVkUmFkaXVzLCBvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSwgeCwgeSk7XG4gICAgICBjdHguYXJjKHBDZW50ZXIueCwgcENlbnRlci55LCBvdXRlclN0YXJ0LCBzdGFydEFuZ2xlIC0gSEFMRl9QSSwgb3V0ZXJTdGFydEFkanVzdGVkQW5nbGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjdHgubW92ZVRvKHgsIHkpO1xuXG4gICAgY29uc3Qgb3V0ZXJTdGFydFggPSBNYXRoLmNvcyhvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSkgKiBvdXRlclJhZGl1cyArIHg7XG4gICAgY29uc3Qgb3V0ZXJTdGFydFkgPSBNYXRoLnNpbihvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSkgKiBvdXRlclJhZGl1cyArIHk7XG4gICAgY3R4LmxpbmVUbyhvdXRlclN0YXJ0WCwgb3V0ZXJTdGFydFkpO1xuXG4gICAgY29uc3Qgb3V0ZXJFbmRYID0gTWF0aC5jb3Mob3V0ZXJFbmRBZGp1c3RlZEFuZ2xlKSAqIG91dGVyUmFkaXVzICsgeDtcbiAgICBjb25zdCBvdXRlckVuZFkgPSBNYXRoLnNpbihvdXRlckVuZEFkanVzdGVkQW5nbGUpICogb3V0ZXJSYWRpdXMgKyB5O1xuICAgIGN0eC5saW5lVG8ob3V0ZXJFbmRYLCBvdXRlckVuZFkpO1xuICB9XG5cbiAgY3R4LmNsb3NlUGF0aCgpO1xufVxuXG5mdW5jdGlvbiBkcmF3QXJjKFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgZWxlbWVudDogQXJjRWxlbWVudCxcbiAgb2Zmc2V0OiBudW1iZXIsXG4gIHNwYWNpbmc6IG51bWJlcixcbiAgY2lyY3VsYXI6IGJvb2xlYW4sXG4pIHtcbiAgY29uc3Qge2Z1bGxDaXJjbGVzLCBzdGFydEFuZ2xlLCBjaXJjdW1mZXJlbmNlfSA9IGVsZW1lbnQ7XG4gIGxldCBlbmRBbmdsZSA9IGVsZW1lbnQuZW5kQW5nbGU7XG4gIGlmIChmdWxsQ2lyY2xlcykge1xuICAgIHBhdGhBcmMoY3R4LCBlbGVtZW50LCBvZmZzZXQsIHNwYWNpbmcsIGVuZEFuZ2xlLCBjaXJjdWxhcik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmdWxsQ2lyY2xlczsgKytpKSB7XG4gICAgICBjdHguZmlsbCgpO1xuICAgIH1cbiAgICBpZiAoIWlzTmFOKGNpcmN1bWZlcmVuY2UpKSB7XG4gICAgICBlbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyAoY2lyY3VtZmVyZW5jZSAlIFRBVSB8fCBUQVUpO1xuICAgIH1cbiAgfVxuICBwYXRoQXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBlbmRBbmdsZSwgY2lyY3VsYXIpO1xuICBjdHguZmlsbCgpO1xuICByZXR1cm4gZW5kQW5nbGU7XG59XG5cbmZ1bmN0aW9uIGRyYXdCb3JkZXIoXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICBlbGVtZW50OiBBcmNFbGVtZW50LFxuICBvZmZzZXQ6IG51bWJlcixcbiAgc3BhY2luZzogbnVtYmVyLFxuICBjaXJjdWxhcjogYm9vbGVhbixcbikge1xuICBjb25zdCB7ZnVsbENpcmNsZXMsIHN0YXJ0QW5nbGUsIGNpcmN1bWZlcmVuY2UsIG9wdGlvbnN9ID0gZWxlbWVudDtcbiAgY29uc3Qge2JvcmRlcldpZHRoLCBib3JkZXJKb2luU3R5bGUsIGJvcmRlckRhc2gsIGJvcmRlckRhc2hPZmZzZXQsIGJvcmRlclJhZGl1c30gPSBvcHRpb25zO1xuICBjb25zdCBpbm5lciA9IG9wdGlvbnMuYm9yZGVyQWxpZ24gPT09ICdpbm5lcic7XG5cbiAgaWYgKCFib3JkZXJXaWR0aCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGN0eC5zZXRMaW5lRGFzaChib3JkZXJEYXNoIHx8IFtdKTtcbiAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gYm9yZGVyRGFzaE9mZnNldDtcblxuICBpZiAoaW5uZXIpIHtcbiAgICBjdHgubGluZVdpZHRoID0gYm9yZGVyV2lkdGggKiAyO1xuICAgIGN0eC5saW5lSm9pbiA9IGJvcmRlckpvaW5TdHlsZSB8fCAncm91bmQnO1xuICB9IGVsc2Uge1xuICAgIGN0eC5saW5lV2lkdGggPSBib3JkZXJXaWR0aDtcbiAgICBjdHgubGluZUpvaW4gPSBib3JkZXJKb2luU3R5bGUgfHwgJ2JldmVsJztcbiAgfVxuXG4gIGxldCBlbmRBbmdsZSA9IGVsZW1lbnQuZW5kQW5nbGU7XG4gIGlmIChmdWxsQ2lyY2xlcykge1xuICAgIHBhdGhBcmMoY3R4LCBlbGVtZW50LCBvZmZzZXQsIHNwYWNpbmcsIGVuZEFuZ2xlLCBjaXJjdWxhcik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmdWxsQ2lyY2xlczsgKytpKSB7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxuICAgIGlmICghaXNOYU4oY2lyY3VtZmVyZW5jZSkpIHtcbiAgICAgIGVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIChjaXJjdW1mZXJlbmNlICUgVEFVIHx8IFRBVSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlubmVyKSB7XG4gICAgY2xpcEFyYyhjdHgsIGVsZW1lbnQsIGVuZEFuZ2xlKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLnNlbGZKb2luICYmIGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSA+PSBQSSAmJiBib3JkZXJSYWRpdXMgPT09IDAgJiYgYm9yZGVySm9pblN0eWxlICE9PSAnbWl0ZXInKSB7XG4gICAgY2xpcFNlbGYoY3R4LCBlbGVtZW50LCBlbmRBbmdsZSk7XG4gIH1cblxuICBpZiAoIWZ1bGxDaXJjbGVzKSB7XG4gICAgcGF0aEFyYyhjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZywgZW5kQW5nbGUsIGNpcmN1bGFyKTtcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBBcmNQcm9wcyBleHRlbmRzIFBvaW50IHtcbiAgc3RhcnRBbmdsZTogbnVtYmVyO1xuICBlbmRBbmdsZTogbnVtYmVyO1xuICBpbm5lclJhZGl1czogbnVtYmVyO1xuICBvdXRlclJhZGl1czogbnVtYmVyO1xuICBjaXJjdW1mZXJlbmNlOiBudW1iZXI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFyY0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PEFyY1Byb3BzLCBBcmNPcHRpb25zPiB7XG5cbiAgc3RhdGljIGlkID0gJ2FyYyc7XG5cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGJvcmRlckFsaWduOiAnY2VudGVyJyxcbiAgICBib3JkZXJDb2xvcjogJyNmZmYnLFxuICAgIGJvcmRlckRhc2g6IFtdLFxuICAgIGJvcmRlckRhc2hPZmZzZXQ6IDAsXG4gICAgYm9yZGVySm9pblN0eWxlOiB1bmRlZmluZWQsXG4gICAgYm9yZGVyUmFkaXVzOiAwLFxuICAgIGJvcmRlcldpZHRoOiAyLFxuICAgIG9mZnNldDogMCxcbiAgICBzcGFjaW5nOiAwLFxuICAgIGFuZ2xlOiB1bmRlZmluZWQsXG4gICAgY2lyY3VsYXI6IHRydWUsXG4gICAgc2VsZkpvaW46IGZhbHNlLFxuICB9O1xuXG4gIHN0YXRpYyBkZWZhdWx0Um91dGVzID0ge1xuICAgIGJhY2tncm91bmRDb2xvcjogJ2JhY2tncm91bmRDb2xvcidcbiAgfTtcblxuICBzdGF0aWMgZGVzY3JpcHRvcnMgPSB7XG4gICAgX3NjcmlwdGFibGU6IHRydWUsXG4gICAgX2luZGV4YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdib3JkZXJEYXNoJ1xuICB9O1xuXG4gIGNpcmN1bWZlcmVuY2U6IG51bWJlcjtcbiAgZW5kQW5nbGU6IG51bWJlcjtcbiAgZnVsbENpcmNsZXM6IG51bWJlcjtcbiAgaW5uZXJSYWRpdXM6IG51bWJlcjtcbiAgb3V0ZXJSYWRpdXM6IG51bWJlcjtcbiAgcGl4ZWxNYXJnaW46IG51bWJlcjtcbiAgc3RhcnRBbmdsZTogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jaXJjdW1mZXJlbmNlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc3RhcnRBbmdsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmVuZEFuZ2xlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBpeGVsTWFyZ2luID0gMDtcbiAgICB0aGlzLmZ1bGxDaXJjbGVzID0gMDtcblxuICAgIGlmIChjZmcpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgY2ZnKTtcbiAgICB9XG4gIH1cblxuICBpblJhbmdlKGNoYXJ0WDogbnVtYmVyLCBjaGFydFk6IG51bWJlciwgdXNlRmluYWxQb3NpdGlvbjogYm9vbGVhbikge1xuICAgIGNvbnN0IHBvaW50ID0gdGhpcy5nZXRQcm9wcyhbJ3gnLCAneSddLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBjb25zdCB7YW5nbGUsIGRpc3RhbmNlfSA9IGdldEFuZ2xlRnJvbVBvaW50KHBvaW50LCB7eDogY2hhcnRYLCB5OiBjaGFydFl9KTtcbiAgICBjb25zdCB7c3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cywgY2lyY3VtZmVyZW5jZX0gPSB0aGlzLmdldFByb3BzKFtcbiAgICAgICdzdGFydEFuZ2xlJyxcbiAgICAgICdlbmRBbmdsZScsXG4gICAgICAnaW5uZXJSYWRpdXMnLFxuICAgICAgJ291dGVyUmFkaXVzJyxcbiAgICAgICdjaXJjdW1mZXJlbmNlJ1xuICAgIF0sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IHJBZGp1c3QgPSAodGhpcy5vcHRpb25zLnNwYWNpbmcgKyB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGgpIC8gMjtcbiAgICBjb25zdCBfY2lyY3VtZmVyZW5jZSA9IHZhbHVlT3JEZWZhdWx0KGNpcmN1bWZlcmVuY2UsIGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSk7XG4gICAgY29uc3Qgbm9uWmVyb0JldHdlZW4gPSBfYW5nbGVCZXR3ZWVuKGFuZ2xlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSkgJiYgc3RhcnRBbmdsZSAhPT0gZW5kQW5nbGU7XG4gICAgY29uc3QgYmV0d2VlbkFuZ2xlcyA9IF9jaXJjdW1mZXJlbmNlID49IFRBVSB8fCBub25aZXJvQmV0d2VlbjtcbiAgICBjb25zdCB3aXRoaW5SYWRpdXMgPSBfaXNCZXR3ZWVuKGRpc3RhbmNlLCBpbm5lclJhZGl1cyArIHJBZGp1c3QsIG91dGVyUmFkaXVzICsgckFkanVzdCk7XG5cbiAgICByZXR1cm4gKGJldHdlZW5BbmdsZXMgJiYgd2l0aGluUmFkaXVzKTtcbiAgfVxuXG4gIGdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb246IGJvb2xlYW4pIHtcbiAgICBjb25zdCB7eCwgeSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1c30gPSB0aGlzLmdldFByb3BzKFtcbiAgICAgICd4JyxcbiAgICAgICd5JyxcbiAgICAgICdzdGFydEFuZ2xlJyxcbiAgICAgICdlbmRBbmdsZScsXG4gICAgICAnaW5uZXJSYWRpdXMnLFxuICAgICAgJ291dGVyUmFkaXVzJ1xuICAgIF0sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IHtvZmZzZXQsIHNwYWNpbmd9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGhhbGZBbmdsZSA9IChzdGFydEFuZ2xlICsgZW5kQW5nbGUpIC8gMjtcbiAgICBjb25zdCBoYWxmUmFkaXVzID0gKGlubmVyUmFkaXVzICsgb3V0ZXJSYWRpdXMgKyBzcGFjaW5nICsgb2Zmc2V0KSAvIDI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHggKyBNYXRoLmNvcyhoYWxmQW5nbGUpICogaGFsZlJhZGl1cyxcbiAgICAgIHk6IHkgKyBNYXRoLnNpbihoYWxmQW5nbGUpICogaGFsZlJhZGl1c1xuICAgIH07XG4gIH1cblxuICB0b29sdGlwUG9zaXRpb24odXNlRmluYWxQb3NpdGlvbjogYm9vbGVhbikge1xuICAgIHJldHVybiB0aGlzLmdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG5cbiAgZHJhdyhjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkge1xuICAgIGNvbnN0IHtvcHRpb25zLCBjaXJjdW1mZXJlbmNlfSA9IHRoaXM7XG4gICAgY29uc3Qgb2Zmc2V0ID0gKG9wdGlvbnMub2Zmc2V0IHx8IDApIC8gNDtcbiAgICBjb25zdCBzcGFjaW5nID0gKG9wdGlvbnMuc3BhY2luZyB8fCAwKSAvIDI7XG4gICAgY29uc3QgY2lyY3VsYXIgPSBvcHRpb25zLmNpcmN1bGFyO1xuICAgIHRoaXMucGl4ZWxNYXJnaW4gPSAob3B0aW9ucy5ib3JkZXJBbGlnbiA9PT0gJ2lubmVyJykgPyAwLjMzIDogMDtcbiAgICB0aGlzLmZ1bGxDaXJjbGVzID0gY2lyY3VtZmVyZW5jZSA+IFRBVSA/IE1hdGguZmxvb3IoY2lyY3VtZmVyZW5jZSAvIFRBVSkgOiAwO1xuXG4gICAgaWYgKGNpcmN1bWZlcmVuY2UgPT09IDAgfHwgdGhpcy5pbm5lclJhZGl1cyA8IDAgfHwgdGhpcy5vdXRlclJhZGl1cyA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjdHguc2F2ZSgpO1xuXG4gICAgY29uc3QgaGFsZkFuZ2xlID0gKHRoaXMuc3RhcnRBbmdsZSArIHRoaXMuZW5kQW5nbGUpIC8gMjtcbiAgICBjdHgudHJhbnNsYXRlKE1hdGguY29zKGhhbGZBbmdsZSkgKiBvZmZzZXQsIE1hdGguc2luKGhhbGZBbmdsZSkgKiBvZmZzZXQpO1xuICAgIGNvbnN0IGZpeCA9IDEgLSBNYXRoLnNpbihNYXRoLm1pbihQSSwgY2lyY3VtZmVyZW5jZSB8fCAwKSk7XG4gICAgY29uc3QgcmFkaXVzT2Zmc2V0ID0gb2Zmc2V0ICogZml4O1xuXG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuYm9yZGVyQ29sb3I7XG5cbiAgICBkcmF3QXJjKGN0eCwgdGhpcywgcmFkaXVzT2Zmc2V0LCBzcGFjaW5nLCBjaXJjdWxhcik7XG4gICAgZHJhd0JvcmRlcihjdHgsIHRoaXMsIHJhZGl1c09mZnNldCwgc3BhY2luZywgY2lyY3VsYXIpO1xuXG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxufVxuIiwiaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi4vY29yZS9jb3JlLmVsZW1lbnQuanMnO1xuaW1wb3J0IHtfYmV6aWVySW50ZXJwb2xhdGlvbiwgX3BvaW50SW5MaW5lLCBfc3RlcHBlZEludGVycG9sYXRpb259IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5pbnRlcnBvbGF0aW9uLmpzJztcbmltcG9ydCB7X2NvbXB1dGVTZWdtZW50cywgX2JvdW5kU2VnbWVudHN9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5zZWdtZW50LmpzJztcbmltcG9ydCB7X3N0ZXBwZWRMaW5lVG8sIF9iZXppZXJDdXJ2ZVRvfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY2FudmFzLmpzJztcbmltcG9ydCB7X3VwZGF0ZUJlemllckNvbnRyb2xQb2ludHN9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jdXJ2ZS5qcyc7XG5pbXBvcnQge3ZhbHVlT3JEZWZhdWx0fSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9lbGVtZW50LnBvaW50LmpzJykuZGVmYXVsdCB9IFBvaW50RWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIHNldFN0eWxlKGN0eCwgb3B0aW9ucywgc3R5bGUgPSBvcHRpb25zKSB7XG4gIGN0eC5saW5lQ2FwID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVyQ2FwU3R5bGUsIG9wdGlvbnMuYm9yZGVyQ2FwU3R5bGUpO1xuICBjdHguc2V0TGluZURhc2godmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVyRGFzaCwgb3B0aW9ucy5ib3JkZXJEYXNoKSk7XG4gIGN0eC5saW5lRGFzaE9mZnNldCA9IHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlckRhc2hPZmZzZXQsIG9wdGlvbnMuYm9yZGVyRGFzaE9mZnNldCk7XG4gIGN0eC5saW5lSm9pbiA9IHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlckpvaW5TdHlsZSwgb3B0aW9ucy5ib3JkZXJKb2luU3R5bGUpO1xuICBjdHgubGluZVdpZHRoID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVyV2lkdGgsIG9wdGlvbnMuYm9yZGVyV2lkdGgpO1xuICBjdHguc3Ryb2tlU3R5bGUgPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJDb2xvciwgb3B0aW9ucy5ib3JkZXJDb2xvcik7XG59XG5cbmZ1bmN0aW9uIGxpbmVUbyhjdHgsIHByZXZpb3VzLCB0YXJnZXQpIHtcbiAgY3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHthbnl9XG4gKi9cbmZ1bmN0aW9uIGdldExpbmVNZXRob2Qob3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5zdGVwcGVkKSB7XG4gICAgcmV0dXJuIF9zdGVwcGVkTGluZVRvO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMudGVuc2lvbiB8fCBvcHRpb25zLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09ICdtb25vdG9uZScpIHtcbiAgICByZXR1cm4gX2JlemllckN1cnZlVG87XG4gIH1cblxuICByZXR1cm4gbGluZVRvO1xufVxuXG5mdW5jdGlvbiBwYXRoVmFycyhwb2ludHMsIHNlZ21lbnQsIHBhcmFtcyA9IHt9KSB7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3Qge3N0YXJ0OiBwYXJhbXNTdGFydCA9IDAsIGVuZDogcGFyYW1zRW5kID0gY291bnQgLSAxfSA9IHBhcmFtcztcbiAgY29uc3Qge3N0YXJ0OiBzZWdtZW50U3RhcnQsIGVuZDogc2VnbWVudEVuZH0gPSBzZWdtZW50O1xuICBjb25zdCBzdGFydCA9IE1hdGgubWF4KHBhcmFtc1N0YXJ0LCBzZWdtZW50U3RhcnQpO1xuICBjb25zdCBlbmQgPSBNYXRoLm1pbihwYXJhbXNFbmQsIHNlZ21lbnRFbmQpO1xuICBjb25zdCBvdXRzaWRlID0gcGFyYW1zU3RhcnQgPCBzZWdtZW50U3RhcnQgJiYgcGFyYW1zRW5kIDwgc2VnbWVudFN0YXJ0IHx8IHBhcmFtc1N0YXJ0ID4gc2VnbWVudEVuZCAmJiBwYXJhbXNFbmQgPiBzZWdtZW50RW5kO1xuXG4gIHJldHVybiB7XG4gICAgY291bnQsXG4gICAgc3RhcnQsXG4gICAgbG9vcDogc2VnbWVudC5sb29wLFxuICAgIGlsZW46IGVuZCA8IHN0YXJ0ICYmICFvdXRzaWRlID8gY291bnQgKyBlbmQgLSBzdGFydCA6IGVuZCAtIHN0YXJ0XG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlIHBhdGggZnJvbSBwb2ludHMsIGdyb3VwaW5nIGJ5IHRydW5jYXRlZCB4LWNvb3JkaW5hdGVcbiAqIFBvaW50cyBuZWVkIHRvIGJlIGluIG9yZGVyIGJ5IHgtY29vcmRpbmF0ZSBmb3IgdGhpcyB0byB3b3JrIGVmZmljaWVudGx5XG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRHxQYXRoMkR9IGN0eCAtIENvbnRleHRcbiAqIEBwYXJhbSB7TGluZUVsZW1lbnR9IGxpbmVcbiAqIEBwYXJhbSB7b2JqZWN0fSBzZWdtZW50XG4gKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudC5zdGFydCAtIHN0YXJ0IGluZGV4IG9mIHRoZSBzZWdtZW50LCByZWZlcnJpbmcgdGhlIHBvaW50cyBhcnJheVxuICogQHBhcmFtIHtudW1iZXJ9IHNlZ21lbnQuZW5kIC0gZW5kIGluZGV4IG9mIHRoZSBzZWdtZW50LCByZWZlcnJpbmcgdGhlIHBvaW50cyBhcnJheVxuICogQHBhcmFtIHtib29sZWFufSBzZWdtZW50Lmxvb3AgLSBpbmRpY2F0ZXMgdGhhdCB0aGUgc2VnbWVudCBpcyBhIGxvb3BcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1zLm1vdmUgLSBtb3ZlIHRvIHN0YXJ0aW5nIHBvaW50ICh2cyBsaW5lIHRvIGl0KVxuICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMucmV2ZXJzZSAtIHBhdGggdGhlIHNlZ21lbnQgZnJvbSBlbmQgdG8gc3RhcnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuc3RhcnQgLSBsaW1pdCBzZWdtZW50IHRvIHBvaW50cyBzdGFydGluZyBmcm9tIGBzdGFydGAgaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuZW5kIC0gbGltaXQgc2VnbWVudCB0byBwb2ludHMgZW5kaW5nIGF0IGBzdGFydGAgKyBgY291bnRgIGluZGV4XG4gKi9cbmZ1bmN0aW9uIHBhdGhTZWdtZW50KGN0eCwgbGluZSwgc2VnbWVudCwgcGFyYW1zKSB7XG4gIGNvbnN0IHtwb2ludHMsIG9wdGlvbnN9ID0gbGluZTtcbiAgY29uc3Qge2NvdW50LCBzdGFydCwgbG9vcCwgaWxlbn0gPSBwYXRoVmFycyhwb2ludHMsIHNlZ21lbnQsIHBhcmFtcyk7XG4gIGNvbnN0IGxpbmVNZXRob2QgPSBnZXRMaW5lTWV0aG9kKG9wdGlvbnMpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG4gIGxldCB7bW92ZSA9IHRydWUsIHJldmVyc2V9ID0gcGFyYW1zIHx8IHt9O1xuICBsZXQgaSwgcG9pbnQsIHByZXY7XG5cbiAgZm9yIChpID0gMDsgaSA8PSBpbGVuOyArK2kpIHtcbiAgICBwb2ludCA9IHBvaW50c1soc3RhcnQgKyAocmV2ZXJzZSA/IGlsZW4gLSBpIDogaSkpICUgY291bnRdO1xuXG4gICAgaWYgKHBvaW50LnNraXApIHtcbiAgICAgIC8vIElmIHRoZXJlIGlzIGEgc2tpcHBlZCBwb2ludCBpbnNpZGUgYSBzZWdtZW50LCBzcGFuR2FwcyBtdXN0IGJlIHRydWVcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAobW92ZSkge1xuICAgICAgY3R4Lm1vdmVUbyhwb2ludC54LCBwb2ludC55KTtcbiAgICAgIG1vdmUgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZU1ldGhvZChjdHgsIHByZXYsIHBvaW50LCByZXZlcnNlLCBvcHRpb25zLnN0ZXBwZWQpO1xuICAgIH1cblxuICAgIHByZXYgPSBwb2ludDtcbiAgfVxuXG4gIGlmIChsb29wKSB7XG4gICAgcG9pbnQgPSBwb2ludHNbKHN0YXJ0ICsgKHJldmVyc2UgPyBpbGVuIDogMCkpICUgY291bnRdO1xuICAgIGxpbmVNZXRob2QoY3R4LCBwcmV2LCBwb2ludCwgcmV2ZXJzZSwgb3B0aW9ucy5zdGVwcGVkKTtcbiAgfVxuXG4gIHJldHVybiAhIWxvb3A7XG59XG5cbi8qKlxuICogQ3JlYXRlIHBhdGggZnJvbSBwb2ludHMsIGdyb3VwaW5nIGJ5IHRydW5jYXRlZCB4LWNvb3JkaW5hdGVcbiAqIFBvaW50cyBuZWVkIHRvIGJlIGluIG9yZGVyIGJ5IHgtY29vcmRpbmF0ZSBmb3IgdGhpcyB0byB3b3JrIGVmZmljaWVudGx5XG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRHxQYXRoMkR9IGN0eCAtIENvbnRleHRcbiAqIEBwYXJhbSB7TGluZUVsZW1lbnR9IGxpbmVcbiAqIEBwYXJhbSB7b2JqZWN0fSBzZWdtZW50XG4gKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudC5zdGFydCAtIHN0YXJ0IGluZGV4IG9mIHRoZSBzZWdtZW50LCByZWZlcnJpbmcgdGhlIHBvaW50cyBhcnJheVxuICogQHBhcmFtIHtudW1iZXJ9IHNlZ21lbnQuZW5kIC0gZW5kIGluZGV4IG9mIHRoZSBzZWdtZW50LCByZWZlcnJpbmcgdGhlIHBvaW50cyBhcnJheVxuICogQHBhcmFtIHtib29sZWFufSBzZWdtZW50Lmxvb3AgLSBpbmRpY2F0ZXMgdGhhdCB0aGUgc2VnbWVudCBpcyBhIGxvb3BcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1zLm1vdmUgLSBtb3ZlIHRvIHN0YXJ0aW5nIHBvaW50ICh2cyBsaW5lIHRvIGl0KVxuICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMucmV2ZXJzZSAtIHBhdGggdGhlIHNlZ21lbnQgZnJvbSBlbmQgdG8gc3RhcnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuc3RhcnQgLSBsaW1pdCBzZWdtZW50IHRvIHBvaW50cyBzdGFydGluZyBmcm9tIGBzdGFydGAgaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuZW5kIC0gbGltaXQgc2VnbWVudCB0byBwb2ludHMgZW5kaW5nIGF0IGBzdGFydGAgKyBgY291bnRgIGluZGV4XG4gKi9cbmZ1bmN0aW9uIGZhc3RQYXRoU2VnbWVudChjdHgsIGxpbmUsIHNlZ21lbnQsIHBhcmFtcykge1xuICBjb25zdCBwb2ludHMgPSBsaW5lLnBvaW50cztcbiAgY29uc3Qge2NvdW50LCBzdGFydCwgaWxlbn0gPSBwYXRoVmFycyhwb2ludHMsIHNlZ21lbnQsIHBhcmFtcyk7XG4gIGNvbnN0IHttb3ZlID0gdHJ1ZSwgcmV2ZXJzZX0gPSBwYXJhbXMgfHwge307XG4gIGxldCBhdmdYID0gMDtcbiAgbGV0IGNvdW50WCA9IDA7XG4gIGxldCBpLCBwb2ludCwgcHJldlgsIG1pblksIG1heFksIGxhc3RZO1xuXG4gIGNvbnN0IHBvaW50SW5kZXggPSAoaW5kZXgpID0+IChzdGFydCArIChyZXZlcnNlID8gaWxlbiAtIGluZGV4IDogaW5kZXgpKSAlIGNvdW50O1xuICBjb25zdCBkcmF3WCA9ICgpID0+IHtcbiAgICBpZiAobWluWSAhPT0gbWF4WSkge1xuICAgICAgLy8gRHJhdyBsaW5lIHRvIG1heFkgYW5kIG1pblksIHVzaW5nIHRoZSBhdmVyYWdlIHgtY29vcmRpbmF0ZVxuICAgICAgY3R4LmxpbmVUbyhhdmdYLCBtYXhZKTtcbiAgICAgIGN0eC5saW5lVG8oYXZnWCwgbWluWSk7XG4gICAgICAvLyBMaW5lIHRvIHktdmFsdWUgb2YgbGFzdCBwb2ludCBpbiBncm91cC4gU28gdGhlIGxpbmUgY29udGludWVzXG4gICAgICAvLyBmcm9tIGNvcnJlY3QgcG9zaXRpb24uIE5vdCB1c2luZyBtb3ZlLCB0byBoYXZlIHNvbGlkIHBhdGguXG4gICAgICBjdHgubGluZVRvKGF2Z1gsIGxhc3RZKTtcbiAgICB9XG4gIH07XG5cbiAgaWYgKG1vdmUpIHtcbiAgICBwb2ludCA9IHBvaW50c1twb2ludEluZGV4KDApXTtcbiAgICBjdHgubW92ZVRvKHBvaW50LngsIHBvaW50LnkpO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8PSBpbGVuOyArK2kpIHtcbiAgICBwb2ludCA9IHBvaW50c1twb2ludEluZGV4KGkpXTtcblxuICAgIGlmIChwb2ludC5za2lwKSB7XG4gICAgICAvLyBJZiB0aGVyZSBpcyBhIHNraXBwZWQgcG9pbnQgaW5zaWRlIGEgc2VnbWVudCwgc3BhbkdhcHMgbXVzdCBiZSB0cnVlXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCB4ID0gcG9pbnQueDtcbiAgICBjb25zdCB5ID0gcG9pbnQueTtcbiAgICBjb25zdCB0cnVuY1ggPSB4IHwgMDsgLy8gdHJ1bmNhdGVkIHgtY29vcmRpbmF0ZVxuXG4gICAgaWYgKHRydW5jWCA9PT0gcHJldlgpIHtcbiAgICAgIC8vIERldGVybWluZSBgbWluWWAgLyBgbWF4WWAgYW5kIGBhdmdYYCB3aGlsZSB3ZSBzdGF5IHdpdGhpbiBzYW1lIHgtcG9zaXRpb25cbiAgICAgIGlmICh5IDwgbWluWSkge1xuICAgICAgICBtaW5ZID0geTtcbiAgICAgIH0gZWxzZSBpZiAoeSA+IG1heFkpIHtcbiAgICAgICAgbWF4WSA9IHk7XG4gICAgICB9XG4gICAgICAvLyBGb3IgZmlyc3QgcG9pbnQgaW4gZ3JvdXAsIGNvdW50WCBpcyBgMGAsIHNvIGF2ZXJhZ2Ugd2lsbCBiZSBgeGAgLyAxLlxuICAgICAgYXZnWCA9IChjb3VudFggKiBhdmdYICsgeCkgLyArK2NvdW50WDtcbiAgICB9IGVsc2Uge1xuICAgICAgZHJhd1goKTtcbiAgICAgIC8vIERyYXcgbGluZSB0byBuZXh0IHgtcG9zaXRpb24sIHVzaW5nIHRoZSBmaXJzdCAob3Igb25seSlcbiAgICAgIC8vIHktdmFsdWUgaW4gdGhhdCBncm91cFxuICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcblxuICAgICAgcHJldlggPSB0cnVuY1g7XG4gICAgICBjb3VudFggPSAwO1xuICAgICAgbWluWSA9IG1heFkgPSB5O1xuICAgIH1cbiAgICAvLyBLZWVwIHRyYWNrIG9mIHRoZSBsYXN0IHktdmFsdWUgaW4gZ3JvdXBcbiAgICBsYXN0WSA9IHk7XG4gIH1cbiAgZHJhd1goKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lIC0gdGhlIGxpbmVcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9nZXRTZWdtZW50TWV0aG9kKGxpbmUpIHtcbiAgY29uc3Qgb3B0cyA9IGxpbmUub3B0aW9ucztcbiAgY29uc3QgYm9yZGVyRGFzaCA9IG9wdHMuYm9yZGVyRGFzaCAmJiBvcHRzLmJvcmRlckRhc2gubGVuZ3RoO1xuICBjb25zdCB1c2VGYXN0UGF0aCA9ICFsaW5lLl9kZWNpbWF0ZWQgJiYgIWxpbmUuX2xvb3AgJiYgIW9wdHMudGVuc2lvbiAmJiBvcHRzLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgIT09ICdtb25vdG9uZScgJiYgIW9wdHMuc3RlcHBlZCAmJiAhYm9yZGVyRGFzaDtcbiAgcmV0dXJuIHVzZUZhc3RQYXRoID8gZmFzdFBhdGhTZWdtZW50IDogcGF0aFNlZ21lbnQ7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2dldEludGVycG9sYXRpb25NZXRob2Qob3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5zdGVwcGVkKSB7XG4gICAgcmV0dXJuIF9zdGVwcGVkSW50ZXJwb2xhdGlvbjtcbiAgfVxuXG4gIGlmIChvcHRpb25zLnRlbnNpb24gfHwgb3B0aW9ucy5jdWJpY0ludGVycG9sYXRpb25Nb2RlID09PSAnbW9ub3RvbmUnKSB7XG4gICAgcmV0dXJuIF9iZXppZXJJbnRlcnBvbGF0aW9uO1xuICB9XG5cbiAgcmV0dXJuIF9wb2ludEluTGluZTtcbn1cblxuZnVuY3Rpb24gc3Ryb2tlUGF0aFdpdGhDYWNoZShjdHgsIGxpbmUsIHN0YXJ0LCBjb3VudCkge1xuICBsZXQgcGF0aCA9IGxpbmUuX3BhdGg7XG4gIGlmICghcGF0aCkge1xuICAgIHBhdGggPSBsaW5lLl9wYXRoID0gbmV3IFBhdGgyRCgpO1xuICAgIGlmIChsaW5lLnBhdGgocGF0aCwgc3RhcnQsIGNvdW50KSkge1xuICAgICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gIH1cbiAgc2V0U3R5bGUoY3R4LCBsaW5lLm9wdGlvbnMpO1xuICBjdHguc3Ryb2tlKHBhdGgpO1xufVxuXG5mdW5jdGlvbiBzdHJva2VQYXRoRGlyZWN0KGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KSB7XG4gIGNvbnN0IHtzZWdtZW50cywgb3B0aW9uc30gPSBsaW5lO1xuICBjb25zdCBzZWdtZW50TWV0aG9kID0gX2dldFNlZ21lbnRNZXRob2QobGluZSk7XG5cbiAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgc2V0U3R5bGUoY3R4LCBvcHRpb25zLCBzZWdtZW50LnN0eWxlKTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgaWYgKHNlZ21lbnRNZXRob2QoY3R4LCBsaW5lLCBzZWdtZW50LCB7c3RhcnQsIGVuZDogc3RhcnQgKyBjb3VudCAtIDF9KSkge1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbn1cblxuY29uc3QgdXNlUGF0aDJEID0gdHlwZW9mIFBhdGgyRCA9PT0gJ2Z1bmN0aW9uJztcblxuZnVuY3Rpb24gZHJhdyhjdHgsIGxpbmUsIHN0YXJ0LCBjb3VudCkge1xuICBpZiAodXNlUGF0aDJEICYmICFsaW5lLm9wdGlvbnMuc2VnbWVudCkge1xuICAgIHN0cm9rZVBhdGhXaXRoQ2FjaGUoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpO1xuICB9IGVsc2Uge1xuICAgIHN0cm9rZVBhdGhEaXJlY3QoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpbmVFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG5cbiAgc3RhdGljIGlkID0gJ2xpbmUnO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGJvcmRlckNhcFN0eWxlOiAnYnV0dCcsXG4gICAgYm9yZGVyRGFzaDogW10sXG4gICAgYm9yZGVyRGFzaE9mZnNldDogMCxcbiAgICBib3JkZXJKb2luU3R5bGU6ICdtaXRlcicsXG4gICAgYm9yZGVyV2lkdGg6IDMsXG4gICAgY2FwQmV6aWVyUG9pbnRzOiB0cnVlLFxuICAgIGN1YmljSW50ZXJwb2xhdGlvbk1vZGU6ICdkZWZhdWx0JyxcbiAgICBmaWxsOiBmYWxzZSxcbiAgICBzcGFuR2FwczogZmFsc2UsXG4gICAgc3RlcHBlZDogZmFsc2UsXG4gICAgdGVuc2lvbjogMCxcbiAgfTtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0Um91dGVzID0ge1xuICAgIGJhY2tncm91bmRDb2xvcjogJ2JhY2tncm91bmRDb2xvcicsXG4gICAgYm9yZGVyQ29sb3I6ICdib3JkZXJDb2xvcidcbiAgfTtcblxuXG4gIHN0YXRpYyBkZXNjcmlwdG9ycyA9IHtcbiAgICBfc2NyaXB0YWJsZTogdHJ1ZSxcbiAgICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JvcmRlckRhc2gnICYmIG5hbWUgIT09ICdmaWxsJyxcbiAgfTtcblxuXG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmFuaW1hdGVkID0gdHJ1ZTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fY2hhcnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fbG9vcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9mdWxsTG9vcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9wYXRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3BvaW50cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zZWdtZW50cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9kZWNpbWF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wb2ludHNVcGRhdGVkID0gZmFsc2U7XG4gICAgdGhpcy5fZGF0YXNldEluZGV4ID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKGNmZykge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjZmcpO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZUNvbnRyb2xQb2ludHMoY2hhcnRBcmVhLCBpbmRleEF4aXMpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGlmICgob3B0aW9ucy50ZW5zaW9uIHx8IG9wdGlvbnMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gJ21vbm90b25lJykgJiYgIW9wdGlvbnMuc3RlcHBlZCAmJiAhdGhpcy5fcG9pbnRzVXBkYXRlZCkge1xuICAgICAgY29uc3QgbG9vcCA9IG9wdGlvbnMuc3BhbkdhcHMgPyB0aGlzLl9sb29wIDogdGhpcy5fZnVsbExvb3A7XG4gICAgICBfdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cyh0aGlzLl9wb2ludHMsIG9wdGlvbnMsIGNoYXJ0QXJlYSwgbG9vcCwgaW5kZXhBeGlzKTtcbiAgICAgIHRoaXMuX3BvaW50c1VwZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHNldCBwb2ludHMocG9pbnRzKSB7XG4gICAgdGhpcy5fcG9pbnRzID0gcG9pbnRzO1xuICAgIGRlbGV0ZSB0aGlzLl9zZWdtZW50cztcbiAgICBkZWxldGUgdGhpcy5fcGF0aDtcbiAgICB0aGlzLl9wb2ludHNVcGRhdGVkID0gZmFsc2U7XG4gIH1cblxuICBnZXQgcG9pbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9wb2ludHM7XG4gIH1cblxuICBnZXQgc2VnbWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlZ21lbnRzIHx8ICh0aGlzLl9zZWdtZW50cyA9IF9jb21wdXRlU2VnbWVudHModGhpcywgdGhpcy5vcHRpb25zLnNlZ21lbnQpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBGaXJzdCBub24tc2tpcHBlZCBwb2ludCBvbiB0aGlzIGxpbmVcblx0ICogQHJldHVybnMge1BvaW50RWxlbWVudHx1bmRlZmluZWR9XG5cdCAqL1xuICBmaXJzdCgpIHtcbiAgICBjb25zdCBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgcmV0dXJuIHNlZ21lbnRzLmxlbmd0aCAmJiBwb2ludHNbc2VnbWVudHNbMF0uc3RhcnRdO1xuICB9XG5cbiAgLyoqXG5cdCAqIExhc3Qgbm9uLXNraXBwZWQgcG9pbnQgb24gdGhpcyBsaW5lXG5cdCAqIEByZXR1cm5zIHtQb2ludEVsZW1lbnR8dW5kZWZpbmVkfVxuXHQgKi9cbiAgbGFzdCgpIHtcbiAgICBjb25zdCBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgY29uc3QgY291bnQgPSBzZWdtZW50cy5sZW5ndGg7XG4gICAgcmV0dXJuIGNvdW50ICYmIHBvaW50c1tzZWdtZW50c1tjb3VudCAtIDFdLmVuZF07XG4gIH1cblxuICAvKipcblx0ICogSW50ZXJwb2xhdGUgYSBwb2ludCBpbiB0aGlzIGxpbmUgYXQgdGhlIHNhbWUgdmFsdWUgb24gYHByb3BlcnR5YCBhc1xuXHQgKiB0aGUgcmVmZXJlbmNlIGBwb2ludGAgcHJvdmlkZWRcblx0ICogQHBhcmFtIHtQb2ludEVsZW1lbnR9IHBvaW50IC0gdGhlIHJlZmVyZW5jZSBwb2ludFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgLSB0aGUgcHJvcGVydHkgdG8gbWF0Y2ggb25cblx0ICogQHJldHVybnMge1BvaW50RWxlbWVudHx1bmRlZmluZWR9XG5cdCAqL1xuICBpbnRlcnBvbGF0ZShwb2ludCwgcHJvcGVydHkpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHZhbHVlID0gcG9pbnRbcHJvcGVydHldO1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgIGNvbnN0IHNlZ21lbnRzID0gX2JvdW5kU2VnbWVudHModGhpcywge3Byb3BlcnR5LCBzdGFydDogdmFsdWUsIGVuZDogdmFsdWV9KTtcblxuICAgIGlmICghc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3QgX2ludGVycG9sYXRlID0gX2dldEludGVycG9sYXRpb25NZXRob2Qob3B0aW9ucyk7XG4gICAgbGV0IGksIGlsZW47XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY29uc3Qge3N0YXJ0LCBlbmR9ID0gc2VnbWVudHNbaV07XG4gICAgICBjb25zdCBwMSA9IHBvaW50c1tzdGFydF07XG4gICAgICBjb25zdCBwMiA9IHBvaW50c1tlbmRdO1xuICAgICAgaWYgKHAxID09PSBwMikge1xuICAgICAgICByZXN1bHQucHVzaChwMSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdCA9IE1hdGguYWJzKCh2YWx1ZSAtIHAxW3Byb3BlcnR5XSkgLyAocDJbcHJvcGVydHldIC0gcDFbcHJvcGVydHldKSk7XG4gICAgICBjb25zdCBpbnRlcnBvbGF0ZWQgPSBfaW50ZXJwb2xhdGUocDEsIHAyLCB0LCBvcHRpb25zLnN0ZXBwZWQpO1xuICAgICAgaW50ZXJwb2xhdGVkW3Byb3BlcnR5XSA9IHBvaW50W3Byb3BlcnR5XTtcbiAgICAgIHJlc3VsdC5wdXNoKGludGVycG9sYXRlZCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQubGVuZ3RoID09PSAxID8gcmVzdWx0WzBdIDogcmVzdWx0O1xuICB9XG5cbiAgLyoqXG5cdCAqIEFwcGVuZCBhIHNlZ21lbnQgb2YgdGhpcyBsaW5lIHRvIGN1cnJlbnQgcGF0aC5cblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuXHQgKiBAcGFyYW0ge29iamVjdH0gc2VnbWVudFxuXHQgKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudC5zdGFydCAtIHN0YXJ0IGluZGV4IG9mIHRoZSBzZWdtZW50LCByZWZlcnJpbmcgdGhlIHBvaW50cyBhcnJheVxuIFx0ICogQHBhcmFtIHtudW1iZXJ9IHNlZ21lbnQuZW5kIC0gZW5kIGluZGV4IG9mIHRoZSBzZWdtZW50LCByZWZlcnJpbmcgdGhlIHBvaW50cyBhcnJheVxuIFx0ICogQHBhcmFtIHtib29sZWFufSBzZWdtZW50Lmxvb3AgLSBpbmRpY2F0ZXMgdGhhdCB0aGUgc2VnbWVudCBpcyBhIGxvb3Bcblx0ICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5tb3ZlIC0gbW92ZSB0byBzdGFydGluZyBwb2ludCAodnMgbGluZSB0byBpdClcblx0ICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMucmV2ZXJzZSAtIHBhdGggdGhlIHNlZ21lbnQgZnJvbSBlbmQgdG8gc3RhcnRcblx0ICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5zdGFydCAtIGxpbWl0IHNlZ21lbnQgdG8gcG9pbnRzIHN0YXJ0aW5nIGZyb20gYHN0YXJ0YCBpbmRleFxuXHQgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmVuZCAtIGxpbWl0IHNlZ21lbnQgdG8gcG9pbnRzIGVuZGluZyBhdCBgc3RhcnRgICsgYGNvdW50YCBpbmRleFxuXHQgKiBAcmV0dXJucyB7dW5kZWZpbmVkfGJvb2xlYW59IC0gdHJ1ZSBpZiB0aGUgc2VnbWVudCBpcyBhIGZ1bGwgbG9vcCAocGF0aCBzaG91bGQgYmUgY2xvc2VkKVxuXHQgKi9cbiAgcGF0aFNlZ21lbnQoY3R4LCBzZWdtZW50LCBwYXJhbXMpIHtcbiAgICBjb25zdCBzZWdtZW50TWV0aG9kID0gX2dldFNlZ21lbnRNZXRob2QodGhpcyk7XG4gICAgcmV0dXJuIHNlZ21lbnRNZXRob2QoY3R4LCB0aGlzLCBzZWdtZW50LCBwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEFwcGVuZCBhbGwgc2VnbWVudHMgb2YgdGhpcyBsaW5lIHRvIGN1cnJlbnQgcGF0aC5cblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR8UGF0aDJEfSBjdHhcblx0ICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydF1cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtjb3VudF1cblx0ICogQHJldHVybnMge3VuZGVmaW5lZHxib29sZWFufSAtIHRydWUgaWYgbGluZSBpcyBhIGZ1bGwgbG9vcCAocGF0aCBzaG91bGQgYmUgY2xvc2VkKVxuXHQgKi9cbiAgcGF0aChjdHgsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICBjb25zdCBzZWdtZW50TWV0aG9kID0gX2dldFNlZ21lbnRNZXRob2QodGhpcyk7XG4gICAgbGV0IGxvb3AgPSB0aGlzLl9sb29wO1xuXG4gICAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICAgIGNvdW50ID0gY291bnQgfHwgKHRoaXMucG9pbnRzLmxlbmd0aCAtIHN0YXJ0KTtcblxuICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgICAgbG9vcCAmPSBzZWdtZW50TWV0aG9kKGN0eCwgdGhpcywgc2VnbWVudCwge3N0YXJ0LCBlbmQ6IHN0YXJ0ICsgY291bnQgLSAxfSk7XG4gICAgfVxuICAgIHJldHVybiAhIWxvb3A7XG4gIH1cblxuICAvKipcblx0ICogRHJhd1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBjaGFydEFyZWFcblx0ICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydF1cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtjb3VudF1cblx0ICovXG4gIGRyYXcoY3R4LCBjaGFydEFyZWEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMgfHwge307XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHMgfHwgW107XG5cbiAgICBpZiAocG9pbnRzLmxlbmd0aCAmJiBvcHRpb25zLmJvcmRlcldpZHRoKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICBkcmF3KGN0eCwgdGhpcywgc3RhcnQsIGNvdW50KTtcblxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hbmltYXRlZCkge1xuICAgICAgLy8gV2hlbiBsaW5lIGlzIGFuaW1hdGVkLCB0aGUgY29udHJvbCBwb2ludHMgYW5kIHBhdGggYXJlIG5vdCBjYWNoZWQuXG4gICAgICB0aGlzLl9wb2ludHNVcGRhdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLl9wYXRoID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi4vY29yZS9jb3JlLmVsZW1lbnQuanMnO1xuaW1wb3J0IHtkcmF3UG9pbnQsIF9pc1BvaW50SW5BcmVhfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY2FudmFzLmpzJztcbmltcG9ydCB0eXBlIHtcbiAgQ2FydGVzaWFuUGFyc2VkRGF0YSxcbiAgQ2hhcnRBcmVhLFxuICBQb2ludCxcbiAgUG9pbnRIb3Zlck9wdGlvbnMsXG4gIFBvaW50T3B0aW9ucyxcbn0gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuXG5mdW5jdGlvbiBpblJhbmdlKGVsOiBQb2ludEVsZW1lbnQsIHBvczogbnVtYmVyLCBheGlzOiAneCcgfCAneScsIHVzZUZpbmFsUG9zaXRpb24/OiBib29sZWFuKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBlbC5vcHRpb25zO1xuICBjb25zdCB7W2F4aXNdOiB2YWx1ZX0gPSBlbC5nZXRQcm9wcyhbYXhpc10sIHVzZUZpbmFsUG9zaXRpb24pO1xuXG4gIHJldHVybiAoTWF0aC5hYnMocG9zIC0gdmFsdWUpIDwgb3B0aW9ucy5yYWRpdXMgKyBvcHRpb25zLmhpdFJhZGl1cyk7XG59XG5cbmV4cG9ydCB0eXBlIFBvaW50UHJvcHMgPSBQb2ludFxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb2ludEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PFBvaW50UHJvcHMsIFBvaW50T3B0aW9ucyAmIFBvaW50SG92ZXJPcHRpb25zPiB7XG5cbiAgc3RhdGljIGlkID0gJ3BvaW50JztcblxuICBwYXJzZWQ6IENhcnRlc2lhblBhcnNlZERhdGE7XG4gIHNraXA/OiBib29sZWFuO1xuICBzdG9wPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBib3JkZXJXaWR0aDogMSxcbiAgICBoaXRSYWRpdXM6IDEsXG4gICAgaG92ZXJCb3JkZXJXaWR0aDogMSxcbiAgICBob3ZlclJhZGl1czogNCxcbiAgICBwb2ludFN0eWxlOiAnY2lyY2xlJyxcbiAgICByYWRpdXM6IDMsXG4gICAgcm90YXRpb246IDBcbiAgfTtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0Um91dGVzID0ge1xuICAgIGJhY2tncm91bmRDb2xvcjogJ2JhY2tncm91bmRDb2xvcicsXG4gICAgYm9yZGVyQ29sb3I6ICdib3JkZXJDb2xvcidcbiAgfTtcblxuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucGFyc2VkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc2tpcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnN0b3AgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoY2ZnKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNmZyk7XG4gICAgfVxuICB9XG5cbiAgaW5SYW5nZShtb3VzZVg6IG51bWJlciwgbW91c2VZOiBudW1iZXIsIHVzZUZpbmFsUG9zaXRpb24/OiBib29sZWFuKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7eCwgeX0gPSB0aGlzLmdldFByb3BzKFsneCcsICd5J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIHJldHVybiAoKE1hdGgucG93KG1vdXNlWCAtIHgsIDIpICsgTWF0aC5wb3cobW91c2VZIC0geSwgMikpIDwgTWF0aC5wb3cob3B0aW9ucy5oaXRSYWRpdXMgKyBvcHRpb25zLnJhZGl1cywgMikpO1xuICB9XG5cbiAgaW5YUmFuZ2UobW91c2VYOiBudW1iZXIsIHVzZUZpbmFsUG9zaXRpb24/OiBib29sZWFuKSB7XG4gICAgcmV0dXJuIGluUmFuZ2UodGhpcywgbW91c2VYLCAneCcsIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG5cbiAgaW5ZUmFuZ2UobW91c2VZOiBudW1iZXIsIHVzZUZpbmFsUG9zaXRpb24/OiBib29sZWFuKSB7XG4gICAgcmV0dXJuIGluUmFuZ2UodGhpcywgbW91c2VZLCAneScsIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG5cbiAgZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbj86IGJvb2xlYW4pIHtcbiAgICBjb25zdCB7eCwgeX0gPSB0aGlzLmdldFByb3BzKFsneCcsICd5J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIHJldHVybiB7eCwgeX07XG4gIH1cblxuICBzaXplKG9wdGlvbnM/OiBQYXJ0aWFsPFBvaW50T3B0aW9ucyAmIFBvaW50SG92ZXJPcHRpb25zPikge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHRoaXMub3B0aW9ucyB8fCB7fTtcbiAgICBsZXQgcmFkaXVzID0gb3B0aW9ucy5yYWRpdXMgfHwgMDtcbiAgICByYWRpdXMgPSBNYXRoLm1heChyYWRpdXMsIHJhZGl1cyAmJiBvcHRpb25zLmhvdmVyUmFkaXVzIHx8IDApO1xuICAgIGNvbnN0IGJvcmRlcldpZHRoID0gcmFkaXVzICYmIG9wdGlvbnMuYm9yZGVyV2lkdGggfHwgMDtcbiAgICByZXR1cm4gKHJhZGl1cyArIGJvcmRlcldpZHRoKSAqIDI7XG4gIH1cblxuICBkcmF3KGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBhcmVhOiBDaGFydEFyZWEpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gICAgaWYgKHRoaXMuc2tpcCB8fCBvcHRpb25zLnJhZGl1cyA8IDAuMSB8fCAhX2lzUG9pbnRJbkFyZWEodGhpcywgYXJlYSwgdGhpcy5zaXplKG9wdGlvbnMpIC8gMikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLmJvcmRlckNvbG9yO1xuICAgIGN0eC5saW5lV2lkdGggPSBvcHRpb25zLmJvcmRlcldpZHRoO1xuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcbiAgICBkcmF3UG9pbnQoY3R4LCBvcHRpb25zLCB0aGlzLngsIHRoaXMueSk7XG4gIH1cblxuICBnZXRSYW5nZSgpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zIHx8IHt9O1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgRmFsbGJhY2tzIHNob3VsZCBuZXZlciBiZSBoaXQgaW4gcHJhY3RpY2VcbiAgICByZXR1cm4gb3B0aW9ucy5yYWRpdXMgKyBvcHRpb25zLmhpdFJhZGl1cztcbiAgfVxufVxuIiwiaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi4vY29yZS9jb3JlLmVsZW1lbnQuanMnO1xuaW1wb3J0IHtpc09iamVjdCwgX2lzQmV0d2VlbiwgX2xpbWl0VmFsdWV9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IHthZGRSb3VuZGVkUmVjdFBhdGh9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jYW52YXMuanMnO1xuaW1wb3J0IHt0b1RSQkwsIHRvVFJCTENvcm5lcnN9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5vcHRpb25zLmpzJztcblxuLyoqIEB0eXBlZGVmIHt7IHg6IG51bWJlciwgeTogbnVtYmVyLCBiYXNlOiBudW1iZXIsIGhvcml6b250YWw6IGJvb2xlYW4sIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyIH19IEJhclByb3BzICovXG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgYm91bmRzIG9mIHRoZSBiYXIgcmVnYXJkbGVzcyBvZiB0aGUgb3JpZW50YXRpb25cbiAqIEBwYXJhbSB7QmFyRWxlbWVudH0gYmFyIHRoZSBiYXJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dXG4gKiBAcmV0dXJuIHtvYmplY3R9IGJvdW5kcyBvZiB0aGUgYmFyXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRCYXJCb3VuZHMoYmFyLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gIGNvbnN0IHt4LCB5LCBiYXNlLCB3aWR0aCwgaGVpZ2h0fSA9IC8qKiBAdHlwZSB7QmFyUHJvcHN9ICovIChiYXIuZ2V0UHJvcHMoWyd4JywgJ3knLCAnYmFzZScsICd3aWR0aCcsICdoZWlnaHQnXSwgdXNlRmluYWxQb3NpdGlvbikpO1xuXG4gIGxldCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIGhhbGY7XG5cbiAgaWYgKGJhci5ob3Jpem9udGFsKSB7XG4gICAgaGFsZiA9IGhlaWdodCAvIDI7XG4gICAgbGVmdCA9IE1hdGgubWluKHgsIGJhc2UpO1xuICAgIHJpZ2h0ID0gTWF0aC5tYXgoeCwgYmFzZSk7XG4gICAgdG9wID0geSAtIGhhbGY7XG4gICAgYm90dG9tID0geSArIGhhbGY7XG4gIH0gZWxzZSB7XG4gICAgaGFsZiA9IHdpZHRoIC8gMjtcbiAgICBsZWZ0ID0geCAtIGhhbGY7XG4gICAgcmlnaHQgPSB4ICsgaGFsZjtcbiAgICB0b3AgPSBNYXRoLm1pbih5LCBiYXNlKTtcbiAgICBib3R0b20gPSBNYXRoLm1heCh5LCBiYXNlKTtcbiAgfVxuXG4gIHJldHVybiB7bGVmdCwgdG9wLCByaWdodCwgYm90dG9tfTtcbn1cblxuZnVuY3Rpb24gc2tpcE9yTGltaXQoc2tpcCwgdmFsdWUsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBza2lwID8gMCA6IF9saW1pdFZhbHVlKHZhbHVlLCBtaW4sIG1heCk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQm9yZGVyV2lkdGgoYmFyLCBtYXhXLCBtYXhIKSB7XG4gIGNvbnN0IHZhbHVlID0gYmFyLm9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gIGNvbnN0IHNraXAgPSBiYXIuYm9yZGVyU2tpcHBlZDtcbiAgY29uc3QgbyA9IHRvVFJCTCh2YWx1ZSk7XG5cbiAgcmV0dXJuIHtcbiAgICB0OiBza2lwT3JMaW1pdChza2lwLnRvcCwgby50b3AsIDAsIG1heEgpLFxuICAgIHI6IHNraXBPckxpbWl0KHNraXAucmlnaHQsIG8ucmlnaHQsIDAsIG1heFcpLFxuICAgIGI6IHNraXBPckxpbWl0KHNraXAuYm90dG9tLCBvLmJvdHRvbSwgMCwgbWF4SCksXG4gICAgbDogc2tpcE9yTGltaXQoc2tpcC5sZWZ0LCBvLmxlZnQsIDAsIG1heFcpXG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlQm9yZGVyUmFkaXVzKGJhciwgbWF4VywgbWF4SCkge1xuICBjb25zdCB7ZW5hYmxlQm9yZGVyUmFkaXVzfSA9IGJhci5nZXRQcm9wcyhbJ2VuYWJsZUJvcmRlclJhZGl1cyddKTtcbiAgY29uc3QgdmFsdWUgPSBiYXIub3B0aW9ucy5ib3JkZXJSYWRpdXM7XG4gIGNvbnN0IG8gPSB0b1RSQkxDb3JuZXJzKHZhbHVlKTtcbiAgY29uc3QgbWF4UiA9IE1hdGgubWluKG1heFcsIG1heEgpO1xuICBjb25zdCBza2lwID0gYmFyLmJvcmRlclNraXBwZWQ7XG5cbiAgLy8gSWYgdGhlIHZhbHVlIGlzIGFuIG9iamVjdCwgYXNzdW1lIHRoZSB1c2VyIGtub3dzIHdoYXQgdGhleSBhcmUgZG9pbmdcbiAgLy8gYW5kIGFwcGx5IGFzIGRpcmVjdGVkLlxuICBjb25zdCBlbmFibGVCb3JkZXIgPSBlbmFibGVCb3JkZXJSYWRpdXMgfHwgaXNPYmplY3QodmFsdWUpO1xuXG4gIHJldHVybiB7XG4gICAgdG9wTGVmdDogc2tpcE9yTGltaXQoIWVuYWJsZUJvcmRlciB8fCBza2lwLnRvcCB8fCBza2lwLmxlZnQsIG8udG9wTGVmdCwgMCwgbWF4UiksXG4gICAgdG9wUmlnaHQ6IHNraXBPckxpbWl0KCFlbmFibGVCb3JkZXIgfHwgc2tpcC50b3AgfHwgc2tpcC5yaWdodCwgby50b3BSaWdodCwgMCwgbWF4UiksXG4gICAgYm90dG9tTGVmdDogc2tpcE9yTGltaXQoIWVuYWJsZUJvcmRlciB8fCBza2lwLmJvdHRvbSB8fCBza2lwLmxlZnQsIG8uYm90dG9tTGVmdCwgMCwgbWF4UiksXG4gICAgYm90dG9tUmlnaHQ6IHNraXBPckxpbWl0KCFlbmFibGVCb3JkZXIgfHwgc2tpcC5ib3R0b20gfHwgc2tpcC5yaWdodCwgby5ib3R0b21SaWdodCwgMCwgbWF4UilcbiAgfTtcbn1cblxuZnVuY3Rpb24gYm91bmRpbmdSZWN0cyhiYXIpIHtcbiAgY29uc3QgYm91bmRzID0gZ2V0QmFyQm91bmRzKGJhcik7XG4gIGNvbnN0IHdpZHRoID0gYm91bmRzLnJpZ2h0IC0gYm91bmRzLmxlZnQ7XG4gIGNvbnN0IGhlaWdodCA9IGJvdW5kcy5ib3R0b20gLSBib3VuZHMudG9wO1xuICBjb25zdCBib3JkZXIgPSBwYXJzZUJvcmRlcldpZHRoKGJhciwgd2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcbiAgY29uc3QgcmFkaXVzID0gcGFyc2VCb3JkZXJSYWRpdXMoYmFyLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuXG4gIHJldHVybiB7XG4gICAgb3V0ZXI6IHtcbiAgICAgIHg6IGJvdW5kcy5sZWZ0LFxuICAgICAgeTogYm91bmRzLnRvcCxcbiAgICAgIHc6IHdpZHRoLFxuICAgICAgaDogaGVpZ2h0LFxuICAgICAgcmFkaXVzXG4gICAgfSxcbiAgICBpbm5lcjoge1xuICAgICAgeDogYm91bmRzLmxlZnQgKyBib3JkZXIubCxcbiAgICAgIHk6IGJvdW5kcy50b3AgKyBib3JkZXIudCxcbiAgICAgIHc6IHdpZHRoIC0gYm9yZGVyLmwgLSBib3JkZXIucixcbiAgICAgIGg6IGhlaWdodCAtIGJvcmRlci50IC0gYm9yZGVyLmIsXG4gICAgICByYWRpdXM6IHtcbiAgICAgICAgdG9wTGVmdDogTWF0aC5tYXgoMCwgcmFkaXVzLnRvcExlZnQgLSBNYXRoLm1heChib3JkZXIudCwgYm9yZGVyLmwpKSxcbiAgICAgICAgdG9wUmlnaHQ6IE1hdGgubWF4KDAsIHJhZGl1cy50b3BSaWdodCAtIE1hdGgubWF4KGJvcmRlci50LCBib3JkZXIucikpLFxuICAgICAgICBib3R0b21MZWZ0OiBNYXRoLm1heCgwLCByYWRpdXMuYm90dG9tTGVmdCAtIE1hdGgubWF4KGJvcmRlci5iLCBib3JkZXIubCkpLFxuICAgICAgICBib3R0b21SaWdodDogTWF0aC5tYXgoMCwgcmFkaXVzLmJvdHRvbVJpZ2h0IC0gTWF0aC5tYXgoYm9yZGVyLmIsIGJvcmRlci5yKSksXG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpblJhbmdlKGJhciwgeCwgeSwgdXNlRmluYWxQb3NpdGlvbikge1xuICBjb25zdCBza2lwWCA9IHggPT09IG51bGw7XG4gIGNvbnN0IHNraXBZID0geSA9PT0gbnVsbDtcbiAgY29uc3Qgc2tpcEJvdGggPSBza2lwWCAmJiBza2lwWTtcbiAgY29uc3QgYm91bmRzID0gYmFyICYmICFza2lwQm90aCAmJiBnZXRCYXJCb3VuZHMoYmFyLCB1c2VGaW5hbFBvc2l0aW9uKTtcblxuICByZXR1cm4gYm91bmRzXG5cdFx0JiYgKHNraXBYIHx8IF9pc0JldHdlZW4oeCwgYm91bmRzLmxlZnQsIGJvdW5kcy5yaWdodCkpXG5cdFx0JiYgKHNraXBZIHx8IF9pc0JldHdlZW4oeSwgYm91bmRzLnRvcCwgYm91bmRzLmJvdHRvbSkpO1xufVxuXG5mdW5jdGlvbiBoYXNSYWRpdXMocmFkaXVzKSB7XG4gIHJldHVybiByYWRpdXMudG9wTGVmdCB8fCByYWRpdXMudG9wUmlnaHQgfHwgcmFkaXVzLmJvdHRvbUxlZnQgfHwgcmFkaXVzLmJvdHRvbVJpZ2h0O1xufVxuXG4vKipcbiAqIEFkZCBhIHBhdGggb2YgYSByZWN0YW5nbGUgdG8gdGhlIGN1cnJlbnQgc3ViLXBhdGhcbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dFxuICogQHBhcmFtIHsqfSByZWN0IEJvdW5kaW5nIHJlY3RcbiAqL1xuZnVuY3Rpb24gYWRkTm9ybWFsUmVjdFBhdGgoY3R4LCByZWN0KSB7XG4gIGN0eC5yZWN0KHJlY3QueCwgcmVjdC55LCByZWN0LncsIHJlY3QuaCk7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVSZWN0KHJlY3QsIGFtb3VudCwgcmVmUmVjdCA9IHt9KSB7XG4gIGNvbnN0IHggPSByZWN0LnggIT09IHJlZlJlY3QueCA/IC1hbW91bnQgOiAwO1xuICBjb25zdCB5ID0gcmVjdC55ICE9PSByZWZSZWN0LnkgPyAtYW1vdW50IDogMDtcbiAgY29uc3QgdyA9IChyZWN0LnggKyByZWN0LncgIT09IHJlZlJlY3QueCArIHJlZlJlY3QudyA/IGFtb3VudCA6IDApIC0geDtcbiAgY29uc3QgaCA9IChyZWN0LnkgKyByZWN0LmggIT09IHJlZlJlY3QueSArIHJlZlJlY3QuaCA/IGFtb3VudCA6IDApIC0geTtcbiAgcmV0dXJuIHtcbiAgICB4OiByZWN0LnggKyB4LFxuICAgIHk6IHJlY3QueSArIHksXG4gICAgdzogcmVjdC53ICsgdyxcbiAgICBoOiByZWN0LmggKyBoLFxuICAgIHJhZGl1czogcmVjdC5yYWRpdXNcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuXG4gIHN0YXRpYyBpZCA9ICdiYXInO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGJvcmRlclNraXBwZWQ6ICdzdGFydCcsXG4gICAgYm9yZGVyV2lkdGg6IDAsXG4gICAgYm9yZGVyUmFkaXVzOiAwLFxuICAgIGluZmxhdGVBbW91bnQ6ICdhdXRvJyxcbiAgICBwb2ludFN0eWxlOiB1bmRlZmluZWRcbiAgfTtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0Um91dGVzID0ge1xuICAgIGJhY2tncm91bmRDb2xvcjogJ2JhY2tncm91bmRDb2xvcicsXG4gICAgYm9yZGVyQ29sb3I6ICdib3JkZXJDb2xvcidcbiAgfTtcblxuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaG9yaXpvbnRhbCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJhc2UgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmluZmxhdGVBbW91bnQgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoY2ZnKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNmZyk7XG4gICAgfVxuICB9XG5cbiAgZHJhdyhjdHgpIHtcbiAgICBjb25zdCB7aW5mbGF0ZUFtb3VudCwgb3B0aW9uczoge2JvcmRlckNvbG9yLCBiYWNrZ3JvdW5kQ29sb3J9fSA9IHRoaXM7XG4gICAgY29uc3Qge2lubmVyLCBvdXRlcn0gPSBib3VuZGluZ1JlY3RzKHRoaXMpO1xuICAgIGNvbnN0IGFkZFJlY3RQYXRoID0gaGFzUmFkaXVzKG91dGVyLnJhZGl1cykgPyBhZGRSb3VuZGVkUmVjdFBhdGggOiBhZGROb3JtYWxSZWN0UGF0aDtcblxuICAgIGN0eC5zYXZlKCk7XG5cbiAgICBpZiAob3V0ZXIudyAhPT0gaW5uZXIudyB8fCBvdXRlci5oICE9PSBpbm5lci5oKSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBhZGRSZWN0UGF0aChjdHgsIGluZmxhdGVSZWN0KG91dGVyLCBpbmZsYXRlQW1vdW50LCBpbm5lcikpO1xuICAgICAgY3R4LmNsaXAoKTtcbiAgICAgIGFkZFJlY3RQYXRoKGN0eCwgaW5mbGF0ZVJlY3QoaW5uZXIsIC1pbmZsYXRlQW1vdW50LCBvdXRlcikpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGJvcmRlckNvbG9yO1xuICAgICAgY3R4LmZpbGwoJ2V2ZW5vZGQnKTtcbiAgICB9XG5cbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgYWRkUmVjdFBhdGgoY3R4LCBpbmZsYXRlUmVjdChpbm5lciwgaW5mbGF0ZUFtb3VudCkpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgY3R4LmZpbGwoKTtcblxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cblxuICBpblJhbmdlKG1vdXNlWCwgbW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIGluUmFuZ2UodGhpcywgbW91c2VYLCBtb3VzZVksIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG5cbiAgaW5YUmFuZ2UobW91c2VYLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIGluUmFuZ2UodGhpcywgbW91c2VYLCBudWxsLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuXG4gIGluWVJhbmdlKG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIHJldHVybiBpblJhbmdlKHRoaXMsIG51bGwsIG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cblxuICBnZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgY29uc3Qge3gsIHksIGJhc2UsIGhvcml6b250YWx9ID0gLyoqIEB0eXBlIHtCYXJQcm9wc30gKi8gKHRoaXMuZ2V0UHJvcHMoWyd4JywgJ3knLCAnYmFzZScsICdob3Jpem9udGFsJ10sIHVzZUZpbmFsUG9zaXRpb24pKTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogaG9yaXpvbnRhbCA/ICh4ICsgYmFzZSkgLyAyIDogeCxcbiAgICAgIHk6IGhvcml6b250YWwgPyB5IDogKHkgKyBiYXNlKSAvIDJcbiAgICB9O1xuICB9XG5cbiAgZ2V0UmFuZ2UoYXhpcykge1xuICAgIHJldHVybiBheGlzID09PSAneCcgPyB0aGlzLndpZHRoIC8gMiA6IHRoaXMuaGVpZ2h0IC8gMjtcbiAgfVxufVxuIiwiaW1wb3J0IHtEb3VnaG51dENvbnRyb2xsZXIsIFBvbGFyQXJlYUNvbnRyb2xsZXIsIGRlZmF1bHRzfSBmcm9tICcuLi9pbmRleC5qcyc7XG5pbXBvcnQgdHlwZSB7Q2hhcnQsIENoYXJ0RGF0YXNldH0gZnJvbSAnLi4vdHlwZXMuanMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbG9yc1BsdWdpbk9wdGlvbnMge1xuICBlbmFibGVkPzogYm9vbGVhbjtcbiAgZm9yY2VPdmVycmlkZT86IGJvb2xlYW47XG59XG5cbmludGVyZmFjZSBDb2xvcnNEZXNjcmlwdG9yIHtcbiAgYmFja2dyb3VuZENvbG9yPzogdW5rbm93bjtcbiAgYm9yZGVyQ29sb3I/OiB1bmtub3duO1xufVxuXG5jb25zdCBCT1JERVJfQ09MT1JTID0gW1xuICAncmdiKDU0LCAxNjIsIDIzNSknLCAvLyBibHVlXG4gICdyZ2IoMjU1LCA5OSwgMTMyKScsIC8vIHJlZFxuICAncmdiKDI1NSwgMTU5LCA2NCknLCAvLyBvcmFuZ2VcbiAgJ3JnYigyNTUsIDIwNSwgODYpJywgLy8geWVsbG93XG4gICdyZ2IoNzUsIDE5MiwgMTkyKScsIC8vIGdyZWVuXG4gICdyZ2IoMTUzLCAxMDIsIDI1NSknLCAvLyBwdXJwbGVcbiAgJ3JnYigyMDEsIDIwMywgMjA3KScgLy8gZ3JleVxuXTtcblxuLy8gQm9yZGVyIGNvbG9ycyB3aXRoIDUwJSB0cmFuc3BhcmVuY3lcbmNvbnN0IEJBQ0tHUk9VTkRfQ09MT1JTID0gLyogI19fUFVSRV9fICovIEJPUkRFUl9DT0xPUlMubWFwKGNvbG9yID0+IGNvbG9yLnJlcGxhY2UoJ3JnYignLCAncmdiYSgnKS5yZXBsYWNlKCcpJywgJywgMC41KScpKTtcblxuZnVuY3Rpb24gZ2V0Qm9yZGVyQ29sb3IoaTogbnVtYmVyKSB7XG4gIHJldHVybiBCT1JERVJfQ09MT1JTW2kgJSBCT1JERVJfQ09MT1JTLmxlbmd0aF07XG59XG5cbmZ1bmN0aW9uIGdldEJhY2tncm91bmRDb2xvcihpOiBudW1iZXIpIHtcbiAgcmV0dXJuIEJBQ0tHUk9VTkRfQ09MT1JTW2kgJSBCQUNLR1JPVU5EX0NPTE9SUy5sZW5ndGhdO1xufVxuXG5mdW5jdGlvbiBjb2xvcml6ZURlZmF1bHREYXRhc2V0KGRhdGFzZXQ6IENoYXJ0RGF0YXNldCwgaTogbnVtYmVyKSB7XG4gIGRhdGFzZXQuYm9yZGVyQ29sb3IgPSBnZXRCb3JkZXJDb2xvcihpKTtcbiAgZGF0YXNldC5iYWNrZ3JvdW5kQ29sb3IgPSBnZXRCYWNrZ3JvdW5kQ29sb3IoaSk7XG5cbiAgcmV0dXJuICsraTtcbn1cblxuZnVuY3Rpb24gY29sb3JpemVEb3VnaG51dERhdGFzZXQoZGF0YXNldDogQ2hhcnREYXRhc2V0LCBpOiBudW1iZXIpIHtcbiAgZGF0YXNldC5iYWNrZ3JvdW5kQ29sb3IgPSBkYXRhc2V0LmRhdGEubWFwKCgpID0+IGdldEJvcmRlckNvbG9yKGkrKykpO1xuXG4gIHJldHVybiBpO1xufVxuXG5mdW5jdGlvbiBjb2xvcml6ZVBvbGFyQXJlYURhdGFzZXQoZGF0YXNldDogQ2hhcnREYXRhc2V0LCBpOiBudW1iZXIpIHtcbiAgZGF0YXNldC5iYWNrZ3JvdW5kQ29sb3IgPSBkYXRhc2V0LmRhdGEubWFwKCgpID0+IGdldEJhY2tncm91bmRDb2xvcihpKyspKTtcblxuICByZXR1cm4gaTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29sb3JpemVyKGNoYXJ0OiBDaGFydCkge1xuICBsZXQgaSA9IDA7XG5cbiAgcmV0dXJuIChkYXRhc2V0OiBDaGFydERhdGFzZXQsIGRhdGFzZXRJbmRleDogbnVtYmVyKSA9PiB7XG4gICAgY29uc3QgY29udHJvbGxlciA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuY29udHJvbGxlcjtcblxuICAgIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgRG91Z2hudXRDb250cm9sbGVyKSB7XG4gICAgICBpID0gY29sb3JpemVEb3VnaG51dERhdGFzZXQoZGF0YXNldCwgaSk7XG4gICAgfSBlbHNlIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgUG9sYXJBcmVhQ29udHJvbGxlcikge1xuICAgICAgaSA9IGNvbG9yaXplUG9sYXJBcmVhRGF0YXNldChkYXRhc2V0LCBpKTtcbiAgICB9IGVsc2UgaWYgKGNvbnRyb2xsZXIpIHtcbiAgICAgIGkgPSBjb2xvcml6ZURlZmF1bHREYXRhc2V0KGRhdGFzZXQsIGkpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnNDb2xvcnNEZWZpbml0aW9ucyhcbiAgZGVzY3JpcHRvcnM6IENvbG9yc0Rlc2NyaXB0b3JbXSB8IFJlY29yZDxzdHJpbmcsIENvbG9yc0Rlc2NyaXB0b3I+XG4pIHtcbiAgbGV0IGs6IG51bWJlciB8IHN0cmluZztcblxuICBmb3IgKGsgaW4gZGVzY3JpcHRvcnMpIHtcbiAgICBpZiAoZGVzY3JpcHRvcnNba10uYm9yZGVyQ29sb3IgfHwgZGVzY3JpcHRvcnNba10uYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5zQ29sb3JzRGVmaW5pdGlvbihcbiAgZGVzY3JpcHRvcjogQ29sb3JzRGVzY3JpcHRvclxuKSB7XG4gIHJldHVybiBkZXNjcmlwdG9yICYmIChkZXNjcmlwdG9yLmJvcmRlckNvbG9yIHx8IGRlc2NyaXB0b3IuYmFja2dyb3VuZENvbG9yKTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnNEZWZhdWx0Q29sb3JzRGVmZW5pdGlvbnMoKSB7XG4gIHJldHVybiBkZWZhdWx0cy5ib3JkZXJDb2xvciAhPT0gJ3JnYmEoMCwwLDAsMC4xKScgfHwgZGVmYXVsdHMuYmFja2dyb3VuZENvbG9yICE9PSAncmdiYSgwLDAsMCwwLjEpJztcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpZDogJ2NvbG9ycycsXG5cbiAgZGVmYXVsdHM6IHtcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGZvcmNlT3ZlcnJpZGU6IGZhbHNlXG4gIH0gYXMgQ29sb3JzUGx1Z2luT3B0aW9ucyxcblxuICBiZWZvcmVMYXlvdXQoY2hhcnQ6IENoYXJ0LCBfYXJncywgb3B0aW9uczogQ29sb3JzUGx1Z2luT3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy5lbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgZGF0YToge2RhdGFzZXRzfSxcbiAgICAgIG9wdGlvbnM6IGNoYXJ0T3B0aW9uc1xuICAgIH0gPSBjaGFydC5jb25maWc7XG4gICAgY29uc3Qge2VsZW1lbnRzfSA9IGNoYXJ0T3B0aW9ucztcblxuICAgIGNvbnN0IGNvbnRhaW5zQ29sb3JEZWZlbml0aW9uID0gKFxuICAgICAgY29udGFpbnNDb2xvcnNEZWZpbml0aW9ucyhkYXRhc2V0cykgfHxcbiAgICAgIGNvbnRhaW5zQ29sb3JzRGVmaW5pdGlvbihjaGFydE9wdGlvbnMpIHx8XG4gICAgICAoZWxlbWVudHMgJiYgY29udGFpbnNDb2xvcnNEZWZpbml0aW9ucyhlbGVtZW50cykpIHx8XG4gICAgICBjb250YWluc0RlZmF1bHRDb2xvcnNEZWZlbml0aW9ucygpKTtcblxuICAgIGlmICghb3B0aW9ucy5mb3JjZU92ZXJyaWRlICYmIGNvbnRhaW5zQ29sb3JEZWZlbml0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY29sb3JpemVyID0gZ2V0Q29sb3JpemVyKGNoYXJ0KTtcblxuICAgIGRhdGFzZXRzLmZvckVhY2goY29sb3JpemVyKTtcbiAgfVxufTtcbiIsImltcG9ydCB7X2xpbWl0VmFsdWUsIF9sb29rdXBCeUtleSwgaXNOdWxsT3JVbmRlZiwgcmVzb2x2ZX0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbmZ1bmN0aW9uIGx0dGJEZWNpbWF0aW9uKGRhdGEsIHN0YXJ0LCBjb3VudCwgYXZhaWxhYmxlV2lkdGgsIG9wdGlvbnMpIHtcbiAgLyoqXG4gICAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBMYXJnZXN0IFRyaWFuZ2xlIFRocmVlIEJ1Y2tldHMgYWxnb3JpdGhtLlxuICAgKlxuICAgKiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGJhc2VkIG9uIHRoZSBvcmlnaW5hbCBpbXBsZW1lbnRhdGlvbiBieSBTdmVpbm4gU3RlaW5hcnNzb25cbiAgICogaW4gaHR0cHM6Ly9naXRodWIuY29tL3N2ZWlubi1zdGVpbmFyc3Nvbi9mbG90LWRvd25zYW1wbGUvYmxvYi9tYXN0ZXIvanF1ZXJ5LmZsb3QuZG93bnNhbXBsZS5qc1xuICAgKlxuICAgKiBUaGUgb3JpZ2luYWwgaW1wbGVtZW50YXRpb24gaXMgTUlUIGxpY2Vuc2VkLlxuICAgKi9cbiAgY29uc3Qgc2FtcGxlcyA9IG9wdGlvbnMuc2FtcGxlcyB8fCBhdmFpbGFibGVXaWR0aDtcbiAgLy8gVGhlcmUgYXJlIGxlc3MgcG9pbnRzIHRoYW4gdGhlIHRocmVzaG9sZCwgcmV0dXJuaW5nIHRoZSB3aG9sZSBhcnJheVxuICBpZiAoc2FtcGxlcyA+PSBjb3VudCkge1xuICAgIHJldHVybiBkYXRhLnNsaWNlKHN0YXJ0LCBzdGFydCArIGNvdW50KTtcbiAgfVxuXG4gIGNvbnN0IGRlY2ltYXRlZCA9IFtdO1xuXG4gIGNvbnN0IGJ1Y2tldFdpZHRoID0gKGNvdW50IC0gMikgLyAoc2FtcGxlcyAtIDIpO1xuICBsZXQgc2FtcGxlZEluZGV4ID0gMDtcbiAgY29uc3QgZW5kSW5kZXggPSBzdGFydCArIGNvdW50IC0gMTtcbiAgLy8gU3RhcnRpbmcgZnJvbSBvZmZzZXRcbiAgbGV0IGEgPSBzdGFydDtcbiAgbGV0IGksIG1heEFyZWFQb2ludCwgbWF4QXJlYSwgYXJlYSwgbmV4dEE7XG5cbiAgZGVjaW1hdGVkW3NhbXBsZWRJbmRleCsrXSA9IGRhdGFbYV07XG5cbiAgZm9yIChpID0gMDsgaSA8IHNhbXBsZXMgLSAyOyBpKyspIHtcbiAgICBsZXQgYXZnWCA9IDA7XG4gICAgbGV0IGF2Z1kgPSAwO1xuICAgIGxldCBqO1xuXG4gICAgLy8gQWRkaW5nIG9mZnNldFxuICAgIGNvbnN0IGF2Z1JhbmdlU3RhcnQgPSBNYXRoLmZsb29yKChpICsgMSkgKiBidWNrZXRXaWR0aCkgKyAxICsgc3RhcnQ7XG4gICAgY29uc3QgYXZnUmFuZ2VFbmQgPSBNYXRoLm1pbihNYXRoLmZsb29yKChpICsgMikgKiBidWNrZXRXaWR0aCkgKyAxLCBjb3VudCkgKyBzdGFydDtcbiAgICBjb25zdCBhdmdSYW5nZUxlbmd0aCA9IGF2Z1JhbmdlRW5kIC0gYXZnUmFuZ2VTdGFydDtcblxuICAgIGZvciAoaiA9IGF2Z1JhbmdlU3RhcnQ7IGogPCBhdmdSYW5nZUVuZDsgaisrKSB7XG4gICAgICBhdmdYICs9IGRhdGFbal0ueDtcbiAgICAgIGF2Z1kgKz0gZGF0YVtqXS55O1xuICAgIH1cblxuICAgIGF2Z1ggLz0gYXZnUmFuZ2VMZW5ndGg7XG4gICAgYXZnWSAvPSBhdmdSYW5nZUxlbmd0aDtcblxuICAgIC8vIEFkZGluZyBvZmZzZXRcbiAgICBjb25zdCByYW5nZU9mZnMgPSBNYXRoLmZsb29yKGkgKiBidWNrZXRXaWR0aCkgKyAxICsgc3RhcnQ7XG4gICAgY29uc3QgcmFuZ2VUbyA9IE1hdGgubWluKE1hdGguZmxvb3IoKGkgKyAxKSAqIGJ1Y2tldFdpZHRoKSArIDEsIGNvdW50KSArIHN0YXJ0O1xuICAgIGNvbnN0IHt4OiBwb2ludEF4LCB5OiBwb2ludEF5fSA9IGRhdGFbYV07XG5cbiAgICAvLyBOb3RlIHRoYXQgdGhpcyBpcyBjaGFuZ2VkIGZyb20gdGhlIG9yaWdpbmFsIGFsZ29yaXRobSB3aGljaCBpbml0aWFsaXplcyB0aGVzZVxuICAgIC8vIHZhbHVlcyB0byAxLiBUaGUgcmVhc29uIGZvciB0aGlzIGNoYW5nZSBpcyB0aGF0IGlmIHRoZSBhcmVhIGlzIHNtYWxsLCBuZXh0QVxuICAgIC8vIHdvdWxkIG5ldmVyIGJlIHNldCBhbmQgdGh1cyBhIGNyYXNoIHdvdWxkIG9jY3VyIGluIHRoZSBuZXh0IGxvb3AgYXMgYGFgIHdvdWxkIGJlY29tZVxuICAgIC8vIGB1bmRlZmluZWRgLiBTaW5jZSB0aGUgYXJlYSBpcyBhbHdheXMgcG9zaXRpdmUsIGJ1dCBjb3VsZCBiZSAwIGluIHRoZSBjYXNlIG9mIGEgZmxhdCB0cmFjZSxcbiAgICAvLyBpbml0aWFsaXppbmcgd2l0aCBhIG5lZ2F0aXZlIG51bWJlciBpcyB0aGUgY29ycmVjdCBzb2x1dGlvbi5cbiAgICBtYXhBcmVhID0gYXJlYSA9IC0xO1xuXG4gICAgZm9yIChqID0gcmFuZ2VPZmZzOyBqIDwgcmFuZ2VUbzsgaisrKSB7XG4gICAgICBhcmVhID0gMC41ICogTWF0aC5hYnMoXG4gICAgICAgIChwb2ludEF4IC0gYXZnWCkgKiAoZGF0YVtqXS55IC0gcG9pbnRBeSkgLVxuICAgICAgICAocG9pbnRBeCAtIGRhdGFbal0ueCkgKiAoYXZnWSAtIHBvaW50QXkpXG4gICAgICApO1xuXG4gICAgICBpZiAoYXJlYSA+IG1heEFyZWEpIHtcbiAgICAgICAgbWF4QXJlYSA9IGFyZWE7XG4gICAgICAgIG1heEFyZWFQb2ludCA9IGRhdGFbal07XG4gICAgICAgIG5leHRBID0gajtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkZWNpbWF0ZWRbc2FtcGxlZEluZGV4KytdID0gbWF4QXJlYVBvaW50O1xuICAgIGEgPSBuZXh0QTtcbiAgfVxuXG4gIC8vIEluY2x1ZGUgdGhlIGxhc3QgcG9pbnRcbiAgZGVjaW1hdGVkW3NhbXBsZWRJbmRleCsrXSA9IGRhdGFbZW5kSW5kZXhdO1xuXG4gIHJldHVybiBkZWNpbWF0ZWQ7XG59XG5cbmZ1bmN0aW9uIG1pbk1heERlY2ltYXRpb24oZGF0YSwgc3RhcnQsIGNvdW50LCBhdmFpbGFibGVXaWR0aCkge1xuICBsZXQgYXZnWCA9IDA7XG4gIGxldCBjb3VudFggPSAwO1xuICBsZXQgaSwgcG9pbnQsIHgsIHksIHByZXZYLCBtaW5JbmRleCwgbWF4SW5kZXgsIHN0YXJ0SW5kZXgsIG1pblksIG1heFk7XG4gIGNvbnN0IGRlY2ltYXRlZCA9IFtdO1xuICBjb25zdCBlbmRJbmRleCA9IHN0YXJ0ICsgY291bnQgLSAxO1xuXG4gIGNvbnN0IHhNaW4gPSBkYXRhW3N0YXJ0XS54O1xuICBjb25zdCB4TWF4ID0gZGF0YVtlbmRJbmRleF0ueDtcbiAgY29uc3QgZHggPSB4TWF4IC0geE1pbjtcblxuICBmb3IgKGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7ICsraSkge1xuICAgIHBvaW50ID0gZGF0YVtpXTtcbiAgICB4ID0gKHBvaW50LnggLSB4TWluKSAvIGR4ICogYXZhaWxhYmxlV2lkdGg7XG4gICAgeSA9IHBvaW50Lnk7XG4gICAgY29uc3QgdHJ1bmNYID0geCB8IDA7XG5cbiAgICBpZiAodHJ1bmNYID09PSBwcmV2WCkge1xuICAgICAgLy8gRGV0ZXJtaW5lIGBtaW5ZYCAvIGBtYXhZYCBhbmQgYGF2Z1hgIHdoaWxlIHdlIHN0YXkgd2l0aGluIHNhbWUgeC1wb3NpdGlvblxuICAgICAgaWYgKHkgPCBtaW5ZKSB7XG4gICAgICAgIG1pblkgPSB5O1xuICAgICAgICBtaW5JbmRleCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKHkgPiBtYXhZKSB7XG4gICAgICAgIG1heFkgPSB5O1xuICAgICAgICBtYXhJbmRleCA9IGk7XG4gICAgICB9XG4gICAgICAvLyBGb3IgZmlyc3QgcG9pbnQgaW4gZ3JvdXAsIGNvdW50WCBpcyBgMGAsIHNvIGF2ZXJhZ2Ugd2lsbCBiZSBgeGAgLyAxLlxuICAgICAgLy8gVXNlIHBvaW50LnggaGVyZSBiZWNhdXNlIHdlJ3JlIGNvbXB1dGluZyB0aGUgYXZlcmFnZSBkYXRhIGB4YCB2YWx1ZVxuICAgICAgYXZnWCA9IChjb3VudFggKiBhdmdYICsgcG9pbnQueCkgLyArK2NvdW50WDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUHVzaCB1cCB0byA0IHBvaW50cywgMyBmb3IgdGhlIGxhc3QgaW50ZXJ2YWwgYW5kIHRoZSBmaXJzdCBwb2ludCBmb3IgdGhpcyBpbnRlcnZhbFxuICAgICAgY29uc3QgbGFzdEluZGV4ID0gaSAtIDE7XG5cbiAgICAgIGlmICghaXNOdWxsT3JVbmRlZihtaW5JbmRleCkgJiYgIWlzTnVsbE9yVW5kZWYobWF4SW5kZXgpKSB7XG4gICAgICAgIC8vIFRoZSBpbnRlcnZhbCBpcyBkZWZpbmVkIGJ5IDQgcG9pbnRzOiBzdGFydCwgbWluLCBtYXgsIGVuZC5cbiAgICAgICAgLy8gVGhlIHN0YXJ0aW5nIHBvaW50IGlzIGFscmVhZHkgY29uc2lkZXJlZCBhdCB0aGlzIHBvaW50LCBzbyB3ZSBuZWVkIHRvIGRldGVybWluZSB3aGljaFxuICAgICAgICAvLyBvZiB0aGUgb3RoZXIgcG9pbnRzIHRvIGFkZC4gV2UgbmVlZCB0byBzb3J0IHRoZXNlIHBvaW50cyB0byBlbnN1cmUgdGhlIGRlY2ltYXRlZCBkYXRhXG4gICAgICAgIC8vIGlzIHN0aWxsIHNvcnRlZCBhbmQgdGhlbiBlbnN1cmUgdGhlcmUgYXJlIG5vIGR1cGxpY2F0ZXMuXG4gICAgICAgIGNvbnN0IGludGVybWVkaWF0ZUluZGV4MSA9IE1hdGgubWluKG1pbkluZGV4LCBtYXhJbmRleCk7XG4gICAgICAgIGNvbnN0IGludGVybWVkaWF0ZUluZGV4MiA9IE1hdGgubWF4KG1pbkluZGV4LCBtYXhJbmRleCk7XG5cbiAgICAgICAgaWYgKGludGVybWVkaWF0ZUluZGV4MSAhPT0gc3RhcnRJbmRleCAmJiBpbnRlcm1lZGlhdGVJbmRleDEgIT09IGxhc3RJbmRleCkge1xuICAgICAgICAgIGRlY2ltYXRlZC5wdXNoKHtcbiAgICAgICAgICAgIC4uLmRhdGFbaW50ZXJtZWRpYXRlSW5kZXgxXSxcbiAgICAgICAgICAgIHg6IGF2Z1gsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVybWVkaWF0ZUluZGV4MiAhPT0gc3RhcnRJbmRleCAmJiBpbnRlcm1lZGlhdGVJbmRleDIgIT09IGxhc3RJbmRleCkge1xuICAgICAgICAgIGRlY2ltYXRlZC5wdXNoKHtcbiAgICAgICAgICAgIC4uLmRhdGFbaW50ZXJtZWRpYXRlSW5kZXgyXSxcbiAgICAgICAgICAgIHg6IGF2Z1hcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBsYXN0SW5kZXggPT09IHN0YXJ0SW5kZXggd2lsbCBvY2N1ciB3aGVuIGEgcmFuZ2UgaGFzIG9ubHkgMSBwb2ludCB3aGljaCBjb3VsZFxuICAgICAgLy8gaGFwcGVuIHdpdGggdmVyeSB1bmV2ZW4gZGF0YVxuICAgICAgaWYgKGkgPiAwICYmIGxhc3RJbmRleCAhPT0gc3RhcnRJbmRleCkge1xuICAgICAgICAvLyBMYXN0IHBvaW50IGluIHRoZSBwcmV2aW91cyBpbnRlcnZhbFxuICAgICAgICBkZWNpbWF0ZWQucHVzaChkYXRhW2xhc3RJbmRleF0pO1xuICAgICAgfVxuXG4gICAgICAvLyBTdGFydCBvZiB0aGUgbmV3IGludGVydmFsXG4gICAgICBkZWNpbWF0ZWQucHVzaChwb2ludCk7XG4gICAgICBwcmV2WCA9IHRydW5jWDtcbiAgICAgIGNvdW50WCA9IDA7XG4gICAgICBtaW5ZID0gbWF4WSA9IHk7XG4gICAgICBtaW5JbmRleCA9IG1heEluZGV4ID0gc3RhcnRJbmRleCA9IGk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlY2ltYXRlZDtcbn1cblxuZnVuY3Rpb24gY2xlYW5EZWNpbWF0ZWREYXRhc2V0KGRhdGFzZXQpIHtcbiAgaWYgKGRhdGFzZXQuX2RlY2ltYXRlZCkge1xuICAgIGNvbnN0IGRhdGEgPSBkYXRhc2V0Ll9kYXRhO1xuICAgIGRlbGV0ZSBkYXRhc2V0Ll9kZWNpbWF0ZWQ7XG4gICAgZGVsZXRlIGRhdGFzZXQuX2RhdGE7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRhdGFzZXQsICdkYXRhJywge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGRhdGEsXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2xlYW5EZWNpbWF0ZWREYXRhKGNoYXJ0KSB7XG4gIGNoYXJ0LmRhdGEuZGF0YXNldHMuZm9yRWFjaCgoZGF0YXNldCkgPT4ge1xuICAgIGNsZWFuRGVjaW1hdGVkRGF0YXNldChkYXRhc2V0KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHNTaW1wbGlmaWVkKG1ldGEsIHBvaW50cykge1xuICBjb25zdCBwb2ludENvdW50ID0gcG9pbnRzLmxlbmd0aDtcblxuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgY291bnQ7XG5cbiAgY29uc3Qge2lTY2FsZX0gPSBtZXRhO1xuICBjb25zdCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gaVNjYWxlLmdldFVzZXJCb3VuZHMoKTtcblxuICBpZiAobWluRGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gX2xpbWl0VmFsdWUoX2xvb2t1cEJ5S2V5KHBvaW50cywgaVNjYWxlLmF4aXMsIG1pbikubG8sIDAsIHBvaW50Q291bnQgLSAxKTtcbiAgfVxuICBpZiAobWF4RGVmaW5lZCkge1xuICAgIGNvdW50ID0gX2xpbWl0VmFsdWUoX2xvb2t1cEJ5S2V5KHBvaW50cywgaVNjYWxlLmF4aXMsIG1heCkuaGkgKyAxLCBzdGFydCwgcG9pbnRDb3VudCkgLSBzdGFydDtcbiAgfSBlbHNlIHtcbiAgICBjb3VudCA9IHBvaW50Q291bnQgLSBzdGFydDtcbiAgfVxuXG4gIHJldHVybiB7c3RhcnQsIGNvdW50fTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpZDogJ2RlY2ltYXRpb24nLFxuXG4gIGRlZmF1bHRzOiB7XG4gICAgYWxnb3JpdGhtOiAnbWluLW1heCcsXG4gICAgZW5hYmxlZDogZmFsc2UsXG4gIH0sXG5cbiAgYmVmb3JlRWxlbWVudHNVcGRhdGU6IChjaGFydCwgYXJncywgb3B0aW9ucykgPT4ge1xuICAgIGlmICghb3B0aW9ucy5lbmFibGVkKSB7XG4gICAgICAvLyBUaGUgZGVjaW1hdGlvbiBwbHVnaW4gbWF5IGhhdmUgYmVlbiBwcmV2aW91c2x5IGVuYWJsZWQuIE5lZWQgdG8gcmVtb3ZlIG9sZCBgZGF0YXNldC5fZGF0YWAgaGFuZGxlcnNcbiAgICAgIGNsZWFuRGVjaW1hdGVkRGF0YShjaGFydCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQXNzdW1lIHRoZSBlbnRpcmUgY2hhcnQgaXMgYXZhaWxhYmxlIHRvIHNob3cgYSBmZXcgbW9yZSBwb2ludHMgdGhhbiBuZWVkZWRcbiAgICBjb25zdCBhdmFpbGFibGVXaWR0aCA9IGNoYXJ0LndpZHRoO1xuXG4gICAgY2hhcnQuZGF0YS5kYXRhc2V0cy5mb3JFYWNoKChkYXRhc2V0LCBkYXRhc2V0SW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHtfZGF0YSwgaW5kZXhBeGlzfSA9IGRhdGFzZXQ7XG4gICAgICBjb25zdCBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBfZGF0YSB8fCBkYXRhc2V0LmRhdGE7XG5cbiAgICAgIGlmIChyZXNvbHZlKFtpbmRleEF4aXMsIGNoYXJ0Lm9wdGlvbnMuaW5kZXhBeGlzXSkgPT09ICd5Jykge1xuICAgICAgICAvLyBEZWNpbWF0aW9uIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBsaW5lcyB0aGF0IGhhdmUgYW4gWCBpbmRleEF4aXNcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW1ldGEuY29udHJvbGxlci5zdXBwb3J0c0RlY2ltYXRpb24pIHtcbiAgICAgICAgLy8gT25seSBsaW5lIGRhdGFzZXRzIGFyZSBzdXBwb3J0ZWRcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB4QXhpcyA9IGNoYXJ0LnNjYWxlc1ttZXRhLnhBeGlzSURdO1xuICAgICAgaWYgKHhBeGlzLnR5cGUgIT09ICdsaW5lYXInICYmIHhBeGlzLnR5cGUgIT09ICd0aW1lJykge1xuICAgICAgICAvLyBPbmx5IGxpbmVhciBpbnRlcnBvbGF0aW9uIGlzIHN1cHBvcnRlZFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFydC5vcHRpb25zLnBhcnNpbmcpIHtcbiAgICAgICAgLy8gUGx1Z2luIG9ubHkgc3VwcG9ydHMgZGF0YSB0aGF0IGRvZXMgbm90IG5lZWQgcGFyc2luZ1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCB7c3RhcnQsIGNvdW50fSA9IGdldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHNTaW1wbGlmaWVkKG1ldGEsIGRhdGEpO1xuICAgICAgY29uc3QgdGhyZXNob2xkID0gb3B0aW9ucy50aHJlc2hvbGQgfHwgNCAqIGF2YWlsYWJsZVdpZHRoO1xuICAgICAgaWYgKGNvdW50IDw9IHRocmVzaG9sZCkge1xuICAgICAgICAvLyBObyBkZWNpbWF0aW9uIGlzIHJlcXVpcmVkIHVudGlsIHdlIGFyZSBhYm92ZSB0aGlzIHRocmVzaG9sZFxuICAgICAgICBjbGVhbkRlY2ltYXRlZERhdGFzZXQoZGF0YXNldCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzTnVsbE9yVW5kZWYoX2RhdGEpKSB7XG4gICAgICAgIC8vIEZpcnN0IHRpbWUgd2UgYXJlIHNlZWluZyB0aGlzIGRhdGFzZXRcbiAgICAgICAgLy8gV2Ugb3ZlcnJpZGUgdGhlICdkYXRhJyBwcm9wZXJ0eSB3aXRoIGEgc2V0dGVyIHRoYXQgc3RvcmVzIHRoZVxuICAgICAgICAvLyByYXcgZGF0YSBpbiBfZGF0YSwgYnV0IHJlYWRzIHRoZSBkZWNpbWF0ZWQgZGF0YSBmcm9tIF9kZWNpbWF0ZWRcbiAgICAgICAgZGF0YXNldC5fZGF0YSA9IGRhdGE7XG4gICAgICAgIGRlbGV0ZSBkYXRhc2V0LmRhdGE7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkYXRhc2V0LCAnZGF0YScsIHtcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlY2ltYXRlZDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgdGhpcy5fZGF0YSA9IGQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gUG9pbnQgdGhlIGNoYXJ0IHRvIHRoZSBkZWNpbWF0ZWQgZGF0YVxuICAgICAgbGV0IGRlY2ltYXRlZDtcbiAgICAgIHN3aXRjaCAob3B0aW9ucy5hbGdvcml0aG0pIHtcbiAgICAgIGNhc2UgJ2x0dGInOlxuICAgICAgICBkZWNpbWF0ZWQgPSBsdHRiRGVjaW1hdGlvbihkYXRhLCBzdGFydCwgY291bnQsIGF2YWlsYWJsZVdpZHRoLCBvcHRpb25zKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtaW4tbWF4JzpcbiAgICAgICAgZGVjaW1hdGVkID0gbWluTWF4RGVjaW1hdGlvbihkYXRhLCBzdGFydCwgY291bnQsIGF2YWlsYWJsZVdpZHRoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRlY2ltYXRpb24gYWxnb3JpdGhtICcke29wdGlvbnMuYWxnb3JpdGhtfSdgKTtcbiAgICAgIH1cblxuICAgICAgZGF0YXNldC5fZGVjaW1hdGVkID0gZGVjaW1hdGVkO1xuICAgIH0pO1xuICB9LFxuXG4gIGRlc3Ryb3koY2hhcnQpIHtcbiAgICBjbGVhbkRlY2ltYXRlZERhdGEoY2hhcnQpO1xuICB9XG59O1xuIiwiaW1wb3J0IHtfYm91bmRTZWdtZW50LCBfYm91bmRTZWdtZW50cywgX25vcm1hbGl6ZUFuZ2xlfSBmcm9tICcuLi8uLi9oZWxwZXJzL2luZGV4LmpzJztcblxuZXhwb3J0IGZ1bmN0aW9uIF9zZWdtZW50cyhsaW5lLCB0YXJnZXQsIHByb3BlcnR5KSB7XG4gIGNvbnN0IHNlZ21lbnRzID0gbGluZS5zZWdtZW50cztcbiAgY29uc3QgcG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGNvbnN0IHRwb2ludHMgPSB0YXJnZXQucG9pbnRzO1xuICBjb25zdCBwYXJ0cyA9IFtdO1xuXG4gIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgIGxldCB7c3RhcnQsIGVuZH0gPSBzZWdtZW50O1xuICAgIGVuZCA9IF9maW5kU2VnbWVudEVuZChzdGFydCwgZW5kLCBwb2ludHMpO1xuXG4gICAgY29uc3QgYm91bmRzID0gX2dldEJvdW5kcyhwcm9wZXJ0eSwgcG9pbnRzW3N0YXJ0XSwgcG9pbnRzW2VuZF0sIHNlZ21lbnQubG9vcCk7XG5cbiAgICBpZiAoIXRhcmdldC5zZWdtZW50cykge1xuICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciBib3VuZGFyeSBub3Qgc3VwcG9ydGluZyBgc2VnbWVudHNgIChzaW1wbGVBcmMpXG4gICAgICAvLyBCb3VuZHMgYXJlIHByb3ZpZGVkIGFzIGB0YXJnZXRgIGZvciBwYXJ0aWFsIGNpcmNsZSwgb3IgdW5kZWZpbmVkIGZvciBmdWxsIGNpcmNsZVxuICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgIHNvdXJjZTogc2VnbWVudCxcbiAgICAgICAgdGFyZ2V0OiBib3VuZHMsXG4gICAgICAgIHN0YXJ0OiBwb2ludHNbc3RhcnRdLFxuICAgICAgICBlbmQ6IHBvaW50c1tlbmRdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIEdldCBhbGwgc2VnbWVudHMgZnJvbSBgdGFyZ2V0YCB0aGF0IGludGVyc2VjdCB0aGUgYm91bmRzIG9mIGN1cnJlbnQgc2VnbWVudCBvZiBgbGluZWBcbiAgICBjb25zdCB0YXJnZXRTZWdtZW50cyA9IF9ib3VuZFNlZ21lbnRzKHRhcmdldCwgYm91bmRzKTtcblxuICAgIGZvciAoY29uc3QgdGd0IG9mIHRhcmdldFNlZ21lbnRzKSB7XG4gICAgICBjb25zdCBzdWJCb3VuZHMgPSBfZ2V0Qm91bmRzKHByb3BlcnR5LCB0cG9pbnRzW3RndC5zdGFydF0sIHRwb2ludHNbdGd0LmVuZF0sIHRndC5sb29wKTtcbiAgICAgIGNvbnN0IGZpbGxTb3VyY2VzID0gX2JvdW5kU2VnbWVudChzZWdtZW50LCBwb2ludHMsIHN1YkJvdW5kcyk7XG5cbiAgICAgIGZvciAoY29uc3QgZmlsbFNvdXJjZSBvZiBmaWxsU291cmNlcykge1xuICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICBzb3VyY2U6IGZpbGxTb3VyY2UsXG4gICAgICAgICAgdGFyZ2V0OiB0Z3QsXG4gICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgIFtwcm9wZXJ0eV06IF9nZXRFZGdlKGJvdW5kcywgc3ViQm91bmRzLCAnc3RhcnQnLCBNYXRoLm1heClcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVuZDoge1xuICAgICAgICAgICAgW3Byb3BlcnR5XTogX2dldEVkZ2UoYm91bmRzLCBzdWJCb3VuZHMsICdlbmQnLCBNYXRoLm1pbilcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcGFydHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfZ2V0Qm91bmRzKHByb3BlcnR5LCBmaXJzdCwgbGFzdCwgbG9vcCkge1xuICBpZiAobG9vcCkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgc3RhcnQgPSBmaXJzdFtwcm9wZXJ0eV07XG4gIGxldCBlbmQgPSBsYXN0W3Byb3BlcnR5XTtcblxuICBpZiAocHJvcGVydHkgPT09ICdhbmdsZScpIHtcbiAgICBzdGFydCA9IF9ub3JtYWxpemVBbmdsZShzdGFydCk7XG4gICAgZW5kID0gX25vcm1hbGl6ZUFuZ2xlKGVuZCk7XG4gIH1cbiAgcmV0dXJuIHtwcm9wZXJ0eSwgc3RhcnQsIGVuZH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfcG9pbnRzRnJvbVNlZ21lbnRzKGJvdW5kYXJ5LCBsaW5lKSB7XG4gIGNvbnN0IHt4ID0gbnVsbCwgeSA9IG51bGx9ID0gYm91bmRhcnkgfHwge307XG4gIGNvbnN0IGxpbmVQb2ludHMgPSBsaW5lLnBvaW50cztcbiAgY29uc3QgcG9pbnRzID0gW107XG4gIGxpbmUuc2VnbWVudHMuZm9yRWFjaCgoe3N0YXJ0LCBlbmR9KSA9PiB7XG4gICAgZW5kID0gX2ZpbmRTZWdtZW50RW5kKHN0YXJ0LCBlbmQsIGxpbmVQb2ludHMpO1xuICAgIGNvbnN0IGZpcnN0ID0gbGluZVBvaW50c1tzdGFydF07XG4gICAgY29uc3QgbGFzdCA9IGxpbmVQb2ludHNbZW5kXTtcbiAgICBpZiAoeSAhPT0gbnVsbCkge1xuICAgICAgcG9pbnRzLnB1c2goe3g6IGZpcnN0LngsIHl9KTtcbiAgICAgIHBvaW50cy5wdXNoKHt4OiBsYXN0LngsIHl9KTtcbiAgICB9IGVsc2UgaWYgKHggIT09IG51bGwpIHtcbiAgICAgIHBvaW50cy5wdXNoKHt4LCB5OiBmaXJzdC55fSk7XG4gICAgICBwb2ludHMucHVzaCh7eCwgeTogbGFzdC55fSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHBvaW50cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9maW5kU2VnbWVudEVuZChzdGFydCwgZW5kLCBwb2ludHMpIHtcbiAgZm9yICg7ZW5kID4gc3RhcnQ7IGVuZC0tKSB7XG4gICAgY29uc3QgcG9pbnQgPSBwb2ludHNbZW5kXTtcbiAgICBpZiAoIWlzTmFOKHBvaW50LngpICYmICFpc05hTihwb2ludC55KSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBlbmQ7XG59XG5cbmZ1bmN0aW9uIF9nZXRFZGdlKGEsIGIsIHByb3AsIGZuKSB7XG4gIGlmIChhICYmIGIpIHtcbiAgICByZXR1cm4gZm4oYVtwcm9wXSwgYltwcm9wXSk7XG4gIH1cbiAgcmV0dXJuIGEgPyBhW3Byb3BdIDogYiA/IGJbcHJvcF0gOiAwO1xufVxuIiwiLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vY29yZS9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi9jb3JlL2NvcmUuc2NhbGUuanMnKS5kZWZhdWx0IH0gU2NhbGVcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi9lbGVtZW50cy9lbGVtZW50LnBvaW50LmpzJykuZGVmYXVsdCB9IFBvaW50RWxlbWVudFxuICovXG5cbmltcG9ydCB7TGluZUVsZW1lbnR9IGZyb20gJy4uLy4uL2VsZW1lbnRzL2luZGV4LmpzJztcbmltcG9ydCB7aXNBcnJheX0gZnJvbSAnLi4vLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQge19wb2ludHNGcm9tU2VnbWVudHN9IGZyb20gJy4vZmlsbGVyLnNlZ21lbnQuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7UG9pbnRFbGVtZW50W10gfCB7IHg6IG51bWJlcjsgeTogbnVtYmVyOyB9fSBib3VuZGFyeVxuICogQHBhcmFtIHtMaW5lRWxlbWVudH0gbGluZVxuICogQHJldHVybiB7TGluZUVsZW1lbnQ/fVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2NyZWF0ZUJvdW5kYXJ5TGluZShib3VuZGFyeSwgbGluZSkge1xuICBsZXQgcG9pbnRzID0gW107XG4gIGxldCBfbG9vcCA9IGZhbHNlO1xuXG4gIGlmIChpc0FycmF5KGJvdW5kYXJ5KSkge1xuICAgIF9sb29wID0gdHJ1ZTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcG9pbnRzID0gYm91bmRhcnk7XG4gIH0gZWxzZSB7XG4gICAgcG9pbnRzID0gX3BvaW50c0Zyb21TZWdtZW50cyhib3VuZGFyeSwgbGluZSk7XG4gIH1cblxuICByZXR1cm4gcG9pbnRzLmxlbmd0aCA/IG5ldyBMaW5lRWxlbWVudCh7XG4gICAgcG9pbnRzLFxuICAgIG9wdGlvbnM6IHt0ZW5zaW9uOiAwfSxcbiAgICBfbG9vcCxcbiAgICBfZnVsbExvb3A6IF9sb29wXG4gIH0pIDogbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9zaG91bGRBcHBseUZpbGwoc291cmNlKSB7XG4gIHJldHVybiBzb3VyY2UgJiYgc291cmNlLmZpbGwgIT09IGZhbHNlO1xufVxuIiwiaW1wb3J0IHtpc09iamVjdCwgaXNGaW5pdGUsIHZhbHVlT3JEZWZhdWx0fSBmcm9tICcuLi8uLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2NvcmUvY29yZS5zY2FsZS5qcycpLmRlZmF1bHQgfSBTY2FsZVxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2VsZW1lbnRzL2VsZW1lbnQubGluZS5qcycpLmRlZmF1bHQgfSBMaW5lRWxlbWVudFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL3R5cGVzL2luZGV4LmpzJykuRmlsbFRhcmdldCB9IEZpbGxUYXJnZXRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi90eXBlcy9pbmRleC5qcycpLkNvbXBsZXhGaWxsVGFyZ2V0IH0gQ29tcGxleEZpbGxUYXJnZXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gX3Jlc29sdmVUYXJnZXQoc291cmNlcywgaW5kZXgsIHByb3BhZ2F0ZSkge1xuICBjb25zdCBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgbGV0IGZpbGwgPSBzb3VyY2UuZmlsbDtcbiAgY29uc3QgdmlzaXRlZCA9IFtpbmRleF07XG4gIGxldCB0YXJnZXQ7XG5cbiAgaWYgKCFwcm9wYWdhdGUpIHtcbiAgICByZXR1cm4gZmlsbDtcbiAgfVxuXG4gIHdoaWxlIChmaWxsICE9PSBmYWxzZSAmJiB2aXNpdGVkLmluZGV4T2YoZmlsbCkgPT09IC0xKSB7XG4gICAgaWYgKCFpc0Zpbml0ZShmaWxsKSkge1xuICAgICAgcmV0dXJuIGZpbGw7XG4gICAgfVxuXG4gICAgdGFyZ2V0ID0gc291cmNlc1tmaWxsXTtcbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0YXJnZXQudmlzaWJsZSkge1xuICAgICAgcmV0dXJuIGZpbGw7XG4gICAgfVxuXG4gICAgdmlzaXRlZC5wdXNoKGZpbGwpO1xuICAgIGZpbGwgPSB0YXJnZXQuZmlsbDtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudFxuICovXG5leHBvcnQgZnVuY3Rpb24gX2RlY29kZUZpbGwobGluZSwgaW5kZXgsIGNvdW50KSB7XG4gIC8qKiBAdHlwZSB7c3RyaW5nIHwge3ZhbHVlOiBudW1iZXJ9fSAqL1xuICBjb25zdCBmaWxsID0gcGFyc2VGaWxsT3B0aW9uKGxpbmUpO1xuXG4gIGlmIChpc09iamVjdChmaWxsKSkge1xuICAgIHJldHVybiBpc05hTihmaWxsLnZhbHVlKSA/IGZhbHNlIDogZmlsbDtcbiAgfVxuXG4gIGxldCB0YXJnZXQgPSBwYXJzZUZsb2F0KGZpbGwpO1xuXG4gIGlmIChpc0Zpbml0ZSh0YXJnZXQpICYmIE1hdGguZmxvb3IodGFyZ2V0KSA9PT0gdGFyZ2V0KSB7XG4gICAgcmV0dXJuIGRlY29kZVRhcmdldEluZGV4KGZpbGxbMF0sIGluZGV4LCB0YXJnZXQsIGNvdW50KTtcbiAgfVxuXG4gIHJldHVybiBbJ29yaWdpbicsICdzdGFydCcsICdlbmQnLCAnc3RhY2snLCAnc2hhcGUnXS5pbmRleE9mKGZpbGwpID49IDAgJiYgZmlsbDtcbn1cblxuZnVuY3Rpb24gZGVjb2RlVGFyZ2V0SW5kZXgoZmlyc3RDaCwgaW5kZXgsIHRhcmdldCwgY291bnQpIHtcbiAgaWYgKGZpcnN0Q2ggPT09ICctJyB8fCBmaXJzdENoID09PSAnKycpIHtcbiAgICB0YXJnZXQgPSBpbmRleCArIHRhcmdldDtcbiAgfVxuXG4gIGlmICh0YXJnZXQgPT09IGluZGV4IHx8IHRhcmdldCA8IDAgfHwgdGFyZ2V0ID49IGNvdW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ZpbGxUYXJnZXQgfCBDb21wbGV4RmlsbFRhcmdldH0gZmlsbFxuICogQHBhcmFtIHtTY2FsZX0gc2NhbGVcbiAqIEByZXR1cm5zIHtudW1iZXIgfCBudWxsfVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2dldFRhcmdldFBpeGVsKGZpbGwsIHNjYWxlKSB7XG4gIGxldCBwaXhlbCA9IG51bGw7XG4gIGlmIChmaWxsID09PSAnc3RhcnQnKSB7XG4gICAgcGl4ZWwgPSBzY2FsZS5ib3R0b207XG4gIH0gZWxzZSBpZiAoZmlsbCA9PT0gJ2VuZCcpIHtcbiAgICBwaXhlbCA9IHNjYWxlLnRvcDtcbiAgfSBlbHNlIGlmIChpc09iamVjdChmaWxsKSkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBwaXhlbCA9IHNjYWxlLmdldFBpeGVsRm9yVmFsdWUoZmlsbC52YWx1ZSk7XG4gIH0gZWxzZSBpZiAoc2NhbGUuZ2V0QmFzZVBpeGVsKSB7XG4gICAgcGl4ZWwgPSBzY2FsZS5nZXRCYXNlUGl4ZWwoKTtcbiAgfVxuICByZXR1cm4gcGl4ZWw7XG59XG5cbi8qKlxuICogQHBhcmFtIHtGaWxsVGFyZ2V0IHwgQ29tcGxleEZpbGxUYXJnZXR9IGZpbGxcbiAqIEBwYXJhbSB7U2NhbGV9IHNjYWxlXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRWYWx1ZVxuICogQHJldHVybnMge251bWJlciB8IHVuZGVmaW5lZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9nZXRUYXJnZXRWYWx1ZShmaWxsLCBzY2FsZSwgc3RhcnRWYWx1ZSkge1xuICBsZXQgdmFsdWU7XG5cbiAgaWYgKGZpbGwgPT09ICdzdGFydCcpIHtcbiAgICB2YWx1ZSA9IHN0YXJ0VmFsdWU7XG4gIH0gZWxzZSBpZiAoZmlsbCA9PT0gJ2VuZCcpIHtcbiAgICB2YWx1ZSA9IHNjYWxlLm9wdGlvbnMucmV2ZXJzZSA/IHNjYWxlLm1pbiA6IHNjYWxlLm1heDtcbiAgfSBlbHNlIGlmIChpc09iamVjdChmaWxsKSkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB2YWx1ZSA9IGZpbGwudmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBzY2FsZS5nZXRCYXNlVmFsdWUoKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtMaW5lRWxlbWVudH0gbGluZVxuICovXG5mdW5jdGlvbiBwYXJzZUZpbGxPcHRpb24obGluZSkge1xuICBjb25zdCBvcHRpb25zID0gbGluZS5vcHRpb25zO1xuICBjb25zdCBmaWxsT3B0aW9uID0gb3B0aW9ucy5maWxsO1xuICBsZXQgZmlsbCA9IHZhbHVlT3JEZWZhdWx0KGZpbGxPcHRpb24gJiYgZmlsbE9wdGlvbi50YXJnZXQsIGZpbGxPcHRpb24pO1xuXG4gIGlmIChmaWxsID09PSB1bmRlZmluZWQpIHtcbiAgICBmaWxsID0gISFvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcbiAgfVxuXG4gIGlmIChmaWxsID09PSBmYWxzZSB8fCBmaWxsID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGZpbGwgPT09IHRydWUpIHtcbiAgICByZXR1cm4gJ29yaWdpbic7XG4gIH1cbiAgcmV0dXJuIGZpbGw7XG59XG4iLCIvKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi9jb3JlL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2NvcmUvY29yZS5zY2FsZS5qcycpLmRlZmF1bHQgfSBTY2FsZVxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2VsZW1lbnRzL2VsZW1lbnQucG9pbnQuanMnKS5kZWZhdWx0IH0gUG9pbnRFbGVtZW50XG4gKi9cblxuaW1wb3J0IHtMaW5lRWxlbWVudH0gZnJvbSAnLi4vLi4vZWxlbWVudHMvaW5kZXguanMnO1xuaW1wb3J0IHtfaXNCZXR3ZWVufSBmcm9tICcuLi8uLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCB7X2NyZWF0ZUJvdW5kYXJ5TGluZX0gZnJvbSAnLi9maWxsZXIuaGVscGVyLmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge3sgY2hhcnQ6IENoYXJ0OyBzY2FsZTogU2NhbGU7IGluZGV4OiBudW1iZXI7IGxpbmU6IExpbmVFbGVtZW50OyB9fSBzb3VyY2VcbiAqIEByZXR1cm4ge0xpbmVFbGVtZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2J1aWxkU3RhY2tMaW5lKHNvdXJjZSkge1xuICBjb25zdCB7c2NhbGUsIGluZGV4LCBsaW5lfSA9IHNvdXJjZTtcbiAgY29uc3QgcG9pbnRzID0gW107XG4gIGNvbnN0IHNlZ21lbnRzID0gbGluZS5zZWdtZW50cztcbiAgY29uc3Qgc291cmNlUG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGNvbnN0IGxpbmVzQmVsb3cgPSBnZXRMaW5lc0JlbG93KHNjYWxlLCBpbmRleCk7XG4gIGxpbmVzQmVsb3cucHVzaChfY3JlYXRlQm91bmRhcnlMaW5lKHt4OiBudWxsLCB5OiBzY2FsZS5ib3R0b219LCBsaW5lKSk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICBmb3IgKGxldCBqID0gc2VnbWVudC5zdGFydDsgaiA8PSBzZWdtZW50LmVuZDsgaisrKSB7XG4gICAgICBhZGRQb2ludHNCZWxvdyhwb2ludHMsIHNvdXJjZVBvaW50c1tqXSwgbGluZXNCZWxvdyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgTGluZUVsZW1lbnQoe3BvaW50cywgb3B0aW9uczoge319KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1NjYWxlfSBzY2FsZVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcmV0dXJuIHtMaW5lRWxlbWVudFtdfVxuICovXG5mdW5jdGlvbiBnZXRMaW5lc0JlbG93KHNjYWxlLCBpbmRleCkge1xuICBjb25zdCBiZWxvdyA9IFtdO1xuICBjb25zdCBtZXRhcyA9IHNjYWxlLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKCdsaW5lJyk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXRhcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG1ldGEgPSBtZXRhc1tpXTtcbiAgICBpZiAobWV0YS5pbmRleCA9PT0gaW5kZXgpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoIW1ldGEuaGlkZGVuKSB7XG4gICAgICBiZWxvdy51bnNoaWZ0KG1ldGEuZGF0YXNldCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBiZWxvdztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1BvaW50RWxlbWVudFtdfSBwb2ludHNcbiAqIEBwYXJhbSB7UG9pbnRFbGVtZW50fSBzb3VyY2VQb2ludFxuICogQHBhcmFtIHtMaW5lRWxlbWVudFtdfSBsaW5lc0JlbG93XG4gKi9cbmZ1bmN0aW9uIGFkZFBvaW50c0JlbG93KHBvaW50cywgc291cmNlUG9pbnQsIGxpbmVzQmVsb3cpIHtcbiAgY29uc3QgcG9zdHBvbmVkID0gW107XG4gIGZvciAobGV0IGogPSAwOyBqIDwgbGluZXNCZWxvdy5sZW5ndGg7IGorKykge1xuICAgIGNvbnN0IGxpbmUgPSBsaW5lc0JlbG93W2pdO1xuICAgIGNvbnN0IHtmaXJzdCwgbGFzdCwgcG9pbnR9ID0gZmluZFBvaW50KGxpbmUsIHNvdXJjZVBvaW50LCAneCcpO1xuXG4gICAgaWYgKCFwb2ludCB8fCAoZmlyc3QgJiYgbGFzdCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoZmlyc3QpIHtcbiAgICAgIC8vIEZpcnN0IHBvaW50IG9mIGEgc2VnbWVudCAtPiBuZWVkIHRvIGFkZCBhbm90aGVyIHBvaW50IGJlZm9yZSB0aGlzLFxuICAgICAgcG9zdHBvbmVkLnVuc2hpZnQocG9pbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb2ludHMucHVzaChwb2ludCk7XG4gICAgICBpZiAoIWxhc3QpIHtcbiAgICAgICAgLy8gSW4gdGhlIG1pZGRsZSBvZiBhIHNlZ21lbnQsIG5vIG5lZWQgdG8gYWRkIG1vcmUgcG9pbnRzLlxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcG9pbnRzLnB1c2goLi4ucG9zdHBvbmVkKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lXG4gKiBAcGFyYW0ge1BvaW50RWxlbWVudH0gc291cmNlUG9pbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eVxuICogQHJldHVybnMge3twb2ludD86IFBvaW50RWxlbWVudCwgZmlyc3Q/OiBib29sZWFuLCBsYXN0PzogYm9vbGVhbn19XG4gKi9cbmZ1bmN0aW9uIGZpbmRQb2ludChsaW5lLCBzb3VyY2VQb2ludCwgcHJvcGVydHkpIHtcbiAgY29uc3QgcG9pbnQgPSBsaW5lLmludGVycG9sYXRlKHNvdXJjZVBvaW50LCBwcm9wZXJ0eSk7XG4gIGlmICghcG9pbnQpIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICBjb25zdCBwb2ludFZhbHVlID0gcG9pbnRbcHJvcGVydHldO1xuICBjb25zdCBzZWdtZW50cyA9IGxpbmUuc2VnbWVudHM7XG4gIGNvbnN0IGxpbmVQb2ludHMgPSBsaW5lLnBvaW50cztcbiAgbGV0IGZpcnN0ID0gZmFsc2U7XG4gIGxldCBsYXN0ID0gZmFsc2U7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgY29uc3QgZmlyc3RWYWx1ZSA9IGxpbmVQb2ludHNbc2VnbWVudC5zdGFydF1bcHJvcGVydHldO1xuICAgIGNvbnN0IGxhc3RWYWx1ZSA9IGxpbmVQb2ludHNbc2VnbWVudC5lbmRdW3Byb3BlcnR5XTtcbiAgICBpZiAoX2lzQmV0d2Vlbihwb2ludFZhbHVlLCBmaXJzdFZhbHVlLCBsYXN0VmFsdWUpKSB7XG4gICAgICBmaXJzdCA9IHBvaW50VmFsdWUgPT09IGZpcnN0VmFsdWU7XG4gICAgICBsYXN0ID0gcG9pbnRWYWx1ZSA9PT0gbGFzdFZhbHVlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB7Zmlyc3QsIGxhc3QsIHBvaW50fTtcbn1cbiIsImltcG9ydCB7VEFVfSBmcm9tICcuLi8uLi9oZWxwZXJzL2luZGV4LmpzJztcblxuLy8gVE9ETzogdXNlIGVsZW1lbnRzLkFyY0VsZW1lbnQgaW5zdGVhZFxuZXhwb3J0IGNsYXNzIHNpbXBsZUFyYyB7XG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICB0aGlzLnggPSBvcHRzLng7XG4gICAgdGhpcy55ID0gb3B0cy55O1xuICAgIHRoaXMucmFkaXVzID0gb3B0cy5yYWRpdXM7XG4gIH1cblxuICBwYXRoU2VnbWVudChjdHgsIGJvdW5kcywgb3B0cykge1xuICAgIGNvbnN0IHt4LCB5LCByYWRpdXN9ID0gdGhpcztcbiAgICBib3VuZHMgPSBib3VuZHMgfHwge3N0YXJ0OiAwLCBlbmQ6IFRBVX07XG4gICAgY3R4LmFyYyh4LCB5LCByYWRpdXMsIGJvdW5kcy5lbmQsIGJvdW5kcy5zdGFydCwgdHJ1ZSk7XG4gICAgcmV0dXJuICFvcHRzLmJvdW5kcztcbiAgfVxuXG4gIGludGVycG9sYXRlKHBvaW50KSB7XG4gICAgY29uc3Qge3gsIHksIHJhZGl1c30gPSB0aGlzO1xuICAgIGNvbnN0IGFuZ2xlID0gcG9pbnQuYW5nbGU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHggKyBNYXRoLmNvcyhhbmdsZSkgKiByYWRpdXMsXG4gICAgICB5OiB5ICsgTWF0aC5zaW4oYW5nbGUpICogcmFkaXVzLFxuICAgICAgYW5nbGVcbiAgICB9O1xuICB9XG59XG4iLCJpbXBvcnQge2lzRmluaXRlfSBmcm9tICcuLi8uLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCB7X2NyZWF0ZUJvdW5kYXJ5TGluZX0gZnJvbSAnLi9maWxsZXIuaGVscGVyLmpzJztcbmltcG9ydCB7X2dldFRhcmdldFBpeGVsLCBfZ2V0VGFyZ2V0VmFsdWV9IGZyb20gJy4vZmlsbGVyLm9wdGlvbnMuanMnO1xuaW1wb3J0IHtfYnVpbGRTdGFja0xpbmV9IGZyb20gJy4vZmlsbGVyLnRhcmdldC5zdGFjay5qcyc7XG5pbXBvcnQge3NpbXBsZUFyY30gZnJvbSAnLi9zaW1wbGVBcmMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi9jb3JlL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2NvcmUvY29yZS5zY2FsZS5qcycpLmRlZmF1bHQgfSBTY2FsZVxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2VsZW1lbnRzL2VsZW1lbnQucG9pbnQuanMnKS5kZWZhdWx0IH0gUG9pbnRFbGVtZW50XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIF9nZXRUYXJnZXQoc291cmNlKSB7XG4gIGNvbnN0IHtjaGFydCwgZmlsbCwgbGluZX0gPSBzb3VyY2U7XG5cbiAgaWYgKGlzRmluaXRlKGZpbGwpKSB7XG4gICAgcmV0dXJuIGdldExpbmVCeUluZGV4KGNoYXJ0LCBmaWxsKTtcbiAgfVxuXG4gIGlmIChmaWxsID09PSAnc3RhY2snKSB7XG4gICAgcmV0dXJuIF9idWlsZFN0YWNrTGluZShzb3VyY2UpO1xuICB9XG5cbiAgaWYgKGZpbGwgPT09ICdzaGFwZScpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGNvbnN0IGJvdW5kYXJ5ID0gY29tcHV0ZUJvdW5kYXJ5KHNvdXJjZSk7XG5cbiAgaWYgKGJvdW5kYXJ5IGluc3RhbmNlb2Ygc2ltcGxlQXJjKSB7XG4gICAgcmV0dXJuIGJvdW5kYXJ5O1xuICB9XG5cbiAgcmV0dXJuIF9jcmVhdGVCb3VuZGFyeUxpbmUoYm91bmRhcnksIGxpbmUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqL1xuZnVuY3Rpb24gZ2V0TGluZUJ5SW5kZXgoY2hhcnQsIGluZGV4KSB7XG4gIGNvbnN0IG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpbmRleCk7XG4gIGNvbnN0IHZpc2libGUgPSBtZXRhICYmIGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaW5kZXgpO1xuICByZXR1cm4gdmlzaWJsZSA/IG1ldGEuZGF0YXNldCA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVCb3VuZGFyeShzb3VyY2UpIHtcbiAgY29uc3Qgc2NhbGUgPSBzb3VyY2Uuc2NhbGUgfHwge307XG5cbiAgaWYgKHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZSkge1xuICAgIHJldHVybiBjb21wdXRlQ2lyY3VsYXJCb3VuZGFyeShzb3VyY2UpO1xuICB9XG4gIHJldHVybiBjb21wdXRlTGluZWFyQm91bmRhcnkoc291cmNlKTtcbn1cblxuXG5mdW5jdGlvbiBjb21wdXRlTGluZWFyQm91bmRhcnkoc291cmNlKSB7XG4gIGNvbnN0IHtzY2FsZSA9IHt9LCBmaWxsfSA9IHNvdXJjZTtcbiAgY29uc3QgcGl4ZWwgPSBfZ2V0VGFyZ2V0UGl4ZWwoZmlsbCwgc2NhbGUpO1xuXG4gIGlmIChpc0Zpbml0ZShwaXhlbCkpIHtcbiAgICBjb25zdCBob3Jpem9udGFsID0gc2NhbGUuaXNIb3Jpem9udGFsKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogaG9yaXpvbnRhbCA/IHBpeGVsIDogbnVsbCxcbiAgICAgIHk6IGhvcml6b250YWwgPyBudWxsIDogcGl4ZWxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVDaXJjdWxhckJvdW5kYXJ5KHNvdXJjZSkge1xuICBjb25zdCB7c2NhbGUsIGZpbGx9ID0gc291cmNlO1xuICBjb25zdCBvcHRpb25zID0gc2NhbGUub3B0aW9ucztcbiAgY29uc3QgbGVuZ3RoID0gc2NhbGUuZ2V0TGFiZWxzKCkubGVuZ3RoO1xuICBjb25zdCBzdGFydCA9IG9wdGlvbnMucmV2ZXJzZSA/IHNjYWxlLm1heCA6IHNjYWxlLm1pbjtcbiAgY29uc3QgdmFsdWUgPSBfZ2V0VGFyZ2V0VmFsdWUoZmlsbCwgc2NhbGUsIHN0YXJ0KTtcbiAgY29uc3QgdGFyZ2V0ID0gW107XG5cbiAgaWYgKG9wdGlvbnMuZ3JpZC5jaXJjdWxhcikge1xuICAgIGNvbnN0IGNlbnRlciA9IHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZSgwLCBzdGFydCk7XG4gICAgcmV0dXJuIG5ldyBzaW1wbGVBcmMoe1xuICAgICAgeDogY2VudGVyLngsXG4gICAgICB5OiBjZW50ZXIueSxcbiAgICAgIHJhZGl1czogc2NhbGUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodmFsdWUpXG4gICAgfSk7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdGFyZ2V0LnB1c2goc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGksIHZhbHVlKSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuIiwiaW1wb3J0IHtjbGlwQXJlYSwgdW5jbGlwQXJlYSwgZ2V0RGF0YXNldENsaXBBcmVhfSBmcm9tICcuLi8uLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCB7X2ZpbmRTZWdtZW50RW5kLCBfZ2V0Qm91bmRzLCBfc2VnbWVudHN9IGZyb20gJy4vZmlsbGVyLnNlZ21lbnQuanMnO1xuaW1wb3J0IHtfZ2V0VGFyZ2V0fSBmcm9tICcuL2ZpbGxlci50YXJnZXQuanMnO1xuXG5leHBvcnQgZnVuY3Rpb24gX2RyYXdmaWxsKGN0eCwgc291cmNlLCBhcmVhKSB7XG4gIGNvbnN0IHRhcmdldCA9IF9nZXRUYXJnZXQoc291cmNlKTtcbiAgY29uc3Qge2NoYXJ0LCBpbmRleCwgbGluZSwgc2NhbGUsIGF4aXN9ID0gc291cmNlO1xuICBjb25zdCBsaW5lT3B0cyA9IGxpbmUub3B0aW9ucztcbiAgY29uc3QgZmlsbE9wdGlvbiA9IGxpbmVPcHRzLmZpbGw7XG4gIGNvbnN0IGNvbG9yID0gbGluZU9wdHMuYmFja2dyb3VuZENvbG9yO1xuICBjb25zdCB7YWJvdmUgPSBjb2xvciwgYmVsb3cgPSBjb2xvcn0gPSBmaWxsT3B0aW9uIHx8IHt9O1xuICBjb25zdCBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaW5kZXgpO1xuICBjb25zdCBjbGlwID0gZ2V0RGF0YXNldENsaXBBcmVhKGNoYXJ0LCBtZXRhKTtcbiAgaWYgKHRhcmdldCAmJiBsaW5lLnBvaW50cy5sZW5ndGgpIHtcbiAgICBjbGlwQXJlYShjdHgsIGFyZWEpO1xuICAgIGRvRmlsbChjdHgsIHtsaW5lLCB0YXJnZXQsIGFib3ZlLCBiZWxvdywgYXJlYSwgc2NhbGUsIGF4aXMsIGNsaXB9KTtcbiAgICB1bmNsaXBBcmVhKGN0eCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZG9GaWxsKGN0eCwgY2ZnKSB7XG4gIGNvbnN0IHtsaW5lLCB0YXJnZXQsIGFib3ZlLCBiZWxvdywgYXJlYSwgc2NhbGUsIGNsaXB9ID0gY2ZnO1xuICBjb25zdCBwcm9wZXJ0eSA9IGxpbmUuX2xvb3AgPyAnYW5nbGUnIDogY2ZnLmF4aXM7XG5cbiAgY3R4LnNhdmUoKTtcblxuICBsZXQgZmlsbENvbG9yID0gYmVsb3c7XG4gIGlmIChiZWxvdyAhPT0gYWJvdmUpIHtcbiAgICBpZiAocHJvcGVydHkgPT09ICd4Jykge1xuICAgICAgY2xpcFZlcnRpY2FsKGN0eCwgdGFyZ2V0LCBhcmVhLnRvcCk7XG4gICAgICBmaWxsKGN0eCwge2xpbmUsIHRhcmdldCwgY29sb3I6IGFib3ZlLCBzY2FsZSwgcHJvcGVydHksIGNsaXB9KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY2xpcFZlcnRpY2FsKGN0eCwgdGFyZ2V0LCBhcmVhLmJvdHRvbSk7XG4gICAgfSBlbHNlIGlmIChwcm9wZXJ0eSA9PT0gJ3knKSB7XG4gICAgICBjbGlwSG9yaXpvbnRhbChjdHgsIHRhcmdldCwgYXJlYS5sZWZ0KTtcbiAgICAgIGZpbGwoY3R4LCB7bGluZSwgdGFyZ2V0LCBjb2xvcjogYmVsb3csIHNjYWxlLCBwcm9wZXJ0eSwgY2xpcH0pO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjbGlwSG9yaXpvbnRhbChjdHgsIHRhcmdldCwgYXJlYS5yaWdodCk7XG4gICAgICBmaWxsQ29sb3IgPSBhYm92ZTtcbiAgICB9XG4gIH1cbiAgZmlsbChjdHgsIHtsaW5lLCB0YXJnZXQsIGNvbG9yOiBmaWxsQ29sb3IsIHNjYWxlLCBwcm9wZXJ0eSwgY2xpcH0pO1xuXG4gIGN0eC5yZXN0b3JlKCk7XG59XG5cbmZ1bmN0aW9uIGNsaXBWZXJ0aWNhbChjdHgsIHRhcmdldCwgY2xpcFkpIHtcbiAgY29uc3Qge3NlZ21lbnRzLCBwb2ludHN9ID0gdGFyZ2V0O1xuICBsZXQgZmlyc3QgPSB0cnVlO1xuICBsZXQgbGluZUxvb3AgPSBmYWxzZTtcblxuICBjdHguYmVnaW5QYXRoKCk7XG4gIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgIGNvbnN0IHtzdGFydCwgZW5kfSA9IHNlZ21lbnQ7XG4gICAgY29uc3QgZmlyc3RQb2ludCA9IHBvaW50c1tzdGFydF07XG4gICAgY29uc3QgbGFzdFBvaW50ID0gcG9pbnRzW19maW5kU2VnbWVudEVuZChzdGFydCwgZW5kLCBwb2ludHMpXTtcbiAgICBpZiAoZmlyc3QpIHtcbiAgICAgIGN0eC5tb3ZlVG8oZmlyc3RQb2ludC54LCBmaXJzdFBvaW50LnkpO1xuICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LmxpbmVUbyhmaXJzdFBvaW50LngsIGNsaXBZKTtcbiAgICAgIGN0eC5saW5lVG8oZmlyc3RQb2ludC54LCBmaXJzdFBvaW50LnkpO1xuICAgIH1cbiAgICBsaW5lTG9vcCA9ICEhdGFyZ2V0LnBhdGhTZWdtZW50KGN0eCwgc2VnbWVudCwge21vdmU6IGxpbmVMb29wfSk7XG4gICAgaWYgKGxpbmVMb29wKSB7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5saW5lVG8obGFzdFBvaW50LngsIGNsaXBZKTtcbiAgICB9XG4gIH1cblxuICBjdHgubGluZVRvKHRhcmdldC5maXJzdCgpLngsIGNsaXBZKTtcbiAgY3R4LmNsb3NlUGF0aCgpO1xuICBjdHguY2xpcCgpO1xufVxuXG5mdW5jdGlvbiBjbGlwSG9yaXpvbnRhbChjdHgsIHRhcmdldCwgY2xpcFgpIHtcbiAgY29uc3Qge3NlZ21lbnRzLCBwb2ludHN9ID0gdGFyZ2V0O1xuICBsZXQgZmlyc3QgPSB0cnVlO1xuICBsZXQgbGluZUxvb3AgPSBmYWxzZTtcblxuICBjdHguYmVnaW5QYXRoKCk7XG4gIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgIGNvbnN0IHtzdGFydCwgZW5kfSA9IHNlZ21lbnQ7XG4gICAgY29uc3QgZmlyc3RQb2ludCA9IHBvaW50c1tzdGFydF07XG4gICAgY29uc3QgbGFzdFBvaW50ID0gcG9pbnRzW19maW5kU2VnbWVudEVuZChzdGFydCwgZW5kLCBwb2ludHMpXTtcbiAgICBpZiAoZmlyc3QpIHtcbiAgICAgIGN0eC5tb3ZlVG8oZmlyc3RQb2ludC54LCBmaXJzdFBvaW50LnkpO1xuICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LmxpbmVUbyhjbGlwWCwgZmlyc3RQb2ludC55KTtcbiAgICAgIGN0eC5saW5lVG8oZmlyc3RQb2ludC54LCBmaXJzdFBvaW50LnkpO1xuICAgIH1cbiAgICBsaW5lTG9vcCA9ICEhdGFyZ2V0LnBhdGhTZWdtZW50KGN0eCwgc2VnbWVudCwge21vdmU6IGxpbmVMb29wfSk7XG4gICAgaWYgKGxpbmVMb29wKSB7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5saW5lVG8oY2xpcFgsIGxhc3RQb2ludC55KTtcbiAgICB9XG4gIH1cblxuICBjdHgubGluZVRvKGNsaXBYLCB0YXJnZXQuZmlyc3QoKS55KTtcbiAgY3R4LmNsb3NlUGF0aCgpO1xuICBjdHguY2xpcCgpO1xufVxuXG5mdW5jdGlvbiBmaWxsKGN0eCwgY2ZnKSB7XG4gIGNvbnN0IHtsaW5lLCB0YXJnZXQsIHByb3BlcnR5LCBjb2xvciwgc2NhbGUsIGNsaXB9ID0gY2ZnO1xuICBjb25zdCBzZWdtZW50cyA9IF9zZWdtZW50cyhsaW5lLCB0YXJnZXQsIHByb3BlcnR5KTtcblxuICBmb3IgKGNvbnN0IHtzb3VyY2U6IHNyYywgdGFyZ2V0OiB0Z3QsIHN0YXJ0LCBlbmR9IG9mIHNlZ21lbnRzKSB7XG4gICAgY29uc3Qge3N0eWxlOiB7YmFja2dyb3VuZENvbG9yID0gY29sb3J9ID0ge319ID0gc3JjO1xuICAgIGNvbnN0IG5vdFNoYXBlID0gdGFyZ2V0ICE9PSB0cnVlO1xuXG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG9yO1xuXG4gICAgY2xpcEJvdW5kcyhjdHgsIHNjYWxlLCBjbGlwLCBub3RTaGFwZSAmJiBfZ2V0Qm91bmRzKHByb3BlcnR5LCBzdGFydCwgZW5kKSk7XG5cbiAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICBjb25zdCBsaW5lTG9vcCA9ICEhbGluZS5wYXRoU2VnbWVudChjdHgsIHNyYyk7XG5cbiAgICBsZXQgbG9vcDtcbiAgICBpZiAobm90U2hhcGUpIHtcbiAgICAgIGlmIChsaW5lTG9vcCkge1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnRlcnBvbGF0ZWRMaW5lVG8oY3R4LCB0YXJnZXQsIGVuZCwgcHJvcGVydHkpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0YXJnZXRMb29wID0gISF0YXJnZXQucGF0aFNlZ21lbnQoY3R4LCB0Z3QsIHttb3ZlOiBsaW5lTG9vcCwgcmV2ZXJzZTogdHJ1ZX0pO1xuICAgICAgbG9vcCA9IGxpbmVMb29wICYmIHRhcmdldExvb3A7XG4gICAgICBpZiAoIWxvb3ApIHtcbiAgICAgICAgaW50ZXJwb2xhdGVkTGluZVRvKGN0eCwgdGFyZ2V0LCBzdGFydCwgcHJvcGVydHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBjdHguZmlsbChsb29wID8gJ2V2ZW5vZGQnIDogJ25vbnplcm8nKTtcblxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2xpcEJvdW5kcyhjdHgsIHNjYWxlLCBjbGlwLCBib3VuZHMpIHtcbiAgY29uc3QgY2hhcnRBcmVhID0gc2NhbGUuY2hhcnQuY2hhcnRBcmVhO1xuICBjb25zdCB7cHJvcGVydHksIHN0YXJ0LCBlbmR9ID0gYm91bmRzIHx8IHt9O1xuXG4gIGlmIChwcm9wZXJ0eSA9PT0gJ3gnIHx8IHByb3BlcnR5ID09PSAneScpIHtcbiAgICBsZXQgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tO1xuXG4gICAgaWYgKHByb3BlcnR5ID09PSAneCcpIHtcbiAgICAgIGxlZnQgPSBzdGFydDtcbiAgICAgIHRvcCA9IGNoYXJ0QXJlYS50b3A7XG4gICAgICByaWdodCA9IGVuZDtcbiAgICAgIGJvdHRvbSA9IGNoYXJ0QXJlYS5ib3R0b207XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlZnQgPSBjaGFydEFyZWEubGVmdDtcbiAgICAgIHRvcCA9IHN0YXJ0O1xuICAgICAgcmlnaHQgPSBjaGFydEFyZWEucmlnaHQ7XG4gICAgICBib3R0b20gPSBlbmQ7XG4gICAgfVxuXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgaWYgKGNsaXApIHtcbiAgICAgIGxlZnQgPSBNYXRoLm1heChsZWZ0LCBjbGlwLmxlZnQpO1xuICAgICAgcmlnaHQgPSBNYXRoLm1pbihyaWdodCwgY2xpcC5yaWdodCk7XG4gICAgICB0b3AgPSBNYXRoLm1heCh0b3AsIGNsaXAudG9wKTtcbiAgICAgIGJvdHRvbSA9IE1hdGgubWluKGJvdHRvbSwgY2xpcC5ib3R0b20pO1xuICAgIH1cblxuICAgIGN0eC5yZWN0KGxlZnQsIHRvcCwgcmlnaHQgLSBsZWZ0LCBib3R0b20gLSB0b3ApO1xuICAgIGN0eC5jbGlwKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW50ZXJwb2xhdGVkTGluZVRvKGN0eCwgdGFyZ2V0LCBwb2ludCwgcHJvcGVydHkpIHtcbiAgY29uc3QgaW50ZXJwb2xhdGVkUG9pbnQgPSB0YXJnZXQuaW50ZXJwb2xhdGUocG9pbnQsIHByb3BlcnR5KTtcbiAgaWYgKGludGVycG9sYXRlZFBvaW50KSB7XG4gICAgY3R4LmxpbmVUbyhpbnRlcnBvbGF0ZWRQb2ludC54LCBpbnRlcnBvbGF0ZWRQb2ludC55KTtcbiAgfVxufVxuXG4iLCIvKipcbiAqIFBsdWdpbiBiYXNlZCBvbiBkaXNjdXNzaW9uIGZyb20gdGhlIGZvbGxvd2luZyBDaGFydC5qcyBpc3N1ZXM6XG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yMzgwI2lzc3VlY29tbWVudC0yNzk5NjE1NjlcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzI0NDAjaXNzdWVjb21tZW50LTI1NjQ2MTg5N1xuICovXG5cbmltcG9ydCBMaW5lRWxlbWVudCBmcm9tICcuLi8uLi9lbGVtZW50cy9lbGVtZW50LmxpbmUuanMnO1xuaW1wb3J0IHtfZHJhd2ZpbGx9IGZyb20gJy4vZmlsbGVyLmRyYXdpbmcuanMnO1xuaW1wb3J0IHtfc2hvdWxkQXBwbHlGaWxsfSBmcm9tICcuL2ZpbGxlci5oZWxwZXIuanMnO1xuaW1wb3J0IHtfZGVjb2RlRmlsbCwgX3Jlc29sdmVUYXJnZXR9IGZyb20gJy4vZmlsbGVyLm9wdGlvbnMuanMnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlkOiAnZmlsbGVyJyxcblxuICBhZnRlckRhdGFzZXRzVXBkYXRlKGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IGNvdW50ID0gKGNoYXJ0LmRhdGEuZGF0YXNldHMgfHwgW10pLmxlbmd0aDtcbiAgICBjb25zdCBzb3VyY2VzID0gW107XG4gICAgbGV0IG1ldGEsIGksIGxpbmUsIHNvdXJjZTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICBsaW5lID0gbWV0YS5kYXRhc2V0O1xuICAgICAgc291cmNlID0gbnVsbDtcblxuICAgICAgaWYgKGxpbmUgJiYgbGluZS5vcHRpb25zICYmIGxpbmUgaW5zdGFuY2VvZiBMaW5lRWxlbWVudCkge1xuICAgICAgICBzb3VyY2UgPSB7XG4gICAgICAgICAgdmlzaWJsZTogY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSxcbiAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICBmaWxsOiBfZGVjb2RlRmlsbChsaW5lLCBpLCBjb3VudCksXG4gICAgICAgICAgY2hhcnQsXG4gICAgICAgICAgYXhpczogbWV0YS5jb250cm9sbGVyLm9wdGlvbnMuaW5kZXhBeGlzLFxuICAgICAgICAgIHNjYWxlOiBtZXRhLnZTY2FsZSxcbiAgICAgICAgICBsaW5lLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBtZXRhLiRmaWxsZXIgPSBzb3VyY2U7XG4gICAgICBzb3VyY2VzLnB1c2goc291cmNlKTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgc291cmNlID0gc291cmNlc1tpXTtcbiAgICAgIGlmICghc291cmNlIHx8IHNvdXJjZS5maWxsID09PSBmYWxzZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc291cmNlLmZpbGwgPSBfcmVzb2x2ZVRhcmdldChzb3VyY2VzLCBpLCBvcHRpb25zLnByb3BhZ2F0ZSk7XG4gICAgfVxuICB9LFxuXG4gIGJlZm9yZURyYXcoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZHJhdyA9IG9wdGlvbnMuZHJhd1RpbWUgPT09ICdiZWZvcmVEcmF3JztcbiAgICBjb25zdCBtZXRhc2V0cyA9IGNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgICBjb25zdCBhcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuICAgIGZvciAobGV0IGkgPSBtZXRhc2V0cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgY29uc3Qgc291cmNlID0gbWV0YXNldHNbaV0uJGZpbGxlcjtcbiAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzb3VyY2UubGluZS51cGRhdGVDb250cm9sUG9pbnRzKGFyZWEsIHNvdXJjZS5heGlzKTtcbiAgICAgIGlmIChkcmF3ICYmIHNvdXJjZS5maWxsKSB7XG4gICAgICAgIF9kcmF3ZmlsbChjaGFydC5jdHgsIHNvdXJjZSwgYXJlYSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGJlZm9yZURhdGFzZXRzRHJhdyhjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5kcmF3VGltZSAhPT0gJ2JlZm9yZURhdGFzZXRzRHJhdycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBtZXRhc2V0cyA9IGNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgICBmb3IgKGxldCBpID0gbWV0YXNldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IG1ldGFzZXRzW2ldLiRmaWxsZXI7XG5cbiAgICAgIGlmIChfc2hvdWxkQXBwbHlGaWxsKHNvdXJjZSkpIHtcbiAgICAgICAgX2RyYXdmaWxsKGNoYXJ0LmN0eCwgc291cmNlLCBjaGFydC5jaGFydEFyZWEpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBiZWZvcmVEYXRhc2V0RHJhdyhjaGFydCwgYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IHNvdXJjZSA9IGFyZ3MubWV0YS4kZmlsbGVyO1xuXG4gICAgaWYgKCFfc2hvdWxkQXBwbHlGaWxsKHNvdXJjZSkgfHwgb3B0aW9ucy5kcmF3VGltZSAhPT0gJ2JlZm9yZURhdGFzZXREcmF3Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIF9kcmF3ZmlsbChjaGFydC5jdHgsIHNvdXJjZSwgY2hhcnQuY2hhcnRBcmVhKTtcbiAgfSxcblxuICBkZWZhdWx0czoge1xuICAgIHByb3BhZ2F0ZTogdHJ1ZSxcbiAgICBkcmF3VGltZTogJ2JlZm9yZURhdGFzZXREcmF3J1xuICB9XG59O1xuIiwiaW1wb3J0IGRlZmF1bHRzIGZyb20gJy4uL2NvcmUvY29yZS5kZWZhdWx0cy5qcyc7XG5pbXBvcnQgRWxlbWVudCBmcm9tICcuLi9jb3JlL2NvcmUuZWxlbWVudC5qcyc7XG5pbXBvcnQgbGF5b3V0cyBmcm9tICcuLi9jb3JlL2NvcmUubGF5b3V0cy5qcyc7XG5pbXBvcnQge2FkZFJvdW5kZWRSZWN0UGF0aCwgZHJhd1BvaW50TGVnZW5kLCByZW5kZXJUZXh0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY2FudmFzLmpzJztcbmltcG9ydCB7XG4gIF9pc0JldHdlZW4sXG4gIGNhbGxiYWNrIGFzIGNhbGwsXG4gIGNsaXBBcmVhLFxuICBnZXRSdGxBZGFwdGVyLFxuICBvdmVycmlkZVRleHREaXJlY3Rpb24sXG4gIHJlc3RvcmVUZXh0RGlyZWN0aW9uLFxuICB0b0ZvbnQsXG4gIHRvUGFkZGluZyxcbiAgdW5jbGlwQXJlYSxcbiAgdmFsdWVPckRlZmF1bHQsXG59IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IHtfYWxpZ25TdGFydEVuZCwgX3RleHRYLCBfdG9MZWZ0UmlnaHRDZW50ZXJ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5leHRyYXMuanMnO1xuaW1wb3J0IHt0b1RSQkxDb3JuZXJzfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMub3B0aW9ucy5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuQ2hhcnRFdmVudCB9IENoYXJ0RXZlbnRcbiAqL1xuXG5jb25zdCBnZXRCb3hTaXplID0gKGxhYmVsT3B0cywgZm9udFNpemUpID0+IHtcbiAgbGV0IHtib3hIZWlnaHQgPSBmb250U2l6ZSwgYm94V2lkdGggPSBmb250U2l6ZX0gPSBsYWJlbE9wdHM7XG5cbiAgaWYgKGxhYmVsT3B0cy51c2VQb2ludFN0eWxlKSB7XG4gICAgYm94SGVpZ2h0ID0gTWF0aC5taW4oYm94SGVpZ2h0LCBmb250U2l6ZSk7XG4gICAgYm94V2lkdGggPSBsYWJlbE9wdHMucG9pbnRTdHlsZVdpZHRoIHx8IE1hdGgubWluKGJveFdpZHRoLCBmb250U2l6ZSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJveFdpZHRoLFxuICAgIGJveEhlaWdodCxcbiAgICBpdGVtSGVpZ2h0OiBNYXRoLm1heChmb250U2l6ZSwgYm94SGVpZ2h0KVxuICB9O1xufTtcblxuY29uc3QgaXRlbXNFcXVhbCA9IChhLCBiKSA9PiBhICE9PSBudWxsICYmIGIgIT09IG51bGwgJiYgYS5kYXRhc2V0SW5kZXggPT09IGIuZGF0YXNldEluZGV4ICYmIGEuaW5kZXggPT09IGIuaW5kZXg7XG5cbmV4cG9ydCBjbGFzcyBMZWdlbmQgZXh0ZW5kcyBFbGVtZW50IHtcblxuICAvKipcblx0ICogQHBhcmFtIHt7IGN0eDogYW55OyBvcHRpb25zOiBhbnk7IGNoYXJ0OiBhbnk7IH19IGNvbmZpZ1xuXHQgKi9cbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2FkZGVkID0gZmFsc2U7XG5cbiAgICAvLyBDb250YWlucyBoaXQgYm94ZXMgZm9yIGVhY2ggZGF0YXNldCAoaW4gZGF0YXNldCBvcmRlcilcbiAgICB0aGlzLmxlZ2VuZEhpdEJveGVzID0gW107XG5cbiAgICAvKipcbiBcdFx0ICogQHByaXZhdGVcbiBcdFx0ICovXG4gICAgdGhpcy5faG92ZXJlZEl0ZW0gPSBudWxsO1xuXG4gICAgLy8gQXJlIHdlIGluIGRvdWdobnV0IG1vZGUgd2hpY2ggaGFzIGEgZGlmZmVyZW50IGRhdGEgdHlwZVxuICAgIHRoaXMuZG91Z2hudXRNb2RlID0gZmFsc2U7XG5cbiAgICB0aGlzLmNoYXJ0ID0gY29uZmlnLmNoYXJ0O1xuICAgIHRoaXMub3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zO1xuICAgIHRoaXMuY3R4ID0gY29uZmlnLmN0eDtcbiAgICB0aGlzLmxlZ2VuZEl0ZW1zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY29sdW1uU2l6ZXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5saW5lV2lkdGhzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWF4SGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWF4V2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50b3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib3R0b20gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sZWZ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9tYXJnaW5zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucG9zaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53ZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mdWxsU2l6ZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHVwZGF0ZShtYXhXaWR0aCwgbWF4SGVpZ2h0LCBtYXJnaW5zKSB7XG4gICAgdGhpcy5tYXhXaWR0aCA9IG1heFdpZHRoO1xuICAgIHRoaXMubWF4SGVpZ2h0ID0gbWF4SGVpZ2h0O1xuICAgIHRoaXMuX21hcmdpbnMgPSBtYXJnaW5zO1xuXG4gICAgdGhpcy5zZXREaW1lbnNpb25zKCk7XG4gICAgdGhpcy5idWlsZExhYmVscygpO1xuICAgIHRoaXMuZml0KCk7XG4gIH1cblxuICBzZXREaW1lbnNpb25zKCkge1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5tYXhXaWR0aDtcbiAgICAgIHRoaXMubGVmdCA9IHRoaXMuX21hcmdpbnMubGVmdDtcbiAgICAgIHRoaXMucmlnaHQgPSB0aGlzLndpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMubWF4SGVpZ2h0O1xuICAgICAgdGhpcy50b3AgPSB0aGlzLl9tYXJnaW5zLnRvcDtcbiAgICAgIHRoaXMuYm90dG9tID0gdGhpcy5oZWlnaHQ7XG4gICAgfVxuICB9XG5cbiAgYnVpbGRMYWJlbHMoKSB7XG4gICAgY29uc3QgbGFiZWxPcHRzID0gdGhpcy5vcHRpb25zLmxhYmVscyB8fCB7fTtcbiAgICBsZXQgbGVnZW5kSXRlbXMgPSBjYWxsKGxhYmVsT3B0cy5nZW5lcmF0ZUxhYmVscywgW3RoaXMuY2hhcnRdLCB0aGlzKSB8fCBbXTtcblxuICAgIGlmIChsYWJlbE9wdHMuZmlsdGVyKSB7XG4gICAgICBsZWdlbmRJdGVtcyA9IGxlZ2VuZEl0ZW1zLmZpbHRlcigoaXRlbSkgPT4gbGFiZWxPcHRzLmZpbHRlcihpdGVtLCB0aGlzLmNoYXJ0LmRhdGEpKTtcbiAgICB9XG5cbiAgICBpZiAobGFiZWxPcHRzLnNvcnQpIHtcbiAgICAgIGxlZ2VuZEl0ZW1zID0gbGVnZW5kSXRlbXMuc29ydCgoYSwgYikgPT4gbGFiZWxPcHRzLnNvcnQoYSwgYiwgdGhpcy5jaGFydC5kYXRhKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXZlcnNlKSB7XG4gICAgICBsZWdlbmRJdGVtcy5yZXZlcnNlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5sZWdlbmRJdGVtcyA9IGxlZ2VuZEl0ZW1zO1xuICB9XG5cbiAgZml0KCkge1xuICAgIGNvbnN0IHtvcHRpb25zLCBjdHh9ID0gdGhpcztcblxuICAgIC8vIFRoZSBsZWdlbmQgbWF5IG5vdCBiZSBkaXNwbGF5ZWQgZm9yIGEgdmFyaWV0eSBvZiByZWFzb25zIGluY2x1ZGluZ1xuICAgIC8vIHRoZSBmYWN0IHRoYXQgdGhlIGRlZmF1bHRzIGdvdCBzZXQgdG8gYGZhbHNlYC5cbiAgICAvLyBXaGVuIHRoZSBsZWdlbmQgaXMgbm90IGRpc3BsYXllZCwgdGhlcmUgYXJlIG5vIGd1YXJhbnRlZXMgdGhhdCB0aGUgb3B0aW9uc1xuICAgIC8vIGFyZSBjb3JyZWN0bHkgZm9ybWF0dGVkIHNvIHdlIG5lZWQgdG8gYmFpbCBvdXQgYXMgZWFybHkgYXMgcG9zc2libGUuXG4gICAgaWYgKCFvcHRpb25zLmRpc3BsYXkpIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLmhlaWdodCA9IDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbGFiZWxPcHRzID0gb3B0aW9ucy5sYWJlbHM7XG4gICAgY29uc3QgbGFiZWxGb250ID0gdG9Gb250KGxhYmVsT3B0cy5mb250KTtcbiAgICBjb25zdCBmb250U2l6ZSA9IGxhYmVsRm9udC5zaXplO1xuICAgIGNvbnN0IHRpdGxlSGVpZ2h0ID0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCk7XG4gICAgY29uc3Qge2JveFdpZHRoLCBpdGVtSGVpZ2h0fSA9IGdldEJveFNpemUobGFiZWxPcHRzLCBmb250U2l6ZSk7XG5cbiAgICBsZXQgd2lkdGgsIGhlaWdodDtcblxuICAgIGN0eC5mb250ID0gbGFiZWxGb250LnN0cmluZztcblxuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB3aWR0aCA9IHRoaXMubWF4V2lkdGg7IC8vIGZpbGwgYWxsIHRoZSB3aWR0aFxuICAgICAgaGVpZ2h0ID0gdGhpcy5fZml0Um93cyh0aXRsZUhlaWdodCwgZm9udFNpemUsIGJveFdpZHRoLCBpdGVtSGVpZ2h0KSArIDEwO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWlnaHQgPSB0aGlzLm1heEhlaWdodDsgLy8gZmlsbCBhbGwgdGhlIGhlaWdodFxuICAgICAgd2lkdGggPSB0aGlzLl9maXRDb2xzKHRpdGxlSGVpZ2h0LCBsYWJlbEZvbnQsIGJveFdpZHRoLCBpdGVtSGVpZ2h0KSArIDEwO1xuICAgIH1cblxuICAgIHRoaXMud2lkdGggPSBNYXRoLm1pbih3aWR0aCwgb3B0aW9ucy5tYXhXaWR0aCB8fCB0aGlzLm1heFdpZHRoKTtcbiAgICB0aGlzLmhlaWdodCA9IE1hdGgubWluKGhlaWdodCwgb3B0aW9ucy5tYXhIZWlnaHQgfHwgdGhpcy5tYXhIZWlnaHQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZml0Um93cyh0aXRsZUhlaWdodCwgZm9udFNpemUsIGJveFdpZHRoLCBpdGVtSGVpZ2h0KSB7XG4gICAgY29uc3Qge2N0eCwgbWF4V2lkdGgsIG9wdGlvbnM6IHtsYWJlbHM6IHtwYWRkaW5nfX19ID0gdGhpcztcbiAgICBjb25zdCBoaXRib3hlcyA9IHRoaXMubGVnZW5kSGl0Qm94ZXMgPSBbXTtcbiAgICAvLyBXaWR0aCBvZiBlYWNoIGxpbmUgb2YgbGVnZW5kIGJveGVzLiBMYWJlbHMgd3JhcCBvbnRvIG11bHRpcGxlIGxpbmVzIHdoZW4gdGhlcmUgYXJlIHRvbyBtYW55IHRvIGZpdCBvbiBvbmVcbiAgICBjb25zdCBsaW5lV2lkdGhzID0gdGhpcy5saW5lV2lkdGhzID0gWzBdO1xuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBpdGVtSGVpZ2h0ICsgcGFkZGluZztcbiAgICBsZXQgdG90YWxIZWlnaHQgPSB0aXRsZUhlaWdodDtcblxuICAgIGN0eC50ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuXG4gICAgbGV0IHJvdyA9IC0xO1xuICAgIGxldCB0b3AgPSAtbGluZUhlaWdodDtcbiAgICB0aGlzLmxlZ2VuZEl0ZW1zLmZvckVhY2goKGxlZ2VuZEl0ZW0sIGkpID0+IHtcbiAgICAgIGNvbnN0IGl0ZW1XaWR0aCA9IGJveFdpZHRoICsgKGZvbnRTaXplIC8gMikgKyBjdHgubWVhc3VyZVRleHQobGVnZW5kSXRlbS50ZXh0KS53aWR0aDtcblxuICAgICAgaWYgKGkgPT09IDAgfHwgbGluZVdpZHRoc1tsaW5lV2lkdGhzLmxlbmd0aCAtIDFdICsgaXRlbVdpZHRoICsgMiAqIHBhZGRpbmcgPiBtYXhXaWR0aCkge1xuICAgICAgICB0b3RhbEhlaWdodCArPSBsaW5lSGVpZ2h0O1xuICAgICAgICBsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gKGkgPiAwID8gMCA6IDEpXSA9IDA7XG4gICAgICAgIHRvcCArPSBsaW5lSGVpZ2h0O1xuICAgICAgICByb3crKztcbiAgICAgIH1cblxuICAgICAgaGl0Ym94ZXNbaV0gPSB7bGVmdDogMCwgdG9wLCByb3csIHdpZHRoOiBpdGVtV2lkdGgsIGhlaWdodDogaXRlbUhlaWdodH07XG5cbiAgICAgIGxpbmVXaWR0aHNbbGluZVdpZHRocy5sZW5ndGggLSAxXSArPSBpdGVtV2lkdGggKyBwYWRkaW5nO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRvdGFsSGVpZ2h0O1xuICB9XG5cbiAgX2ZpdENvbHModGl0bGVIZWlnaHQsIGxhYmVsRm9udCwgYm94V2lkdGgsIF9pdGVtSGVpZ2h0KSB7XG4gICAgY29uc3Qge2N0eCwgbWF4SGVpZ2h0LCBvcHRpb25zOiB7bGFiZWxzOiB7cGFkZGluZ319fSA9IHRoaXM7XG4gICAgY29uc3QgaGl0Ym94ZXMgPSB0aGlzLmxlZ2VuZEhpdEJveGVzID0gW107XG4gICAgY29uc3QgY29sdW1uU2l6ZXMgPSB0aGlzLmNvbHVtblNpemVzID0gW107XG4gICAgY29uc3QgaGVpZ2h0TGltaXQgPSBtYXhIZWlnaHQgLSB0aXRsZUhlaWdodDtcblxuICAgIGxldCB0b3RhbFdpZHRoID0gcGFkZGluZztcbiAgICBsZXQgY3VycmVudENvbFdpZHRoID0gMDtcbiAgICBsZXQgY3VycmVudENvbEhlaWdodCA9IDA7XG5cbiAgICBsZXQgbGVmdCA9IDA7XG4gICAgbGV0IGNvbCA9IDA7XG5cbiAgICB0aGlzLmxlZ2VuZEl0ZW1zLmZvckVhY2goKGxlZ2VuZEl0ZW0sIGkpID0+IHtcbiAgICAgIGNvbnN0IHtpdGVtV2lkdGgsIGl0ZW1IZWlnaHR9ID0gY2FsY3VsYXRlSXRlbVNpemUoYm94V2lkdGgsIGxhYmVsRm9udCwgY3R4LCBsZWdlbmRJdGVtLCBfaXRlbUhlaWdodCk7XG5cbiAgICAgIC8vIElmIHRvbyB0YWxsLCBnbyB0byBuZXcgY29sdW1uXG4gICAgICBpZiAoaSA+IDAgJiYgY3VycmVudENvbEhlaWdodCArIGl0ZW1IZWlnaHQgKyAyICogcGFkZGluZyA+IGhlaWdodExpbWl0KSB7XG4gICAgICAgIHRvdGFsV2lkdGggKz0gY3VycmVudENvbFdpZHRoICsgcGFkZGluZztcbiAgICAgICAgY29sdW1uU2l6ZXMucHVzaCh7d2lkdGg6IGN1cnJlbnRDb2xXaWR0aCwgaGVpZ2h0OiBjdXJyZW50Q29sSGVpZ2h0fSk7IC8vIHByZXZpb3VzIGNvbHVtbiBzaXplXG4gICAgICAgIGxlZnQgKz0gY3VycmVudENvbFdpZHRoICsgcGFkZGluZztcbiAgICAgICAgY29sKys7XG4gICAgICAgIGN1cnJlbnRDb2xXaWR0aCA9IGN1cnJlbnRDb2xIZWlnaHQgPSAwO1xuICAgICAgfVxuXG4gICAgICAvLyBTdG9yZSB0aGUgaGl0Ym94IHdpZHRoIGFuZCBoZWlnaHQgaGVyZS4gRmluYWwgcG9zaXRpb24gd2lsbCBiZSB1cGRhdGVkIGluIGBkcmF3YFxuICAgICAgaGl0Ym94ZXNbaV0gPSB7bGVmdCwgdG9wOiBjdXJyZW50Q29sSGVpZ2h0LCBjb2wsIHdpZHRoOiBpdGVtV2lkdGgsIGhlaWdodDogaXRlbUhlaWdodH07XG5cbiAgICAgIC8vIEdldCBtYXggd2lkdGhcbiAgICAgIGN1cnJlbnRDb2xXaWR0aCA9IE1hdGgubWF4KGN1cnJlbnRDb2xXaWR0aCwgaXRlbVdpZHRoKTtcbiAgICAgIGN1cnJlbnRDb2xIZWlnaHQgKz0gaXRlbUhlaWdodCArIHBhZGRpbmc7XG4gICAgfSk7XG5cbiAgICB0b3RhbFdpZHRoICs9IGN1cnJlbnRDb2xXaWR0aDtcbiAgICBjb2x1bW5TaXplcy5wdXNoKHt3aWR0aDogY3VycmVudENvbFdpZHRoLCBoZWlnaHQ6IGN1cnJlbnRDb2xIZWlnaHR9KTsgLy8gcHJldmlvdXMgY29sdW1uIHNpemVcblxuICAgIHJldHVybiB0b3RhbFdpZHRoO1xuICB9XG5cbiAgYWRqdXN0SGl0Qm94ZXMoKSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0aXRsZUhlaWdodCA9IHRoaXMuX2NvbXB1dGVUaXRsZUhlaWdodCgpO1xuICAgIGNvbnN0IHtsZWdlbmRIaXRCb3hlczogaGl0Ym94ZXMsIG9wdGlvbnM6IHthbGlnbiwgbGFiZWxzOiB7cGFkZGluZ30sIHJ0bH19ID0gdGhpcztcbiAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKHJ0bCwgdGhpcy5sZWZ0LCB0aGlzLndpZHRoKTtcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgbGV0IHJvdyA9IDA7XG4gICAgICBsZXQgbGVmdCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLmxlZnQgKyBwYWRkaW5nLCB0aGlzLnJpZ2h0IC0gdGhpcy5saW5lV2lkdGhzW3Jvd10pO1xuICAgICAgZm9yIChjb25zdCBoaXRib3ggb2YgaGl0Ym94ZXMpIHtcbiAgICAgICAgaWYgKHJvdyAhPT0gaGl0Ym94LnJvdykge1xuICAgICAgICAgIHJvdyA9IGhpdGJveC5yb3c7XG4gICAgICAgICAgbGVmdCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLmxlZnQgKyBwYWRkaW5nLCB0aGlzLnJpZ2h0IC0gdGhpcy5saW5lV2lkdGhzW3Jvd10pO1xuICAgICAgICB9XG4gICAgICAgIGhpdGJveC50b3AgKz0gdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmc7XG4gICAgICAgIGhpdGJveC5sZWZ0ID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsSGVscGVyLngobGVmdCksIGhpdGJveC53aWR0aCk7XG4gICAgICAgIGxlZnQgKz0gaGl0Ym94LndpZHRoICsgcGFkZGluZztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGNvbCA9IDA7XG4gICAgICBsZXQgdG9wID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMudG9wICsgdGl0bGVIZWlnaHQgKyBwYWRkaW5nLCB0aGlzLmJvdHRvbSAtIHRoaXMuY29sdW1uU2l6ZXNbY29sXS5oZWlnaHQpO1xuICAgICAgZm9yIChjb25zdCBoaXRib3ggb2YgaGl0Ym94ZXMpIHtcbiAgICAgICAgaWYgKGhpdGJveC5jb2wgIT09IGNvbCkge1xuICAgICAgICAgIGNvbCA9IGhpdGJveC5jb2w7XG4gICAgICAgICAgdG9wID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMudG9wICsgdGl0bGVIZWlnaHQgKyBwYWRkaW5nLCB0aGlzLmJvdHRvbSAtIHRoaXMuY29sdW1uU2l6ZXNbY29sXS5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGhpdGJveC50b3AgPSB0b3A7XG4gICAgICAgIGhpdGJveC5sZWZ0ICs9IHRoaXMubGVmdCArIHBhZGRpbmc7XG4gICAgICAgIGhpdGJveC5sZWZ0ID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsSGVscGVyLngoaGl0Ym94LmxlZnQpLCBoaXRib3gud2lkdGgpO1xuICAgICAgICB0b3AgKz0gaGl0Ym94LmhlaWdodCArIHBhZGRpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaXNIb3Jpem9udGFsKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMucG9zaXRpb24gPT09ICd0b3AnIHx8IHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9PT0gJ2JvdHRvbSc7XG4gIH1cblxuICBkcmF3KCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZGlzcGxheSkge1xuICAgICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgICBjbGlwQXJlYShjdHgsIHRoaXMpO1xuXG4gICAgICB0aGlzLl9kcmF3KCk7XG5cbiAgICAgIHVuY2xpcEFyZWEoY3R4KTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9kcmF3KCkge1xuICAgIGNvbnN0IHtvcHRpb25zOiBvcHRzLCBjb2x1bW5TaXplcywgbGluZVdpZHRocywgY3R4fSA9IHRoaXM7XG4gICAgY29uc3Qge2FsaWduLCBsYWJlbHM6IGxhYmVsT3B0c30gPSBvcHRzO1xuICAgIGNvbnN0IGRlZmF1bHRDb2xvciA9IGRlZmF1bHRzLmNvbG9yO1xuICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0cy5ydGwsIHRoaXMubGVmdCwgdGhpcy53aWR0aCk7XG4gICAgY29uc3QgbGFiZWxGb250ID0gdG9Gb250KGxhYmVsT3B0cy5mb250KTtcbiAgICBjb25zdCB7cGFkZGluZ30gPSBsYWJlbE9wdHM7XG4gICAgY29uc3QgZm9udFNpemUgPSBsYWJlbEZvbnQuc2l6ZTtcbiAgICBjb25zdCBoYWxmRm9udFNpemUgPSBmb250U2l6ZSAvIDI7XG4gICAgbGV0IGN1cnNvcjtcblxuICAgIHRoaXMuZHJhd1RpdGxlKCk7XG5cbiAgICAvLyBDYW52YXMgc2V0dXBcbiAgICBjdHgudGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbignbGVmdCcpO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBjdHgubGluZVdpZHRoID0gMC41O1xuICAgIGN0eC5mb250ID0gbGFiZWxGb250LnN0cmluZztcblxuICAgIGNvbnN0IHtib3hXaWR0aCwgYm94SGVpZ2h0LCBpdGVtSGVpZ2h0fSA9IGdldEJveFNpemUobGFiZWxPcHRzLCBmb250U2l6ZSk7XG5cbiAgICAvLyBjdXJyZW50IHBvc2l0aW9uXG4gICAgY29uc3QgZHJhd0xlZ2VuZEJveCA9IGZ1bmN0aW9uKHgsIHksIGxlZ2VuZEl0ZW0pIHtcbiAgICAgIGlmIChpc05hTihib3hXaWR0aCkgfHwgYm94V2lkdGggPD0gMCB8fCBpc05hTihib3hIZWlnaHQpIHx8IGJveEhlaWdodCA8IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgdGhlIGN0eCBmb3IgdGhlIGJveFxuICAgICAgY3R4LnNhdmUoKTtcblxuICAgICAgY29uc3QgbGluZVdpZHRoID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5saW5lV2lkdGgsIDEpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0uZmlsbFN0eWxlLCBkZWZhdWx0Q29sb3IpO1xuICAgICAgY3R4LmxpbmVDYXAgPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVDYXAsICdidXR0Jyk7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVEYXNoT2Zmc2V0LCAwKTtcbiAgICAgIGN0eC5saW5lSm9pbiA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZUpvaW4sICdtaXRlcicpO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0uc3Ryb2tlU3R5bGUsIGRlZmF1bHRDb2xvcik7XG5cbiAgICAgIGN0eC5zZXRMaW5lRGFzaCh2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVEYXNoLCBbXSkpO1xuXG4gICAgICBpZiAobGFiZWxPcHRzLnVzZVBvaW50U3R5bGUpIHtcbiAgICAgICAgLy8gUmVjYWxjdWxhdGUgeCBhbmQgeSBmb3IgZHJhd1BvaW50KCkgYmVjYXVzZSBpdHMgZXhwZWN0aW5nXG4gICAgICAgIC8vIHggYW5kIHkgdG8gYmUgY2VudGVyIG9mIGZpZ3VyZSAoaW5zdGVhZCBvZiB0b3AgbGVmdClcbiAgICAgICAgY29uc3QgZHJhd09wdGlvbnMgPSB7XG4gICAgICAgICAgcmFkaXVzOiBib3hIZWlnaHQgKiBNYXRoLlNRUlQyIC8gMixcbiAgICAgICAgICBwb2ludFN0eWxlOiBsZWdlbmRJdGVtLnBvaW50U3R5bGUsXG4gICAgICAgICAgcm90YXRpb246IGxlZ2VuZEl0ZW0ucm90YXRpb24sXG4gICAgICAgICAgYm9yZGVyV2lkdGg6IGxpbmVXaWR0aFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjZW50ZXJYID0gcnRsSGVscGVyLnhQbHVzKHgsIGJveFdpZHRoIC8gMik7XG4gICAgICAgIGNvbnN0IGNlbnRlclkgPSB5ICsgaGFsZkZvbnRTaXplO1xuXG4gICAgICAgIC8vIERyYXcgcG9pbnRTdHlsZSBhcyBsZWdlbmQgc3ltYm9sXG4gICAgICAgIGRyYXdQb2ludExlZ2VuZChjdHgsIGRyYXdPcHRpb25zLCBjZW50ZXJYLCBjZW50ZXJZLCBsYWJlbE9wdHMucG9pbnRTdHlsZVdpZHRoICYmIGJveFdpZHRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIERyYXcgYm94IGFzIGxlZ2VuZCBzeW1ib2xcbiAgICAgICAgLy8gQWRqdXN0IHBvc2l0aW9uIHdoZW4gYm94SGVpZ2h0IDwgZm9udFNpemUgKHdhbnQgaXQgY2VudGVyZWQpXG4gICAgICAgIGNvbnN0IHlCb3hUb3AgPSB5ICsgTWF0aC5tYXgoKGZvbnRTaXplIC0gYm94SGVpZ2h0KSAvIDIsIDApO1xuICAgICAgICBjb25zdCB4Qm94TGVmdCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHgsIGJveFdpZHRoKTtcbiAgICAgICAgY29uc3QgYm9yZGVyUmFkaXVzID0gdG9UUkJMQ29ybmVycyhsZWdlbmRJdGVtLmJvcmRlclJhZGl1cyk7XG5cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgIGlmIChPYmplY3QudmFsdWVzKGJvcmRlclJhZGl1cykuc29tZSh2ID0+IHYgIT09IDApKSB7XG4gICAgICAgICAgYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwge1xuICAgICAgICAgICAgeDogeEJveExlZnQsXG4gICAgICAgICAgICB5OiB5Qm94VG9wLFxuICAgICAgICAgICAgdzogYm94V2lkdGgsXG4gICAgICAgICAgICBoOiBib3hIZWlnaHQsXG4gICAgICAgICAgICByYWRpdXM6IGJvcmRlclJhZGl1cyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHgucmVjdCh4Qm94TGVmdCwgeUJveFRvcCwgYm94V2lkdGgsIGJveEhlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICBpZiAobGluZVdpZHRoICE9PSAwKSB7XG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfTtcblxuICAgIGNvbnN0IGZpbGxUZXh0ID0gZnVuY3Rpb24oeCwgeSwgbGVnZW5kSXRlbSkge1xuICAgICAgcmVuZGVyVGV4dChjdHgsIGxlZ2VuZEl0ZW0udGV4dCwgeCwgeSArIChpdGVtSGVpZ2h0IC8gMiksIGxhYmVsRm9udCwge1xuICAgICAgICBzdHJpa2V0aHJvdWdoOiBsZWdlbmRJdGVtLmhpZGRlbixcbiAgICAgICAgdGV4dEFsaWduOiBydGxIZWxwZXIudGV4dEFsaWduKGxlZ2VuZEl0ZW0udGV4dEFsaWduKVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIEhvcml6b250YWxcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IHRpdGxlSGVpZ2h0ID0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCk7XG4gICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgY3Vyc29yID0ge1xuICAgICAgICB4OiBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy5sZWZ0ICsgcGFkZGluZywgdGhpcy5yaWdodCAtIGxpbmVXaWR0aHNbMF0pLFxuICAgICAgICB5OiB0aGlzLnRvcCArIHBhZGRpbmcgKyB0aXRsZUhlaWdodCxcbiAgICAgICAgbGluZTogMFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3Vyc29yID0ge1xuICAgICAgICB4OiB0aGlzLmxlZnQgKyBwYWRkaW5nLFxuICAgICAgICB5OiBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmcsIHRoaXMuYm90dG9tIC0gY29sdW1uU2l6ZXNbMF0uaGVpZ2h0KSxcbiAgICAgICAgbGluZTogMFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBvdmVycmlkZVRleHREaXJlY3Rpb24odGhpcy5jdHgsIG9wdHMudGV4dERpcmVjdGlvbik7XG5cbiAgICBjb25zdCBsaW5lSGVpZ2h0ID0gaXRlbUhlaWdodCArIHBhZGRpbmc7XG4gICAgdGhpcy5sZWdlbmRJdGVtcy5mb3JFYWNoKChsZWdlbmRJdGVtLCBpKSA9PiB7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBsZWdlbmRJdGVtLmZvbnRDb2xvcjsgLy8gZm9yIHN0cmlrZXRocm91Z2ggZWZmZWN0XG4gICAgICBjdHguZmlsbFN0eWxlID0gbGVnZW5kSXRlbS5mb250Q29sb3I7IC8vIHJlbmRlciBpbiBjb3JyZWN0IGNvbG91clxuXG4gICAgICBjb25zdCB0ZXh0V2lkdGggPSBjdHgubWVhc3VyZVRleHQobGVnZW5kSXRlbS50ZXh0KS53aWR0aDtcbiAgICAgIGNvbnN0IHRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24obGVnZW5kSXRlbS50ZXh0QWxpZ24gfHwgKGxlZ2VuZEl0ZW0udGV4dEFsaWduID0gbGFiZWxPcHRzLnRleHRBbGlnbikpO1xuICAgICAgY29uc3Qgd2lkdGggPSBib3hXaWR0aCArIGhhbGZGb250U2l6ZSArIHRleHRXaWR0aDtcbiAgICAgIGxldCB4ID0gY3Vyc29yLng7XG4gICAgICBsZXQgeSA9IGN1cnNvci55O1xuXG4gICAgICBydGxIZWxwZXIuc2V0V2lkdGgodGhpcy53aWR0aCk7XG5cbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgaWYgKGkgPiAwICYmIHggKyB3aWR0aCArIHBhZGRpbmcgPiB0aGlzLnJpZ2h0KSB7XG4gICAgICAgICAgeSA9IGN1cnNvci55ICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgY3Vyc29yLmxpbmUrKztcbiAgICAgICAgICB4ID0gY3Vyc29yLnggPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy5sZWZ0ICsgcGFkZGluZywgdGhpcy5yaWdodCAtIGxpbmVXaWR0aHNbY3Vyc29yLmxpbmVdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpID4gMCAmJiB5ICsgbGluZUhlaWdodCA+IHRoaXMuYm90dG9tKSB7XG4gICAgICAgIHggPSBjdXJzb3IueCA9IHggKyBjb2x1bW5TaXplc1tjdXJzb3IubGluZV0ud2lkdGggKyBwYWRkaW5nO1xuICAgICAgICBjdXJzb3IubGluZSsrO1xuICAgICAgICB5ID0gY3Vyc29yLnkgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmcsIHRoaXMuYm90dG9tIC0gY29sdW1uU2l6ZXNbY3Vyc29yLmxpbmVdLmhlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlYWxYID0gcnRsSGVscGVyLngoeCk7XG5cbiAgICAgIGRyYXdMZWdlbmRCb3gocmVhbFgsIHksIGxlZ2VuZEl0ZW0pO1xuXG4gICAgICB4ID0gX3RleHRYKHRleHRBbGlnbiwgeCArIGJveFdpZHRoICsgaGFsZkZvbnRTaXplLCBpc0hvcml6b250YWwgPyB4ICsgd2lkdGggOiB0aGlzLnJpZ2h0LCBvcHRzLnJ0bCk7XG5cbiAgICAgIC8vIEZpbGwgdGhlIGFjdHVhbCBsYWJlbFxuICAgICAgZmlsbFRleHQocnRsSGVscGVyLngoeCksIHksIGxlZ2VuZEl0ZW0pO1xuXG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIGN1cnNvci54ICs9IHdpZHRoICsgcGFkZGluZztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxlZ2VuZEl0ZW0udGV4dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3QgZm9udExpbmVIZWlnaHQgPSBsYWJlbEZvbnQubGluZUhlaWdodDtcbiAgICAgICAgY3Vyc29yLnkgKz0gY2FsY3VsYXRlTGVnZW5kSXRlbUhlaWdodChsZWdlbmRJdGVtLCBmb250TGluZUhlaWdodCkgKyBwYWRkaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3Vyc29yLnkgKz0gbGluZUhlaWdodDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJlc3RvcmVUZXh0RGlyZWN0aW9uKHRoaXMuY3R4LCBvcHRzLnRleHREaXJlY3Rpb24pO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGRyYXdUaXRsZSgpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRpdGxlT3B0cyA9IG9wdHMudGl0bGU7XG4gICAgY29uc3QgdGl0bGVGb250ID0gdG9Gb250KHRpdGxlT3B0cy5mb250KTtcbiAgICBjb25zdCB0aXRsZVBhZGRpbmcgPSB0b1BhZGRpbmcodGl0bGVPcHRzLnBhZGRpbmcpO1xuXG4gICAgaWYgKCF0aXRsZU9wdHMuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0cy5ydGwsIHRoaXMubGVmdCwgdGhpcy53aWR0aCk7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aXRsZU9wdHMucG9zaXRpb247XG4gICAgY29uc3QgaGFsZkZvbnRTaXplID0gdGl0bGVGb250LnNpemUgLyAyO1xuICAgIGNvbnN0IHRvcFBhZGRpbmdQbHVzSGFsZkZvbnRTaXplID0gdGl0bGVQYWRkaW5nLnRvcCArIGhhbGZGb250U2l6ZTtcbiAgICBsZXQgeTtcblxuICAgIC8vIFRoZXNlIGRlZmF1bHRzIGFyZSB1c2VkIHdoZW4gdGhlIGxlZ2VuZCBpcyB2ZXJ0aWNhbC5cbiAgICAvLyBXaGVuIGhvcml6b250YWwsIHRoZXkgYXJlIGNvbXB1dGVkIGJlbG93LlxuICAgIGxldCBsZWZ0ID0gdGhpcy5sZWZ0O1xuICAgIGxldCBtYXhXaWR0aCA9IHRoaXMud2lkdGg7XG5cbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgLy8gTW92ZSBsZWZ0IC8gcmlnaHQgc28gdGhhdCB0aGUgdGl0bGUgaXMgYWJvdmUgdGhlIGxlZ2VuZCBsaW5lc1xuICAgICAgbWF4V2lkdGggPSBNYXRoLm1heCguLi50aGlzLmxpbmVXaWR0aHMpO1xuICAgICAgeSA9IHRoaXMudG9wICsgdG9wUGFkZGluZ1BsdXNIYWxmRm9udFNpemU7XG4gICAgICBsZWZ0ID0gX2FsaWduU3RhcnRFbmQob3B0cy5hbGlnbiwgbGVmdCwgdGhpcy5yaWdodCAtIG1heFdpZHRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTW92ZSBkb3duIHNvIHRoYXQgdGhlIHRpdGxlIGlzIGFib3ZlIHRoZSBsZWdlbmQgc3RhY2sgaW4gZXZlcnkgYWxpZ25tZW50XG4gICAgICBjb25zdCBtYXhIZWlnaHQgPSB0aGlzLmNvbHVtblNpemVzLnJlZHVjZSgoYWNjLCBzaXplKSA9PiBNYXRoLm1heChhY2MsIHNpemUuaGVpZ2h0KSwgMCk7XG4gICAgICB5ID0gdG9wUGFkZGluZ1BsdXNIYWxmRm9udFNpemUgKyBfYWxpZ25TdGFydEVuZChvcHRzLmFsaWduLCB0aGlzLnRvcCwgdGhpcy5ib3R0b20gLSBtYXhIZWlnaHQgLSBvcHRzLmxhYmVscy5wYWRkaW5nIC0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCkpO1xuICAgIH1cblxuICAgIC8vIE5vdyB0aGF0IHdlIGtub3cgdGhlIGxlZnQgZWRnZSBvZiB0aGUgaW5uZXIgbGVnZW5kIGJveCwgY29tcHV0ZSB0aGUgY29ycmVjdFxuICAgIC8vIFggY29vcmRpbmF0ZSBmcm9tIHRoZSB0aXRsZSBhbGlnbm1lbnRcbiAgICBjb25zdCB4ID0gX2FsaWduU3RhcnRFbmQocG9zaXRpb24sIGxlZnQsIGxlZnQgKyBtYXhXaWR0aCk7XG5cbiAgICAvLyBDYW52YXMgc2V0dXBcbiAgICBjdHgudGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbihfdG9MZWZ0UmlnaHRDZW50ZXIocG9zaXRpb24pKTtcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gdGl0bGVPcHRzLmNvbG9yO1xuICAgIGN0eC5maWxsU3R5bGUgPSB0aXRsZU9wdHMuY29sb3I7XG4gICAgY3R4LmZvbnQgPSB0aXRsZUZvbnQuc3RyaW5nO1xuXG4gICAgcmVuZGVyVGV4dChjdHgsIHRpdGxlT3B0cy50ZXh0LCB4LCB5LCB0aXRsZUZvbnQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY29tcHV0ZVRpdGxlSGVpZ2h0KCkge1xuICAgIGNvbnN0IHRpdGxlT3B0cyA9IHRoaXMub3B0aW9ucy50aXRsZTtcbiAgICBjb25zdCB0aXRsZUZvbnQgPSB0b0ZvbnQodGl0bGVPcHRzLmZvbnQpO1xuICAgIGNvbnN0IHRpdGxlUGFkZGluZyA9IHRvUGFkZGluZyh0aXRsZU9wdHMucGFkZGluZyk7XG4gICAgcmV0dXJuIHRpdGxlT3B0cy5kaXNwbGF5ID8gdGl0bGVGb250LmxpbmVIZWlnaHQgKyB0aXRsZVBhZGRpbmcuaGVpZ2h0IDogMDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldExlZ2VuZEl0ZW1BdCh4LCB5KSB7XG4gICAgbGV0IGksIGhpdEJveCwgbGg7XG5cbiAgICBpZiAoX2lzQmV0d2Vlbih4LCB0aGlzLmxlZnQsIHRoaXMucmlnaHQpXG4gICAgICAmJiBfaXNCZXR3ZWVuKHksIHRoaXMudG9wLCB0aGlzLmJvdHRvbSkpIHtcbiAgICAgIC8vIFNlZSBpZiB3ZSBhcmUgdG91Y2hpbmcgb25lIG9mIHRoZSBkYXRhc2V0IGJveGVzXG4gICAgICBsaCA9IHRoaXMubGVnZW5kSGl0Qm94ZXM7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGgubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaGl0Qm94ID0gbGhbaV07XG5cbiAgICAgICAgaWYgKF9pc0JldHdlZW4oeCwgaGl0Qm94LmxlZnQsIGhpdEJveC5sZWZ0ICsgaGl0Qm94LndpZHRoKVxuICAgICAgICAgICYmIF9pc0JldHdlZW4oeSwgaGl0Qm94LnRvcCwgaGl0Qm94LnRvcCArIGhpdEJveC5oZWlnaHQpKSB7XG4gICAgICAgICAgLy8gVG91Y2hpbmcgYW4gZWxlbWVudFxuICAgICAgICAgIHJldHVybiB0aGlzLmxlZ2VuZEl0ZW1zW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcblx0ICogSGFuZGxlIGFuIGV2ZW50XG5cdCAqIEBwYXJhbSB7Q2hhcnRFdmVudH0gZSAtIFRoZSBldmVudCB0byBoYW5kbGVcblx0ICovXG4gIGhhbmRsZUV2ZW50KGUpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGlmICghaXNMaXN0ZW5lZChlLnR5cGUsIG9wdHMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2hhcnQgZXZlbnQgYWxyZWFkeSBoYXMgcmVsYXRpdmUgcG9zaXRpb24gaW4gaXRcbiAgICBjb25zdCBob3ZlcmVkSXRlbSA9IHRoaXMuX2dldExlZ2VuZEl0ZW1BdChlLngsIGUueSk7XG5cbiAgICBpZiAoZS50eXBlID09PSAnbW91c2Vtb3ZlJyB8fCBlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzID0gdGhpcy5faG92ZXJlZEl0ZW07XG4gICAgICBjb25zdCBzYW1lSXRlbSA9IGl0ZW1zRXF1YWwocHJldmlvdXMsIGhvdmVyZWRJdGVtKTtcbiAgICAgIGlmIChwcmV2aW91cyAmJiAhc2FtZUl0ZW0pIHtcbiAgICAgICAgY2FsbChvcHRzLm9uTGVhdmUsIFtlLCBwcmV2aW91cywgdGhpc10sIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9ob3ZlcmVkSXRlbSA9IGhvdmVyZWRJdGVtO1xuXG4gICAgICBpZiAoaG92ZXJlZEl0ZW0gJiYgIXNhbWVJdGVtKSB7XG4gICAgICAgIGNhbGwob3B0cy5vbkhvdmVyLCBbZSwgaG92ZXJlZEl0ZW0sIHRoaXNdLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhvdmVyZWRJdGVtKSB7XG4gICAgICBjYWxsKG9wdHMub25DbGljaywgW2UsIGhvdmVyZWRJdGVtLCB0aGlzXSwgdGhpcyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUl0ZW1TaXplKGJveFdpZHRoLCBsYWJlbEZvbnQsIGN0eCwgbGVnZW5kSXRlbSwgX2l0ZW1IZWlnaHQpIHtcbiAgY29uc3QgaXRlbVdpZHRoID0gY2FsY3VsYXRlSXRlbVdpZHRoKGxlZ2VuZEl0ZW0sIGJveFdpZHRoLCBsYWJlbEZvbnQsIGN0eCk7XG4gIGNvbnN0IGl0ZW1IZWlnaHQgPSBjYWxjdWxhdGVJdGVtSGVpZ2h0KF9pdGVtSGVpZ2h0LCBsZWdlbmRJdGVtLCBsYWJlbEZvbnQubGluZUhlaWdodCk7XG4gIHJldHVybiB7aXRlbVdpZHRoLCBpdGVtSGVpZ2h0fTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlSXRlbVdpZHRoKGxlZ2VuZEl0ZW0sIGJveFdpZHRoLCBsYWJlbEZvbnQsIGN0eCkge1xuICBsZXQgbGVnZW5kSXRlbVRleHQgPSBsZWdlbmRJdGVtLnRleHQ7XG4gIGlmIChsZWdlbmRJdGVtVGV4dCAmJiB0eXBlb2YgbGVnZW5kSXRlbVRleHQgIT09ICdzdHJpbmcnKSB7XG4gICAgbGVnZW5kSXRlbVRleHQgPSBsZWdlbmRJdGVtVGV4dC5yZWR1Y2UoKGEsIGIpID0+IGEubGVuZ3RoID4gYi5sZW5ndGggPyBhIDogYik7XG4gIH1cbiAgcmV0dXJuIGJveFdpZHRoICsgKGxhYmVsRm9udC5zaXplIC8gMikgKyBjdHgubWVhc3VyZVRleHQobGVnZW5kSXRlbVRleHQpLndpZHRoO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVJdGVtSGVpZ2h0KF9pdGVtSGVpZ2h0LCBsZWdlbmRJdGVtLCBmb250TGluZUhlaWdodCkge1xuICBsZXQgaXRlbUhlaWdodCA9IF9pdGVtSGVpZ2h0O1xuICBpZiAodHlwZW9mIGxlZ2VuZEl0ZW0udGV4dCAhPT0gJ3N0cmluZycpIHtcbiAgICBpdGVtSGVpZ2h0ID0gY2FsY3VsYXRlTGVnZW5kSXRlbUhlaWdodChsZWdlbmRJdGVtLCBmb250TGluZUhlaWdodCk7XG4gIH1cbiAgcmV0dXJuIGl0ZW1IZWlnaHQ7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUxlZ2VuZEl0ZW1IZWlnaHQobGVnZW5kSXRlbSwgZm9udExpbmVIZWlnaHQpIHtcbiAgY29uc3QgbGFiZWxIZWlnaHQgPSBsZWdlbmRJdGVtLnRleHQgPyBsZWdlbmRJdGVtLnRleHQubGVuZ3RoIDogMDtcbiAgcmV0dXJuIGZvbnRMaW5lSGVpZ2h0ICogbGFiZWxIZWlnaHQ7XG59XG5cbmZ1bmN0aW9uIGlzTGlzdGVuZWQodHlwZSwgb3B0cykge1xuICBpZiAoKHR5cGUgPT09ICdtb3VzZW1vdmUnIHx8IHR5cGUgPT09ICdtb3VzZW91dCcpICYmIChvcHRzLm9uSG92ZXIgfHwgb3B0cy5vbkxlYXZlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChvcHRzLm9uQ2xpY2sgJiYgKHR5cGUgPT09ICdjbGljaycgfHwgdHlwZSA9PT0gJ21vdXNldXAnKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpZDogJ2xlZ2VuZCcsXG5cbiAgLyoqXG5cdCAqIEZvciB0ZXN0c1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2VsZW1lbnQ6IExlZ2VuZCxcblxuICBzdGFydChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsZWdlbmQgPSBjaGFydC5sZWdlbmQgPSBuZXcgTGVnZW5kKHtjdHg6IGNoYXJ0LmN0eCwgb3B0aW9ucywgY2hhcnR9KTtcbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgbGVnZW5kLCBvcHRpb25zKTtcbiAgICBsYXlvdXRzLmFkZEJveChjaGFydCwgbGVnZW5kKTtcbiAgfSxcblxuICBzdG9wKGNoYXJ0KSB7XG4gICAgbGF5b3V0cy5yZW1vdmVCb3goY2hhcnQsIGNoYXJ0LmxlZ2VuZCk7XG4gICAgZGVsZXRlIGNoYXJ0LmxlZ2VuZDtcbiAgfSxcblxuICAvLyBEdXJpbmcgdGhlIGJlZm9yZVVwZGF0ZSBzdGVwLCB0aGUgbGF5b3V0IGNvbmZpZ3VyYXRpb24gbmVlZHMgdG8gcnVuXG4gIC8vIFRoaXMgZW5zdXJlcyB0aGF0IGlmIHRoZSBsZWdlbmQgcG9zaXRpb24gY2hhbmdlcyAodmlhIGFuIG9wdGlvbiB1cGRhdGUpXG4gIC8vIHRoZSBsYXlvdXQgc3lzdGVtIHJlc3BlY3RzIHRoZSBjaGFuZ2UuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNzUyN1xuICBiZWZvcmVVcGRhdGUoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbGVnZW5kID0gY2hhcnQubGVnZW5kO1xuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCBsZWdlbmQsIG9wdGlvbnMpO1xuICAgIGxlZ2VuZC5vcHRpb25zID0gb3B0aW9ucztcbiAgfSxcblxuICAvLyBUaGUgbGFiZWxzIG5lZWQgdG8gYmUgYnVpbHQgYWZ0ZXIgZGF0YXNldHMgYXJlIHVwZGF0ZWQgdG8gZW5zdXJlIHRoYXQgY29sb3JzXG4gIC8vIGFuZCBvdGhlciBzdHlsaW5nIGFyZSBjb3JyZWN0LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzY5NjhcbiAgYWZ0ZXJVcGRhdGUoY2hhcnQpIHtcbiAgICBjb25zdCBsZWdlbmQgPSBjaGFydC5sZWdlbmQ7XG4gICAgbGVnZW5kLmJ1aWxkTGFiZWxzKCk7XG4gICAgbGVnZW5kLmFkanVzdEhpdEJveGVzKCk7XG4gIH0sXG5cblxuICBhZnRlckV2ZW50KGNoYXJ0LCBhcmdzKSB7XG4gICAgaWYgKCFhcmdzLnJlcGxheSkge1xuICAgICAgY2hhcnQubGVnZW5kLmhhbmRsZUV2ZW50KGFyZ3MuZXZlbnQpO1xuICAgIH1cbiAgfSxcblxuICBkZWZhdWx0czoge1xuICAgIGRpc3BsYXk6IHRydWUsXG4gICAgcG9zaXRpb246ICd0b3AnLFxuICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICBmdWxsU2l6ZTogdHJ1ZSxcbiAgICByZXZlcnNlOiBmYWxzZSxcbiAgICB3ZWlnaHQ6IDEwMDAsXG5cbiAgICAvLyBhIGNhbGxiYWNrIHRoYXQgd2lsbCBoYW5kbGVcbiAgICBvbkNsaWNrKGUsIGxlZ2VuZEl0ZW0sIGxlZ2VuZCkge1xuICAgICAgY29uc3QgaW5kZXggPSBsZWdlbmRJdGVtLmRhdGFzZXRJbmRleDtcbiAgICAgIGNvbnN0IGNpID0gbGVnZW5kLmNoYXJ0O1xuICAgICAgaWYgKGNpLmlzRGF0YXNldFZpc2libGUoaW5kZXgpKSB7XG4gICAgICAgIGNpLmhpZGUoaW5kZXgpO1xuICAgICAgICBsZWdlbmRJdGVtLmhpZGRlbiA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaS5zaG93KGluZGV4KTtcbiAgICAgICAgbGVnZW5kSXRlbS5oaWRkZW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgb25Ib3ZlcjogbnVsbCxcbiAgICBvbkxlYXZlOiBudWxsLFxuXG4gICAgbGFiZWxzOiB7XG4gICAgICBjb2xvcjogKGN0eCkgPT4gY3R4LmNoYXJ0Lm9wdGlvbnMuY29sb3IsXG4gICAgICBib3hXaWR0aDogNDAsXG4gICAgICBwYWRkaW5nOiAxMCxcbiAgICAgIC8vIEdlbmVyYXRlcyBsYWJlbHMgc2hvd24gaW4gdGhlIGxlZ2VuZFxuICAgICAgLy8gVmFsaWQgcHJvcGVydGllcyB0byByZXR1cm46XG4gICAgICAvLyB0ZXh0IDogdGV4dCB0byBkaXNwbGF5XG4gICAgICAvLyBmaWxsU3R5bGUgOiBmaWxsIG9mIGNvbG91cmVkIGJveFxuICAgICAgLy8gc3Ryb2tlU3R5bGU6IHN0cm9rZSBvZiBjb2xvdXJlZCBib3hcbiAgICAgIC8vIGhpZGRlbiA6IGlmIHRoaXMgbGVnZW5kIGl0ZW0gcmVmZXJzIHRvIGEgaGlkZGVuIGl0ZW1cbiAgICAgIC8vIGxpbmVDYXAgOiBjYXAgc3R5bGUgZm9yIGxpbmVcbiAgICAgIC8vIGxpbmVEYXNoXG4gICAgICAvLyBsaW5lRGFzaE9mZnNldCA6XG4gICAgICAvLyBsaW5lSm9pbiA6XG4gICAgICAvLyBsaW5lV2lkdGggOlxuICAgICAgZ2VuZXJhdGVMYWJlbHMoY2hhcnQpIHtcbiAgICAgICAgY29uc3QgZGF0YXNldHMgPSBjaGFydC5kYXRhLmRhdGFzZXRzO1xuICAgICAgICBjb25zdCB7bGFiZWxzOiB7dXNlUG9pbnRTdHlsZSwgcG9pbnRTdHlsZSwgdGV4dEFsaWduLCBjb2xvciwgdXNlQm9yZGVyUmFkaXVzLCBib3JkZXJSYWRpdXN9fSA9IGNoYXJ0LmxlZ2VuZC5vcHRpb25zO1xuXG4gICAgICAgIHJldHVybiBjaGFydC5fZ2V0U29ydGVkRGF0YXNldE1ldGFzKCkubWFwKChtZXRhKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3R5bGUgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUodXNlUG9pbnRTdHlsZSA/IDAgOiB1bmRlZmluZWQpO1xuICAgICAgICAgIGNvbnN0IGJvcmRlcldpZHRoID0gdG9QYWRkaW5nKHN0eWxlLmJvcmRlcldpZHRoKTtcblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0ZXh0OiBkYXRhc2V0c1ttZXRhLmluZGV4XS5sYWJlbCxcbiAgICAgICAgICAgIGZpbGxTdHlsZTogc3R5bGUuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgZm9udENvbG9yOiBjb2xvcixcbiAgICAgICAgICAgIGhpZGRlbjogIW1ldGEudmlzaWJsZSxcbiAgICAgICAgICAgIGxpbmVDYXA6IHN0eWxlLmJvcmRlckNhcFN0eWxlLFxuICAgICAgICAgICAgbGluZURhc2g6IHN0eWxlLmJvcmRlckRhc2gsXG4gICAgICAgICAgICBsaW5lRGFzaE9mZnNldDogc3R5bGUuYm9yZGVyRGFzaE9mZnNldCxcbiAgICAgICAgICAgIGxpbmVKb2luOiBzdHlsZS5ib3JkZXJKb2luU3R5bGUsXG4gICAgICAgICAgICBsaW5lV2lkdGg6IChib3JkZXJXaWR0aC53aWR0aCArIGJvcmRlcldpZHRoLmhlaWdodCkgLyA0LFxuICAgICAgICAgICAgc3Ryb2tlU3R5bGU6IHN0eWxlLmJvcmRlckNvbG9yLFxuICAgICAgICAgICAgcG9pbnRTdHlsZTogcG9pbnRTdHlsZSB8fCBzdHlsZS5wb2ludFN0eWxlLFxuICAgICAgICAgICAgcm90YXRpb246IHN0eWxlLnJvdGF0aW9uLFxuICAgICAgICAgICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24gfHwgc3R5bGUudGV4dEFsaWduLFxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiB1c2VCb3JkZXJSYWRpdXMgJiYgKGJvcmRlclJhZGl1cyB8fCBzdHlsZS5ib3JkZXJSYWRpdXMpLFxuXG4gICAgICAgICAgICAvLyBCZWxvdyBpcyBleHRyYSBkYXRhIHVzZWQgZm9yIHRvZ2dsaW5nIHRoZSBkYXRhc2V0c1xuICAgICAgICAgICAgZGF0YXNldEluZGV4OiBtZXRhLmluZGV4XG4gICAgICAgICAgfTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHRpdGxlOiB7XG4gICAgICBjb2xvcjogKGN0eCkgPT4gY3R4LmNoYXJ0Lm9wdGlvbnMuY29sb3IsXG4gICAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICAgIHBvc2l0aW9uOiAnY2VudGVyJyxcbiAgICAgIHRleHQ6ICcnLFxuICAgIH1cbiAgfSxcblxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gIW5hbWUuc3RhcnRzV2l0aCgnb24nKSxcbiAgICBsYWJlbHM6IHtcbiAgICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gIVsnZ2VuZXJhdGVMYWJlbHMnLCAnZmlsdGVyJywgJ3NvcnQnXS5pbmNsdWRlcyhuYW1lKSxcbiAgICB9XG4gIH0sXG59O1xuIiwiaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi4vY29yZS9jb3JlLmVsZW1lbnQuanMnO1xuaW1wb3J0IGxheW91dHMgZnJvbSAnLi4vY29yZS9jb3JlLmxheW91dHMuanMnO1xuaW1wb3J0IHtQSSwgaXNBcnJheSwgdG9QYWRkaW5nLCB0b0ZvbnR9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IHtfdG9MZWZ0UmlnaHRDZW50ZXIsIF9hbGlnblN0YXJ0RW5kfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuZXh0cmFzLmpzJztcbmltcG9ydCB7cmVuZGVyVGV4dH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNhbnZhcy5qcyc7XG5cbmV4cG9ydCBjbGFzcyBUaXRsZSBleHRlbmRzIEVsZW1lbnQge1xuICAvKipcblx0ICogQHBhcmFtIHt7IGN0eDogYW55OyBvcHRpb25zOiBhbnk7IGNoYXJ0OiBhbnk7IH19IGNvbmZpZ1xuXHQgKi9cbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuY2hhcnQgPSBjb25maWcuY2hhcnQ7XG4gICAgdGhpcy5vcHRpb25zID0gY29uZmlnLm9wdGlvbnM7XG4gICAgdGhpcy5jdHggPSBjb25maWcuY3R4O1xuICAgIHRoaXMuX3BhZGRpbmcgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50b3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib3R0b20gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sZWZ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBvc2l0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2VpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZnVsbFNpemUgPSB1bmRlZmluZWQ7XG4gIH1cblxuICB1cGRhdGUobWF4V2lkdGgsIG1heEhlaWdodCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICB0aGlzLmxlZnQgPSAwO1xuICAgIHRoaXMudG9wID0gMDtcblxuICAgIGlmICghb3B0cy5kaXNwbGF5KSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5oZWlnaHQgPSB0aGlzLnJpZ2h0ID0gdGhpcy5ib3R0b20gPSAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMud2lkdGggPSB0aGlzLnJpZ2h0ID0gbWF4V2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSB0aGlzLmJvdHRvbSA9IG1heEhlaWdodDtcblxuICAgIGNvbnN0IGxpbmVDb3VudCA9IGlzQXJyYXkob3B0cy50ZXh0KSA/IG9wdHMudGV4dC5sZW5ndGggOiAxO1xuICAgIHRoaXMuX3BhZGRpbmcgPSB0b1BhZGRpbmcob3B0cy5wYWRkaW5nKTtcbiAgICBjb25zdCB0ZXh0U2l6ZSA9IGxpbmVDb3VudCAqIHRvRm9udChvcHRzLmZvbnQpLmxpbmVIZWlnaHQgKyB0aGlzLl9wYWRkaW5nLmhlaWdodDtcblxuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB0aGlzLmhlaWdodCA9IHRleHRTaXplO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndpZHRoID0gdGV4dFNpemU7XG4gICAgfVxuICB9XG5cbiAgaXNIb3Jpem9udGFsKCkge1xuICAgIGNvbnN0IHBvcyA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcbiAgICByZXR1cm4gcG9zID09PSAndG9wJyB8fCBwb3MgPT09ICdib3R0b20nO1xuICB9XG5cbiAgX2RyYXdBcmdzKG9mZnNldCkge1xuICAgIGNvbnN0IHt0b3AsIGxlZnQsIGJvdHRvbSwgcmlnaHQsIG9wdGlvbnN9ID0gdGhpcztcbiAgICBjb25zdCBhbGlnbiA9IG9wdGlvbnMuYWxpZ247XG4gICAgbGV0IHJvdGF0aW9uID0gMDtcbiAgICBsZXQgbWF4V2lkdGgsIHRpdGxlWCwgdGl0bGVZO1xuXG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHRpdGxlWCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCBsZWZ0LCByaWdodCk7XG4gICAgICB0aXRsZVkgPSB0b3AgKyBvZmZzZXQ7XG4gICAgICBtYXhXaWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG9wdGlvbnMucG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICB0aXRsZVggPSBsZWZ0ICsgb2Zmc2V0O1xuICAgICAgICB0aXRsZVkgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgYm90dG9tLCB0b3ApO1xuICAgICAgICByb3RhdGlvbiA9IFBJICogLTAuNTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpdGxlWCA9IHJpZ2h0IC0gb2Zmc2V0O1xuICAgICAgICB0aXRsZVkgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdG9wLCBib3R0b20pO1xuICAgICAgICByb3RhdGlvbiA9IFBJICogMC41O1xuICAgICAgfVxuICAgICAgbWF4V2lkdGggPSBib3R0b20gLSB0b3A7XG4gICAgfVxuICAgIHJldHVybiB7dGl0bGVYLCB0aXRsZVksIG1heFdpZHRoLCByb3RhdGlvbn07XG4gIH1cblxuICBkcmF3KCkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBpZiAoIW9wdHMuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGZvbnRPcHRzID0gdG9Gb250KG9wdHMuZm9udCk7XG4gICAgY29uc3QgbGluZUhlaWdodCA9IGZvbnRPcHRzLmxpbmVIZWlnaHQ7XG4gICAgY29uc3Qgb2Zmc2V0ID0gbGluZUhlaWdodCAvIDIgKyB0aGlzLl9wYWRkaW5nLnRvcDtcbiAgICBjb25zdCB7dGl0bGVYLCB0aXRsZVksIG1heFdpZHRoLCByb3RhdGlvbn0gPSB0aGlzLl9kcmF3QXJncyhvZmZzZXQpO1xuXG4gICAgcmVuZGVyVGV4dChjdHgsIG9wdHMudGV4dCwgMCwgMCwgZm9udE9wdHMsIHtcbiAgICAgIGNvbG9yOiBvcHRzLmNvbG9yLFxuICAgICAgbWF4V2lkdGgsXG4gICAgICByb3RhdGlvbixcbiAgICAgIHRleHRBbGlnbjogX3RvTGVmdFJpZ2h0Q2VudGVyKG9wdHMuYWxpZ24pLFxuICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJyxcbiAgICAgIHRyYW5zbGF0aW9uOiBbdGl0bGVYLCB0aXRsZVldLFxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRpdGxlKGNoYXJ0LCB0aXRsZU9wdHMpIHtcbiAgY29uc3QgdGl0bGUgPSBuZXcgVGl0bGUoe1xuICAgIGN0eDogY2hhcnQuY3R4LFxuICAgIG9wdGlvbnM6IHRpdGxlT3B0cyxcbiAgICBjaGFydFxuICB9KTtcblxuICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgdGl0bGUsIHRpdGxlT3B0cyk7XG4gIGxheW91dHMuYWRkQm94KGNoYXJ0LCB0aXRsZSk7XG4gIGNoYXJ0LnRpdGxlQmxvY2sgPSB0aXRsZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpZDogJ3RpdGxlJyxcblxuICAvKipcblx0ICogRm9yIHRlc3RzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZWxlbWVudDogVGl0bGUsXG5cbiAgc3RhcnQoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY3JlYXRlVGl0bGUoY2hhcnQsIG9wdGlvbnMpO1xuICB9LFxuXG4gIHN0b3AoY2hhcnQpIHtcbiAgICBjb25zdCB0aXRsZUJsb2NrID0gY2hhcnQudGl0bGVCbG9jaztcbiAgICBsYXlvdXRzLnJlbW92ZUJveChjaGFydCwgdGl0bGVCbG9jayk7XG4gICAgZGVsZXRlIGNoYXJ0LnRpdGxlQmxvY2s7XG4gIH0sXG5cbiAgYmVmb3JlVXBkYXRlKGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IHRpdGxlID0gY2hhcnQudGl0bGVCbG9jaztcbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgdGl0bGUsIG9wdGlvbnMpO1xuICAgIHRpdGxlLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9LFxuXG4gIGRlZmF1bHRzOiB7XG4gICAgYWxpZ246ICdjZW50ZXInLFxuICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgIGZvbnQ6IHtcbiAgICAgIHdlaWdodDogJ2JvbGQnLFxuICAgIH0sXG4gICAgZnVsbFNpemU6IHRydWUsXG4gICAgcGFkZGluZzogMTAsXG4gICAgcG9zaXRpb246ICd0b3AnLFxuICAgIHRleHQ6ICcnLFxuICAgIHdlaWdodDogMjAwMCAgICAgICAgIC8vIGJ5IGRlZmF1bHQgZ3JlYXRlciB0aGFuIGxlZ2VuZCAoMTAwMCkgdG8gYmUgYWJvdmVcbiAgfSxcblxuICBkZWZhdWx0Um91dGVzOiB7XG4gICAgY29sb3I6ICdjb2xvcidcbiAgfSxcblxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiB0cnVlLFxuICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICB9LFxufTtcbiIsImltcG9ydCB7VGl0bGV9IGZyb20gJy4vcGx1Z2luLnRpdGxlLmpzJztcbmltcG9ydCBsYXlvdXRzIGZyb20gJy4uL2NvcmUvY29yZS5sYXlvdXRzLmpzJztcblxuY29uc3QgbWFwID0gbmV3IFdlYWtNYXAoKTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBpZDogJ3N1YnRpdGxlJyxcblxuICBzdGFydChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0aXRsZSA9IG5ldyBUaXRsZSh7XG4gICAgICBjdHg6IGNoYXJ0LmN0eCxcbiAgICAgIG9wdGlvbnMsXG4gICAgICBjaGFydFxuICAgIH0pO1xuXG4gICAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIHRpdGxlLCBvcHRpb25zKTtcbiAgICBsYXlvdXRzLmFkZEJveChjaGFydCwgdGl0bGUpO1xuICAgIG1hcC5zZXQoY2hhcnQsIHRpdGxlKTtcbiAgfSxcblxuICBzdG9wKGNoYXJ0KSB7XG4gICAgbGF5b3V0cy5yZW1vdmVCb3goY2hhcnQsIG1hcC5nZXQoY2hhcnQpKTtcbiAgICBtYXAuZGVsZXRlKGNoYXJ0KTtcbiAgfSxcblxuICBiZWZvcmVVcGRhdGUoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdGl0bGUgPSBtYXAuZ2V0KGNoYXJ0KTtcbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgdGl0bGUsIG9wdGlvbnMpO1xuICAgIHRpdGxlLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9LFxuXG4gIGRlZmF1bHRzOiB7XG4gICAgYWxpZ246ICdjZW50ZXInLFxuICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgIGZvbnQ6IHtcbiAgICAgIHdlaWdodDogJ25vcm1hbCcsXG4gICAgfSxcbiAgICBmdWxsU2l6ZTogdHJ1ZSxcbiAgICBwYWRkaW5nOiAwLFxuICAgIHBvc2l0aW9uOiAndG9wJyxcbiAgICB0ZXh0OiAnJyxcbiAgICB3ZWlnaHQ6IDE1MDAgICAgICAgICAvLyBieSBkZWZhdWx0IGdyZWF0ZXIgdGhhbiBsZWdlbmQgKDEwMDApIGFuZCBzbWFsbGVyIHRoYW4gdGl0bGUgKDIwMDApXG4gIH0sXG5cbiAgZGVmYXVsdFJvdXRlczoge1xuICAgIGNvbG9yOiAnY29sb3InXG4gIH0sXG5cbiAgZGVzY3JpcHRvcnM6IHtcbiAgICBfc2NyaXB0YWJsZTogdHJ1ZSxcbiAgICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgfSxcbn07XG4iLCJpbXBvcnQgQW5pbWF0aW9ucyBmcm9tICcuLi9jb3JlL2NvcmUuYW5pbWF0aW9ucy5qcyc7XG5pbXBvcnQgRWxlbWVudCBmcm9tICcuLi9jb3JlL2NvcmUuZWxlbWVudC5qcyc7XG5pbXBvcnQge2FkZFJvdW5kZWRSZWN0UGF0aH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNhbnZhcy5qcyc7XG5pbXBvcnQge2VhY2gsIG5vb3AsIGlzTnVsbE9yVW5kZWYsIGlzQXJyYXksIF9lbGVtZW50c0VxdWFsLCBpc09iamVjdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHt0b0ZvbnQsIHRvUGFkZGluZywgdG9UUkJMQ29ybmVyc30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm9wdGlvbnMuanMnO1xuaW1wb3J0IHtnZXRSdGxBZGFwdGVyLCBvdmVycmlkZVRleHREaXJlY3Rpb24sIHJlc3RvcmVUZXh0RGlyZWN0aW9ufSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMucnRsLmpzJztcbmltcG9ydCB7ZGlzdGFuY2VCZXR3ZWVuUG9pbnRzLCBfbGltaXRWYWx1ZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IHtjcmVhdGVDb250ZXh0LCBkcmF3UG9pbnR9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9wbGF0Zm9ybS9wbGF0Zm9ybS5iYXNlLmpzJykuQ2hhcnQgfSBDaGFydFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuQ2hhcnRFdmVudCB9IENoYXJ0RXZlbnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi90eXBlcy9pbmRleC5qcycpLkFjdGl2ZUVsZW1lbnQgfSBBY3RpdmVFbGVtZW50XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vY29yZS9jb3JlLmludGVyYWN0aW9uLmpzJykuSW50ZXJhY3Rpb25JdGVtIH0gSW50ZXJhY3Rpb25JdGVtXG4gKi9cblxuY29uc3QgcG9zaXRpb25lcnMgPSB7XG4gIC8qKlxuXHQgKiBBdmVyYWdlIG1vZGUgcGxhY2VzIHRoZSB0b29sdGlwIGF0IHRoZSBhdmVyYWdlIHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50cyBzaG93blxuXHQgKi9cbiAgYXZlcmFnZShpdGVtcykge1xuICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IGksIGxlbjtcbiAgICBsZXQgeFNldCA9IG5ldyBTZXQoKTtcbiAgICBsZXQgeSA9IDA7XG4gICAgbGV0IGNvdW50ID0gMDtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjb25zdCBlbCA9IGl0ZW1zW2ldLmVsZW1lbnQ7XG4gICAgICBpZiAoZWwgJiYgZWwuaGFzVmFsdWUoKSkge1xuICAgICAgICBjb25zdCBwb3MgPSBlbC50b29sdGlwUG9zaXRpb24oKTtcbiAgICAgICAgeFNldC5hZGQocG9zLngpO1xuICAgICAgICB5ICs9IHBvcy55O1xuICAgICAgICArK2NvdW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5vIHZpc2libGUgaXRlbXMgd2hlcmUgZm91bmQsIHJldHVybiBmYWxzZSBzbyB3ZSBkb24ndCBoYXZlIHRvIGRpdmlkZSBieSAwIHdoaWNoIHJlZHVjZXMgaW4gTmFOXG4gICAgaWYgKGNvdW50ID09PSAwIHx8IHhTZXQuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHhBdmVyYWdlID0gWy4uLnhTZXRdLnJlZHVjZSgoYSwgYikgPT4gYSArIGIpIC8geFNldC5zaXplO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHhBdmVyYWdlLFxuICAgICAgeTogeSAvIGNvdW50XG4gICAgfTtcbiAgfSxcblxuICAvKipcblx0ICogR2V0cyB0aGUgdG9vbHRpcCBwb3NpdGlvbiBuZWFyZXN0IG9mIHRoZSBpdGVtIG5lYXJlc3QgdG8gdGhlIGV2ZW50IHBvc2l0aW9uXG5cdCAqL1xuICBuZWFyZXN0KGl0ZW1zLCBldmVudFBvc2l0aW9uKSB7XG4gICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgeCA9IGV2ZW50UG9zaXRpb24ueDtcbiAgICBsZXQgeSA9IGV2ZW50UG9zaXRpb24ueTtcbiAgICBsZXQgbWluRGlzdGFuY2UgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgbGV0IGksIGxlbiwgbmVhcmVzdEVsZW1lbnQ7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgY29uc3QgZWwgPSBpdGVtc1tpXS5lbGVtZW50O1xuICAgICAgaWYgKGVsICYmIGVsLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgY29uc3QgY2VudGVyID0gZWwuZ2V0Q2VudGVyUG9pbnQoKTtcbiAgICAgICAgY29uc3QgZCA9IGRpc3RhbmNlQmV0d2VlblBvaW50cyhldmVudFBvc2l0aW9uLCBjZW50ZXIpO1xuXG4gICAgICAgIGlmIChkIDwgbWluRGlzdGFuY2UpIHtcbiAgICAgICAgICBtaW5EaXN0YW5jZSA9IGQ7XG4gICAgICAgICAgbmVhcmVzdEVsZW1lbnQgPSBlbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChuZWFyZXN0RWxlbWVudCkge1xuICAgICAgY29uc3QgdHAgPSBuZWFyZXN0RWxlbWVudC50b29sdGlwUG9zaXRpb24oKTtcbiAgICAgIHggPSB0cC54O1xuICAgICAgeSA9IHRwLnk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfTtcbiAgfVxufTtcblxuLy8gSGVscGVyIHRvIHB1c2ggb3IgY29uY2F0IGJhc2VkIG9uIGlmIHRoZSAybmQgcGFyYW1ldGVyIGlzIGFuIGFycmF5IG9yIG5vdFxuZnVuY3Rpb24gcHVzaE9yQ29uY2F0KGJhc2UsIHRvUHVzaCkge1xuICBpZiAodG9QdXNoKSB7XG4gICAgaWYgKGlzQXJyYXkodG9QdXNoKSkge1xuICAgICAgLy8gYmFzZSA9IGJhc2UuY29uY2F0KHRvUHVzaCk7XG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShiYXNlLCB0b1B1c2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlLnB1c2godG9QdXNoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYmFzZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFycmF5IG9mIHN0cmluZ3Mgc3BsaXQgYnkgbmV3bGluZVxuICogQHBhcmFtIHsqfSBzdHIgLSBUaGUgdmFsdWUgdG8gc3BsaXQgYnkgbmV3bGluZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd8c3RyaW5nW119IHZhbHVlIGlmIG5ld2xpbmUgcHJlc2VudCAtIFJldHVybmVkIGZyb20gU3RyaW5nIHNwbGl0KCkgbWV0aG9kXG4gKiBAZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gc3BsaXROZXdsaW5lcyhzdHIpIHtcbiAgaWYgKCh0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyB8fCBzdHIgaW5zdGFuY2VvZiBTdHJpbmcpICYmIHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgcmV0dXJuIHN0ci5zcGxpdCgnXFxuJyk7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cblxuXG4vKipcbiAqIFByaXZhdGUgaGVscGVyIHRvIGNyZWF0ZSBhIHRvb2x0aXAgaXRlbSBtb2RlbFxuICogQHBhcmFtIHtDaGFydH0gY2hhcnRcbiAqIEBwYXJhbSB7QWN0aXZlRWxlbWVudH0gaXRlbSAtIHtlbGVtZW50LCBpbmRleCwgZGF0YXNldEluZGV4fSB0byBjcmVhdGUgdGhlIHRvb2x0aXAgaXRlbSBmb3JcbiAqIEByZXR1cm4gbmV3IHRvb2x0aXAgaXRlbVxuICovXG5mdW5jdGlvbiBjcmVhdGVUb29sdGlwSXRlbShjaGFydCwgaXRlbSkge1xuICBjb25zdCB7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH0gPSBpdGVtO1xuICBjb25zdCBjb250cm9sbGVyID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5jb250cm9sbGVyO1xuICBjb25zdCB7bGFiZWwsIHZhbHVlfSA9IGNvbnRyb2xsZXIuZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCk7XG5cbiAgcmV0dXJuIHtcbiAgICBjaGFydCxcbiAgICBsYWJlbCxcbiAgICBwYXJzZWQ6IGNvbnRyb2xsZXIuZ2V0UGFyc2VkKGluZGV4KSxcbiAgICByYXc6IGNoYXJ0LmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XS5kYXRhW2luZGV4XSxcbiAgICBmb3JtYXR0ZWRWYWx1ZTogdmFsdWUsXG4gICAgZGF0YXNldDogY29udHJvbGxlci5nZXREYXRhc2V0KCksXG4gICAgZGF0YUluZGV4OiBpbmRleCxcbiAgICBkYXRhc2V0SW5kZXgsXG4gICAgZWxlbWVudFxuICB9O1xufVxuXG4vKipcbiAqIEdldCB0aGUgc2l6ZSBvZiB0aGUgdG9vbHRpcFxuICovXG5mdW5jdGlvbiBnZXRUb29sdGlwU2l6ZSh0b29sdGlwLCBvcHRpb25zKSB7XG4gIGNvbnN0IGN0eCA9IHRvb2x0aXAuY2hhcnQuY3R4O1xuICBjb25zdCB7Ym9keSwgZm9vdGVyLCB0aXRsZX0gPSB0b29sdGlwO1xuICBjb25zdCB7Ym94V2lkdGgsIGJveEhlaWdodH0gPSBvcHRpb25zO1xuICBjb25zdCBib2R5Rm9udCA9IHRvRm9udChvcHRpb25zLmJvZHlGb250KTtcbiAgY29uc3QgdGl0bGVGb250ID0gdG9Gb250KG9wdGlvbnMudGl0bGVGb250KTtcbiAgY29uc3QgZm9vdGVyRm9udCA9IHRvRm9udChvcHRpb25zLmZvb3RlckZvbnQpO1xuICBjb25zdCB0aXRsZUxpbmVDb3VudCA9IHRpdGxlLmxlbmd0aDtcbiAgY29uc3QgZm9vdGVyTGluZUNvdW50ID0gZm9vdGVyLmxlbmd0aDtcbiAgY29uc3QgYm9keUxpbmVJdGVtQ291bnQgPSBib2R5Lmxlbmd0aDtcblxuICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdGlvbnMucGFkZGluZyk7XG4gIGxldCBoZWlnaHQgPSBwYWRkaW5nLmhlaWdodDtcbiAgbGV0IHdpZHRoID0gMDtcblxuICAvLyBDb3VudCBvZiBhbGwgbGluZXMgaW4gdGhlIGJvZHlcbiAgbGV0IGNvbWJpbmVkQm9keUxlbmd0aCA9IGJvZHkucmVkdWNlKChjb3VudCwgYm9keUl0ZW0pID0+IGNvdW50ICsgYm9keUl0ZW0uYmVmb3JlLmxlbmd0aCArIGJvZHlJdGVtLmxpbmVzLmxlbmd0aCArIGJvZHlJdGVtLmFmdGVyLmxlbmd0aCwgMCk7XG4gIGNvbWJpbmVkQm9keUxlbmd0aCArPSB0b29sdGlwLmJlZm9yZUJvZHkubGVuZ3RoICsgdG9vbHRpcC5hZnRlckJvZHkubGVuZ3RoO1xuXG4gIGlmICh0aXRsZUxpbmVDb3VudCkge1xuICAgIGhlaWdodCArPSB0aXRsZUxpbmVDb3VudCAqIHRpdGxlRm9udC5saW5lSGVpZ2h0XG5cdFx0XHQrICh0aXRsZUxpbmVDb3VudCAtIDEpICogb3B0aW9ucy50aXRsZVNwYWNpbmdcblx0XHRcdCsgb3B0aW9ucy50aXRsZU1hcmdpbkJvdHRvbTtcbiAgfVxuICBpZiAoY29tYmluZWRCb2R5TGVuZ3RoKSB7XG4gICAgLy8gQm9keSBsaW5lcyBtYXkgaW5jbHVkZSBzb21lIGV4dHJhIGhlaWdodCBkZXBlbmRpbmcgb24gYm94SGVpZ2h0XG4gICAgY29uc3QgYm9keUxpbmVIZWlnaHQgPSBvcHRpb25zLmRpc3BsYXlDb2xvcnMgPyBNYXRoLm1heChib3hIZWlnaHQsIGJvZHlGb250LmxpbmVIZWlnaHQpIDogYm9keUZvbnQubGluZUhlaWdodDtcbiAgICBoZWlnaHQgKz0gYm9keUxpbmVJdGVtQ291bnQgKiBib2R5TGluZUhlaWdodFxuXHRcdFx0KyAoY29tYmluZWRCb2R5TGVuZ3RoIC0gYm9keUxpbmVJdGVtQ291bnQpICogYm9keUZvbnQubGluZUhlaWdodFxuXHRcdFx0KyAoY29tYmluZWRCb2R5TGVuZ3RoIC0gMSkgKiBvcHRpb25zLmJvZHlTcGFjaW5nO1xuICB9XG4gIGlmIChmb290ZXJMaW5lQ291bnQpIHtcbiAgICBoZWlnaHQgKz0gb3B0aW9ucy5mb290ZXJNYXJnaW5Ub3Bcblx0XHRcdCsgZm9vdGVyTGluZUNvdW50ICogZm9vdGVyRm9udC5saW5lSGVpZ2h0XG5cdFx0XHQrIChmb290ZXJMaW5lQ291bnQgLSAxKSAqIG9wdGlvbnMuZm9vdGVyU3BhY2luZztcbiAgfVxuXG4gIC8vIFRpdGxlIHdpZHRoXG4gIGxldCB3aWR0aFBhZGRpbmcgPSAwO1xuICBjb25zdCBtYXhMaW5lV2lkdGggPSBmdW5jdGlvbihsaW5lKSB7XG4gICAgd2lkdGggPSBNYXRoLm1heCh3aWR0aCwgY3R4Lm1lYXN1cmVUZXh0KGxpbmUpLndpZHRoICsgd2lkdGhQYWRkaW5nKTtcbiAgfTtcblxuICBjdHguc2F2ZSgpO1xuXG4gIGN0eC5mb250ID0gdGl0bGVGb250LnN0cmluZztcbiAgZWFjaCh0b29sdGlwLnRpdGxlLCBtYXhMaW5lV2lkdGgpO1xuXG4gIC8vIEJvZHkgd2lkdGhcbiAgY3R4LmZvbnQgPSBib2R5Rm9udC5zdHJpbmc7XG4gIGVhY2godG9vbHRpcC5iZWZvcmVCb2R5LmNvbmNhdCh0b29sdGlwLmFmdGVyQm9keSksIG1heExpbmVXaWR0aCk7XG5cbiAgLy8gQm9keSBsaW5lcyBtYXkgaW5jbHVkZSBzb21lIGV4dHJhIHdpZHRoIGR1ZSB0byB0aGUgY29sb3IgYm94XG4gIHdpZHRoUGFkZGluZyA9IG9wdGlvbnMuZGlzcGxheUNvbG9ycyA/IChib3hXaWR0aCArIDIgKyBvcHRpb25zLmJveFBhZGRpbmcpIDogMDtcbiAgZWFjaChib2R5LCAoYm9keUl0ZW0pID0+IHtcbiAgICBlYWNoKGJvZHlJdGVtLmJlZm9yZSwgbWF4TGluZVdpZHRoKTtcbiAgICBlYWNoKGJvZHlJdGVtLmxpbmVzLCBtYXhMaW5lV2lkdGgpO1xuICAgIGVhY2goYm9keUl0ZW0uYWZ0ZXIsIG1heExpbmVXaWR0aCk7XG4gIH0pO1xuXG4gIC8vIFJlc2V0IGJhY2sgdG8gMFxuICB3aWR0aFBhZGRpbmcgPSAwO1xuXG4gIC8vIEZvb3RlciB3aWR0aFxuICBjdHguZm9udCA9IGZvb3RlckZvbnQuc3RyaW5nO1xuICBlYWNoKHRvb2x0aXAuZm9vdGVyLCBtYXhMaW5lV2lkdGgpO1xuXG4gIGN0eC5yZXN0b3JlKCk7XG5cbiAgLy8gQWRkIHBhZGRpbmdcbiAgd2lkdGggKz0gcGFkZGluZy53aWR0aDtcblxuICByZXR1cm4ge3dpZHRoLCBoZWlnaHR9O1xufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmVZQWxpZ24oY2hhcnQsIHNpemUpIHtcbiAgY29uc3Qge3ksIGhlaWdodH0gPSBzaXplO1xuXG4gIGlmICh5IDwgaGVpZ2h0IC8gMikge1xuICAgIHJldHVybiAndG9wJztcbiAgfSBlbHNlIGlmICh5ID4gKGNoYXJ0LmhlaWdodCAtIGhlaWdodCAvIDIpKSB7XG4gICAgcmV0dXJuICdib3R0b20nO1xuICB9XG4gIHJldHVybiAnY2VudGVyJztcbn1cblxuZnVuY3Rpb24gZG9lc05vdEZpdFdpdGhBbGlnbih4QWxpZ24sIGNoYXJ0LCBvcHRpb25zLCBzaXplKSB7XG4gIGNvbnN0IHt4LCB3aWR0aH0gPSBzaXplO1xuICBjb25zdCBjYXJldCA9IG9wdGlvbnMuY2FyZXRTaXplICsgb3B0aW9ucy5jYXJldFBhZGRpbmc7XG4gIGlmICh4QWxpZ24gPT09ICdsZWZ0JyAmJiB4ICsgd2lkdGggKyBjYXJldCA+IGNoYXJ0LndpZHRoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoeEFsaWduID09PSAncmlnaHQnICYmIHggLSB3aWR0aCAtIGNhcmV0IDwgMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRldGVybWluZVhBbGlnbihjaGFydCwgb3B0aW9ucywgc2l6ZSwgeUFsaWduKSB7XG4gIGNvbnN0IHt4LCB3aWR0aH0gPSBzaXplO1xuICBjb25zdCB7d2lkdGg6IGNoYXJ0V2lkdGgsIGNoYXJ0QXJlYToge2xlZnQsIHJpZ2h0fX0gPSBjaGFydDtcbiAgbGV0IHhBbGlnbiA9ICdjZW50ZXInO1xuXG4gIGlmICh5QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgeEFsaWduID0geCA8PSAobGVmdCArIHJpZ2h0KSAvIDIgPyAnbGVmdCcgOiAncmlnaHQnO1xuICB9IGVsc2UgaWYgKHggPD0gd2lkdGggLyAyKSB7XG4gICAgeEFsaWduID0gJ2xlZnQnO1xuICB9IGVsc2UgaWYgKHggPj0gY2hhcnRXaWR0aCAtIHdpZHRoIC8gMikge1xuICAgIHhBbGlnbiA9ICdyaWdodCc7XG4gIH1cblxuICBpZiAoZG9lc05vdEZpdFdpdGhBbGlnbih4QWxpZ24sIGNoYXJ0LCBvcHRpb25zLCBzaXplKSkge1xuICAgIHhBbGlnbiA9ICdjZW50ZXInO1xuICB9XG5cbiAgcmV0dXJuIHhBbGlnbjtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IHRoZSBhbGlnbm1lbnQgb2YgYSB0b29sdGlwIGdpdmVuIHRoZSBzaXplXG4gKi9cbmZ1bmN0aW9uIGRldGVybWluZUFsaWdubWVudChjaGFydCwgb3B0aW9ucywgc2l6ZSkge1xuICBjb25zdCB5QWxpZ24gPSBzaXplLnlBbGlnbiB8fCBvcHRpb25zLnlBbGlnbiB8fCBkZXRlcm1pbmVZQWxpZ24oY2hhcnQsIHNpemUpO1xuXG4gIHJldHVybiB7XG4gICAgeEFsaWduOiBzaXplLnhBbGlnbiB8fCBvcHRpb25zLnhBbGlnbiB8fCBkZXRlcm1pbmVYQWxpZ24oY2hhcnQsIG9wdGlvbnMsIHNpemUsIHlBbGlnbiksXG4gICAgeUFsaWduXG4gIH07XG59XG5cbmZ1bmN0aW9uIGFsaWduWChzaXplLCB4QWxpZ24pIHtcbiAgbGV0IHt4LCB3aWR0aH0gPSBzaXplO1xuICBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgeCAtPSB3aWR0aDtcbiAgfSBlbHNlIGlmICh4QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgeCAtPSAod2lkdGggLyAyKTtcbiAgfVxuICByZXR1cm4geDtcbn1cblxuZnVuY3Rpb24gYWxpZ25ZKHNpemUsIHlBbGlnbiwgcGFkZGluZ0FuZFNpemUpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICBsZXQge3ksIGhlaWdodH0gPSBzaXplO1xuICBpZiAoeUFsaWduID09PSAndG9wJykge1xuICAgIHkgKz0gcGFkZGluZ0FuZFNpemU7XG4gIH0gZWxzZSBpZiAoeUFsaWduID09PSAnYm90dG9tJykge1xuICAgIHkgLT0gaGVpZ2h0ICsgcGFkZGluZ0FuZFNpemU7XG4gIH0gZWxzZSB7XG4gICAgeSAtPSAoaGVpZ2h0IC8gMik7XG4gIH1cbiAgcmV0dXJuIHk7XG59XG5cbi8qKlxuICogSGVscGVyIHRvIGdldCB0aGUgbG9jYXRpb24gYSB0b29sdGlwIG5lZWRzIHRvIGJlIHBsYWNlZCBhdCBnaXZlbiB0aGUgaW5pdGlhbCBwb3NpdGlvbiAodmlhIHRoZSB2bSkgYW5kIHRoZSBzaXplIGFuZCBhbGlnbm1lbnRcbiAqL1xuZnVuY3Rpb24gZ2V0QmFja2dyb3VuZFBvaW50KG9wdGlvbnMsIHNpemUsIGFsaWdubWVudCwgY2hhcnQpIHtcbiAgY29uc3Qge2NhcmV0U2l6ZSwgY2FyZXRQYWRkaW5nLCBjb3JuZXJSYWRpdXN9ID0gb3B0aW9ucztcbiAgY29uc3Qge3hBbGlnbiwgeUFsaWdufSA9IGFsaWdubWVudDtcbiAgY29uc3QgcGFkZGluZ0FuZFNpemUgPSBjYXJldFNpemUgKyBjYXJldFBhZGRpbmc7XG4gIGNvbnN0IHt0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCwgYm90dG9tUmlnaHR9ID0gdG9UUkJMQ29ybmVycyhjb3JuZXJSYWRpdXMpO1xuXG4gIGxldCB4ID0gYWxpZ25YKHNpemUsIHhBbGlnbik7XG4gIGNvbnN0IHkgPSBhbGlnblkoc2l6ZSwgeUFsaWduLCBwYWRkaW5nQW5kU2l6ZSk7XG5cbiAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICBpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgIHggKz0gcGFkZGluZ0FuZFNpemU7XG4gICAgfSBlbHNlIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgIHggLT0gcGFkZGluZ0FuZFNpemU7XG4gICAgfVxuICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgeCAtPSBNYXRoLm1heCh0b3BMZWZ0LCBib3R0b21MZWZ0KSArIGNhcmV0U2l6ZTtcbiAgfSBlbHNlIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICB4ICs9IE1hdGgubWF4KHRvcFJpZ2h0LCBib3R0b21SaWdodCkgKyBjYXJldFNpemU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IF9saW1pdFZhbHVlKHgsIDAsIGNoYXJ0LndpZHRoIC0gc2l6ZS53aWR0aCksXG4gICAgeTogX2xpbWl0VmFsdWUoeSwgMCwgY2hhcnQuaGVpZ2h0IC0gc2l6ZS5oZWlnaHQpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEFsaWduZWRYKHRvb2x0aXAsIGFsaWduLCBvcHRpb25zKSB7XG4gIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcblxuICByZXR1cm4gYWxpZ24gPT09ICdjZW50ZXInXG4gICAgPyB0b29sdGlwLnggKyB0b29sdGlwLndpZHRoIC8gMlxuICAgIDogYWxpZ24gPT09ICdyaWdodCdcbiAgICAgID8gdG9vbHRpcC54ICsgdG9vbHRpcC53aWR0aCAtIHBhZGRpbmcucmlnaHRcbiAgICAgIDogdG9vbHRpcC54ICsgcGFkZGluZy5sZWZ0O1xufVxuXG4vKipcbiAqIEhlbHBlciB0byBidWlsZCBiZWZvcmUgYW5kIGFmdGVyIGJvZHkgbGluZXNcbiAqL1xuZnVuY3Rpb24gZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXMoY2FsbGJhY2spIHtcbiAgcmV0dXJuIHB1c2hPckNvbmNhdChbXSwgc3BsaXROZXdsaW5lcyhjYWxsYmFjaykpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUb29sdGlwQ29udGV4dChwYXJlbnQsIHRvb2x0aXAsIHRvb2x0aXBJdGVtcykge1xuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsIHtcbiAgICB0b29sdGlwLFxuICAgIHRvb2x0aXBJdGVtcyxcbiAgICB0eXBlOiAndG9vbHRpcCdcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG92ZXJyaWRlQ2FsbGJhY2tzKGNhbGxiYWNrcywgY29udGV4dCkge1xuICBjb25zdCBvdmVycmlkZSA9IGNvbnRleHQgJiYgY29udGV4dC5kYXRhc2V0ICYmIGNvbnRleHQuZGF0YXNldC50b29sdGlwICYmIGNvbnRleHQuZGF0YXNldC50b29sdGlwLmNhbGxiYWNrcztcbiAgcmV0dXJuIG92ZXJyaWRlID8gY2FsbGJhY2tzLm92ZXJyaWRlKG92ZXJyaWRlKSA6IGNhbGxiYWNrcztcbn1cblxuY29uc3QgZGVmYXVsdENhbGxiYWNrcyA9IHtcbiAgLy8gQXJncyBhcmU6ICh0b29sdGlwSXRlbXMsIGRhdGEpXG4gIGJlZm9yZVRpdGxlOiBub29wLFxuICB0aXRsZSh0b29sdGlwSXRlbXMpIHtcbiAgICBpZiAodG9vbHRpcEl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSB0b29sdGlwSXRlbXNbMF07XG4gICAgICBjb25zdCBsYWJlbHMgPSBpdGVtLmNoYXJ0LmRhdGEubGFiZWxzO1xuICAgICAgY29uc3QgbGFiZWxDb3VudCA9IGxhYmVscyA/IGxhYmVscy5sZW5ndGggOiAwO1xuXG4gICAgICBpZiAodGhpcyAmJiB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLm1vZGUgPT09ICdkYXRhc2V0Jykge1xuICAgICAgICByZXR1cm4gaXRlbS5kYXRhc2V0LmxhYmVsIHx8ICcnO1xuICAgICAgfSBlbHNlIGlmIChpdGVtLmxhYmVsKSB7XG4gICAgICAgIHJldHVybiBpdGVtLmxhYmVsO1xuICAgICAgfSBlbHNlIGlmIChsYWJlbENvdW50ID4gMCAmJiBpdGVtLmRhdGFJbmRleCA8IGxhYmVsQ291bnQpIHtcbiAgICAgICAgcmV0dXJuIGxhYmVsc1tpdGVtLmRhdGFJbmRleF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9LFxuICBhZnRlclRpdGxlOiBub29wLFxuXG4gIC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW1zLCBkYXRhKVxuICBiZWZvcmVCb2R5OiBub29wLFxuXG4gIC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW0sIGRhdGEpXG4gIGJlZm9yZUxhYmVsOiBub29wLFxuICBsYWJlbCh0b29sdGlwSXRlbSkge1xuICAgIGlmICh0aGlzICYmIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMubW9kZSA9PT0gJ2RhdGFzZXQnKSB7XG4gICAgICByZXR1cm4gdG9vbHRpcEl0ZW0ubGFiZWwgKyAnOiAnICsgdG9vbHRpcEl0ZW0uZm9ybWF0dGVkVmFsdWUgfHwgdG9vbHRpcEl0ZW0uZm9ybWF0dGVkVmFsdWU7XG4gICAgfVxuXG4gICAgbGV0IGxhYmVsID0gdG9vbHRpcEl0ZW0uZGF0YXNldC5sYWJlbCB8fCAnJztcblxuICAgIGlmIChsYWJlbCkge1xuICAgICAgbGFiZWwgKz0gJzogJztcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSB0b29sdGlwSXRlbS5mb3JtYXR0ZWRWYWx1ZTtcbiAgICBpZiAoIWlzTnVsbE9yVW5kZWYodmFsdWUpKSB7XG4gICAgICBsYWJlbCArPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGxhYmVsO1xuICB9LFxuICBsYWJlbENvbG9yKHRvb2x0aXBJdGVtKSB7XG4gICAgY29uc3QgbWV0YSA9IHRvb2x0aXBJdGVtLmNoYXJ0LmdldERhdGFzZXRNZXRhKHRvb2x0aXBJdGVtLmRhdGFzZXRJbmRleCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZSh0b29sdGlwSXRlbS5kYXRhSW5kZXgpO1xuICAgIHJldHVybiB7XG4gICAgICBib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvcixcbiAgICAgIGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICBib3JkZXJXaWR0aDogb3B0aW9ucy5ib3JkZXJXaWR0aCxcbiAgICAgIGJvcmRlckRhc2g6IG9wdGlvbnMuYm9yZGVyRGFzaCxcbiAgICAgIGJvcmRlckRhc2hPZmZzZXQ6IG9wdGlvbnMuYm9yZGVyRGFzaE9mZnNldCxcbiAgICAgIGJvcmRlclJhZGl1czogMCxcbiAgICB9O1xuICB9LFxuICBsYWJlbFRleHRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmJvZHlDb2xvcjtcbiAgfSxcbiAgbGFiZWxQb2ludFN0eWxlKHRvb2x0aXBJdGVtKSB7XG4gICAgY29uc3QgbWV0YSA9IHRvb2x0aXBJdGVtLmNoYXJ0LmdldERhdGFzZXRNZXRhKHRvb2x0aXBJdGVtLmRhdGFzZXRJbmRleCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZSh0b29sdGlwSXRlbS5kYXRhSW5kZXgpO1xuICAgIHJldHVybiB7XG4gICAgICBwb2ludFN0eWxlOiBvcHRpb25zLnBvaW50U3R5bGUsXG4gICAgICByb3RhdGlvbjogb3B0aW9ucy5yb3RhdGlvbixcbiAgICB9O1xuICB9LFxuICBhZnRlckxhYmVsOiBub29wLFxuXG4gIC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW1zLCBkYXRhKVxuICBhZnRlckJvZHk6IG5vb3AsXG5cbiAgLy8gQXJncyBhcmU6ICh0b29sdGlwSXRlbXMsIGRhdGEpXG4gIGJlZm9yZUZvb3Rlcjogbm9vcCxcbiAgZm9vdGVyOiBub29wLFxuICBhZnRlckZvb3Rlcjogbm9vcFxufTtcblxuLyoqXG4gKiBJbnZva2UgY2FsbGJhY2sgZnJvbSBvYmplY3Qgd2l0aCBjb250ZXh0IGFuZCBhcmd1bWVudHMuXG4gKiBJZiBjYWxsYmFjayByZXR1cm5zIGB1bmRlZmluZWRgLCB0aGVuIHdpbGwgYmUgaW52b2tlZCBkZWZhdWx0IGNhbGxiYWNrLlxuICogQHBhcmFtIHtSZWNvcmQ8a2V5b2YgdHlwZW9mIGRlZmF1bHRDYWxsYmFja3MsIEZ1bmN0aW9uPn0gY2FsbGJhY2tzXG4gKiBAcGFyYW0ge2tleW9mIHR5cGVvZiBkZWZhdWx0Q2FsbGJhY2tzfSBuYW1lXG4gKiBAcGFyYW0geyp9IGN0eFxuICogQHBhcmFtIHsqfSBhcmdcbiAqIEByZXR1cm5zIHthbnl9XG4gKi9cbmZ1bmN0aW9uIGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKGNhbGxiYWNrcywgbmFtZSwgY3R4LCBhcmcpIHtcbiAgY29uc3QgcmVzdWx0ID0gY2FsbGJhY2tzW25hbWVdLmNhbGwoY3R4LCBhcmcpO1xuXG4gIGlmICh0eXBlb2YgcmVzdWx0ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBkZWZhdWx0Q2FsbGJhY2tzW25hbWVdLmNhbGwoY3R4LCBhcmcpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGNsYXNzIFRvb2x0aXAgZXh0ZW5kcyBFbGVtZW50IHtcblxuICAvKipcbiAgICogQG5hbWVzcGFjZSBDaGFydC5Ub29sdGlwLnBvc2l0aW9uZXJzXG4gICAqL1xuICBzdGF0aWMgcG9zaXRpb25lcnMgPSBwb3NpdGlvbmVycztcblxuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5vcGFjaXR5ID0gMDtcbiAgICB0aGlzLl9hY3RpdmUgPSBbXTtcbiAgICB0aGlzLl9ldmVudFBvc2l0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NpemUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fY2FjaGVkQW5pbWF0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl90b29sdGlwSXRlbXMgPSBbXTtcbiAgICB0aGlzLiRhbmltYXRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jaGFydCA9IGNvbmZpZy5jaGFydDtcbiAgICB0aGlzLm9wdGlvbnMgPSBjb25maWcub3B0aW9ucztcbiAgICB0aGlzLmRhdGFQb2ludHMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50aXRsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJlZm9yZUJvZHkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib2R5ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYWZ0ZXJCb2R5ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZm9vdGVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueEFsaWduID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueUFsaWduID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNhcmV0WCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNhcmV0WSA9IHVuZGVmaW5lZDtcbiAgICAvLyBUT0RPOiBWNCwgbWFrZSB0aGlzIHByaXZhdGUsIHJlbmFtZSB0byBgX2xhYmVsU3R5bGVzYCwgYW5kIGNvbWJpbmUgd2l0aCBgbGFiZWxQb2ludFN0eWxlc2BcbiAgICAvLyBhbmQgYGxhYmVsVGV4dENvbG9yc2AgdG8gY3JlYXRlIGEgc2luZ2xlIHZhcmlhYmxlXG4gICAgdGhpcy5sYWJlbENvbG9ycyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxhYmVsUG9pbnRTdHlsZXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sYWJlbFRleHRDb2xvcnMgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpbml0aWFsaXplKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuX2NhY2hlZEFuaW1hdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3Jlc29sdmVBbmltYXRpb25zKCkge1xuICAgIGNvbnN0IGNhY2hlZCA9IHRoaXMuX2NhY2hlZEFuaW1hdGlvbnM7XG5cbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH1cblxuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNvbnN0IG9wdHMgPSBvcHRpb25zLmVuYWJsZWQgJiYgY2hhcnQub3B0aW9ucy5hbmltYXRpb24gJiYgb3B0aW9ucy5hbmltYXRpb25zO1xuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBuZXcgQW5pbWF0aW9ucyh0aGlzLmNoYXJ0LCBvcHRzKTtcbiAgICBpZiAob3B0cy5fY2FjaGVhYmxlKSB7XG4gICAgICB0aGlzLl9jYWNoZWRBbmltYXRpb25zID0gT2JqZWN0LmZyZWV6ZShhbmltYXRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRDb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLiRjb250ZXh0IHx8XG5cdFx0XHQodGhpcy4kY29udGV4dCA9IGNyZWF0ZVRvb2x0aXBDb250ZXh0KHRoaXMuY2hhcnQuZ2V0Q29udGV4dCgpLCB0aGlzLCB0aGlzLl90b29sdGlwSXRlbXMpKTtcbiAgfVxuXG4gIGdldFRpdGxlKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7Y2FsbGJhY2tzfSA9IG9wdGlvbnM7XG5cbiAgICBjb25zdCBiZWZvcmVUaXRsZSA9IGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKGNhbGxiYWNrcywgJ2JlZm9yZVRpdGxlJywgdGhpcywgY29udGV4dCk7XG4gICAgY29uc3QgdGl0bGUgPSBpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhjYWxsYmFja3MsICd0aXRsZScsIHRoaXMsIGNvbnRleHQpO1xuICAgIGNvbnN0IGFmdGVyVGl0bGUgPSBpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhjYWxsYmFja3MsICdhZnRlclRpdGxlJywgdGhpcywgY29udGV4dCk7XG5cbiAgICBsZXQgbGluZXMgPSBbXTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhiZWZvcmVUaXRsZSkpO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKHRpdGxlKSk7XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYWZ0ZXJUaXRsZSkpO1xuXG4gICAgcmV0dXJuIGxpbmVzO1xuICB9XG5cbiAgZ2V0QmVmb3JlQm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXMoXG4gICAgICBpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhvcHRpb25zLmNhbGxiYWNrcywgJ2JlZm9yZUJvZHknLCB0aGlzLCB0b29sdGlwSXRlbXMpXG4gICAgKTtcbiAgfVxuXG4gIGdldEJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge2NhbGxiYWNrc30gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJvZHlJdGVtcyA9IFtdO1xuXG4gICAgZWFjaCh0b29sdGlwSXRlbXMsIChjb250ZXh0KSA9PiB7XG4gICAgICBjb25zdCBib2R5SXRlbSA9IHtcbiAgICAgICAgYmVmb3JlOiBbXSxcbiAgICAgICAgbGluZXM6IFtdLFxuICAgICAgICBhZnRlcjogW11cbiAgICAgIH07XG4gICAgICBjb25zdCBzY29wZWQgPSBvdmVycmlkZUNhbGxiYWNrcyhjYWxsYmFja3MsIGNvbnRleHQpO1xuICAgICAgcHVzaE9yQ29uY2F0KGJvZHlJdGVtLmJlZm9yZSwgc3BsaXROZXdsaW5lcyhpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhzY29wZWQsICdiZWZvcmVMYWJlbCcsIHRoaXMsIGNvbnRleHQpKSk7XG4gICAgICBwdXNoT3JDb25jYXQoYm9keUl0ZW0ubGluZXMsIGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKHNjb3BlZCwgJ2xhYmVsJywgdGhpcywgY29udGV4dCkpO1xuICAgICAgcHVzaE9yQ29uY2F0KGJvZHlJdGVtLmFmdGVyLCBzcGxpdE5ld2xpbmVzKGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKHNjb3BlZCwgJ2FmdGVyTGFiZWwnLCB0aGlzLCBjb250ZXh0KSkpO1xuXG4gICAgICBib2R5SXRlbXMucHVzaChib2R5SXRlbSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYm9keUl0ZW1zO1xuICB9XG5cbiAgZ2V0QWZ0ZXJCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucykge1xuICAgIHJldHVybiBnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyhcbiAgICAgIGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKG9wdGlvbnMuY2FsbGJhY2tzLCAnYWZ0ZXJCb2R5JywgdGhpcywgdG9vbHRpcEl0ZW1zKVxuICAgICk7XG4gIH1cblxuICAvLyBHZXQgdGhlIGZvb3RlciBhbmQgYmVmb3JlRm9vdGVyIGFuZCBhZnRlckZvb3RlciBsaW5lc1xuICBnZXRGb290ZXIodG9vbHRpcEl0ZW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge2NhbGxiYWNrc30gPSBvcHRpb25zO1xuXG4gICAgY29uc3QgYmVmb3JlRm9vdGVyID0gaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soY2FsbGJhY2tzLCAnYmVmb3JlRm9vdGVyJywgdGhpcywgdG9vbHRpcEl0ZW1zKTtcbiAgICBjb25zdCBmb290ZXIgPSBpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhjYWxsYmFja3MsICdmb290ZXInLCB0aGlzLCB0b29sdGlwSXRlbXMpO1xuICAgIGNvbnN0IGFmdGVyRm9vdGVyID0gaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soY2FsbGJhY2tzLCAnYWZ0ZXJGb290ZXInLCB0aGlzLCB0b29sdGlwSXRlbXMpO1xuXG4gICAgbGV0IGxpbmVzID0gW107XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYmVmb3JlRm9vdGVyKSk7XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoZm9vdGVyKSk7XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYWZ0ZXJGb290ZXIpKTtcblxuICAgIHJldHVybiBsaW5lcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2NyZWF0ZUl0ZW1zKG9wdGlvbnMpIHtcbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLl9hY3RpdmU7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuY2hhcnQuZGF0YTtcbiAgICBjb25zdCBsYWJlbENvbG9ycyA9IFtdO1xuICAgIGNvbnN0IGxhYmVsUG9pbnRTdHlsZXMgPSBbXTtcbiAgICBjb25zdCBsYWJlbFRleHRDb2xvcnMgPSBbXTtcbiAgICBsZXQgdG9vbHRpcEl0ZW1zID0gW107XG4gICAgbGV0IGksIGxlbjtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGFjdGl2ZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgdG9vbHRpcEl0ZW1zLnB1c2goY3JlYXRlVG9vbHRpcEl0ZW0odGhpcy5jaGFydCwgYWN0aXZlW2ldKSk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHVzZXIgcHJvdmlkZWQgYSBmaWx0ZXIgZnVuY3Rpb24sIHVzZSBpdCB0byBtb2RpZnkgdGhlIHRvb2x0aXAgaXRlbXNcbiAgICBpZiAob3B0aW9ucy5maWx0ZXIpIHtcbiAgICAgIHRvb2x0aXBJdGVtcyA9IHRvb2x0aXBJdGVtcy5maWx0ZXIoKGVsZW1lbnQsIGluZGV4LCBhcnJheSkgPT4gb3B0aW9ucy5maWx0ZXIoZWxlbWVudCwgaW5kZXgsIGFycmF5LCBkYXRhKSk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHVzZXIgcHJvdmlkZWQgYSBzb3J0aW5nIGZ1bmN0aW9uLCB1c2UgaXQgdG8gbW9kaWZ5IHRoZSB0b29sdGlwIGl0ZW1zXG4gICAgaWYgKG9wdGlvbnMuaXRlbVNvcnQpIHtcbiAgICAgIHRvb2x0aXBJdGVtcyA9IHRvb2x0aXBJdGVtcy5zb3J0KChhLCBiKSA9PiBvcHRpb25zLml0ZW1Tb3J0KGEsIGIsIGRhdGEpKTtcbiAgICB9XG5cbiAgICAvLyBEZXRlcm1pbmUgY29sb3JzIGZvciBib3hlc1xuICAgIGVhY2godG9vbHRpcEl0ZW1zLCAoY29udGV4dCkgPT4ge1xuICAgICAgY29uc3Qgc2NvcGVkID0gb3ZlcnJpZGVDYWxsYmFja3Mob3B0aW9ucy5jYWxsYmFja3MsIGNvbnRleHQpO1xuICAgICAgbGFiZWxDb2xvcnMucHVzaChpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhzY29wZWQsICdsYWJlbENvbG9yJywgdGhpcywgY29udGV4dCkpO1xuICAgICAgbGFiZWxQb2ludFN0eWxlcy5wdXNoKGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKHNjb3BlZCwgJ2xhYmVsUG9pbnRTdHlsZScsIHRoaXMsIGNvbnRleHQpKTtcbiAgICAgIGxhYmVsVGV4dENvbG9ycy5wdXNoKGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKHNjb3BlZCwgJ2xhYmVsVGV4dENvbG9yJywgdGhpcywgY29udGV4dCkpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5sYWJlbENvbG9ycyA9IGxhYmVsQ29sb3JzO1xuICAgIHRoaXMubGFiZWxQb2ludFN0eWxlcyA9IGxhYmVsUG9pbnRTdHlsZXM7XG4gICAgdGhpcy5sYWJlbFRleHRDb2xvcnMgPSBsYWJlbFRleHRDb2xvcnM7XG4gICAgdGhpcy5kYXRhUG9pbnRzID0gdG9vbHRpcEl0ZW1zO1xuICAgIHJldHVybiB0b29sdGlwSXRlbXM7XG4gIH1cblxuICB1cGRhdGUoY2hhbmdlZCwgcmVwbGF5KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLl9hY3RpdmU7XG4gICAgbGV0IHByb3BlcnRpZXM7XG4gICAgbGV0IHRvb2x0aXBJdGVtcyA9IFtdO1xuXG4gICAgaWYgKCFhY3RpdmUubGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5vcGFjaXR5ICE9PSAwKSB7XG4gICAgICAgIHByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uZXJzW29wdGlvbnMucG9zaXRpb25dLmNhbGwodGhpcywgYWN0aXZlLCB0aGlzLl9ldmVudFBvc2l0aW9uKTtcbiAgICAgIHRvb2x0aXBJdGVtcyA9IHRoaXMuX2NyZWF0ZUl0ZW1zKG9wdGlvbnMpO1xuXG4gICAgICB0aGlzLnRpdGxlID0gdGhpcy5nZXRUaXRsZSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5iZWZvcmVCb2R5ID0gdGhpcy5nZXRCZWZvcmVCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucyk7XG4gICAgICB0aGlzLmJvZHkgPSB0aGlzLmdldEJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuYWZ0ZXJCb2R5ID0gdGhpcy5nZXRBZnRlckJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuZm9vdGVyID0gdGhpcy5nZXRGb290ZXIodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcblxuICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuX3NpemUgPSBnZXRUb29sdGlwU2l6ZSh0aGlzLCBvcHRpb25zKTtcbiAgICAgIGNvbnN0IHBvc2l0aW9uQW5kU2l6ZSA9IE9iamVjdC5hc3NpZ24oe30sIHBvc2l0aW9uLCBzaXplKTtcbiAgICAgIGNvbnN0IGFsaWdubWVudCA9IGRldGVybWluZUFsaWdubWVudCh0aGlzLmNoYXJ0LCBvcHRpb25zLCBwb3NpdGlvbkFuZFNpemUpO1xuICAgICAgY29uc3QgYmFja2dyb3VuZFBvaW50ID0gZ2V0QmFja2dyb3VuZFBvaW50KG9wdGlvbnMsIHBvc2l0aW9uQW5kU2l6ZSwgYWxpZ25tZW50LCB0aGlzLmNoYXJ0KTtcblxuICAgICAgdGhpcy54QWxpZ24gPSBhbGlnbm1lbnQueEFsaWduO1xuICAgICAgdGhpcy55QWxpZ24gPSBhbGlnbm1lbnQueUFsaWduO1xuXG4gICAgICBwcm9wZXJ0aWVzID0ge1xuICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICB4OiBiYWNrZ3JvdW5kUG9pbnQueCxcbiAgICAgICAgeTogYmFja2dyb3VuZFBvaW50LnksXG4gICAgICAgIHdpZHRoOiBzaXplLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHNpemUuaGVpZ2h0LFxuICAgICAgICBjYXJldFg6IHBvc2l0aW9uLngsXG4gICAgICAgIGNhcmV0WTogcG9zaXRpb24ueVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLl90b29sdGlwSXRlbXMgPSB0b29sdGlwSXRlbXM7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcblxuICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucygpLnVwZGF0ZSh0aGlzLCBwcm9wZXJ0aWVzKTtcbiAgICB9XG5cbiAgICBpZiAoY2hhbmdlZCAmJiBvcHRpb25zLmV4dGVybmFsKSB7XG4gICAgICBvcHRpb25zLmV4dGVybmFsLmNhbGwodGhpcywge2NoYXJ0OiB0aGlzLmNoYXJ0LCB0b29sdGlwOiB0aGlzLCByZXBsYXl9KTtcbiAgICB9XG4gIH1cblxuICBkcmF3Q2FyZXQodG9vbHRpcFBvaW50LCBjdHgsIHNpemUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjYXJldFBvc2l0aW9uID0gdGhpcy5nZXRDYXJldFBvc2l0aW9uKHRvb2x0aXBQb2ludCwgc2l6ZSwgb3B0aW9ucyk7XG5cbiAgICBjdHgubGluZVRvKGNhcmV0UG9zaXRpb24ueDEsIGNhcmV0UG9zaXRpb24ueTEpO1xuICAgIGN0eC5saW5lVG8oY2FyZXRQb3NpdGlvbi54MiwgY2FyZXRQb3NpdGlvbi55Mik7XG4gICAgY3R4LmxpbmVUbyhjYXJldFBvc2l0aW9uLngzLCBjYXJldFBvc2l0aW9uLnkzKTtcbiAgfVxuXG4gIGdldENhcmV0UG9zaXRpb24odG9vbHRpcFBvaW50LCBzaXplLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge3hBbGlnbiwgeUFsaWdufSA9IHRoaXM7XG4gICAgY29uc3Qge2NhcmV0U2l6ZSwgY29ybmVyUmFkaXVzfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qge3RvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0LCBib3R0b21SaWdodH0gPSB0b1RSQkxDb3JuZXJzKGNvcm5lclJhZGl1cyk7XG4gICAgY29uc3Qge3g6IHB0WCwgeTogcHRZfSA9IHRvb2x0aXBQb2ludDtcbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSBzaXplO1xuICAgIGxldCB4MSwgeDIsIHgzLCB5MSwgeTIsIHkzO1xuXG4gICAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIHkyID0gcHRZICsgKGhlaWdodCAvIDIpO1xuXG4gICAgICBpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgICAgeDEgPSBwdFg7XG4gICAgICAgIHgyID0geDEgLSBjYXJldFNpemU7XG5cbiAgICAgICAgLy8gTGVmdCBkcmF3cyBib3R0b20gLT4gdG9wLCB0aGlzIHkxIGlzIG9uIHRoZSBib3R0b21cbiAgICAgICAgeTEgPSB5MiArIGNhcmV0U2l6ZTtcbiAgICAgICAgeTMgPSB5MiAtIGNhcmV0U2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgxID0gcHRYICsgd2lkdGg7XG4gICAgICAgIHgyID0geDEgKyBjYXJldFNpemU7XG5cbiAgICAgICAgLy8gUmlnaHQgZHJhd3MgdG9wIC0+IGJvdHRvbSwgdGh1cyB5MSBpcyBvbiB0aGUgdG9wXG4gICAgICAgIHkxID0geTIgLSBjYXJldFNpemU7XG4gICAgICAgIHkzID0geTIgKyBjYXJldFNpemU7XG4gICAgICB9XG5cbiAgICAgIHgzID0geDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgICB4MiA9IHB0WCArIE1hdGgubWF4KHRvcExlZnQsIGJvdHRvbUxlZnQpICsgKGNhcmV0U2l6ZSk7XG4gICAgICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICB4MiA9IHB0WCArIHdpZHRoIC0gTWF0aC5tYXgodG9wUmlnaHQsIGJvdHRvbVJpZ2h0KSAtIGNhcmV0U2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgyID0gdGhpcy5jYXJldFg7XG4gICAgICB9XG5cbiAgICAgIGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XG4gICAgICAgIHkxID0gcHRZO1xuICAgICAgICB5MiA9IHkxIC0gY2FyZXRTaXplO1xuXG4gICAgICAgIC8vIFRvcCBkcmF3cyBsZWZ0IC0+IHJpZ2h0LCB0aHVzIHgxIGlzIG9uIHRoZSBsZWZ0XG4gICAgICAgIHgxID0geDIgLSBjYXJldFNpemU7XG4gICAgICAgIHgzID0geDIgKyBjYXJldFNpemU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5MSA9IHB0WSArIGhlaWdodDtcbiAgICAgICAgeTIgPSB5MSArIGNhcmV0U2l6ZTtcblxuICAgICAgICAvLyBCb3R0b20gZHJhd3MgcmlnaHQgLT4gbGVmdCwgdGh1cyB4MSBpcyBvbiB0aGUgcmlnaHRcbiAgICAgICAgeDEgPSB4MiArIGNhcmV0U2l6ZTtcbiAgICAgICAgeDMgPSB4MiAtIGNhcmV0U2l6ZTtcbiAgICAgIH1cbiAgICAgIHkzID0geTE7XG4gICAgfVxuICAgIHJldHVybiB7eDEsIHgyLCB4MywgeTEsIHkyLCB5M307XG4gIH1cblxuICBkcmF3VGl0bGUocHQsIGN0eCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHRpdGxlID0gdGhpcy50aXRsZTtcbiAgICBjb25zdCBsZW5ndGggPSB0aXRsZS5sZW5ndGg7XG4gICAgbGV0IHRpdGxlRm9udCwgdGl0bGVTcGFjaW5nLCBpO1xuXG4gICAgaWYgKGxlbmd0aCkge1xuICAgICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRpb25zLnJ0bCwgdGhpcy54LCB0aGlzLndpZHRoKTtcblxuICAgICAgcHQueCA9IGdldEFsaWduZWRYKHRoaXMsIG9wdGlvbnMudGl0bGVBbGlnbiwgb3B0aW9ucyk7XG5cbiAgICAgIGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKG9wdGlvbnMudGl0bGVBbGlnbik7XG4gICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cbiAgICAgIHRpdGxlRm9udCA9IHRvRm9udChvcHRpb25zLnRpdGxlRm9udCk7XG4gICAgICB0aXRsZVNwYWNpbmcgPSBvcHRpb25zLnRpdGxlU3BhY2luZztcblxuICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMudGl0bGVDb2xvcjtcbiAgICAgIGN0eC5mb250ID0gdGl0bGVGb250LnN0cmluZztcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGN0eC5maWxsVGV4dCh0aXRsZVtpXSwgcnRsSGVscGVyLngocHQueCksIHB0LnkgKyB0aXRsZUZvbnQubGluZUhlaWdodCAvIDIpO1xuICAgICAgICBwdC55ICs9IHRpdGxlRm9udC5saW5lSGVpZ2h0ICsgdGl0bGVTcGFjaW5nOyAvLyBMaW5lIEhlaWdodCBhbmQgc3BhY2luZ1xuXG4gICAgICAgIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgcHQueSArPSBvcHRpb25zLnRpdGxlTWFyZ2luQm90dG9tIC0gdGl0bGVTcGFjaW5nOyAvLyBJZiBMYXN0LCBhZGQgbWFyZ2luLCByZW1vdmUgc3BhY2luZ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZHJhd0NvbG9yQm94KGN0eCwgcHQsIGksIHJ0bEhlbHBlciwgb3B0aW9ucykge1xuICAgIGNvbnN0IGxhYmVsQ29sb3IgPSB0aGlzLmxhYmVsQ29sb3JzW2ldO1xuICAgIGNvbnN0IGxhYmVsUG9pbnRTdHlsZSA9IHRoaXMubGFiZWxQb2ludFN0eWxlc1tpXTtcbiAgICBjb25zdCB7Ym94SGVpZ2h0LCBib3hXaWR0aH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJvZHlGb250ID0gdG9Gb250KG9wdGlvbnMuYm9keUZvbnQpO1xuICAgIGNvbnN0IGNvbG9yWCA9IGdldEFsaWduZWRYKHRoaXMsICdsZWZ0Jywgb3B0aW9ucyk7XG4gICAgY29uc3QgcnRsQ29sb3JYID0gcnRsSGVscGVyLngoY29sb3JYKTtcbiAgICBjb25zdCB5T2ZmU2V0ID0gYm94SGVpZ2h0IDwgYm9keUZvbnQubGluZUhlaWdodCA/IChib2R5Rm9udC5saW5lSGVpZ2h0IC0gYm94SGVpZ2h0KSAvIDIgOiAwO1xuICAgIGNvbnN0IGNvbG9yWSA9IHB0LnkgKyB5T2ZmU2V0O1xuXG4gICAgaWYgKG9wdGlvbnMudXNlUG9pbnRTdHlsZSkge1xuICAgICAgY29uc3QgZHJhd09wdGlvbnMgPSB7XG4gICAgICAgIHJhZGl1czogTWF0aC5taW4oYm94V2lkdGgsIGJveEhlaWdodCkgLyAyLCAvLyBmaXQgdGhlIGNpcmNsZSBpbiB0aGUgYm94XG4gICAgICAgIHBvaW50U3R5bGU6IGxhYmVsUG9pbnRTdHlsZS5wb2ludFN0eWxlLFxuICAgICAgICByb3RhdGlvbjogbGFiZWxQb2ludFN0eWxlLnJvdGF0aW9uLFxuICAgICAgICBib3JkZXJXaWR0aDogMVxuICAgICAgfTtcbiAgICAgIC8vIFJlY2FsY3VsYXRlIHggYW5kIHkgZm9yIGRyYXdQb2ludCgpIGJlY2F1c2UgaXRzIGV4cGVjdGluZ1xuICAgICAgLy8geCBhbmQgeSB0byBiZSBjZW50ZXIgb2YgZmlndXJlIChpbnN0ZWFkIG9mIHRvcCBsZWZ0KVxuICAgICAgY29uc3QgY2VudGVyWCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bENvbG9yWCwgYm94V2lkdGgpICsgYm94V2lkdGggLyAyO1xuICAgICAgY29uc3QgY2VudGVyWSA9IGNvbG9yWSArIGJveEhlaWdodCAvIDI7XG5cbiAgICAgIC8vIEZpbGwgdGhlIHBvaW50IHdpdGggd2hpdGUgc28gdGhhdCBjb2xvdXJzIG1lcmdlIG5pY2VseSBpZiB0aGUgb3BhY2l0eSBpcyA8IDFcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMubXVsdGlLZXlCYWNrZ3JvdW5kO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMubXVsdGlLZXlCYWNrZ3JvdW5kO1xuICAgICAgZHJhd1BvaW50KGN0eCwgZHJhd09wdGlvbnMsIGNlbnRlclgsIGNlbnRlclkpO1xuXG4gICAgICAvLyBEcmF3IHRoZSBwb2ludFxuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gbGFiZWxDb2xvci5ib3JkZXJDb2xvcjtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBsYWJlbENvbG9yLmJhY2tncm91bmRDb2xvcjtcbiAgICAgIGRyYXdQb2ludChjdHgsIGRyYXdPcHRpb25zLCBjZW50ZXJYLCBjZW50ZXJZKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQm9yZGVyXG4gICAgICBjdHgubGluZVdpZHRoID0gaXNPYmplY3QobGFiZWxDb2xvci5ib3JkZXJXaWR0aCkgPyBNYXRoLm1heCguLi5PYmplY3QudmFsdWVzKGxhYmVsQ29sb3IuYm9yZGVyV2lkdGgpKSA6IChsYWJlbENvbG9yLmJvcmRlcldpZHRoIHx8IDEpOyAvLyBUT0RPLCB2NCByZW1vdmUgZmFsbGJhY2tcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGxhYmVsQ29sb3IuYm9yZGVyQ29sb3I7XG4gICAgICBjdHguc2V0TGluZURhc2gobGFiZWxDb2xvci5ib3JkZXJEYXNoIHx8IFtdKTtcbiAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IGxhYmVsQ29sb3IuYm9yZGVyRGFzaE9mZnNldCB8fCAwO1xuXG4gICAgICAvLyBGaWxsIGEgd2hpdGUgcmVjdCBzbyB0aGF0IGNvbG91cnMgbWVyZ2UgbmljZWx5IGlmIHRoZSBvcGFjaXR5IGlzIDwgMVxuICAgICAgY29uc3Qgb3V0ZXJYID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsQ29sb3JYLCBib3hXaWR0aCk7XG4gICAgICBjb25zdCBpbm5lclggPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxIZWxwZXIueFBsdXMocnRsQ29sb3JYLCAxKSwgYm94V2lkdGggLSAyKTtcbiAgICAgIGNvbnN0IGJvcmRlclJhZGl1cyA9IHRvVFJCTENvcm5lcnMobGFiZWxDb2xvci5ib3JkZXJSYWRpdXMpO1xuXG4gICAgICBpZiAoT2JqZWN0LnZhbHVlcyhib3JkZXJSYWRpdXMpLnNvbWUodiA9PiB2ICE9PSAwKSkge1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLm11bHRpS2V5QmFja2dyb3VuZDtcbiAgICAgICAgYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwge1xuICAgICAgICAgIHg6IG91dGVyWCxcbiAgICAgICAgICB5OiBjb2xvclksXG4gICAgICAgICAgdzogYm94V2lkdGgsXG4gICAgICAgICAgaDogYm94SGVpZ2h0LFxuICAgICAgICAgIHJhZGl1czogYm9yZGVyUmFkaXVzLFxuICAgICAgICB9KTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgICAgIC8vIElubmVyIHNxdWFyZVxuICAgICAgICBjdHguZmlsbFN0eWxlID0gbGFiZWxDb2xvci5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwge1xuICAgICAgICAgIHg6IGlubmVyWCxcbiAgICAgICAgICB5OiBjb2xvclkgKyAxLFxuICAgICAgICAgIHc6IGJveFdpZHRoIC0gMixcbiAgICAgICAgICBoOiBib3hIZWlnaHQgLSAyLFxuICAgICAgICAgIHJhZGl1czogYm9yZGVyUmFkaXVzLFxuICAgICAgICB9KTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vcm1hbCByZWN0XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLm11bHRpS2V5QmFja2dyb3VuZDtcbiAgICAgICAgY3R4LmZpbGxSZWN0KG91dGVyWCwgY29sb3JZLCBib3hXaWR0aCwgYm94SGVpZ2h0KTtcbiAgICAgICAgY3R4LnN0cm9rZVJlY3Qob3V0ZXJYLCBjb2xvclksIGJveFdpZHRoLCBib3hIZWlnaHQpO1xuICAgICAgICAvLyBJbm5lciBzcXVhcmVcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGxhYmVsQ29sb3IuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICBjdHguZmlsbFJlY3QoaW5uZXJYLCBjb2xvclkgKyAxLCBib3hXaWR0aCAtIDIsIGJveEhlaWdodCAtIDIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJlc3RvcmUgZmlsbFN0eWxlXG4gICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMubGFiZWxUZXh0Q29sb3JzW2ldO1xuICB9XG5cbiAgZHJhd0JvZHkocHQsIGN0eCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHtib2R5fSA9IHRoaXM7XG4gICAgY29uc3Qge2JvZHlTcGFjaW5nLCBib2R5QWxpZ24sIGRpc3BsYXlDb2xvcnMsIGJveEhlaWdodCwgYm94V2lkdGgsIGJveFBhZGRpbmd9ID0gb3B0aW9ucztcbiAgICBjb25zdCBib2R5Rm9udCA9IHRvRm9udChvcHRpb25zLmJvZHlGb250KTtcbiAgICBsZXQgYm9keUxpbmVIZWlnaHQgPSBib2R5Rm9udC5saW5lSGVpZ2h0O1xuICAgIGxldCB4TGluZVBhZGRpbmcgPSAwO1xuXG4gICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRpb25zLnJ0bCwgdGhpcy54LCB0aGlzLndpZHRoKTtcblxuICAgIGNvbnN0IGZpbGxMaW5lT2ZUZXh0ID0gZnVuY3Rpb24obGluZSkge1xuICAgICAgY3R4LmZpbGxUZXh0KGxpbmUsIHJ0bEhlbHBlci54KHB0LnggKyB4TGluZVBhZGRpbmcpLCBwdC55ICsgYm9keUxpbmVIZWlnaHQgLyAyKTtcbiAgICAgIHB0LnkgKz0gYm9keUxpbmVIZWlnaHQgKyBib2R5U3BhY2luZztcbiAgICB9O1xuXG4gICAgY29uc3QgYm9keUFsaWduRm9yQ2FsY3VsYXRpb24gPSBydGxIZWxwZXIudGV4dEFsaWduKGJvZHlBbGlnbik7XG4gICAgbGV0IGJvZHlJdGVtLCB0ZXh0Q29sb3IsIGxpbmVzLCBpLCBqLCBpbGVuLCBqbGVuO1xuXG4gICAgY3R4LnRleHRBbGlnbiA9IGJvZHlBbGlnbjtcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgY3R4LmZvbnQgPSBib2R5Rm9udC5zdHJpbmc7XG5cbiAgICBwdC54ID0gZ2V0QWxpZ25lZFgodGhpcywgYm9keUFsaWduRm9yQ2FsY3VsYXRpb24sIG9wdGlvbnMpO1xuXG4gICAgLy8gQmVmb3JlIGJvZHkgbGluZXNcbiAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5ib2R5Q29sb3I7XG4gICAgZWFjaCh0aGlzLmJlZm9yZUJvZHksIGZpbGxMaW5lT2ZUZXh0KTtcblxuICAgIHhMaW5lUGFkZGluZyA9IGRpc3BsYXlDb2xvcnMgJiYgYm9keUFsaWduRm9yQ2FsY3VsYXRpb24gIT09ICdyaWdodCdcbiAgICAgID8gYm9keUFsaWduID09PSAnY2VudGVyJyA/IChib3hXaWR0aCAvIDIgKyBib3hQYWRkaW5nKSA6IChib3hXaWR0aCArIDIgKyBib3hQYWRkaW5nKVxuICAgICAgOiAwO1xuXG4gICAgLy8gRHJhdyBib2R5IGxpbmVzIG5vd1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBib2R5Lmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgYm9keUl0ZW0gPSBib2R5W2ldO1xuICAgICAgdGV4dENvbG9yID0gdGhpcy5sYWJlbFRleHRDb2xvcnNbaV07XG5cbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0ZXh0Q29sb3I7XG4gICAgICBlYWNoKGJvZHlJdGVtLmJlZm9yZSwgZmlsbExpbmVPZlRleHQpO1xuXG4gICAgICBsaW5lcyA9IGJvZHlJdGVtLmxpbmVzO1xuICAgICAgLy8gRHJhdyBMZWdlbmQtbGlrZSBib3hlcyBpZiBuZWVkZWRcbiAgICAgIGlmIChkaXNwbGF5Q29sb3JzICYmIGxpbmVzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl9kcmF3Q29sb3JCb3goY3R4LCBwdCwgaSwgcnRsSGVscGVyLCBvcHRpb25zKTtcbiAgICAgICAgYm9keUxpbmVIZWlnaHQgPSBNYXRoLm1heChib2R5Rm9udC5saW5lSGVpZ2h0LCBib3hIZWlnaHQpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGogPSAwLCBqbGVuID0gbGluZXMubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XG4gICAgICAgIGZpbGxMaW5lT2ZUZXh0KGxpbmVzW2pdKTtcbiAgICAgICAgLy8gUmVzZXQgZm9yIGFueSBsaW5lcyB0aGF0IGRvbid0IGluY2x1ZGUgY29sb3Jib3hcbiAgICAgICAgYm9keUxpbmVIZWlnaHQgPSBib2R5Rm9udC5saW5lSGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICBlYWNoKGJvZHlJdGVtLmFmdGVyLCBmaWxsTGluZU9mVGV4dCk7XG4gICAgfVxuXG4gICAgLy8gUmVzZXQgYmFjayB0byAwIGZvciBhZnRlciBib2R5XG4gICAgeExpbmVQYWRkaW5nID0gMDtcbiAgICBib2R5TGluZUhlaWdodCA9IGJvZHlGb250LmxpbmVIZWlnaHQ7XG5cbiAgICAvLyBBZnRlciBib2R5IGxpbmVzXG4gICAgZWFjaCh0aGlzLmFmdGVyQm9keSwgZmlsbExpbmVPZlRleHQpO1xuICAgIHB0LnkgLT0gYm9keVNwYWNpbmc7IC8vIFJlbW92ZSBsYXN0IGJvZHkgc3BhY2luZ1xuICB9XG5cbiAgZHJhd0Zvb3RlcihwdCwgY3R4LCBvcHRpb25zKSB7XG4gICAgY29uc3QgZm9vdGVyID0gdGhpcy5mb290ZXI7XG4gICAgY29uc3QgbGVuZ3RoID0gZm9vdGVyLmxlbmd0aDtcbiAgICBsZXQgZm9vdGVyRm9udCwgaTtcblxuICAgIGlmIChsZW5ndGgpIHtcbiAgICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0aW9ucy5ydGwsIHRoaXMueCwgdGhpcy53aWR0aCk7XG5cbiAgICAgIHB0LnggPSBnZXRBbGlnbmVkWCh0aGlzLCBvcHRpb25zLmZvb3RlckFsaWduLCBvcHRpb25zKTtcbiAgICAgIHB0LnkgKz0gb3B0aW9ucy5mb290ZXJNYXJnaW5Ub3A7XG5cbiAgICAgIGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKG9wdGlvbnMuZm9vdGVyQWxpZ24pO1xuICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuXG4gICAgICBmb290ZXJGb250ID0gdG9Gb250KG9wdGlvbnMuZm9vdGVyRm9udCk7XG5cbiAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmZvb3RlckNvbG9yO1xuICAgICAgY3R4LmZvbnQgPSBmb290ZXJGb250LnN0cmluZztcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGN0eC5maWxsVGV4dChmb290ZXJbaV0sIHJ0bEhlbHBlci54KHB0LngpLCBwdC55ICsgZm9vdGVyRm9udC5saW5lSGVpZ2h0IC8gMik7XG4gICAgICAgIHB0LnkgKz0gZm9vdGVyRm9udC5saW5lSGVpZ2h0ICsgb3B0aW9ucy5mb290ZXJTcGFjaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGRyYXdCYWNrZ3JvdW5kKHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge3hBbGlnbiwgeUFsaWdufSA9IHRoaXM7XG4gICAgY29uc3Qge3gsIHl9ID0gcHQ7XG4gICAgY29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gdG9vbHRpcFNpemU7XG4gICAgY29uc3Qge3RvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0LCBib3R0b21SaWdodH0gPSB0b1RSQkxDb3JuZXJzKG9wdGlvbnMuY29ybmVyUmFkaXVzKTtcblxuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLmJvcmRlckNvbG9yO1xuICAgIGN0eC5saW5lV2lkdGggPSBvcHRpb25zLmJvcmRlcldpZHRoO1xuXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8oeCArIHRvcExlZnQsIHkpO1xuICAgIGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XG4gICAgICB0aGlzLmRyYXdDYXJldChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGN0eC5saW5lVG8oeCArIHdpZHRoIC0gdG9wUmlnaHQsIHkpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgdG9wUmlnaHQpO1xuICAgIGlmICh5QWxpZ24gPT09ICdjZW50ZXInICYmIHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgdGhpcy5kcmF3Q2FyZXQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjdHgubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIGJvdHRvbVJpZ2h0KTtcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCAtIGJvdHRvbVJpZ2h0LCB5ICsgaGVpZ2h0KTtcbiAgICBpZiAoeUFsaWduID09PSAnYm90dG9tJykge1xuICAgICAgdGhpcy5kcmF3Q2FyZXQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjdHgubGluZVRvKHggKyBib3R0b21MZWZ0LCB5ICsgaGVpZ2h0KTtcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gYm90dG9tTGVmdCk7XG4gICAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicgJiYgeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgIHRoaXMuZHJhd0NhcmV0KHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY3R4LmxpbmVUbyh4LCB5ICsgdG9wTGVmdCk7XG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSwgeCArIHRvcExlZnQsIHkpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcblxuICAgIGN0eC5maWxsKCk7XG5cbiAgICBpZiAob3B0aW9ucy5ib3JkZXJXaWR0aCA+IDApIHtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogVXBkYXRlIHgveSBhbmltYXRpb24gdGFyZ2V0cyB3aGVuIF9hY3RpdmUgZWxlbWVudHMgYXJlIGFuaW1hdGluZyB0b29cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF91cGRhdGVBbmltYXRpb25UYXJnZXQob3B0aW9ucykge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBhbmltcyA9IHRoaXMuJGFuaW1hdGlvbnM7XG4gICAgY29uc3QgYW5pbVggPSBhbmltcyAmJiBhbmltcy54O1xuICAgIGNvbnN0IGFuaW1ZID0gYW5pbXMgJiYgYW5pbXMueTtcbiAgICBpZiAoYW5pbVggfHwgYW5pbVkpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25lcnNbb3B0aW9ucy5wb3NpdGlvbl0uY2FsbCh0aGlzLCB0aGlzLl9hY3RpdmUsIHRoaXMuX2V2ZW50UG9zaXRpb24pO1xuICAgICAgaWYgKCFwb3NpdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzaXplID0gdGhpcy5fc2l6ZSA9IGdldFRvb2x0aXBTaXplKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgY29uc3QgcG9zaXRpb25BbmRTaXplID0gT2JqZWN0LmFzc2lnbih7fSwgcG9zaXRpb24sIHRoaXMuX3NpemUpO1xuICAgICAgY29uc3QgYWxpZ25tZW50ID0gZGV0ZXJtaW5lQWxpZ25tZW50KGNoYXJ0LCBvcHRpb25zLCBwb3NpdGlvbkFuZFNpemUpO1xuICAgICAgY29uc3QgcG9pbnQgPSBnZXRCYWNrZ3JvdW5kUG9pbnQob3B0aW9ucywgcG9zaXRpb25BbmRTaXplLCBhbGlnbm1lbnQsIGNoYXJ0KTtcbiAgICAgIGlmIChhbmltWC5fdG8gIT09IHBvaW50LnggfHwgYW5pbVkuX3RvICE9PSBwb2ludC55KSB7XG4gICAgICAgIHRoaXMueEFsaWduID0gYWxpZ25tZW50LnhBbGlnbjtcbiAgICAgICAgdGhpcy55QWxpZ24gPSBhbGlnbm1lbnQueUFsaWduO1xuICAgICAgICB0aGlzLndpZHRoID0gc2l6ZS53aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBzaXplLmhlaWdodDtcbiAgICAgICAgdGhpcy5jYXJldFggPSBwb3NpdGlvbi54O1xuICAgICAgICB0aGlzLmNhcmV0WSA9IHBvc2l0aW9uLnk7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKCkudXBkYXRlKHRoaXMsIHBvaW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIGlmIHRoZSB0b29sdGlwIHdpbGwgZHJhdyBhbnl0aGluZ1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdG9vbHRpcCB3aWxsIHJlbmRlclxuICAgKi9cbiAgX3dpbGxSZW5kZXIoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5vcGFjaXR5O1xuICB9XG5cbiAgZHJhdyhjdHgpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGxldCBvcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xuXG4gICAgaWYgKCFvcGFjaXR5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlQW5pbWF0aW9uVGFyZ2V0KG9wdGlvbnMpO1xuXG4gICAgY29uc3QgdG9vbHRpcFNpemUgPSB7XG4gICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgIGhlaWdodDogdGhpcy5oZWlnaHRcbiAgICB9O1xuICAgIGNvbnN0IHB0ID0ge1xuICAgICAgeDogdGhpcy54LFxuICAgICAgeTogdGhpcy55XG4gICAgfTtcblxuICAgIC8vIElFMTEvRWRnZSBkb2VzIG5vdCBsaWtlIHZlcnkgc21hbGwgb3BhY2l0aWVzLCBzbyBzbmFwIHRvIDBcbiAgICBvcGFjaXR5ID0gTWF0aC5hYnMob3BhY2l0eSkgPCAxZS0zID8gMCA6IG9wYWNpdHk7XG5cbiAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdGlvbnMucGFkZGluZyk7XG5cbiAgICAvLyBUcnV0aHkvZmFsc2V5IHZhbHVlIGZvciBlbXB0eSB0b29sdGlwXG4gICAgY29uc3QgaGFzVG9vbHRpcENvbnRlbnQgPSB0aGlzLnRpdGxlLmxlbmd0aCB8fCB0aGlzLmJlZm9yZUJvZHkubGVuZ3RoIHx8IHRoaXMuYm9keS5sZW5ndGggfHwgdGhpcy5hZnRlckJvZHkubGVuZ3RoIHx8IHRoaXMuZm9vdGVyLmxlbmd0aDtcblxuICAgIGlmIChvcHRpb25zLmVuYWJsZWQgJiYgaGFzVG9vbHRpcENvbnRlbnQpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSBvcGFjaXR5O1xuXG4gICAgICAvLyBEcmF3IEJhY2tncm91bmRcbiAgICAgIHRoaXMuZHJhd0JhY2tncm91bmQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xuXG4gICAgICBvdmVycmlkZVRleHREaXJlY3Rpb24oY3R4LCBvcHRpb25zLnRleHREaXJlY3Rpb24pO1xuXG4gICAgICBwdC55ICs9IHBhZGRpbmcudG9wO1xuXG4gICAgICAvLyBUaXRsZXNcbiAgICAgIHRoaXMuZHJhd1RpdGxlKHB0LCBjdHgsIG9wdGlvbnMpO1xuXG4gICAgICAvLyBCb2R5XG4gICAgICB0aGlzLmRyYXdCb2R5KHB0LCBjdHgsIG9wdGlvbnMpO1xuXG4gICAgICAvLyBGb290ZXJcbiAgICAgIHRoaXMuZHJhd0Zvb3RlcihwdCwgY3R4LCBvcHRpb25zKTtcblxuICAgICAgcmVzdG9yZVRleHREaXJlY3Rpb24oY3R4LCBvcHRpb25zLnRleHREaXJlY3Rpb24pO1xuXG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXQgYWN0aXZlIGVsZW1lbnRzIGluIHRoZSB0b29sdGlwXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgb2YgZWxlbWVudHMgdGhhdCBhcmUgYWN0aXZlIGluIHRoZSB0b29sdGlwXG5cdCAqL1xuICBnZXRBY3RpdmVFbGVtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlIHx8IFtdO1xuICB9XG5cbiAgLyoqXG5cdCAqIFNldCBhY3RpdmUgZWxlbWVudHMgaW4gdGhlIHRvb2x0aXBcblx0ICogQHBhcmFtIHthcnJheX0gYWN0aXZlRWxlbWVudHMgQXJyYXkgb2YgYWN0aXZlIGRhdGFzZXRJbmRleC9pbmRleCBwYWlycy5cblx0ICogQHBhcmFtIHtvYmplY3R9IGV2ZW50UG9zaXRpb24gU3ludGhldGljIGV2ZW50IHBvc2l0aW9uIHVzZWQgaW4gcG9zaXRpb25pbmdcblx0ICovXG4gIHNldEFjdGl2ZUVsZW1lbnRzKGFjdGl2ZUVsZW1lbnRzLCBldmVudFBvc2l0aW9uKSB7XG4gICAgY29uc3QgbGFzdEFjdGl2ZSA9IHRoaXMuX2FjdGl2ZTtcbiAgICBjb25zdCBhY3RpdmUgPSBhY3RpdmVFbGVtZW50cy5tYXAoKHtkYXRhc2V0SW5kZXgsIGluZGV4fSkgPT4ge1xuICAgICAgY29uc3QgbWV0YSA9IHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcblxuICAgICAgaWYgKCFtZXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgYSBkYXRhc2V0IGF0IGluZGV4ICcgKyBkYXRhc2V0SW5kZXgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhc2V0SW5kZXgsXG4gICAgICAgIGVsZW1lbnQ6IG1ldGEuZGF0YVtpbmRleF0sXG4gICAgICAgIGluZGV4LFxuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCBjaGFuZ2VkID0gIV9lbGVtZW50c0VxdWFsKGxhc3RBY3RpdmUsIGFjdGl2ZSk7XG4gICAgY29uc3QgcG9zaXRpb25DaGFuZ2VkID0gdGhpcy5fcG9zaXRpb25DaGFuZ2VkKGFjdGl2ZSwgZXZlbnRQb3NpdGlvbik7XG5cbiAgICBpZiAoY2hhbmdlZCB8fCBwb3NpdGlvbkNoYW5nZWQpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgIHRoaXMuX2V2ZW50UG9zaXRpb24gPSBldmVudFBvc2l0aW9uO1xuICAgICAgdGhpcy5faWdub3JlUmVwbGF5RXZlbnRzID0gdHJ1ZTtcbiAgICAgIHRoaXMudXBkYXRlKHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBIYW5kbGUgYW4gZXZlbnRcblx0ICogQHBhcmFtIHtDaGFydEV2ZW50fSBlIC0gVGhlIGV2ZW50IHRvIGhhbmRsZVxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXBsYXldIC0gVGhpcyBpcyBhIHJlcGxheWVkIGV2ZW50IChmcm9tIHVwZGF0ZSlcblx0ICogQHBhcmFtIHtib29sZWFufSBbaW5DaGFydEFyZWFdIC0gVGhlIGV2ZW50IGlzIGluc2lkZSBjaGFydEFyZWFcblx0ICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIHRvb2x0aXAgY2hhbmdlZFxuXHQgKi9cbiAgaGFuZGxlRXZlbnQoZSwgcmVwbGF5LCBpbkNoYXJ0QXJlYSA9IHRydWUpIHtcbiAgICBpZiAocmVwbGF5ICYmIHRoaXMuX2lnbm9yZVJlcGxheUV2ZW50cykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLl9pZ25vcmVSZXBsYXlFdmVudHMgPSBmYWxzZTtcblxuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbGFzdEFjdGl2ZSA9IHRoaXMuX2FjdGl2ZSB8fCBbXTtcbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLl9nZXRBY3RpdmVFbGVtZW50cyhlLCBsYXN0QWN0aXZlLCByZXBsYXksIGluQ2hhcnRBcmVhKTtcblxuICAgIC8vIFdoZW4gdGhlcmUgYXJlIG11bHRpcGxlIGl0ZW1zIHNob3duLCBidXQgdGhlIHRvb2x0aXAgcG9zaXRpb24gaXMgbmVhcmVzdCBtb2RlXG4gICAgLy8gYW4gdXBkYXRlIG1heSBuZWVkIHRvIGJlIG1hZGUgYmVjYXVzZSBvdXIgcG9zaXRpb24gbWF5IGhhdmUgY2hhbmdlZCBldmVuIHRob3VnaFxuICAgIC8vIHRoZSBpdGVtcyBhcmUgdGhlIHNhbWUgYXMgYmVmb3JlLlxuICAgIGNvbnN0IHBvc2l0aW9uQ2hhbmdlZCA9IHRoaXMuX3Bvc2l0aW9uQ2hhbmdlZChhY3RpdmUsIGUpO1xuXG4gICAgLy8gUmVtZW1iZXIgTGFzdCBBY3RpdmVzXG4gICAgY29uc3QgY2hhbmdlZCA9IHJlcGxheSB8fCAhX2VsZW1lbnRzRXF1YWwoYWN0aXZlLCBsYXN0QWN0aXZlKSB8fCBwb3NpdGlvbkNoYW5nZWQ7XG5cbiAgICAvLyBPbmx5IGhhbmRsZSB0YXJnZXQgZXZlbnQgb24gdG9vbHRpcCBjaGFuZ2VcbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gYWN0aXZlO1xuXG4gICAgICBpZiAob3B0aW9ucy5lbmFibGVkIHx8IG9wdGlvbnMuZXh0ZXJuYWwpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRQb3NpdGlvbiA9IHtcbiAgICAgICAgICB4OiBlLngsXG4gICAgICAgICAgeTogZS55XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy51cGRhdGUodHJ1ZSwgcmVwbGF5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBIZWxwZXIgZm9yIGRldGVybWluaW5nIHRoZSBhY3RpdmUgZWxlbWVudHMgZm9yIGV2ZW50XG5cdCAqIEBwYXJhbSB7Q2hhcnRFdmVudH0gZSAtIFRoZSBldmVudCB0byBoYW5kbGVcblx0ICogQHBhcmFtIHtJbnRlcmFjdGlvbkl0ZW1bXX0gbGFzdEFjdGl2ZSAtIFByZXZpb3VzbHkgYWN0aXZlIGVsZW1lbnRzXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlcGxheV0gLSBUaGlzIGlzIGEgcmVwbGF5ZWQgZXZlbnQgKGZyb20gdXBkYXRlKVxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbkNoYXJ0QXJlYV0gLSBUaGUgZXZlbnQgaXMgaW5zaWRlIGNoYXJ0QXJlYVxuXHQgKiBAcmV0dXJucyB7SW50ZXJhY3Rpb25JdGVtW119IC0gQWN0aXZlIGVsZW1lbnRzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0QWN0aXZlRWxlbWVudHMoZSwgbGFzdEFjdGl2ZSwgcmVwbGF5LCBpbkNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBpZiAoZS50eXBlID09PSAnbW91c2VvdXQnKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgaWYgKCFpbkNoYXJ0QXJlYSkge1xuICAgICAgLy8gTGV0IHVzZXIgY29udHJvbCB0aGUgYWN0aXZlIGVsZW1lbnRzIG91dHNpZGUgY2hhcnRBcmVhLiBFZy4gdXNpbmcgTGVnZW5kLlxuICAgICAgLy8gQnV0IG1ha2Ugc3VyZSB0aGF0IGFjdGl2ZSBlbGVtZW50cyBhcmUgc3RpbGwgdmFsaWQuXG4gICAgICByZXR1cm4gbGFzdEFjdGl2ZS5maWx0ZXIoaSA9PlxuICAgICAgICB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbaS5kYXRhc2V0SW5kZXhdICYmXG4gICAgICAgIHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEoaS5kYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXIuZ2V0UGFyc2VkKGkuaW5kZXgpICE9PSB1bmRlZmluZWRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gRmluZCBBY3RpdmUgRWxlbWVudHMgZm9yIHRvb2x0aXBzXG4gICAgY29uc3QgYWN0aXZlID0gdGhpcy5jaGFydC5nZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKGUsIG9wdGlvbnMubW9kZSwgb3B0aW9ucywgcmVwbGF5KTtcblxuICAgIGlmIChvcHRpb25zLnJldmVyc2UpIHtcbiAgICAgIGFjdGl2ZS5yZXZlcnNlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjdGl2ZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBEZXRlcm1pbmUgaWYgdGhlIGFjdGl2ZSBlbGVtZW50cyArIGV2ZW50IGNvbWJpbmF0aW9uIGNoYW5nZXMgdGhlXG5cdCAqIHRvb2x0aXAgcG9zaXRpb25cblx0ICogQHBhcmFtIHthcnJheX0gYWN0aXZlIC0gQWN0aXZlIGVsZW1lbnRzXG5cdCAqIEBwYXJhbSB7Q2hhcnRFdmVudH0gZSAtIEV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoZSBwb3NpdGlvbiBjaGFuZ2Vcblx0ICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHBvc2l0aW9uIGhhcyBjaGFuZ2VkXG5cdCAqL1xuICBfcG9zaXRpb25DaGFuZ2VkKGFjdGl2ZSwgZSkge1xuICAgIGNvbnN0IHtjYXJldFgsIGNhcmV0WSwgb3B0aW9uc30gPSB0aGlzO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25lcnNbb3B0aW9ucy5wb3NpdGlvbl0uY2FsbCh0aGlzLCBhY3RpdmUsIGUpO1xuICAgIHJldHVybiBwb3NpdGlvbiAhPT0gZmFsc2UgJiYgKGNhcmV0WCAhPT0gcG9zaXRpb24ueCB8fCBjYXJldFkgIT09IHBvc2l0aW9uLnkpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaWQ6ICd0b29sdGlwJyxcbiAgX2VsZW1lbnQ6IFRvb2x0aXAsXG4gIHBvc2l0aW9uZXJzLFxuXG4gIGFmdGVySW5pdChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgY2hhcnQudG9vbHRpcCA9IG5ldyBUb29sdGlwKHtjaGFydCwgb3B0aW9uc30pO1xuICAgIH1cbiAgfSxcblxuICBiZWZvcmVVcGRhdGUoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgaWYgKGNoYXJ0LnRvb2x0aXApIHtcbiAgICAgIGNoYXJ0LnRvb2x0aXAuaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgICB9XG4gIH0sXG5cbiAgcmVzZXQoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgaWYgKGNoYXJ0LnRvb2x0aXApIHtcbiAgICAgIGNoYXJ0LnRvb2x0aXAuaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgICB9XG4gIH0sXG5cbiAgYWZ0ZXJEcmF3KGNoYXJ0KSB7XG4gICAgY29uc3QgdG9vbHRpcCA9IGNoYXJ0LnRvb2x0aXA7XG5cbiAgICBpZiAodG9vbHRpcCAmJiB0b29sdGlwLl93aWxsUmVuZGVyKCkpIHtcbiAgICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICAgIHRvb2x0aXBcbiAgICAgIH07XG5cbiAgICAgIGlmIChjaGFydC5ub3RpZnlQbHVnaW5zKCdiZWZvcmVUb29sdGlwRHJhdycsIHsuLi5hcmdzLCBjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdG9vbHRpcC5kcmF3KGNoYXJ0LmN0eCk7XG5cbiAgICAgIGNoYXJ0Lm5vdGlmeVBsdWdpbnMoJ2FmdGVyVG9vbHRpcERyYXcnLCBhcmdzKTtcbiAgICB9XG4gIH0sXG5cbiAgYWZ0ZXJFdmVudChjaGFydCwgYXJncykge1xuICAgIGlmIChjaGFydC50b29sdGlwKSB7XG4gICAgICAvLyBJZiB0aGUgZXZlbnQgaXMgcmVwbGF5ZWQgZnJvbSBgdXBkYXRlYCwgd2Ugc2hvdWxkIGV2YWx1YXRlIHdpdGggdGhlIGZpbmFsIHBvc2l0aW9ucy5cbiAgICAgIGNvbnN0IHVzZUZpbmFsUG9zaXRpb24gPSBhcmdzLnJlcGxheTtcbiAgICAgIGlmIChjaGFydC50b29sdGlwLmhhbmRsZUV2ZW50KGFyZ3MuZXZlbnQsIHVzZUZpbmFsUG9zaXRpb24sIGFyZ3MuaW5DaGFydEFyZWEpKSB7XG4gICAgICAgIC8vIG5vdGlmeSBjaGFydCBhYm91dCB0aGUgY2hhbmdlLCBzbyBpdCB3aWxsIHJlbmRlclxuICAgICAgICBhcmdzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBkZWZhdWx0czoge1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgZXh0ZXJuYWw6IG51bGwsXG4gICAgcG9zaXRpb246ICdhdmVyYWdlJyxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDAuOCknLFxuICAgIHRpdGxlQ29sb3I6ICcjZmZmJyxcbiAgICB0aXRsZUZvbnQ6IHtcbiAgICAgIHdlaWdodDogJ2JvbGQnLFxuICAgIH0sXG4gICAgdGl0bGVTcGFjaW5nOiAyLFxuICAgIHRpdGxlTWFyZ2luQm90dG9tOiA2LFxuICAgIHRpdGxlQWxpZ246ICdsZWZ0JyxcbiAgICBib2R5Q29sb3I6ICcjZmZmJyxcbiAgICBib2R5U3BhY2luZzogMixcbiAgICBib2R5Rm9udDoge1xuICAgIH0sXG4gICAgYm9keUFsaWduOiAnbGVmdCcsXG4gICAgZm9vdGVyQ29sb3I6ICcjZmZmJyxcbiAgICBmb290ZXJTcGFjaW5nOiAyLFxuICAgIGZvb3Rlck1hcmdpblRvcDogNixcbiAgICBmb290ZXJGb250OiB7XG4gICAgICB3ZWlnaHQ6ICdib2xkJyxcbiAgICB9LFxuICAgIGZvb3RlckFsaWduOiAnbGVmdCcsXG4gICAgcGFkZGluZzogNixcbiAgICBjYXJldFBhZGRpbmc6IDIsXG4gICAgY2FyZXRTaXplOiA1LFxuICAgIGNvcm5lclJhZGl1czogNixcbiAgICBib3hIZWlnaHQ6IChjdHgsIG9wdHMpID0+IG9wdHMuYm9keUZvbnQuc2l6ZSxcbiAgICBib3hXaWR0aDogKGN0eCwgb3B0cykgPT4gb3B0cy5ib2R5Rm9udC5zaXplLFxuICAgIG11bHRpS2V5QmFja2dyb3VuZDogJyNmZmYnLFxuICAgIGRpc3BsYXlDb2xvcnM6IHRydWUsXG4gICAgYm94UGFkZGluZzogMCxcbiAgICBib3JkZXJDb2xvcjogJ3JnYmEoMCwwLDAsMCknLFxuICAgIGJvcmRlcldpZHRoOiAwLFxuICAgIGFuaW1hdGlvbjoge1xuICAgICAgZHVyYXRpb246IDQwMCxcbiAgICAgIGVhc2luZzogJ2Vhc2VPdXRRdWFydCcsXG4gICAgfSxcbiAgICBhbmltYXRpb25zOiB7XG4gICAgICBudW1iZXJzOiB7XG4gICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICBwcm9wZXJ0aWVzOiBbJ3gnLCAneScsICd3aWR0aCcsICdoZWlnaHQnLCAnY2FyZXRYJywgJ2NhcmV0WSddLFxuICAgICAgfSxcbiAgICAgIG9wYWNpdHk6IHtcbiAgICAgICAgZWFzaW5nOiAnbGluZWFyJyxcbiAgICAgICAgZHVyYXRpb246IDIwMFxuICAgICAgfVxuICAgIH0sXG4gICAgY2FsbGJhY2tzOiBkZWZhdWx0Q2FsbGJhY2tzXG4gIH0sXG5cbiAgZGVmYXVsdFJvdXRlczoge1xuICAgIGJvZHlGb250OiAnZm9udCcsXG4gICAgZm9vdGVyRm9udDogJ2ZvbnQnLFxuICAgIHRpdGxlRm9udDogJ2ZvbnQnXG4gIH0sXG5cbiAgZGVzY3JpcHRvcnM6IHtcbiAgICBfc2NyaXB0YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdmaWx0ZXInICYmIG5hbWUgIT09ICdpdGVtU29ydCcgJiYgbmFtZSAhPT0gJ2V4dGVybmFsJyxcbiAgICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgICBjYWxsYmFja3M6IHtcbiAgICAgIF9zY3JpcHRhYmxlOiBmYWxzZSxcbiAgICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICAgIH0sXG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICBfZmFsbGJhY2s6IGZhbHNlXG4gICAgfSxcbiAgICBhbmltYXRpb25zOiB7XG4gICAgICBfZmFsbGJhY2s6ICdhbmltYXRpb24nXG4gICAgfVxuICB9LFxuXG4gIC8vIFJlc29sdmUgYWRkaXRpb25hbGx5IGZyb20gYGludGVyYWN0aW9uYCBvcHRpb25zIGFuZCBkZWZhdWx0cy5cbiAgYWRkaXRpb25hbE9wdGlvblNjb3BlczogWydpbnRlcmFjdGlvbiddXG59O1xuIiwiaW1wb3J0IFNjYWxlIGZyb20gJy4uL2NvcmUvY29yZS5zY2FsZS5qcyc7XG5pbXBvcnQge2lzTnVsbE9yVW5kZWYsIHZhbHVlT3JEZWZhdWx0LCBfbGltaXRWYWx1ZX0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbmNvbnN0IGFkZElmU3RyaW5nID0gKGxhYmVscywgcmF3LCBpbmRleCwgYWRkZWRMYWJlbHMpID0+IHtcbiAgaWYgKHR5cGVvZiByYXcgPT09ICdzdHJpbmcnKSB7XG4gICAgaW5kZXggPSBsYWJlbHMucHVzaChyYXcpIC0gMTtcbiAgICBhZGRlZExhYmVscy51bnNoaWZ0KHtpbmRleCwgbGFiZWw6IHJhd30pO1xuICB9IGVsc2UgaWYgKGlzTmFOKHJhdykpIHtcbiAgICBpbmRleCA9IG51bGw7XG4gIH1cbiAgcmV0dXJuIGluZGV4O1xufTtcblxuZnVuY3Rpb24gZmluZE9yQWRkTGFiZWwobGFiZWxzLCByYXcsIGluZGV4LCBhZGRlZExhYmVscykge1xuICBjb25zdCBmaXJzdCA9IGxhYmVscy5pbmRleE9mKHJhdyk7XG4gIGlmIChmaXJzdCA9PT0gLTEpIHtcbiAgICByZXR1cm4gYWRkSWZTdHJpbmcobGFiZWxzLCByYXcsIGluZGV4LCBhZGRlZExhYmVscyk7XG4gIH1cbiAgY29uc3QgbGFzdCA9IGxhYmVscy5sYXN0SW5kZXhPZihyYXcpO1xuICByZXR1cm4gZmlyc3QgIT09IGxhc3QgPyBpbmRleCA6IGZpcnN0O1xufVxuXG5jb25zdCB2YWxpZEluZGV4ID0gKGluZGV4LCBtYXgpID0+IGluZGV4ID09PSBudWxsID8gbnVsbCA6IF9saW1pdFZhbHVlKE1hdGgucm91bmQoaW5kZXgpLCAwLCBtYXgpO1xuXG5mdW5jdGlvbiBfZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICBjb25zdCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuXG4gIGlmICh2YWx1ZSA+PSAwICYmIHZhbHVlIDwgbGFiZWxzLmxlbmd0aCkge1xuICAgIHJldHVybiBsYWJlbHNbdmFsdWVdO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2F0ZWdvcnlTY2FsZSBleHRlbmRzIFNjYWxlIHtcblxuICBzdGF0aWMgaWQgPSAnY2F0ZWdvcnknO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIHRpY2tzOiB7XG4gICAgICBjYWxsYmFjazogX2dldExhYmVsRm9yVmFsdWVcbiAgICB9XG4gIH07XG5cbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoY2ZnKTtcblxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IDA7XG4gICAgdGhpcy5fYWRkZWRMYWJlbHMgPSBbXTtcbiAgfVxuXG4gIGluaXQoc2NhbGVPcHRpb25zKSB7XG4gICAgY29uc3QgYWRkZWQgPSB0aGlzLl9hZGRlZExhYmVscztcbiAgICBpZiAoYWRkZWQubGVuZ3RoKSB7XG4gICAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuICAgICAgZm9yIChjb25zdCB7aW5kZXgsIGxhYmVsfSBvZiBhZGRlZCkge1xuICAgICAgICBpZiAobGFiZWxzW2luZGV4XSA9PT0gbGFiZWwpIHtcbiAgICAgICAgICBsYWJlbHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fYWRkZWRMYWJlbHMgPSBbXTtcbiAgICB9XG4gICAgc3VwZXIuaW5pdChzY2FsZU9wdGlvbnMpO1xuICB9XG5cbiAgcGFyc2UocmF3LCBpbmRleCkge1xuICAgIGlmIChpc051bGxPclVuZGVmKHJhdykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuICAgIGluZGV4ID0gaXNGaW5pdGUoaW5kZXgpICYmIGxhYmVsc1tpbmRleF0gPT09IHJhdyA/IGluZGV4XG4gICAgICA6IGZpbmRPckFkZExhYmVsKGxhYmVscywgcmF3LCB2YWx1ZU9yRGVmYXVsdChpbmRleCwgcmF3KSwgdGhpcy5fYWRkZWRMYWJlbHMpO1xuICAgIHJldHVybiB2YWxpZEluZGV4KGluZGV4LCBsYWJlbHMubGVuZ3RoIC0gMSk7XG4gIH1cblxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgIGNvbnN0IHttaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHRoaXMuZ2V0VXNlckJvdW5kcygpO1xuICAgIGxldCB7bWluLCBtYXh9ID0gdGhpcy5nZXRNaW5NYXgodHJ1ZSk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmJvdW5kcyA9PT0gJ3RpY2tzJykge1xuICAgICAgaWYgKCFtaW5EZWZpbmVkKSB7XG4gICAgICAgIG1pbiA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoIW1heERlZmluZWQpIHtcbiAgICAgICAgbWF4ID0gdGhpcy5nZXRMYWJlbHMoKS5sZW5ndGggLSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubWluID0gbWluO1xuICAgIHRoaXMubWF4ID0gbWF4O1xuICB9XG5cbiAgYnVpbGRUaWNrcygpIHtcbiAgICBjb25zdCBtaW4gPSB0aGlzLm1pbjtcbiAgICBjb25zdCBtYXggPSB0aGlzLm1heDtcbiAgICBjb25zdCBvZmZzZXQgPSB0aGlzLm9wdGlvbnMub2Zmc2V0O1xuICAgIGNvbnN0IHRpY2tzID0gW107XG4gICAgbGV0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG5cbiAgICAvLyBJZiB3ZSBhcmUgdmlld2luZyBzb21lIHN1YnNldCBvZiBsYWJlbHMsIHNsaWNlIHRoZSBvcmlnaW5hbCBhcnJheVxuICAgIGxhYmVscyA9IChtaW4gPT09IDAgJiYgbWF4ID09PSBsYWJlbHMubGVuZ3RoIC0gMSkgPyBsYWJlbHMgOiBsYWJlbHMuc2xpY2UobWluLCBtYXggKyAxKTtcblxuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSBNYXRoLm1heChsYWJlbHMubGVuZ3RoIC0gKG9mZnNldCA/IDAgOiAxKSwgMSk7XG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHRoaXMubWluIC0gKG9mZnNldCA/IDAuNSA6IDApO1xuXG4gICAgZm9yIChsZXQgdmFsdWUgPSBtaW47IHZhbHVlIDw9IG1heDsgdmFsdWUrKykge1xuICAgICAgdGlja3MucHVzaCh7dmFsdWV9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRpY2tzO1xuICB9XG5cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiBfZ2V0TGFiZWxGb3JWYWx1ZS5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBjb25maWd1cmUoKSB7XG4gICAgc3VwZXIuY29uZmlndXJlKCk7XG5cbiAgICBpZiAoIXRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIC8vIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB2ZXJ0aWNhbCBjYXRlZ29yeSBzY2FsZSByZXZlcnNlIGlzIGludmVydGVkLlxuICAgICAgdGhpcy5fcmV2ZXJzZVBpeGVscyA9ICF0aGlzLl9yZXZlcnNlUGl4ZWxzO1xuICAgIH1cbiAgfVxuXG4gIC8vIFVzZWQgdG8gZ2V0IGRhdGEgdmFsdWUgbG9jYXRpb25zLiBWYWx1ZSBjYW4gZWl0aGVyIGJlIGFuIGluZGV4IG9yIGEgbnVtZXJpY2FsIHZhbHVlXG4gIGdldFBpeGVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlKHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyBOYU4gOiB0aGlzLmdldFBpeGVsRm9yRGVjaW1hbCgodmFsdWUgLSB0aGlzLl9zdGFydFZhbHVlKSAvIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG5cbiAgLy8gTXVzdCBvdmVycmlkZSBiYXNlIGltcGxlbWVudGF0aW9uIGJlY2F1c2UgaXQgY2FsbHMgZ2V0UGl4ZWxGb3JWYWx1ZVxuICAvLyBhbmQgY2F0ZWdvcnkgc2NhbGUgY2FuIGhhdmUgZHVwbGljYXRlIHZhbHVlc1xuICBnZXRQaXhlbEZvclRpY2soaW5kZXgpIHtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IHRpY2tzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvclZhbHVlKHRpY2tzW2luZGV4XS52YWx1ZSk7XG4gIH1cblxuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQodGhpcy5fc3RhcnRWYWx1ZSArIHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAqIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG5cbiAgZ2V0QmFzZVBpeGVsKCkge1xuICAgIHJldHVybiB0aGlzLmJvdHRvbTtcbiAgfVxufVxuIiwiaW1wb3J0IHtpc051bGxPclVuZGVmfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge2FsbW9zdEVxdWFscywgYWxtb3N0V2hvbGUsIG5pY2VOdW0sIF9kZWNpbWFsUGxhY2VzLCBfc2V0TWluQW5kTWF4QnlLZXksIHNpZ24sIHRvUmFkaWFuc30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IFNjYWxlIGZyb20gJy4uL2NvcmUvY29yZS5zY2FsZS5qcyc7XG5pbXBvcnQge2Zvcm1hdE51bWJlcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmludGwuanMnO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgc2V0IG9mIGxpbmVhciB0aWNrcyBmb3IgYW4gYXhpc1xuICogMS4gSWYgZ2VuZXJhdGlvbk9wdGlvbnMubWluLCBnZW5lcmF0aW9uT3B0aW9ucy5tYXgsIGFuZCBnZW5lcmF0aW9uT3B0aW9ucy5zdGVwIGFyZSBkZWZpbmVkOlxuICogICAgaWYgKG1heCAtIG1pbikgLyBzdGVwIGlzIGFuIGludGVnZXIsIHRpY2tzIGFyZSBnZW5lcmF0ZWQgYXMgW21pbiwgbWluICsgc3RlcCwgLi4uLCBtYXhdXG4gKiAgICBOb3RlIHRoYXQgdGhlIGdlbmVyYXRpb25PcHRpb25zLm1heENvdW50IHNldHRpbmcgaXMgcmVzcGVjdGVkIGluIHRoaXMgc2NlbmFyaW9cbiAqXG4gKiAyLiBJZiBnZW5lcmF0aW9uT3B0aW9ucy5taW4sIGdlbmVyYXRpb25PcHRpb25zLm1heCwgYW5kIGdlbmVyYXRpb25PcHRpb25zLmNvdW50IGlzIGRlZmluZWRcbiAqICAgIHNwYWNpbmcgPSAobWF4IC0gbWluKSAvIGNvdW50XG4gKiAgICBUaWNrcyBhcmUgZ2VuZXJhdGVkIGFzIFttaW4sIG1pbiArIHNwYWNpbmcsIC4uLiwgbWF4XVxuICpcbiAqIDMuIElmIGdlbmVyYXRpb25PcHRpb25zLmNvdW50IGlzIGRlZmluZWRcbiAqICAgIHNwYWNpbmcgPSAobmljZU1heCAtIG5pY2VNaW4pIC8gY291bnRcbiAqXG4gKiA0LiBDb21wdXRlIG9wdGltYWwgc3BhY2luZyBvZiB0aWNrcyB1c2luZyBuaWNlTnVtIGFsZ29yaXRobVxuICpcbiAqIEBwYXJhbSBnZW5lcmF0aW9uT3B0aW9ucyB0aGUgb3B0aW9ucyB1c2VkIHRvIGdlbmVyYXRlIHRoZSB0aWNrc1xuICogQHBhcmFtIGRhdGFSYW5nZSB0aGUgcmFuZ2Ugb2YgdGhlIGRhdGFcbiAqIEByZXR1cm5zIHtvYmplY3RbXX0gYXJyYXkgb2YgdGljayBvYmplY3RzXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlVGlja3MoZ2VuZXJhdGlvbk9wdGlvbnMsIGRhdGFSYW5nZSkge1xuICBjb25zdCB0aWNrcyA9IFtdO1xuICAvLyBUbyBnZXQgYSBcIm5pY2VcIiB2YWx1ZSBmb3IgdGhlIHRpY2sgc3BhY2luZywgd2Ugd2lsbCB1c2UgdGhlIGFwcHJvcHJpYXRlbHkgbmFtZWRcbiAgLy8gXCJuaWNlIG51bWJlclwiIGFsZ29yaXRobS4gU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg1MDY4ODEvbmljZS1sYWJlbC1hbGdvcml0aG0tZm9yLWNoYXJ0cy13aXRoLW1pbmltdW0tdGlja3NcbiAgLy8gZm9yIGRldGFpbHMuXG5cbiAgY29uc3QgTUlOX1NQQUNJTkcgPSAxZS0xNDtcbiAgY29uc3Qge2JvdW5kcywgc3RlcCwgbWluLCBtYXgsIHByZWNpc2lvbiwgY291bnQsIG1heFRpY2tzLCBtYXhEaWdpdHMsIGluY2x1ZGVCb3VuZHN9ID0gZ2VuZXJhdGlvbk9wdGlvbnM7XG4gIGNvbnN0IHVuaXQgPSBzdGVwIHx8IDE7XG4gIGNvbnN0IG1heFNwYWNlcyA9IG1heFRpY2tzIC0gMTtcbiAgY29uc3Qge21pbjogcm1pbiwgbWF4OiBybWF4fSA9IGRhdGFSYW5nZTtcbiAgY29uc3QgbWluRGVmaW5lZCA9ICFpc051bGxPclVuZGVmKG1pbik7XG4gIGNvbnN0IG1heERlZmluZWQgPSAhaXNOdWxsT3JVbmRlZihtYXgpO1xuICBjb25zdCBjb3VudERlZmluZWQgPSAhaXNOdWxsT3JVbmRlZihjb3VudCk7XG4gIGNvbnN0IG1pblNwYWNpbmcgPSAocm1heCAtIHJtaW4pIC8gKG1heERpZ2l0cyArIDEpO1xuICBsZXQgc3BhY2luZyA9IG5pY2VOdW0oKHJtYXggLSBybWluKSAvIG1heFNwYWNlcyAvIHVuaXQpICogdW5pdDtcbiAgbGV0IGZhY3RvciwgbmljZU1pbiwgbmljZU1heCwgbnVtU3BhY2VzO1xuXG4gIC8vIEJleW9uZCBNSU5fU1BBQ0lORyBmbG9hdGluZyBwb2ludCBudW1iZXJzIGJlaW5nIHRvIGxvc2UgcHJlY2lzaW9uXG4gIC8vIHN1Y2ggdGhhdCB3ZSBjYW4ndCBkbyB0aGUgbWF0aCBuZWNlc3NhcnkgdG8gZ2VuZXJhdGUgdGlja3NcbiAgaWYgKHNwYWNpbmcgPCBNSU5fU1BBQ0lORyAmJiAhbWluRGVmaW5lZCAmJiAhbWF4RGVmaW5lZCkge1xuICAgIHJldHVybiBbe3ZhbHVlOiBybWlufSwge3ZhbHVlOiBybWF4fV07XG4gIH1cblxuICBudW1TcGFjZXMgPSBNYXRoLmNlaWwocm1heCAvIHNwYWNpbmcpIC0gTWF0aC5mbG9vcihybWluIC8gc3BhY2luZyk7XG4gIGlmIChudW1TcGFjZXMgPiBtYXhTcGFjZXMpIHtcbiAgICAvLyBJZiB0aGUgY2FsY3VsYXRlZCBudW0gb2Ygc3BhY2VzIGV4Y2VlZHMgbWF4TnVtU3BhY2VzLCByZWNhbGN1bGF0ZSBpdFxuICAgIHNwYWNpbmcgPSBuaWNlTnVtKG51bVNwYWNlcyAqIHNwYWNpbmcgLyBtYXhTcGFjZXMgLyB1bml0KSAqIHVuaXQ7XG4gIH1cblxuICBpZiAoIWlzTnVsbE9yVW5kZWYocHJlY2lzaW9uKSkge1xuICAgIC8vIElmIHRoZSB1c2VyIHNwZWNpZmllZCBhIHByZWNpc2lvbiwgcm91bmQgdG8gdGhhdCBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXNcbiAgICBmYWN0b3IgPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uKTtcbiAgICBzcGFjaW5nID0gTWF0aC5jZWlsKHNwYWNpbmcgKiBmYWN0b3IpIC8gZmFjdG9yO1xuICB9XG5cbiAgaWYgKGJvdW5kcyA9PT0gJ3RpY2tzJykge1xuICAgIG5pY2VNaW4gPSBNYXRoLmZsb29yKHJtaW4gLyBzcGFjaW5nKSAqIHNwYWNpbmc7XG4gICAgbmljZU1heCA9IE1hdGguY2VpbChybWF4IC8gc3BhY2luZykgKiBzcGFjaW5nO1xuICB9IGVsc2Uge1xuICAgIG5pY2VNaW4gPSBybWluO1xuICAgIG5pY2VNYXggPSBybWF4O1xuICB9XG5cbiAgaWYgKG1pbkRlZmluZWQgJiYgbWF4RGVmaW5lZCAmJiBzdGVwICYmIGFsbW9zdFdob2xlKChtYXggLSBtaW4pIC8gc3RlcCwgc3BhY2luZyAvIDEwMDApKSB7XG4gICAgLy8gQ2FzZSAxOiBJZiBtaW4sIG1heCBhbmQgc3RlcFNpemUgYXJlIHNldCBhbmQgdGhleSBtYWtlIGFuIGV2ZW5seSBzcGFjZWQgc2NhbGUgdXNlIGl0LlxuICAgIC8vIHNwYWNpbmcgPSBzdGVwO1xuICAgIC8vIG51bVNwYWNlcyA9IChtYXggLSBtaW4pIC8gc3BhY2luZztcbiAgICAvLyBOb3RlIHRoYXQgd2Ugcm91bmQgaGVyZSB0byBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgYWxtb3N0V2hvbGUgdHJhbnNsYXRlZCBhbiBGUCBlcnJvclxuICAgIG51bVNwYWNlcyA9IE1hdGgucm91bmQoTWF0aC5taW4oKG1heCAtIG1pbikgLyBzcGFjaW5nLCBtYXhUaWNrcykpO1xuICAgIHNwYWNpbmcgPSAobWF4IC0gbWluKSAvIG51bVNwYWNlcztcbiAgICBuaWNlTWluID0gbWluO1xuICAgIG5pY2VNYXggPSBtYXg7XG4gIH0gZWxzZSBpZiAoY291bnREZWZpbmVkKSB7XG4gICAgLy8gQ2FzZXMgMiAmIDMsIHdlIGhhdmUgYSBjb3VudCBzcGVjaWZpZWQuIEhhbmRsZSBvcHRpb25hbCB1c2VyIGRlZmluZWQgZWRnZXMgdG8gdGhlIHJhbmdlLlxuICAgIC8vIFNvbWV0aW1lcyB0aGVzZSBhcmUgbm8tb3BzLCBidXQgaXQgbWFrZXMgdGhlIGNvZGUgYSBsb3QgY2xlYXJlclxuICAgIC8vIGFuZCB3aGVuIGEgdXNlciBkZWZpbmVkIHJhbmdlIGlzIHNwZWNpZmllZCwgd2Ugd2FudCB0aGUgY29ycmVjdCB0aWNrc1xuICAgIG5pY2VNaW4gPSBtaW5EZWZpbmVkID8gbWluIDogbmljZU1pbjtcbiAgICBuaWNlTWF4ID0gbWF4RGVmaW5lZCA/IG1heCA6IG5pY2VNYXg7XG4gICAgbnVtU3BhY2VzID0gY291bnQgLSAxO1xuICAgIHNwYWNpbmcgPSAobmljZU1heCAtIG5pY2VNaW4pIC8gbnVtU3BhY2VzO1xuICB9IGVsc2Uge1xuICAgIC8vIENhc2UgNFxuICAgIG51bVNwYWNlcyA9IChuaWNlTWF4IC0gbmljZU1pbikgLyBzcGFjaW5nO1xuXG4gICAgLy8gSWYgdmVyeSBjbG9zZSB0byBvdXIgcm91bmRlZCB2YWx1ZSwgdXNlIGl0LlxuICAgIGlmIChhbG1vc3RFcXVhbHMobnVtU3BhY2VzLCBNYXRoLnJvdW5kKG51bVNwYWNlcyksIHNwYWNpbmcgLyAxMDAwKSkge1xuICAgICAgbnVtU3BhY2VzID0gTWF0aC5yb3VuZChudW1TcGFjZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBudW1TcGFjZXMgPSBNYXRoLmNlaWwobnVtU3BhY2VzKTtcbiAgICB9XG4gIH1cblxuICAvLyBUaGUgc3BhY2luZyB3aWxsIGhhdmUgY2hhbmdlZCBpbiBjYXNlcyAxLCAyLCBhbmQgMyBzbyB0aGUgZmFjdG9yIGNhbm5vdCBiZSBjb21wdXRlZFxuICAvLyB1bnRpbCB0aGlzIHBvaW50XG4gIGNvbnN0IGRlY2ltYWxQbGFjZXMgPSBNYXRoLm1heChcbiAgICBfZGVjaW1hbFBsYWNlcyhzcGFjaW5nKSxcbiAgICBfZGVjaW1hbFBsYWNlcyhuaWNlTWluKVxuICApO1xuICBmYWN0b3IgPSBNYXRoLnBvdygxMCwgaXNOdWxsT3JVbmRlZihwcmVjaXNpb24pID8gZGVjaW1hbFBsYWNlcyA6IHByZWNpc2lvbik7XG4gIG5pY2VNaW4gPSBNYXRoLnJvdW5kKG5pY2VNaW4gKiBmYWN0b3IpIC8gZmFjdG9yO1xuICBuaWNlTWF4ID0gTWF0aC5yb3VuZChuaWNlTWF4ICogZmFjdG9yKSAvIGZhY3RvcjtcblxuICBsZXQgaiA9IDA7XG4gIGlmIChtaW5EZWZpbmVkKSB7XG4gICAgaWYgKGluY2x1ZGVCb3VuZHMgJiYgbmljZU1pbiAhPT0gbWluKSB7XG4gICAgICB0aWNrcy5wdXNoKHt2YWx1ZTogbWlufSk7XG5cbiAgICAgIGlmIChuaWNlTWluIDwgbWluKSB7XG4gICAgICAgIGorKzsgLy8gU2tpcCBuaWNlTWluXG4gICAgICB9XG4gICAgICAvLyBJZiB0aGUgbmV4dCBuaWNlIHRpY2sgaXMgY2xvc2UgdG8gbWluLCBza2lwIGl0XG4gICAgICBpZiAoYWxtb3N0RXF1YWxzKE1hdGgucm91bmQoKG5pY2VNaW4gKyBqICogc3BhY2luZykgKiBmYWN0b3IpIC8gZmFjdG9yLCBtaW4sIHJlbGF0aXZlTGFiZWxTaXplKG1pbiwgbWluU3BhY2luZywgZ2VuZXJhdGlvbk9wdGlvbnMpKSkge1xuICAgICAgICBqKys7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuaWNlTWluIDwgbWluKSB7XG4gICAgICBqKys7XG4gICAgfVxuICB9XG5cbiAgZm9yICg7IGogPCBudW1TcGFjZXM7ICsraikge1xuICAgIGNvbnN0IHRpY2tWYWx1ZSA9IE1hdGgucm91bmQoKG5pY2VNaW4gKyBqICogc3BhY2luZykgKiBmYWN0b3IpIC8gZmFjdG9yO1xuICAgIGlmIChtYXhEZWZpbmVkICYmIHRpY2tWYWx1ZSA+IG1heCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRpY2tzLnB1c2goe3ZhbHVlOiB0aWNrVmFsdWV9KTtcbiAgfVxuXG4gIGlmIChtYXhEZWZpbmVkICYmIGluY2x1ZGVCb3VuZHMgJiYgbmljZU1heCAhPT0gbWF4KSB7XG4gICAgLy8gSWYgdGhlIHByZXZpb3VzIHRpY2sgaXMgdG9vIGNsb3NlIHRvIG1heCwgcmVwbGFjZSBpdCB3aXRoIG1heCwgZWxzZSBhZGQgbWF4XG4gICAgaWYgKHRpY2tzLmxlbmd0aCAmJiBhbG1vc3RFcXVhbHModGlja3NbdGlja3MubGVuZ3RoIC0gMV0udmFsdWUsIG1heCwgcmVsYXRpdmVMYWJlbFNpemUobWF4LCBtaW5TcGFjaW5nLCBnZW5lcmF0aW9uT3B0aW9ucykpKSB7XG4gICAgICB0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52YWx1ZSA9IG1heDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGlja3MucHVzaCh7dmFsdWU6IG1heH0pO1xuICAgIH1cbiAgfSBlbHNlIGlmICghbWF4RGVmaW5lZCB8fCBuaWNlTWF4ID09PSBtYXgpIHtcbiAgICB0aWNrcy5wdXNoKHt2YWx1ZTogbmljZU1heH0pO1xuICB9XG5cbiAgcmV0dXJuIHRpY2tzO1xufVxuXG5mdW5jdGlvbiByZWxhdGl2ZUxhYmVsU2l6ZSh2YWx1ZSwgbWluU3BhY2luZywge2hvcml6b250YWwsIG1pblJvdGF0aW9ufSkge1xuICBjb25zdCByYWQgPSB0b1JhZGlhbnMobWluUm90YXRpb24pO1xuICBjb25zdCByYXRpbyA9IChob3Jpem9udGFsID8gTWF0aC5zaW4ocmFkKSA6IE1hdGguY29zKHJhZCkpIHx8IDAuMDAxO1xuICBjb25zdCBsZW5ndGggPSAwLjc1ICogbWluU3BhY2luZyAqICgnJyArIHZhbHVlKS5sZW5ndGg7XG4gIHJldHVybiBNYXRoLm1pbihtaW5TcGFjaW5nIC8gcmF0aW8sIGxlbmd0aCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpbmVhclNjYWxlQmFzZSBleHRlbmRzIFNjYWxlIHtcblxuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcihjZmcpO1xuXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5zdGFydCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLmVuZCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLl9zdGFydFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuX2VuZFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSAwO1xuICB9XG5cbiAgcGFyc2UocmF3LCBpbmRleCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgaWYgKGlzTnVsbE9yVW5kZWYocmF3KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICgodHlwZW9mIHJhdyA9PT0gJ251bWJlcicgfHwgcmF3IGluc3RhbmNlb2YgTnVtYmVyKSAmJiAhaXNGaW5pdGUoK3JhdykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiArcmF3O1xuICB9XG5cbiAgaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpIHtcbiAgICBjb25zdCB7YmVnaW5BdFplcm99ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHttaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHRoaXMuZ2V0VXNlckJvdW5kcygpO1xuICAgIGxldCB7bWluLCBtYXh9ID0gdGhpcztcblxuICAgIGNvbnN0IHNldE1pbiA9IHYgPT4gKG1pbiA9IG1pbkRlZmluZWQgPyBtaW4gOiB2KTtcbiAgICBjb25zdCBzZXRNYXggPSB2ID0+IChtYXggPSBtYXhEZWZpbmVkID8gbWF4IDogdik7XG5cbiAgICBpZiAoYmVnaW5BdFplcm8pIHtcbiAgICAgIGNvbnN0IG1pblNpZ24gPSBzaWduKG1pbik7XG4gICAgICBjb25zdCBtYXhTaWduID0gc2lnbihtYXgpO1xuXG4gICAgICBpZiAobWluU2lnbiA8IDAgJiYgbWF4U2lnbiA8IDApIHtcbiAgICAgICAgc2V0TWF4KDApO1xuICAgICAgfSBlbHNlIGlmIChtaW5TaWduID4gMCAmJiBtYXhTaWduID4gMCkge1xuICAgICAgICBzZXRNaW4oMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1pbiA9PT0gbWF4KSB7XG4gICAgICBsZXQgb2Zmc2V0ID0gbWF4ID09PSAwID8gMSA6IE1hdGguYWJzKG1heCAqIDAuMDUpO1xuXG4gICAgICBzZXRNYXgobWF4ICsgb2Zmc2V0KTtcblxuICAgICAgaWYgKCFiZWdpbkF0WmVybykge1xuICAgICAgICBzZXRNaW4obWluIC0gb2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5taW4gPSBtaW47XG4gICAgdGhpcy5tYXggPSBtYXg7XG4gIH1cblxuICBnZXRUaWNrTGltaXQoKSB7XG4gICAgY29uc3QgdGlja09wdHMgPSB0aGlzLm9wdGlvbnMudGlja3M7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICAgIGxldCB7bWF4VGlja3NMaW1pdCwgc3RlcFNpemV9ID0gdGlja09wdHM7XG4gICAgbGV0IG1heFRpY2tzO1xuXG4gICAgaWYgKHN0ZXBTaXplKSB7XG4gICAgICBtYXhUaWNrcyA9IE1hdGguY2VpbCh0aGlzLm1heCAvIHN0ZXBTaXplKSAtIE1hdGguZmxvb3IodGhpcy5taW4gLyBzdGVwU2l6ZSkgKyAxO1xuICAgICAgaWYgKG1heFRpY2tzID4gMTAwMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oYHNjYWxlcy4ke3RoaXMuaWR9LnRpY2tzLnN0ZXBTaXplOiAke3N0ZXBTaXplfSB3b3VsZCByZXN1bHQgZ2VuZXJhdGluZyB1cCB0byAke21heFRpY2tzfSB0aWNrcy4gTGltaXRpbmcgdG8gMTAwMC5gKTtcbiAgICAgICAgbWF4VGlja3MgPSAxMDAwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtYXhUaWNrcyA9IHRoaXMuY29tcHV0ZVRpY2tMaW1pdCgpO1xuICAgICAgbWF4VGlja3NMaW1pdCA9IG1heFRpY2tzTGltaXQgfHwgMTE7XG4gICAgfVxuXG4gICAgaWYgKG1heFRpY2tzTGltaXQpIHtcbiAgICAgIG1heFRpY2tzID0gTWF0aC5taW4obWF4VGlja3NMaW1pdCwgbWF4VGlja3MpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXhUaWNrcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBjb21wdXRlVGlja0xpbWl0KCkge1xuICAgIHJldHVybiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gIH1cblxuICBidWlsZFRpY2tzKCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xuXG4gICAgLy8gRmlndXJlIG91dCB3aGF0IHRoZSBtYXggbnVtYmVyIG9mIHRpY2tzIHdlIGNhbiBzdXBwb3J0IGl0IGlzIGJhc2VkIG9uIHRoZSBzaXplIG9mXG4gICAgLy8gdGhlIGF4aXMgYXJlYS4gRm9yIG5vdywgd2Ugc2F5IHRoYXQgdGhlIG1pbmltdW0gdGljayBzcGFjaW5nIGluIHBpeGVscyBtdXN0IGJlIDQwXG4gICAgLy8gV2UgYWxzbyBsaW1pdCB0aGUgbWF4aW11bSBudW1iZXIgb2YgdGlja3MgdG8gMTEgd2hpY2ggZ2l2ZXMgYSBuaWNlIDEwIHNxdWFyZXMgb25cbiAgICAvLyB0aGUgZ3JhcGguIE1ha2Ugc3VyZSB3ZSBhbHdheXMgaGF2ZSBhdCBsZWFzdCAyIHRpY2tzXG4gICAgbGV0IG1heFRpY2tzID0gdGhpcy5nZXRUaWNrTGltaXQoKTtcbiAgICBtYXhUaWNrcyA9IE1hdGgubWF4KDIsIG1heFRpY2tzKTtcblxuICAgIGNvbnN0IG51bWVyaWNHZW5lcmF0b3JPcHRpb25zID0ge1xuICAgICAgbWF4VGlja3MsXG4gICAgICBib3VuZHM6IG9wdHMuYm91bmRzLFxuICAgICAgbWluOiBvcHRzLm1pbixcbiAgICAgIG1heDogb3B0cy5tYXgsXG4gICAgICBwcmVjaXNpb246IHRpY2tPcHRzLnByZWNpc2lvbixcbiAgICAgIHN0ZXA6IHRpY2tPcHRzLnN0ZXBTaXplLFxuICAgICAgY291bnQ6IHRpY2tPcHRzLmNvdW50LFxuICAgICAgbWF4RGlnaXRzOiB0aGlzLl9tYXhEaWdpdHMoKSxcbiAgICAgIGhvcml6b250YWw6IHRoaXMuaXNIb3Jpem9udGFsKCksXG4gICAgICBtaW5Sb3RhdGlvbjogdGlja09wdHMubWluUm90YXRpb24gfHwgMCxcbiAgICAgIGluY2x1ZGVCb3VuZHM6IHRpY2tPcHRzLmluY2x1ZGVCb3VuZHMgIT09IGZhbHNlXG4gICAgfTtcbiAgICBjb25zdCBkYXRhUmFuZ2UgPSB0aGlzLl9yYW5nZSB8fCB0aGlzO1xuICAgIGNvbnN0IHRpY2tzID0gZ2VuZXJhdGVUaWNrcyhudW1lcmljR2VuZXJhdG9yT3B0aW9ucywgZGF0YVJhbmdlKTtcblxuICAgIC8vIEF0IHRoaXMgcG9pbnQsIHdlIG5lZWQgdG8gdXBkYXRlIG91ciBtYXggYW5kIG1pbiBnaXZlbiB0aGUgdGljayB2YWx1ZXMsXG4gICAgLy8gc2luY2Ugd2UgcHJvYmFibHkgaGF2ZSBleHBhbmRlZCB0aGUgcmFuZ2Ugb2YgdGhlIHNjYWxlXG4gICAgaWYgKG9wdHMuYm91bmRzID09PSAndGlja3MnKSB7XG4gICAgICBfc2V0TWluQW5kTWF4QnlLZXkodGlja3MsIHRoaXMsICd2YWx1ZScpO1xuICAgIH1cblxuICAgIGlmIChvcHRzLnJldmVyc2UpIHtcbiAgICAgIHRpY2tzLnJldmVyc2UoKTtcblxuICAgICAgdGhpcy5zdGFydCA9IHRoaXMubWF4O1xuICAgICAgdGhpcy5lbmQgPSB0aGlzLm1pbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGFydCA9IHRoaXMubWluO1xuICAgICAgdGhpcy5lbmQgPSB0aGlzLm1heDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGlja3M7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgY29uZmlndXJlKCkge1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICBsZXQgc3RhcnQgPSB0aGlzLm1pbjtcbiAgICBsZXQgZW5kID0gdGhpcy5tYXg7XG5cbiAgICBzdXBlci5jb25maWd1cmUoKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMub2Zmc2V0ICYmIHRpY2tzLmxlbmd0aCkge1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gKGVuZCAtIHN0YXJ0KSAvIE1hdGgubWF4KHRpY2tzLmxlbmd0aCAtIDEsIDEpIC8gMjtcbiAgICAgIHN0YXJ0IC09IG9mZnNldDtcbiAgICAgIGVuZCArPSBvZmZzZXQ7XG4gICAgfVxuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSBzdGFydDtcbiAgICB0aGlzLl9lbmRWYWx1ZSA9IGVuZDtcbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gZW5kIC0gc3RhcnQ7XG4gIH1cblxuICBnZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZvcm1hdE51bWJlcih2YWx1ZSwgdGhpcy5jaGFydC5vcHRpb25zLmxvY2FsZSwgdGhpcy5vcHRpb25zLnRpY2tzLmZvcm1hdCk7XG4gIH1cbn1cbiIsImltcG9ydCB7aXNGaW5pdGV9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCBMaW5lYXJTY2FsZUJhc2UgZnJvbSAnLi9zY2FsZS5saW5lYXJiYXNlLmpzJztcbmltcG9ydCBUaWNrcyBmcm9tICcuLi9jb3JlL2NvcmUudGlja3MuanMnO1xuaW1wb3J0IHt0b1JhZGlhbnN9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaW5lYXJTY2FsZSBleHRlbmRzIExpbmVhclNjYWxlQmFzZSB7XG5cbiAgc3RhdGljIGlkID0gJ2xpbmVhcic7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgdGlja3M6IHtcbiAgICAgIGNhbGxiYWNrOiBUaWNrcy5mb3JtYXR0ZXJzLm51bWVyaWNcbiAgICB9XG4gIH07XG5cblxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgIGNvbnN0IHttaW4sIG1heH0gPSB0aGlzLmdldE1pbk1heCh0cnVlKTtcblxuICAgIHRoaXMubWluID0gaXNGaW5pdGUobWluKSA/IG1pbiA6IDA7XG4gICAgdGhpcy5tYXggPSBpc0Zpbml0ZShtYXgpID8gbWF4IDogMTtcblxuICAgIC8vIENvbW1vbiBiYXNlIGltcGxlbWVudGF0aW9uIHRvIGhhbmRsZSBtaW4sIG1heCwgYmVnaW5BdFplcm9cbiAgICB0aGlzLmhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG51bWJlciBvZiB0aWNrcyBiYXNlZCBvbiB0aGUgc2NhbGUgZGltZW5zaW9uXG5cdCAqIEBwcm90ZWN0ZWRcbiBcdCAqL1xuICBjb21wdXRlVGlja0xpbWl0KCkge1xuICAgIGNvbnN0IGhvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IGxlbmd0aCA9IGhvcml6b250YWwgPyB0aGlzLndpZHRoIDogdGhpcy5oZWlnaHQ7XG4gICAgY29uc3QgbWluUm90YXRpb24gPSB0b1JhZGlhbnModGhpcy5vcHRpb25zLnRpY2tzLm1pblJvdGF0aW9uKTtcbiAgICBjb25zdCByYXRpbyA9IChob3Jpem9udGFsID8gTWF0aC5zaW4obWluUm90YXRpb24pIDogTWF0aC5jb3MobWluUm90YXRpb24pKSB8fCAwLjAwMTtcbiAgICBjb25zdCB0aWNrRm9udCA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoMCk7XG4gICAgcmV0dXJuIE1hdGguY2VpbChsZW5ndGggLyBNYXRoLm1pbig0MCwgdGlja0ZvbnQubGluZUhlaWdodCAvIHJhdGlvKSk7XG4gIH1cblxuICAvLyBVdGlsc1xuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gTmFOIDogdGhpcy5nZXRQaXhlbEZvckRlY2ltYWwoKHZhbHVlIC0gdGhpcy5fc3RhcnRWYWx1ZSkgLyB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxuXG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhcnRWYWx1ZSArIHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAqIHRoaXMuX3ZhbHVlUmFuZ2U7XG4gIH1cbn1cbiIsImltcG9ydCB7ZmluaXRlT3JEZWZhdWx0LCBpc0Zpbml0ZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHtmb3JtYXROdW1iZXJ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5pbnRsLmpzJztcbmltcG9ydCB7X3NldE1pbkFuZE1heEJ5S2V5LCBsb2cxMH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IFNjYWxlIGZyb20gJy4uL2NvcmUvY29yZS5zY2FsZS5qcyc7XG5pbXBvcnQgTGluZWFyU2NhbGVCYXNlIGZyb20gJy4vc2NhbGUubGluZWFyYmFzZS5qcyc7XG5pbXBvcnQgVGlja3MgZnJvbSAnLi4vY29yZS9jb3JlLnRpY2tzLmpzJztcblxuY29uc3QgbG9nMTBGbG9vciA9IHYgPT4gTWF0aC5mbG9vcihsb2cxMCh2KSk7XG5jb25zdCBjaGFuZ2VFeHBvbmVudCA9ICh2LCBtKSA9PiBNYXRoLnBvdygxMCwgbG9nMTBGbG9vcih2KSArIG0pO1xuXG5mdW5jdGlvbiBpc01ham9yKHRpY2tWYWwpIHtcbiAgY29uc3QgcmVtYWluID0gdGlja1ZhbCAvIChNYXRoLnBvdygxMCwgbG9nMTBGbG9vcih0aWNrVmFsKSkpO1xuICByZXR1cm4gcmVtYWluID09PSAxO1xufVxuXG5mdW5jdGlvbiBzdGVwcyhtaW4sIG1heCwgcmFuZ2VFeHApIHtcbiAgY29uc3QgcmFuZ2VTdGVwID0gTWF0aC5wb3coMTAsIHJhbmdlRXhwKTtcbiAgY29uc3Qgc3RhcnQgPSBNYXRoLmZsb29yKG1pbiAvIHJhbmdlU3RlcCk7XG4gIGNvbnN0IGVuZCA9IE1hdGguY2VpbChtYXggLyByYW5nZVN0ZXApO1xuICByZXR1cm4gZW5kIC0gc3RhcnQ7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0RXhwKG1pbiwgbWF4KSB7XG4gIGNvbnN0IHJhbmdlID0gbWF4IC0gbWluO1xuICBsZXQgcmFuZ2VFeHAgPSBsb2cxMEZsb29yKHJhbmdlKTtcbiAgd2hpbGUgKHN0ZXBzKG1pbiwgbWF4LCByYW5nZUV4cCkgPiAxMCkge1xuICAgIHJhbmdlRXhwKys7XG4gIH1cbiAgd2hpbGUgKHN0ZXBzKG1pbiwgbWF4LCByYW5nZUV4cCkgPCAxMCkge1xuICAgIHJhbmdlRXhwLS07XG4gIH1cbiAgcmV0dXJuIE1hdGgubWluKHJhbmdlRXhwLCBsb2cxMEZsb29yKG1pbikpO1xufVxuXG5cbi8qKlxuICogR2VuZXJhdGUgYSBzZXQgb2YgbG9nYXJpdGhtaWMgdGlja3NcbiAqIEBwYXJhbSBnZW5lcmF0aW9uT3B0aW9ucyB0aGUgb3B0aW9ucyB1c2VkIHRvIGdlbmVyYXRlIHRoZSB0aWNrc1xuICogQHBhcmFtIGRhdGFSYW5nZSB0aGUgcmFuZ2Ugb2YgdGhlIGRhdGFcbiAqIEByZXR1cm5zIHtvYmplY3RbXX0gYXJyYXkgb2YgdGljayBvYmplY3RzXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlVGlja3MoZ2VuZXJhdGlvbk9wdGlvbnMsIHttaW4sIG1heH0pIHtcbiAgbWluID0gZmluaXRlT3JEZWZhdWx0KGdlbmVyYXRpb25PcHRpb25zLm1pbiwgbWluKTtcbiAgY29uc3QgdGlja3MgPSBbXTtcbiAgY29uc3QgbWluRXhwID0gbG9nMTBGbG9vcihtaW4pO1xuICBsZXQgZXhwID0gc3RhcnRFeHAobWluLCBtYXgpO1xuICBsZXQgcHJlY2lzaW9uID0gZXhwIDwgMCA/IE1hdGgucG93KDEwLCBNYXRoLmFicyhleHApKSA6IDE7XG4gIGNvbnN0IHN0ZXBTaXplID0gTWF0aC5wb3coMTAsIGV4cCk7XG4gIGNvbnN0IGJhc2UgPSBtaW5FeHAgPiBleHAgPyBNYXRoLnBvdygxMCwgbWluRXhwKSA6IDA7XG4gIGNvbnN0IHN0YXJ0ID0gTWF0aC5yb3VuZCgobWluIC0gYmFzZSkgKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uO1xuICBjb25zdCBvZmZzZXQgPSBNYXRoLmZsb29yKChtaW4gLSBiYXNlKSAvIHN0ZXBTaXplIC8gMTApICogc3RlcFNpemUgKiAxMDtcbiAgbGV0IHNpZ25pZmljYW5kID0gTWF0aC5mbG9vcigoc3RhcnQgLSBvZmZzZXQpIC8gTWF0aC5wb3coMTAsIGV4cCkpO1xuICBsZXQgdmFsdWUgPSBmaW5pdGVPckRlZmF1bHQoZ2VuZXJhdGlvbk9wdGlvbnMubWluLCBNYXRoLnJvdW5kKChiYXNlICsgb2Zmc2V0ICsgc2lnbmlmaWNhbmQgKiBNYXRoLnBvdygxMCwgZXhwKSkgKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uKTtcbiAgd2hpbGUgKHZhbHVlIDwgbWF4KSB7XG4gICAgdGlja3MucHVzaCh7dmFsdWUsIG1ham9yOiBpc01ham9yKHZhbHVlKSwgc2lnbmlmaWNhbmR9KTtcbiAgICBpZiAoc2lnbmlmaWNhbmQgPj0gMTApIHtcbiAgICAgIHNpZ25pZmljYW5kID0gc2lnbmlmaWNhbmQgPCAxNSA/IDE1IDogMjA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNpZ25pZmljYW5kKys7XG4gICAgfVxuICAgIGlmIChzaWduaWZpY2FuZCA+PSAyMCkge1xuICAgICAgZXhwKys7XG4gICAgICBzaWduaWZpY2FuZCA9IDI7XG4gICAgICBwcmVjaXNpb24gPSBleHAgPj0gMCA/IDEgOiBwcmVjaXNpb247XG4gICAgfVxuICAgIHZhbHVlID0gTWF0aC5yb3VuZCgoYmFzZSArIG9mZnNldCArIHNpZ25pZmljYW5kICogTWF0aC5wb3coMTAsIGV4cCkpICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbjtcbiAgfVxuICBjb25zdCBsYXN0VGljayA9IGZpbml0ZU9yRGVmYXVsdChnZW5lcmF0aW9uT3B0aW9ucy5tYXgsIHZhbHVlKTtcbiAgdGlja3MucHVzaCh7dmFsdWU6IGxhc3RUaWNrLCBtYWpvcjogaXNNYWpvcihsYXN0VGljayksIHNpZ25pZmljYW5kfSk7XG5cbiAgcmV0dXJuIHRpY2tzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMb2dhcml0aG1pY1NjYWxlIGV4dGVuZHMgU2NhbGUge1xuXG4gIHN0YXRpYyBpZCA9ICdsb2dhcml0aG1pYyc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgdGlja3M6IHtcbiAgICAgIGNhbGxiYWNrOiBUaWNrcy5mb3JtYXR0ZXJzLmxvZ2FyaXRobWljLFxuICAgICAgbWFqb3I6IHtcbiAgICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuXG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKGNmZyk7XG5cbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLnN0YXJ0ID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuZW5kID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IDA7XG4gIH1cblxuICBwYXJzZShyYXcsIGluZGV4KSB7XG4gICAgY29uc3QgdmFsdWUgPSBMaW5lYXJTY2FsZUJhc2UucHJvdG90eXBlLnBhcnNlLmFwcGx5KHRoaXMsIFtyYXcsIGluZGV4XSk7XG4gICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICB0aGlzLl96ZXJvID0gdHJ1ZTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBpc0Zpbml0ZSh2YWx1ZSkgJiYgdmFsdWUgPiAwID8gdmFsdWUgOiBudWxsO1xuICB9XG5cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICBjb25zdCB7bWluLCBtYXh9ID0gdGhpcy5nZXRNaW5NYXgodHJ1ZSk7XG5cbiAgICB0aGlzLm1pbiA9IGlzRmluaXRlKG1pbikgPyBNYXRoLm1heCgwLCBtaW4pIDogbnVsbDtcbiAgICB0aGlzLm1heCA9IGlzRmluaXRlKG1heCkgPyBNYXRoLm1heCgwLCBtYXgpIDogbnVsbDtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuYmVnaW5BdFplcm8pIHtcbiAgICAgIHRoaXMuX3plcm8gPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIGlmIGRhdGEgaGFzIGAwYCBpbiBpdCBvciBgYmVnaW5BdFplcm9gIGlzIHRydWUsIG1pbiAobm9uIHplcm8pIHZhbHVlIGlzIGF0IGJvdHRvbVxuICAgIC8vIG9mIHNjYWxlLCBhbmQgaXQgZG9lcyBub3QgZXF1YWwgc3VnZ2VzdGVkTWluLCBsb3dlciB0aGUgbWluIGJvdW5kIGJ5IG9uZSBleHAuXG4gICAgaWYgKHRoaXMuX3plcm8gJiYgdGhpcy5taW4gIT09IHRoaXMuX3N1Z2dlc3RlZE1pbiAmJiAhaXNGaW5pdGUodGhpcy5fdXNlck1pbikpIHtcbiAgICAgIHRoaXMubWluID0gbWluID09PSBjaGFuZ2VFeHBvbmVudCh0aGlzLm1pbiwgMCkgPyBjaGFuZ2VFeHBvbmVudCh0aGlzLm1pbiwgLTEpIDogY2hhbmdlRXhwb25lbnQodGhpcy5taW4sIDApO1xuICAgIH1cblxuICAgIHRoaXMuaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpO1xuICB9XG5cbiAgaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpIHtcbiAgICBjb25zdCB7bWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcbiAgICBsZXQgbWluID0gdGhpcy5taW47XG4gICAgbGV0IG1heCA9IHRoaXMubWF4O1xuXG4gICAgY29uc3Qgc2V0TWluID0gdiA9PiAobWluID0gbWluRGVmaW5lZCA/IG1pbiA6IHYpO1xuICAgIGNvbnN0IHNldE1heCA9IHYgPT4gKG1heCA9IG1heERlZmluZWQgPyBtYXggOiB2KTtcblxuICAgIGlmIChtaW4gPT09IG1heCkge1xuICAgICAgaWYgKG1pbiA8PSAwKSB7IC8vIGluY2x1ZGVzIG51bGxcbiAgICAgICAgc2V0TWluKDEpO1xuICAgICAgICBzZXRNYXgoMTApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0TWluKGNoYW5nZUV4cG9uZW50KG1pbiwgLTEpKTtcbiAgICAgICAgc2V0TWF4KGNoYW5nZUV4cG9uZW50KG1heCwgKzEpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1pbiA8PSAwKSB7XG4gICAgICBzZXRNaW4oY2hhbmdlRXhwb25lbnQobWF4LCAtMSkpO1xuICAgIH1cbiAgICBpZiAobWF4IDw9IDApIHtcblxuICAgICAgc2V0TWF4KGNoYW5nZUV4cG9uZW50KG1pbiwgKzEpKTtcbiAgICB9XG5cbiAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICB0aGlzLm1heCA9IG1heDtcbiAgfVxuXG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcblxuICAgIGNvbnN0IGdlbmVyYXRpb25PcHRpb25zID0ge1xuICAgICAgbWluOiB0aGlzLl91c2VyTWluLFxuICAgICAgbWF4OiB0aGlzLl91c2VyTWF4XG4gICAgfTtcbiAgICBjb25zdCB0aWNrcyA9IGdlbmVyYXRlVGlja3MoZ2VuZXJhdGlvbk9wdGlvbnMsIHRoaXMpO1xuXG4gICAgLy8gQXQgdGhpcyBwb2ludCwgd2UgbmVlZCB0byB1cGRhdGUgb3VyIG1heCBhbmQgbWluIGdpdmVuIHRoZSB0aWNrIHZhbHVlcyxcbiAgICAvLyBzaW5jZSB3ZSBwcm9iYWJseSBoYXZlIGV4cGFuZGVkIHRoZSByYW5nZSBvZiB0aGUgc2NhbGVcbiAgICBpZiAob3B0cy5ib3VuZHMgPT09ICd0aWNrcycpIHtcbiAgICAgIF9zZXRNaW5BbmRNYXhCeUtleSh0aWNrcywgdGhpcywgJ3ZhbHVlJyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMucmV2ZXJzZSkge1xuICAgICAgdGlja3MucmV2ZXJzZSgpO1xuXG4gICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5tYXg7XG4gICAgICB0aGlzLmVuZCA9IHRoaXMubWluO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5taW47XG4gICAgICB0aGlzLmVuZCA9IHRoaXMubWF4O1xuICAgIH1cblxuICAgIHJldHVybiB0aWNrcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkXG4gICAgICA/ICcwJ1xuICAgICAgOiBmb3JtYXROdW1iZXIodmFsdWUsIHRoaXMuY2hhcnQub3B0aW9ucy5sb2NhbGUsIHRoaXMub3B0aW9ucy50aWNrcy5mb3JtYXQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMubWluO1xuXG4gICAgc3VwZXIuY29uZmlndXJlKCk7XG5cbiAgICB0aGlzLl9zdGFydFZhbHVlID0gbG9nMTAoc3RhcnQpO1xuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSBsb2cxMCh0aGlzLm1heCkgLSBsb2cxMChzdGFydCk7XG4gIH1cblxuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IDApIHtcbiAgICAgIHZhbHVlID0gdGhpcy5taW47XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCBpc05hTih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yRGVjaW1hbCh2YWx1ZSA9PT0gdGhpcy5taW5cbiAgICAgID8gMFxuICAgICAgOiAobG9nMTAodmFsdWUpIC0gdGhpcy5fc3RhcnRWYWx1ZSkgLyB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxuXG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICBjb25zdCBkZWNpbWFsID0gdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpO1xuICAgIHJldHVybiBNYXRoLnBvdygxMCwgdGhpcy5fc3RhcnRWYWx1ZSArIGRlY2ltYWwgKiB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxufVxuIiwiaW1wb3J0IGRlZmF1bHRzIGZyb20gJy4uL2NvcmUvY29yZS5kZWZhdWx0cy5qcyc7XG5pbXBvcnQge19sb25nZXN0VGV4dCwgYWRkUm91bmRlZFJlY3RQYXRoLCByZW5kZXJUZXh0LCBfaXNQb2ludEluQXJlYX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNhbnZhcy5qcyc7XG5pbXBvcnQge0hBTEZfUEksIFRBVSwgdG9EZWdyZWVzLCB0b1JhZGlhbnMsIF9ub3JtYWxpemVBbmdsZSwgUEl9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5tYXRoLmpzJztcbmltcG9ydCBMaW5lYXJTY2FsZUJhc2UgZnJvbSAnLi9zY2FsZS5saW5lYXJiYXNlLmpzJztcbmltcG9ydCBUaWNrcyBmcm9tICcuLi9jb3JlL2NvcmUudGlja3MuanMnO1xuaW1wb3J0IHt2YWx1ZU9yRGVmYXVsdCwgaXNBcnJheSwgaXNGaW5pdGUsIGNhbGxiYWNrIGFzIGNhbGxDYWxsYmFjaywgaXNOdWxsT3JVbmRlZn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHtjcmVhdGVDb250ZXh0LCB0b0ZvbnQsIHRvUGFkZGluZywgdG9UUkJMQ29ybmVyc30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm9wdGlvbnMuanMnO1xuXG5mdW5jdGlvbiBnZXRUaWNrQmFja2Ryb3BIZWlnaHQob3B0cykge1xuICBjb25zdCB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG5cbiAgaWYgKHRpY2tPcHRzLmRpc3BsYXkgJiYgb3B0cy5kaXNwbGF5KSB7XG4gICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyh0aWNrT3B0cy5iYWNrZHJvcFBhZGRpbmcpO1xuICAgIHJldHVybiB2YWx1ZU9yRGVmYXVsdCh0aWNrT3B0cy5mb250ICYmIHRpY2tPcHRzLmZvbnQuc2l6ZSwgZGVmYXVsdHMuZm9udC5zaXplKSArIHBhZGRpbmcuaGVpZ2h0O1xuICB9XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBtZWFzdXJlTGFiZWxTaXplKGN0eCwgZm9udCwgbGFiZWwpIHtcbiAgbGFiZWwgPSBpc0FycmF5KGxhYmVsKSA/IGxhYmVsIDogW2xhYmVsXTtcbiAgcmV0dXJuIHtcbiAgICB3OiBfbG9uZ2VzdFRleHQoY3R4LCBmb250LnN0cmluZywgbGFiZWwpLFxuICAgIGg6IGxhYmVsLmxlbmd0aCAqIGZvbnQubGluZUhlaWdodFxuICB9O1xufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmVMaW1pdHMoYW5nbGUsIHBvcywgc2l6ZSwgbWluLCBtYXgpIHtcbiAgaWYgKGFuZ2xlID09PSBtaW4gfHwgYW5nbGUgPT09IG1heCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogcG9zIC0gKHNpemUgLyAyKSxcbiAgICAgIGVuZDogcG9zICsgKHNpemUgLyAyKVxuICAgIH07XG4gIH0gZWxzZSBpZiAoYW5nbGUgPCBtaW4gfHwgYW5nbGUgPiBtYXgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IHBvcyAtIHNpemUsXG4gICAgICBlbmQ6IHBvc1xuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBwb3MsXG4gICAgZW5kOiBwb3MgKyBzaXplXG4gIH07XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGZpdCBhIHJhZGlhbCBsaW5lYXIgc2NhbGUgd2l0aCBwb2ludCBsYWJlbHNcbiAqL1xuZnVuY3Rpb24gZml0V2l0aFBvaW50TGFiZWxzKHNjYWxlKSB7XG5cbiAgLy8gUmlnaHQsIHRoaXMgaXMgcmVhbGx5IGNvbmZ1c2luZyBhbmQgdGhlcmUgaXMgYSBsb3Qgb2YgbWF0aHMgZ29pbmcgb24gaGVyZVxuICAvLyBUaGUgZ2lzdCBvZiB0aGUgcHJvYmxlbSBpcyBoZXJlOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9ubm5pY2svNjk2Y2M5YzU1ZjRiMGJlYjhmZTlcbiAgLy9cbiAgLy8gUmVhY3Rpb246IGh0dHBzOi8vZGwuZHJvcGJveHVzZXJjb250ZW50LmNvbS91LzM0NjAxMzYzL3Rvb211Y2hzY2llbmNlLmdpZlxuICAvL1xuICAvLyBTb2x1dGlvbjpcbiAgLy9cbiAgLy8gV2UgYXNzdW1lIHRoZSByYWRpdXMgb2YgdGhlIHBvbHlnb24gaXMgaGFsZiB0aGUgc2l6ZSBvZiB0aGUgY2FudmFzIGF0IGZpcnN0XG4gIC8vIGF0IGVhY2ggaW5kZXggd2UgY2hlY2sgaWYgdGhlIHRleHQgb3ZlcmxhcHMuXG4gIC8vXG4gIC8vIFdoZXJlIGl0IGRvZXMsIHdlIHN0b3JlIHRoYXQgYW5nbGUgYW5kIHRoYXQgaW5kZXguXG4gIC8vXG4gIC8vIEFmdGVyIGZpbmRpbmcgdGhlIGxhcmdlc3QgaW5kZXggYW5kIGFuZ2xlIHdlIGNhbGN1bGF0ZSBob3cgbXVjaCB3ZSBuZWVkIHRvIHJlbW92ZVxuICAvLyBmcm9tIHRoZSBzaGFwZSByYWRpdXMgdG8gbW92ZSB0aGUgcG9pbnQgaW53YXJkcyBieSB0aGF0IHguXG4gIC8vXG4gIC8vIFdlIGF2ZXJhZ2UgdGhlIGxlZnQgYW5kIHJpZ2h0IGRpc3RhbmNlcyB0byBnZXQgdGhlIG1heGltdW0gc2hhcGUgcmFkaXVzIHRoYXQgY2FuIGZpdCBpbiB0aGUgYm94XG4gIC8vIGFsb25nIHdpdGggbGFiZWxzLlxuICAvL1xuICAvLyBPbmNlIHdlIGhhdmUgdGhhdCwgd2UgY2FuIGZpbmQgdGhlIGNlbnRyZSBwb2ludCBmb3IgdGhlIGNoYXJ0LCBieSB0YWtpbmcgdGhlIHggdGV4dCBwcm90cnVzaW9uXG4gIC8vIG9uIGVhY2ggc2lkZSwgcmVtb3ZpbmcgdGhhdCBmcm9tIHRoZSBzaXplLCBoYWx2aW5nIGl0IGFuZCBhZGRpbmcgdGhlIGxlZnQgeCBwcm90cnVzaW9uIHdpZHRoLlxuICAvL1xuICAvLyBUaGlzIHdpbGwgbWVhbiB3ZSBoYXZlIGEgc2hhcGUgZml0dGVkIHRvIHRoZSBjYW52YXMsIGFzIGxhcmdlIGFzIGl0IGNhbiBiZSB3aXRoIHRoZSBsYWJlbHNcbiAgLy8gYW5kIHBvc2l0aW9uIGl0IGluIHRoZSBtb3N0IHNwYWNlIGVmZmljaWVudCBtYW5uZXJcbiAgLy9cbiAgLy8gaHR0cHM6Ly9kbC5kcm9wYm94dXNlcmNvbnRlbnQuY29tL3UvMzQ2MDEzNjMveWVhaHNjaWVuY2UuZ2lmXG5cbiAgLy8gR2V0IG1heGltdW0gcmFkaXVzIG9mIHRoZSBwb2x5Z29uLiBFaXRoZXIgaGFsZiB0aGUgaGVpZ2h0IChtaW51cyB0aGUgdGV4dCB3aWR0aCkgb3IgaGFsZiB0aGUgd2lkdGguXG4gIC8vIFVzZSB0aGlzIHRvIGNhbGN1bGF0ZSB0aGUgb2Zmc2V0ICsgY2hhbmdlLiAtIE1ha2Ugc3VyZSBML1IgcHJvdHJ1c2lvbiBpcyBhdCBsZWFzdCAwIHRvIHN0b3AgaXNzdWVzIHdpdGggY2VudHJlIHBvaW50c1xuICBjb25zdCBvcmlnID0ge1xuICAgIGw6IHNjYWxlLmxlZnQgKyBzY2FsZS5fcGFkZGluZy5sZWZ0LFxuICAgIHI6IHNjYWxlLnJpZ2h0IC0gc2NhbGUuX3BhZGRpbmcucmlnaHQsXG4gICAgdDogc2NhbGUudG9wICsgc2NhbGUuX3BhZGRpbmcudG9wLFxuICAgIGI6IHNjYWxlLmJvdHRvbSAtIHNjYWxlLl9wYWRkaW5nLmJvdHRvbVxuICB9O1xuICBjb25zdCBsaW1pdHMgPSBPYmplY3QuYXNzaWduKHt9LCBvcmlnKTtcbiAgY29uc3QgbGFiZWxTaXplcyA9IFtdO1xuICBjb25zdCBwYWRkaW5nID0gW107XG4gIGNvbnN0IHZhbHVlQ291bnQgPSBzY2FsZS5fcG9pbnRMYWJlbHMubGVuZ3RoO1xuICBjb25zdCBwb2ludExhYmVsT3B0cyA9IHNjYWxlLm9wdGlvbnMucG9pbnRMYWJlbHM7XG4gIGNvbnN0IGFkZGl0aW9uYWxBbmdsZSA9IHBvaW50TGFiZWxPcHRzLmNlbnRlclBvaW50TGFiZWxzID8gUEkgLyB2YWx1ZUNvdW50IDogMDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlQ291bnQ7IGkrKykge1xuICAgIGNvbnN0IG9wdHMgPSBwb2ludExhYmVsT3B0cy5zZXRDb250ZXh0KHNjYWxlLmdldFBvaW50TGFiZWxDb250ZXh0KGkpKTtcbiAgICBwYWRkaW5nW2ldID0gb3B0cy5wYWRkaW5nO1xuICAgIGNvbnN0IHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGksIHNjYWxlLmRyYXdpbmdBcmVhICsgcGFkZGluZ1tpXSwgYWRkaXRpb25hbEFuZ2xlKTtcbiAgICBjb25zdCBwbEZvbnQgPSB0b0ZvbnQob3B0cy5mb250KTtcbiAgICBjb25zdCB0ZXh0U2l6ZSA9IG1lYXN1cmVMYWJlbFNpemUoc2NhbGUuY3R4LCBwbEZvbnQsIHNjYWxlLl9wb2ludExhYmVsc1tpXSk7XG4gICAgbGFiZWxTaXplc1tpXSA9IHRleHRTaXplO1xuXG4gICAgY29uc3QgYW5nbGVSYWRpYW5zID0gX25vcm1hbGl6ZUFuZ2xlKHNjYWxlLmdldEluZGV4QW5nbGUoaSkgKyBhZGRpdGlvbmFsQW5nbGUpO1xuICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5yb3VuZCh0b0RlZ3JlZXMoYW5nbGVSYWRpYW5zKSk7XG4gICAgY29uc3QgaExpbWl0cyA9IGRldGVybWluZUxpbWl0cyhhbmdsZSwgcG9pbnRQb3NpdGlvbi54LCB0ZXh0U2l6ZS53LCAwLCAxODApO1xuICAgIGNvbnN0IHZMaW1pdHMgPSBkZXRlcm1pbmVMaW1pdHMoYW5nbGUsIHBvaW50UG9zaXRpb24ueSwgdGV4dFNpemUuaCwgOTAsIDI3MCk7XG4gICAgdXBkYXRlTGltaXRzKGxpbWl0cywgb3JpZywgYW5nbGVSYWRpYW5zLCBoTGltaXRzLCB2TGltaXRzKTtcbiAgfVxuXG4gIHNjYWxlLnNldENlbnRlclBvaW50KFxuICAgIG9yaWcubCAtIGxpbWl0cy5sLFxuICAgIGxpbWl0cy5yIC0gb3JpZy5yLFxuICAgIG9yaWcudCAtIGxpbWl0cy50LFxuICAgIGxpbWl0cy5iIC0gb3JpZy5iXG4gICk7XG5cbiAgLy8gTm93IHRoYXQgdGV4dCBzaXplIGlzIGRldGVybWluZWQsIGNvbXB1dGUgdGhlIGZ1bGwgcG9zaXRpb25zXG4gIHNjYWxlLl9wb2ludExhYmVsSXRlbXMgPSBidWlsZFBvaW50TGFiZWxJdGVtcyhzY2FsZSwgbGFiZWxTaXplcywgcGFkZGluZyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbWl0cyhsaW1pdHMsIG9yaWcsIGFuZ2xlLCBoTGltaXRzLCB2TGltaXRzKSB7XG4gIGNvbnN0IHNpbiA9IE1hdGguYWJzKE1hdGguc2luKGFuZ2xlKSk7XG4gIGNvbnN0IGNvcyA9IE1hdGguYWJzKE1hdGguY29zKGFuZ2xlKSk7XG4gIGxldCB4ID0gMDtcbiAgbGV0IHkgPSAwO1xuICBpZiAoaExpbWl0cy5zdGFydCA8IG9yaWcubCkge1xuICAgIHggPSAob3JpZy5sIC0gaExpbWl0cy5zdGFydCkgLyBzaW47XG4gICAgbGltaXRzLmwgPSBNYXRoLm1pbihsaW1pdHMubCwgb3JpZy5sIC0geCk7XG4gIH0gZWxzZSBpZiAoaExpbWl0cy5lbmQgPiBvcmlnLnIpIHtcbiAgICB4ID0gKGhMaW1pdHMuZW5kIC0gb3JpZy5yKSAvIHNpbjtcbiAgICBsaW1pdHMuciA9IE1hdGgubWF4KGxpbWl0cy5yLCBvcmlnLnIgKyB4KTtcbiAgfVxuICBpZiAodkxpbWl0cy5zdGFydCA8IG9yaWcudCkge1xuICAgIHkgPSAob3JpZy50IC0gdkxpbWl0cy5zdGFydCkgLyBjb3M7XG4gICAgbGltaXRzLnQgPSBNYXRoLm1pbihsaW1pdHMudCwgb3JpZy50IC0geSk7XG4gIH0gZWxzZSBpZiAodkxpbWl0cy5lbmQgPiBvcmlnLmIpIHtcbiAgICB5ID0gKHZMaW1pdHMuZW5kIC0gb3JpZy5iKSAvIGNvcztcbiAgICBsaW1pdHMuYiA9IE1hdGgubWF4KGxpbWl0cy5iLCBvcmlnLmIgKyB5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVQb2ludExhYmVsSXRlbShzY2FsZSwgaW5kZXgsIGl0ZW1PcHRzKSB7XG4gIGNvbnN0IG91dGVyRGlzdGFuY2UgPSBzY2FsZS5kcmF3aW5nQXJlYTtcbiAgY29uc3Qge2V4dHJhLCBhZGRpdGlvbmFsQW5nbGUsIHBhZGRpbmcsIHNpemV9ID0gaXRlbU9wdHM7XG4gIGNvbnN0IHBvaW50TGFiZWxQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oaW5kZXgsIG91dGVyRGlzdGFuY2UgKyBleHRyYSArIHBhZGRpbmcsIGFkZGl0aW9uYWxBbmdsZSk7XG4gIGNvbnN0IGFuZ2xlID0gTWF0aC5yb3VuZCh0b0RlZ3JlZXMoX25vcm1hbGl6ZUFuZ2xlKHBvaW50TGFiZWxQb3NpdGlvbi5hbmdsZSArIEhBTEZfUEkpKSk7XG4gIGNvbnN0IHkgPSB5Rm9yQW5nbGUocG9pbnRMYWJlbFBvc2l0aW9uLnksIHNpemUuaCwgYW5nbGUpO1xuICBjb25zdCB0ZXh0QWxpZ24gPSBnZXRUZXh0QWxpZ25Gb3JBbmdsZShhbmdsZSk7XG4gIGNvbnN0IGxlZnQgPSBsZWZ0Rm9yVGV4dEFsaWduKHBvaW50TGFiZWxQb3NpdGlvbi54LCBzaXplLncsIHRleHRBbGlnbik7XG4gIHJldHVybiB7XG4gICAgLy8gaWYgdG8gZHJhdyBvciBvdmVybGFwcGVkXG4gICAgdmlzaWJsZTogdHJ1ZSxcblxuICAgIC8vIFRleHQgcG9zaXRpb25cbiAgICB4OiBwb2ludExhYmVsUG9zaXRpb24ueCxcbiAgICB5LFxuXG4gICAgLy8gVGV4dCByZW5kZXJpbmcgZGF0YVxuICAgIHRleHRBbGlnbixcblxuICAgIC8vIEJvdW5kaW5nIGJveFxuICAgIGxlZnQsXG4gICAgdG9wOiB5LFxuICAgIHJpZ2h0OiBsZWZ0ICsgc2l6ZS53LFxuICAgIGJvdHRvbTogeSArIHNpemUuaFxuICB9O1xufVxuXG5mdW5jdGlvbiBpc05vdE92ZXJsYXBwZWQoaXRlbSwgYXJlYSkge1xuICBpZiAoIWFyZWEpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCB7bGVmdCwgdG9wLCByaWdodCwgYm90dG9tfSA9IGl0ZW07XG4gIGNvbnN0IGFwZXhlc0luQXJlYSA9IF9pc1BvaW50SW5BcmVhKHt4OiBsZWZ0LCB5OiB0b3B9LCBhcmVhKSB8fCBfaXNQb2ludEluQXJlYSh7eDogbGVmdCwgeTogYm90dG9tfSwgYXJlYSkgfHxcbiAgICBfaXNQb2ludEluQXJlYSh7eDogcmlnaHQsIHk6IHRvcH0sIGFyZWEpIHx8IF9pc1BvaW50SW5BcmVhKHt4OiByaWdodCwgeTogYm90dG9tfSwgYXJlYSk7XG4gIHJldHVybiAhYXBleGVzSW5BcmVhO1xufVxuXG5mdW5jdGlvbiBidWlsZFBvaW50TGFiZWxJdGVtcyhzY2FsZSwgbGFiZWxTaXplcywgcGFkZGluZykge1xuICBjb25zdCBpdGVtcyA9IFtdO1xuICBjb25zdCB2YWx1ZUNvdW50ID0gc2NhbGUuX3BvaW50TGFiZWxzLmxlbmd0aDtcbiAgY29uc3Qgb3B0cyA9IHNjYWxlLm9wdGlvbnM7XG4gIGNvbnN0IHtjZW50ZXJQb2ludExhYmVscywgZGlzcGxheX0gPSBvcHRzLnBvaW50TGFiZWxzO1xuICBjb25zdCBpdGVtT3B0cyA9IHtcbiAgICBleHRyYTogZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KG9wdHMpIC8gMixcbiAgICBhZGRpdGlvbmFsQW5nbGU6IGNlbnRlclBvaW50TGFiZWxzID8gUEkgLyB2YWx1ZUNvdW50IDogMFxuICB9O1xuICBsZXQgYXJlYTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlQ291bnQ7IGkrKykge1xuICAgIGl0ZW1PcHRzLnBhZGRpbmcgPSBwYWRkaW5nW2ldO1xuICAgIGl0ZW1PcHRzLnNpemUgPSBsYWJlbFNpemVzW2ldO1xuXG4gICAgY29uc3QgaXRlbSA9IGNyZWF0ZVBvaW50TGFiZWxJdGVtKHNjYWxlLCBpLCBpdGVtT3B0cyk7XG4gICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICBpZiAoZGlzcGxheSA9PT0gJ2F1dG8nKSB7XG4gICAgICBpdGVtLnZpc2libGUgPSBpc05vdE92ZXJsYXBwZWQoaXRlbSwgYXJlYSk7XG4gICAgICBpZiAoaXRlbS52aXNpYmxlKSB7XG4gICAgICAgIGFyZWEgPSBpdGVtO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gaXRlbXM7XG59XG5cbmZ1bmN0aW9uIGdldFRleHRBbGlnbkZvckFuZ2xlKGFuZ2xlKSB7XG4gIGlmIChhbmdsZSA9PT0gMCB8fCBhbmdsZSA9PT0gMTgwKSB7XG4gICAgcmV0dXJuICdjZW50ZXInO1xuICB9IGVsc2UgaWYgKGFuZ2xlIDwgMTgwKSB7XG4gICAgcmV0dXJuICdsZWZ0JztcbiAgfVxuXG4gIHJldHVybiAncmlnaHQnO1xufVxuXG5mdW5jdGlvbiBsZWZ0Rm9yVGV4dEFsaWduKHgsIHcsIGFsaWduKSB7XG4gIGlmIChhbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgIHggLT0gdztcbiAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICB4IC09ICh3IC8gMik7XG4gIH1cbiAgcmV0dXJuIHg7XG59XG5cbmZ1bmN0aW9uIHlGb3JBbmdsZSh5LCBoLCBhbmdsZSkge1xuICBpZiAoYW5nbGUgPT09IDkwIHx8IGFuZ2xlID09PSAyNzApIHtcbiAgICB5IC09IChoIC8gMik7XG4gIH0gZWxzZSBpZiAoYW5nbGUgPiAyNzAgfHwgYW5nbGUgPCA5MCkge1xuICAgIHkgLT0gaDtcbiAgfVxuICByZXR1cm4geTtcbn1cblxuZnVuY3Rpb24gZHJhd1BvaW50TGFiZWxCb3goY3R4LCBvcHRzLCBpdGVtKSB7XG4gIGNvbnN0IHtsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b219ID0gaXRlbTtcbiAgY29uc3Qge2JhY2tkcm9wQ29sb3J9ID0gb3B0cztcblxuICBpZiAoIWlzTnVsbE9yVW5kZWYoYmFja2Ryb3BDb2xvcikpIHtcbiAgICBjb25zdCBib3JkZXJSYWRpdXMgPSB0b1RSQkxDb3JuZXJzKG9wdHMuYm9yZGVyUmFkaXVzKTtcbiAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdHMuYmFja2Ryb3BQYWRkaW5nKTtcbiAgICBjdHguZmlsbFN0eWxlID0gYmFja2Ryb3BDb2xvcjtcblxuICAgIGNvbnN0IGJhY2tkcm9wTGVmdCA9IGxlZnQgLSBwYWRkaW5nLmxlZnQ7XG4gICAgY29uc3QgYmFja2Ryb3BUb3AgPSB0b3AgLSBwYWRkaW5nLnRvcDtcbiAgICBjb25zdCBiYWNrZHJvcFdpZHRoID0gcmlnaHQgLSBsZWZ0ICsgcGFkZGluZy53aWR0aDtcbiAgICBjb25zdCBiYWNrZHJvcEhlaWdodCA9IGJvdHRvbSAtIHRvcCArIHBhZGRpbmcuaGVpZ2h0O1xuXG4gICAgaWYgKE9iamVjdC52YWx1ZXMoYm9yZGVyUmFkaXVzKS5zb21lKHYgPT4gdiAhPT0gMCkpIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGFkZFJvdW5kZWRSZWN0UGF0aChjdHgsIHtcbiAgICAgICAgeDogYmFja2Ryb3BMZWZ0LFxuICAgICAgICB5OiBiYWNrZHJvcFRvcCxcbiAgICAgICAgdzogYmFja2Ryb3BXaWR0aCxcbiAgICAgICAgaDogYmFja2Ryb3BIZWlnaHQsXG4gICAgICAgIHJhZGl1czogYm9yZGVyUmFkaXVzLFxuICAgICAgfSk7XG4gICAgICBjdHguZmlsbCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHguZmlsbFJlY3QoYmFja2Ryb3BMZWZ0LCBiYWNrZHJvcFRvcCwgYmFja2Ryb3BXaWR0aCwgYmFja2Ryb3BIZWlnaHQpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkcmF3UG9pbnRMYWJlbHMoc2NhbGUsIGxhYmVsQ291bnQpIHtcbiAgY29uc3Qge2N0eCwgb3B0aW9uczoge3BvaW50TGFiZWxzfX0gPSBzY2FsZTtcblxuICBmb3IgKGxldCBpID0gbGFiZWxDb3VudCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3QgaXRlbSA9IHNjYWxlLl9wb2ludExhYmVsSXRlbXNbaV07XG4gICAgaWYgKCFpdGVtLnZpc2libGUpIHtcbiAgICAgIC8vIG92ZXJsYXBwaW5nXG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3Qgb3B0c0F0SW5kZXggPSBwb2ludExhYmVscy5zZXRDb250ZXh0KHNjYWxlLmdldFBvaW50TGFiZWxDb250ZXh0KGkpKTtcbiAgICBkcmF3UG9pbnRMYWJlbEJveChjdHgsIG9wdHNBdEluZGV4LCBpdGVtKTtcbiAgICBjb25zdCBwbEZvbnQgPSB0b0ZvbnQob3B0c0F0SW5kZXguZm9udCk7XG4gICAgY29uc3Qge3gsIHksIHRleHRBbGlnbn0gPSBpdGVtO1xuXG4gICAgcmVuZGVyVGV4dChcbiAgICAgIGN0eCxcbiAgICAgIHNjYWxlLl9wb2ludExhYmVsc1tpXSxcbiAgICAgIHgsXG4gICAgICB5ICsgKHBsRm9udC5saW5lSGVpZ2h0IC8gMiksXG4gICAgICBwbEZvbnQsXG4gICAgICB7XG4gICAgICAgIGNvbG9yOiBvcHRzQXRJbmRleC5jb2xvcixcbiAgICAgICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgICAgIHRleHRCYXNlbGluZTogJ21pZGRsZSdcbiAgICAgIH1cbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhdGhSYWRpdXNMaW5lKHNjYWxlLCByYWRpdXMsIGNpcmN1bGFyLCBsYWJlbENvdW50KSB7XG4gIGNvbnN0IHtjdHh9ID0gc2NhbGU7XG4gIGlmIChjaXJjdWxhcikge1xuICAgIC8vIERyYXcgY2lyY3VsYXIgYXJjcyBiZXR3ZWVuIHRoZSBwb2ludHNcbiAgICBjdHguYXJjKHNjYWxlLnhDZW50ZXIsIHNjYWxlLnlDZW50ZXIsIHJhZGl1cywgMCwgVEFVKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBEcmF3IHN0cmFpZ2h0IGxpbmVzIGNvbm5lY3RpbmcgZWFjaCBpbmRleFxuICAgIGxldCBwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbigwLCByYWRpdXMpO1xuICAgIGN0eC5tb3ZlVG8ocG9pbnRQb3NpdGlvbi54LCBwb2ludFBvc2l0aW9uLnkpO1xuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsYWJlbENvdW50OyBpKyspIHtcbiAgICAgIHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGksIHJhZGl1cyk7XG4gICAgICBjdHgubGluZVRvKHBvaW50UG9zaXRpb24ueCwgcG9pbnRQb3NpdGlvbi55KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZHJhd1JhZGl1c0xpbmUoc2NhbGUsIGdyaWRMaW5lT3B0cywgcmFkaXVzLCBsYWJlbENvdW50LCBib3JkZXJPcHRzKSB7XG4gIGNvbnN0IGN0eCA9IHNjYWxlLmN0eDtcbiAgY29uc3QgY2lyY3VsYXIgPSBncmlkTGluZU9wdHMuY2lyY3VsYXI7XG5cbiAgY29uc3Qge2NvbG9yLCBsaW5lV2lkdGh9ID0gZ3JpZExpbmVPcHRzO1xuXG4gIGlmICgoIWNpcmN1bGFyICYmICFsYWJlbENvdW50KSB8fCAhY29sb3IgfHwgIWxpbmVXaWR0aCB8fCByYWRpdXMgPCAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY3R4LnNhdmUoKTtcbiAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gIGN0eC5zZXRMaW5lRGFzaChib3JkZXJPcHRzLmRhc2ggfHwgW10pO1xuICBjdHgubGluZURhc2hPZmZzZXQgPSBib3JkZXJPcHRzLmRhc2hPZmZzZXQ7XG5cbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBwYXRoUmFkaXVzTGluZShzY2FsZSwgcmFkaXVzLCBjaXJjdWxhciwgbGFiZWxDb3VudCk7XG4gIGN0eC5jbG9zZVBhdGgoKTtcbiAgY3R4LnN0cm9rZSgpO1xuICBjdHgucmVzdG9yZSgpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVQb2ludExhYmVsQ29udGV4dChwYXJlbnQsIGluZGV4LCBsYWJlbCkge1xuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsIHtcbiAgICBsYWJlbCxcbiAgICBpbmRleCxcbiAgICB0eXBlOiAncG9pbnRMYWJlbCdcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJhZGlhbExpbmVhclNjYWxlIGV4dGVuZHMgTGluZWFyU2NhbGVCYXNlIHtcblxuICBzdGF0aWMgaWQgPSAncmFkaWFsTGluZWFyJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBkaXNwbGF5OiB0cnVlLFxuXG4gICAgLy8gQm9vbGVhbiAtIFdoZXRoZXIgdG8gYW5pbWF0ZSBzY2FsaW5nIHRoZSBjaGFydCBmcm9tIHRoZSBjZW50cmVcbiAgICBhbmltYXRlOiB0cnVlLFxuICAgIHBvc2l0aW9uOiAnY2hhcnRBcmVhJyxcblxuICAgIGFuZ2xlTGluZXM6IHtcbiAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICBsaW5lV2lkdGg6IDEsXG4gICAgICBib3JkZXJEYXNoOiBbXSxcbiAgICAgIGJvcmRlckRhc2hPZmZzZXQ6IDAuMFxuICAgIH0sXG5cbiAgICBncmlkOiB7XG4gICAgICBjaXJjdWxhcjogZmFsc2VcbiAgICB9LFxuXG4gICAgc3RhcnRBbmdsZTogMCxcblxuICAgIC8vIGxhYmVsIHNldHRpbmdzXG4gICAgdGlja3M6IHtcbiAgICAgIC8vIEJvb2xlYW4gLSBTaG93IGEgYmFja2Ryb3AgdG8gdGhlIHNjYWxlIGxhYmVsXG4gICAgICBzaG93TGFiZWxCYWNrZHJvcDogdHJ1ZSxcblxuICAgICAgY2FsbGJhY2s6IFRpY2tzLmZvcm1hdHRlcnMubnVtZXJpY1xuICAgIH0sXG5cbiAgICBwb2ludExhYmVsczoge1xuICAgICAgYmFja2Ryb3BDb2xvcjogdW5kZWZpbmVkLFxuXG4gICAgICAvLyBOdW1iZXIgLSBUaGUgYmFja2Ryb3AgcGFkZGluZyBhYm92ZSAmIGJlbG93IHRoZSBsYWJlbCBpbiBwaXhlbHNcbiAgICAgIGJhY2tkcm9wUGFkZGluZzogMixcblxuICAgICAgLy8gQm9vbGVhbiAtIGlmIHRydWUsIHNob3cgcG9pbnQgbGFiZWxzXG4gICAgICBkaXNwbGF5OiB0cnVlLFxuXG4gICAgICAvLyBOdW1iZXIgLSBQb2ludCBsYWJlbCBmb250IHNpemUgaW4gcGl4ZWxzXG4gICAgICBmb250OiB7XG4gICAgICAgIHNpemU6IDEwXG4gICAgICB9LFxuXG4gICAgICAvLyBGdW5jdGlvbiAtIFVzZWQgdG8gY29udmVydCBwb2ludCBsYWJlbHNcbiAgICAgIGNhbGxiYWNrKGxhYmVsKSB7XG4gICAgICAgIHJldHVybiBsYWJlbDtcbiAgICAgIH0sXG5cbiAgICAgIC8vIE51bWJlciAtIEFkZGl0aW9ubCBwYWRkaW5nIGJldHdlZW4gc2NhbGUgYW5kIHBvaW50TGFiZWxcbiAgICAgIHBhZGRpbmc6IDUsXG5cbiAgICAgIC8vIEJvb2xlYW4gLSBpZiB0cnVlLCBjZW50ZXIgcG9pbnQgbGFiZWxzIHRvIHNsaWNlcyBpbiBwb2xhciBjaGFydFxuICAgICAgY2VudGVyUG9pbnRMYWJlbHM6IGZhbHNlXG4gICAgfVxuICB9O1xuXG4gIHN0YXRpYyBkZWZhdWx0Um91dGVzID0ge1xuICAgICdhbmdsZUxpbmVzLmNvbG9yJzogJ2JvcmRlckNvbG9yJyxcbiAgICAncG9pbnRMYWJlbHMuY29sb3InOiAnY29sb3InLFxuICAgICd0aWNrcy5jb2xvcic6ICdjb2xvcidcbiAgfTtcblxuICBzdGF0aWMgZGVzY3JpcHRvcnMgPSB7XG4gICAgYW5nbGVMaW5lczoge1xuICAgICAgX2ZhbGxiYWNrOiAnZ3JpZCdcbiAgICB9XG4gIH07XG5cbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoY2ZnKTtcblxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMueENlbnRlciA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLnlDZW50ZXIgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5kcmF3aW5nQXJlYSA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge3N0cmluZ1tdfSAqL1xuICAgIHRoaXMuX3BvaW50TGFiZWxzID0gW107XG4gICAgdGhpcy5fcG9pbnRMYWJlbEl0ZW1zID0gW107XG4gIH1cblxuICBzZXREaW1lbnNpb25zKCkge1xuICAgIC8vIFNldCB0aGUgdW5jb25zdHJhaW5lZCBkaW1lbnNpb24gYmVmb3JlIGxhYmVsIHJvdGF0aW9uXG4gICAgY29uc3QgcGFkZGluZyA9IHRoaXMuX3BhZGRpbmcgPSB0b1BhZGRpbmcoZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KHRoaXMub3B0aW9ucykgLyAyKTtcbiAgICBjb25zdCB3ID0gdGhpcy53aWR0aCA9IHRoaXMubWF4V2lkdGggLSBwYWRkaW5nLndpZHRoO1xuICAgIGNvbnN0IGggPSB0aGlzLmhlaWdodCA9IHRoaXMubWF4SGVpZ2h0IC0gcGFkZGluZy5oZWlnaHQ7XG4gICAgdGhpcy54Q2VudGVyID0gTWF0aC5mbG9vcih0aGlzLmxlZnQgKyB3IC8gMiArIHBhZGRpbmcubGVmdCk7XG4gICAgdGhpcy55Q2VudGVyID0gTWF0aC5mbG9vcih0aGlzLnRvcCArIGggLyAyICsgcGFkZGluZy50b3ApO1xuICAgIHRoaXMuZHJhd2luZ0FyZWEgPSBNYXRoLmZsb29yKE1hdGgubWluKHcsIGgpIC8gMik7XG4gIH1cblxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgIGNvbnN0IHttaW4sIG1heH0gPSB0aGlzLmdldE1pbk1heChmYWxzZSk7XG5cbiAgICB0aGlzLm1pbiA9IGlzRmluaXRlKG1pbikgJiYgIWlzTmFOKG1pbikgPyBtaW4gOiAwO1xuICAgIHRoaXMubWF4ID0gaXNGaW5pdGUobWF4KSAmJiAhaXNOYU4obWF4KSA/IG1heCA6IDA7XG5cbiAgICAvLyBDb21tb24gYmFzZSBpbXBsZW1lbnRhdGlvbiB0byBoYW5kbGUgbWluLCBtYXgsIGJlZ2luQXRaZXJvXG4gICAgdGhpcy5oYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCk7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgbWF4aW11bSBudW1iZXIgb2YgdGlja3MgYmFzZWQgb24gdGhlIHNjYWxlIGRpbWVuc2lvblxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBjb21wdXRlVGlja0xpbWl0KCkge1xuICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy5kcmF3aW5nQXJlYSAvIGdldFRpY2tCYWNrZHJvcEhlaWdodCh0aGlzLm9wdGlvbnMpKTtcbiAgfVxuXG4gIGdlbmVyYXRlVGlja0xhYmVscyh0aWNrcykge1xuICAgIExpbmVhclNjYWxlQmFzZS5wcm90b3R5cGUuZ2VuZXJhdGVUaWNrTGFiZWxzLmNhbGwodGhpcywgdGlja3MpO1xuXG4gICAgLy8gUG9pbnQgbGFiZWxzXG4gICAgdGhpcy5fcG9pbnRMYWJlbHMgPSB0aGlzLmdldExhYmVscygpXG4gICAgICAubWFwKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBjYWxsQ2FsbGJhY2sodGhpcy5vcHRpb25zLnBvaW50TGFiZWxzLmNhbGxiYWNrLCBbdmFsdWUsIGluZGV4XSwgdGhpcyk7XG4gICAgICAgIHJldHVybiBsYWJlbCB8fCBsYWJlbCA9PT0gMCA/IGxhYmVsIDogJyc7XG4gICAgICB9KVxuICAgICAgLmZpbHRlcigodiwgaSkgPT4gdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSk7XG4gIH1cblxuICBmaXQoKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcblxuICAgIGlmIChvcHRzLmRpc3BsYXkgJiYgb3B0cy5wb2ludExhYmVscy5kaXNwbGF5KSB7XG4gICAgICBmaXRXaXRoUG9pbnRMYWJlbHModGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0Q2VudGVyUG9pbnQoMCwgMCwgMCwgMCk7XG4gICAgfVxuICB9XG5cbiAgc2V0Q2VudGVyUG9pbnQobGVmdE1vdmVtZW50LCByaWdodE1vdmVtZW50LCB0b3BNb3ZlbWVudCwgYm90dG9tTW92ZW1lbnQpIHtcbiAgICB0aGlzLnhDZW50ZXIgKz0gTWF0aC5mbG9vcigobGVmdE1vdmVtZW50IC0gcmlnaHRNb3ZlbWVudCkgLyAyKTtcbiAgICB0aGlzLnlDZW50ZXIgKz0gTWF0aC5mbG9vcigodG9wTW92ZW1lbnQgLSBib3R0b21Nb3ZlbWVudCkgLyAyKTtcbiAgICB0aGlzLmRyYXdpbmdBcmVhIC09IE1hdGgubWluKHRoaXMuZHJhd2luZ0FyZWEgLyAyLCBNYXRoLm1heChsZWZ0TW92ZW1lbnQsIHJpZ2h0TW92ZW1lbnQsIHRvcE1vdmVtZW50LCBib3R0b21Nb3ZlbWVudCkpO1xuICB9XG5cbiAgZ2V0SW5kZXhBbmdsZShpbmRleCkge1xuICAgIGNvbnN0IGFuZ2xlTXVsdGlwbGllciA9IFRBVSAvICh0aGlzLl9wb2ludExhYmVscy5sZW5ndGggfHwgMSk7XG4gICAgY29uc3Qgc3RhcnRBbmdsZSA9IHRoaXMub3B0aW9ucy5zdGFydEFuZ2xlIHx8IDA7XG5cbiAgICByZXR1cm4gX25vcm1hbGl6ZUFuZ2xlKGluZGV4ICogYW5nbGVNdWx0aXBsaWVyICsgdG9SYWRpYW5zKHN0YXJ0QW5nbGUpKTtcbiAgfVxuXG4gIGdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKGlzTnVsbE9yVW5kZWYodmFsdWUpKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cblxuICAgIC8vIFRha2UgaW50byBhY2NvdW50IGhhbGYgZm9udCBzaXplICsgdGhlIHlQYWRkaW5nIG9mIHRoZSB0b3AgdmFsdWVcbiAgICBjb25zdCBzY2FsaW5nRmFjdG9yID0gdGhpcy5kcmF3aW5nQXJlYSAvICh0aGlzLm1heCAtIHRoaXMubWluKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnJldmVyc2UpIHtcbiAgICAgIHJldHVybiAodGhpcy5tYXggLSB2YWx1ZSkgKiBzY2FsaW5nRmFjdG9yO1xuICAgIH1cbiAgICByZXR1cm4gKHZhbHVlIC0gdGhpcy5taW4pICogc2NhbGluZ0ZhY3RvcjtcbiAgfVxuXG4gIGdldFZhbHVlRm9yRGlzdGFuY2VGcm9tQ2VudGVyKGRpc3RhbmNlKSB7XG4gICAgaWYgKGlzTnVsbE9yVW5kZWYoZGlzdGFuY2UpKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cblxuICAgIGNvbnN0IHNjYWxlZERpc3RhbmNlID0gZGlzdGFuY2UgLyAodGhpcy5kcmF3aW5nQXJlYSAvICh0aGlzLm1heCAtIHRoaXMubWluKSk7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5yZXZlcnNlID8gdGhpcy5tYXggLSBzY2FsZWREaXN0YW5jZSA6IHRoaXMubWluICsgc2NhbGVkRGlzdGFuY2U7XG4gIH1cblxuICBnZXRQb2ludExhYmVsQ29udGV4dChpbmRleCkge1xuICAgIGNvbnN0IHBvaW50TGFiZWxzID0gdGhpcy5fcG9pbnRMYWJlbHMgfHwgW107XG5cbiAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHBvaW50TGFiZWxzLmxlbmd0aCkge1xuICAgICAgY29uc3QgcG9pbnRMYWJlbCA9IHBvaW50TGFiZWxzW2luZGV4XTtcbiAgICAgIHJldHVybiBjcmVhdGVQb2ludExhYmVsQ29udGV4dCh0aGlzLmdldENvbnRleHQoKSwgaW5kZXgsIHBvaW50TGFiZWwpO1xuICAgIH1cbiAgfVxuXG4gIGdldFBvaW50UG9zaXRpb24oaW5kZXgsIGRpc3RhbmNlRnJvbUNlbnRlciwgYWRkaXRpb25hbEFuZ2xlID0gMCkge1xuICAgIGNvbnN0IGFuZ2xlID0gdGhpcy5nZXRJbmRleEFuZ2xlKGluZGV4KSAtIEhBTEZfUEkgKyBhZGRpdGlvbmFsQW5nbGU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IE1hdGguY29zKGFuZ2xlKSAqIGRpc3RhbmNlRnJvbUNlbnRlciArIHRoaXMueENlbnRlcixcbiAgICAgIHk6IE1hdGguc2luKGFuZ2xlKSAqIGRpc3RhbmNlRnJvbUNlbnRlciArIHRoaXMueUNlbnRlcixcbiAgICAgIGFuZ2xlXG4gICAgfTtcbiAgfVxuXG4gIGdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpbmRleCwgdmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQb2ludFBvc2l0aW9uKGluZGV4LCB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHZhbHVlKSk7XG4gIH1cblxuICBnZXRCYXNlUG9zaXRpb24oaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoaW5kZXggfHwgMCwgdGhpcy5nZXRCYXNlVmFsdWUoKSk7XG4gIH1cblxuICBnZXRQb2ludExhYmVsUG9zaXRpb24oaW5kZXgpIHtcbiAgICBjb25zdCB7bGVmdCwgdG9wLCByaWdodCwgYm90dG9tfSA9IHRoaXMuX3BvaW50TGFiZWxJdGVtc1tpbmRleF07XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQsXG4gICAgICB0b3AsXG4gICAgICByaWdodCxcbiAgICAgIGJvdHRvbSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGRyYXdCYWNrZ3JvdW5kKCkge1xuICAgIGNvbnN0IHtiYWNrZ3JvdW5kQ29sb3IsIGdyaWQ6IHtjaXJjdWxhcn19ID0gdGhpcy5vcHRpb25zO1xuICAgIGlmIChiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIHBhdGhSYWRpdXNMaW5lKHRoaXMsIHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodGhpcy5fZW5kVmFsdWUpLCBjaXJjdWxhciwgdGhpcy5fcG9pbnRMYWJlbHMubGVuZ3RoKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgICBjdHguZmlsbCgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZHJhd0dyaWQoKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7YW5nbGVMaW5lcywgZ3JpZCwgYm9yZGVyfSA9IG9wdHM7XG4gICAgY29uc3QgbGFiZWxDb3VudCA9IHRoaXMuX3BvaW50TGFiZWxzLmxlbmd0aDtcblxuICAgIGxldCBpLCBvZmZzZXQsIHBvc2l0aW9uO1xuXG4gICAgaWYgKG9wdHMucG9pbnRMYWJlbHMuZGlzcGxheSkge1xuICAgICAgZHJhd1BvaW50TGFiZWxzKHRoaXMsIGxhYmVsQ291bnQpO1xuICAgIH1cblxuICAgIGlmIChncmlkLmRpc3BsYXkpIHtcbiAgICAgIHRoaXMudGlja3MuZm9yRWFjaCgodGljaywgaW5kZXgpID0+IHtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAwIHx8IChpbmRleCA9PT0gMCAmJiB0aGlzLm1pbiA8IDApKSB7XG4gICAgICAgICAgb2Zmc2V0ID0gdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh0aWNrLnZhbHVlKTtcbiAgICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5nZXRDb250ZXh0KGluZGV4KTtcbiAgICAgICAgICBjb25zdCBvcHRzQXRJbmRleCA9IGdyaWQuc2V0Q29udGV4dChjb250ZXh0KTtcbiAgICAgICAgICBjb25zdCBvcHRzQXRJbmRleEJvcmRlciA9IGJvcmRlci5zZXRDb250ZXh0KGNvbnRleHQpO1xuXG4gICAgICAgICAgZHJhd1JhZGl1c0xpbmUodGhpcywgb3B0c0F0SW5kZXgsIG9mZnNldCwgbGFiZWxDb3VudCwgb3B0c0F0SW5kZXhCb3JkZXIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYW5nbGVMaW5lcy5kaXNwbGF5KSB7XG4gICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICBmb3IgKGkgPSBsYWJlbENvdW50IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3Qgb3B0c0F0SW5kZXggPSBhbmdsZUxpbmVzLnNldENvbnRleHQodGhpcy5nZXRQb2ludExhYmVsQ29udGV4dChpKSk7XG4gICAgICAgIGNvbnN0IHtjb2xvciwgbGluZVdpZHRofSA9IG9wdHNBdEluZGV4O1xuXG4gICAgICAgIGlmICghbGluZVdpZHRoIHx8ICFjb2xvcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG5cbiAgICAgICAgY3R4LnNldExpbmVEYXNoKG9wdHNBdEluZGV4LmJvcmRlckRhc2gpO1xuICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBvcHRzQXRJbmRleC5ib3JkZXJEYXNoT2Zmc2V0O1xuXG4gICAgICAgIG9mZnNldCA9IHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUob3B0cy5yZXZlcnNlID8gdGhpcy5taW4gOiB0aGlzLm1heCk7XG4gICAgICAgIHBvc2l0aW9uID0gdGhpcy5nZXRQb2ludFBvc2l0aW9uKGksIG9mZnNldCk7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyh0aGlzLnhDZW50ZXIsIHRoaXMueUNlbnRlcik7XG4gICAgICAgIGN0eC5saW5lVG8ocG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIH1cblxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZHJhd0JvcmRlcigpIHt9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGRyYXdMYWJlbHMoKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG5cbiAgICBpZiAoIXRpY2tPcHRzLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzdGFydEFuZ2xlID0gdGhpcy5nZXRJbmRleEFuZ2xlKDApO1xuICAgIGxldCBvZmZzZXQsIHdpZHRoO1xuXG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHgudHJhbnNsYXRlKHRoaXMueENlbnRlciwgdGhpcy55Q2VudGVyKTtcbiAgICBjdHgucm90YXRlKHN0YXJ0QW5nbGUpO1xuICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cbiAgICB0aGlzLnRpY2tzLmZvckVhY2goKHRpY2ssIGluZGV4KSA9PiB7XG4gICAgICBpZiAoKGluZGV4ID09PSAwICYmIHRoaXMubWluID49IDApICYmICFvcHRzLnJldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBvcHRzQXRJbmRleCA9IHRpY2tPcHRzLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGluZGV4KSk7XG4gICAgICBjb25zdCB0aWNrRm9udCA9IHRvRm9udChvcHRzQXRJbmRleC5mb250KTtcbiAgICAgIG9mZnNldCA9IHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodGhpcy50aWNrc1tpbmRleF0udmFsdWUpO1xuXG4gICAgICBpZiAob3B0c0F0SW5kZXguc2hvd0xhYmVsQmFja2Ryb3ApIHtcbiAgICAgICAgY3R4LmZvbnQgPSB0aWNrRm9udC5zdHJpbmc7XG4gICAgICAgIHdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KHRpY2subGFiZWwpLndpZHRoO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gb3B0c0F0SW5kZXguYmFja2Ryb3BDb2xvcjtcblxuICAgICAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdHNBdEluZGV4LmJhY2tkcm9wUGFkZGluZyk7XG4gICAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgICAtd2lkdGggLyAyIC0gcGFkZGluZy5sZWZ0LFxuICAgICAgICAgIC1vZmZzZXQgLSB0aWNrRm9udC5zaXplIC8gMiAtIHBhZGRpbmcudG9wLFxuICAgICAgICAgIHdpZHRoICsgcGFkZGluZy53aWR0aCxcbiAgICAgICAgICB0aWNrRm9udC5zaXplICsgcGFkZGluZy5oZWlnaHRcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmVuZGVyVGV4dChjdHgsIHRpY2subGFiZWwsIDAsIC1vZmZzZXQsIHRpY2tGb250LCB7XG4gICAgICAgIGNvbG9yOiBvcHRzQXRJbmRleC5jb2xvcixcbiAgICAgICAgc3Ryb2tlQ29sb3I6IG9wdHNBdEluZGV4LnRleHRTdHJva2VDb2xvcixcbiAgICAgICAgc3Ryb2tlV2lkdGg6IG9wdHNBdEluZGV4LnRleHRTdHJva2VXaWR0aCxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3VGl0bGUoKSB7fVxufVxuIiwiaW1wb3J0IGFkYXB0ZXJzIGZyb20gJy4uL2NvcmUvY29yZS5hZGFwdGVycy5qcyc7XG5pbXBvcnQge2NhbGxiYWNrIGFzIGNhbGwsIGlzRmluaXRlLCBpc051bGxPclVuZGVmLCBtZXJnZUlmLCB2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHt0b1JhZGlhbnMsIGlzTnVtYmVyLCBfbGltaXRWYWx1ZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IFNjYWxlIGZyb20gJy4uL2NvcmUvY29yZS5zY2FsZS5qcyc7XG5pbXBvcnQge19hcnJheVVuaXF1ZSwgX2ZpbHRlckJldHdlZW4sIF9sb29rdXB9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb2xsZWN0aW9uLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vY29yZS9jb3JlLmFkYXB0ZXJzLmpzJykuVGltZVVuaXQgfSBVbml0XG4gKiBAdHlwZWRlZiB7e2NvbW1vbjogYm9vbGVhbiwgc2l6ZTogbnVtYmVyLCBzdGVwcz86IG51bWJlcn19IEludGVydmFsXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vY29yZS9jb3JlLmFkYXB0ZXJzLmpzJykuRGF0ZUFkYXB0ZXIgfSBEYXRlQWRhcHRlclxuICovXG5cbi8qKlxuICogQHR5cGUge09iamVjdDxVbml0LCBJbnRlcnZhbD59XG4gKi9cbmNvbnN0IElOVEVSVkFMUyA9IHtcbiAgbWlsbGlzZWNvbmQ6IHtjb21tb246IHRydWUsIHNpemU6IDEsIHN0ZXBzOiAxMDAwfSxcbiAgc2Vjb25kOiB7Y29tbW9uOiB0cnVlLCBzaXplOiAxMDAwLCBzdGVwczogNjB9LFxuICBtaW51dGU6IHtjb21tb246IHRydWUsIHNpemU6IDYwMDAwLCBzdGVwczogNjB9LFxuICBob3VyOiB7Y29tbW9uOiB0cnVlLCBzaXplOiAzNjAwMDAwLCBzdGVwczogMjR9LFxuICBkYXk6IHtjb21tb246IHRydWUsIHNpemU6IDg2NDAwMDAwLCBzdGVwczogMzB9LFxuICB3ZWVrOiB7Y29tbW9uOiBmYWxzZSwgc2l6ZTogNjA0ODAwMDAwLCBzdGVwczogNH0sXG4gIG1vbnRoOiB7Y29tbW9uOiB0cnVlLCBzaXplOiAyLjYyOGU5LCBzdGVwczogMTJ9LFxuICBxdWFydGVyOiB7Y29tbW9uOiBmYWxzZSwgc2l6ZTogNy44ODRlOSwgc3RlcHM6IDR9LFxuICB5ZWFyOiB7Y29tbW9uOiB0cnVlLCBzaXplOiAzLjE1NGUxMH1cbn07XG5cbi8qKlxuICogQHR5cGUge1VuaXRbXX1cbiAqL1xuY29uc3QgVU5JVFMgPSAvKiogQHR5cGUgVW5pdFtdICovIC8qICNfX1BVUkVfXyAqLyAoT2JqZWN0LmtleXMoSU5URVJWQUxTKSk7XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBiXG4gKi9cbmZ1bmN0aW9uIHNvcnRlcihhLCBiKSB7XG4gIHJldHVybiBhIC0gYjtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RpbWVTY2FsZX0gc2NhbGVcbiAqIEBwYXJhbSB7Kn0gaW5wdXRcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gcGFyc2Uoc2NhbGUsIGlucHV0KSB7XG4gIGlmIChpc051bGxPclVuZGVmKGlucHV0KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgYWRhcHRlciA9IHNjYWxlLl9hZGFwdGVyO1xuICBjb25zdCB7cGFyc2VyLCByb3VuZCwgaXNvV2Vla2RheX0gPSBzY2FsZS5fcGFyc2VPcHRzO1xuICBsZXQgdmFsdWUgPSBpbnB1dDtcblxuICBpZiAodHlwZW9mIHBhcnNlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhbHVlID0gcGFyc2VyKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE9ubHkgcGFyc2UgaWYgaXQncyBub3QgYSB0aW1lc3RhbXAgYWxyZWFkeVxuICBpZiAoIWlzRmluaXRlKHZhbHVlKSkge1xuICAgIHZhbHVlID0gdHlwZW9mIHBhcnNlciA9PT0gJ3N0cmluZydcbiAgICAgID8gYWRhcHRlci5wYXJzZSh2YWx1ZSwgcGFyc2VyKVxuICAgICAgOiBhZGFwdGVyLnBhcnNlKHZhbHVlKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHJvdW5kKSB7XG4gICAgdmFsdWUgPSByb3VuZCA9PT0gJ3dlZWsnICYmIChpc051bWJlcihpc29XZWVrZGF5KSB8fCBpc29XZWVrZGF5ID09PSB0cnVlKVxuICAgICAgPyBhZGFwdGVyLnN0YXJ0T2YodmFsdWUsICdpc29XZWVrJywgaXNvV2Vla2RheSlcbiAgICAgIDogYWRhcHRlci5zdGFydE9mKHZhbHVlLCByb3VuZCk7XG4gIH1cblxuICByZXR1cm4gK3ZhbHVlO1xufVxuXG4vKipcbiAqIEZpZ3VyZXMgb3V0IHdoYXQgdW5pdCByZXN1bHRzIGluIGFuIGFwcHJvcHJpYXRlIG51bWJlciBvZiBhdXRvLWdlbmVyYXRlZCB0aWNrc1xuICogQHBhcmFtIHtVbml0fSBtaW5Vbml0XG4gKiBAcGFyYW0ge251bWJlcn0gbWluXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4XG4gKiBAcGFyYW0ge251bWJlcn0gY2FwYWNpdHlcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyhtaW5Vbml0LCBtaW4sIG1heCwgY2FwYWNpdHkpIHtcbiAgY29uc3QgaWxlbiA9IFVOSVRTLmxlbmd0aDtcblxuICBmb3IgKGxldCBpID0gVU5JVFMuaW5kZXhPZihtaW5Vbml0KTsgaSA8IGlsZW4gLSAxOyArK2kpIHtcbiAgICBjb25zdCBpbnRlcnZhbCA9IElOVEVSVkFMU1tVTklUU1tpXV07XG4gICAgY29uc3QgZmFjdG9yID0gaW50ZXJ2YWwuc3RlcHMgPyBpbnRlcnZhbC5zdGVwcyA6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuXG4gICAgaWYgKGludGVydmFsLmNvbW1vbiAmJiBNYXRoLmNlaWwoKG1heCAtIG1pbikgLyAoZmFjdG9yICogaW50ZXJ2YWwuc2l6ZSkpIDw9IGNhcGFjaXR5KSB7XG4gICAgICByZXR1cm4gVU5JVFNbaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFVOSVRTW2lsZW4gLSAxXTtcbn1cblxuLyoqXG4gKiBGaWd1cmVzIG91dCB3aGF0IHVuaXQgdG8gZm9ybWF0IGEgc2V0IG9mIHRpY2tzIHdpdGhcbiAqIEBwYXJhbSB7VGltZVNjYWxlfSBzY2FsZVxuICogQHBhcmFtIHtudW1iZXJ9IG51bVRpY2tzXG4gKiBAcGFyYW0ge1VuaXR9IG1pblVuaXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhcbiAqIEByZXR1cm4ge1VuaXR9XG4gKi9cbmZ1bmN0aW9uIGRldGVybWluZVVuaXRGb3JGb3JtYXR0aW5nKHNjYWxlLCBudW1UaWNrcywgbWluVW5pdCwgbWluLCBtYXgpIHtcbiAgZm9yIChsZXQgaSA9IFVOSVRTLmxlbmd0aCAtIDE7IGkgPj0gVU5JVFMuaW5kZXhPZihtaW5Vbml0KTsgaS0tKSB7XG4gICAgY29uc3QgdW5pdCA9IFVOSVRTW2ldO1xuICAgIGlmIChJTlRFUlZBTFNbdW5pdF0uY29tbW9uICYmIHNjYWxlLl9hZGFwdGVyLmRpZmYobWF4LCBtaW4sIHVuaXQpID49IG51bVRpY2tzIC0gMSkge1xuICAgICAgcmV0dXJuIHVuaXQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFVOSVRTW21pblVuaXQgPyBVTklUUy5pbmRleE9mKG1pblVuaXQpIDogMF07XG59XG5cbi8qKlxuICogQHBhcmFtIHtVbml0fSB1bml0XG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGRldGVybWluZU1ham9yVW5pdCh1bml0KSB7XG4gIGZvciAobGV0IGkgPSBVTklUUy5pbmRleE9mKHVuaXQpICsgMSwgaWxlbiA9IFVOSVRTLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGlmIChJTlRFUlZBTFNbVU5JVFNbaV1dLmNvbW1vbikge1xuICAgICAgcmV0dXJuIFVOSVRTW2ldO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSB0aWNrc1xuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVcbiAqIEBwYXJhbSB7bnVtYmVyW119IFt0aW1lc3RhbXBzXSAtIGlmIGRlZmluZWQsIHNuYXAgdG8gdGhlc2UgdGltZXN0YW1wc1xuICovXG5mdW5jdGlvbiBhZGRUaWNrKHRpY2tzLCB0aW1lLCB0aW1lc3RhbXBzKSB7XG4gIGlmICghdGltZXN0YW1wcykge1xuICAgIHRpY2tzW3RpbWVdID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgIGNvbnN0IHtsbywgaGl9ID0gX2xvb2t1cCh0aW1lc3RhbXBzLCB0aW1lKTtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSB0aW1lc3RhbXBzW2xvXSA+PSB0aW1lID8gdGltZXN0YW1wc1tsb10gOiB0aW1lc3RhbXBzW2hpXTtcbiAgICB0aWNrc1t0aW1lc3RhbXBdID0gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VGltZVNjYWxlfSBzY2FsZVxuICogQHBhcmFtIHtvYmplY3RbXX0gdGlja3NcbiAqIEBwYXJhbSB7b2JqZWN0fSBtYXBcbiAqIEBwYXJhbSB7VW5pdH0gbWFqb3JVbml0XG4gKiBAcmV0dXJuIHtvYmplY3RbXX1cbiAqL1xuZnVuY3Rpb24gc2V0TWFqb3JUaWNrcyhzY2FsZSwgdGlja3MsIG1hcCwgbWFqb3JVbml0KSB7XG4gIGNvbnN0IGFkYXB0ZXIgPSBzY2FsZS5fYWRhcHRlcjtcbiAgY29uc3QgZmlyc3QgPSArYWRhcHRlci5zdGFydE9mKHRpY2tzWzBdLnZhbHVlLCBtYWpvclVuaXQpO1xuICBjb25zdCBsYXN0ID0gdGlja3NbdGlja3MubGVuZ3RoIC0gMV0udmFsdWU7XG4gIGxldCBtYWpvciwgaW5kZXg7XG5cbiAgZm9yIChtYWpvciA9IGZpcnN0OyBtYWpvciA8PSBsYXN0OyBtYWpvciA9ICthZGFwdGVyLmFkZChtYWpvciwgMSwgbWFqb3JVbml0KSkge1xuICAgIGluZGV4ID0gbWFwW21ham9yXTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdGlja3NbaW5kZXhdLm1ham9yID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRpY2tzO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VGltZVNjYWxlfSBzY2FsZVxuICogQHBhcmFtIHtudW1iZXJbXX0gdmFsdWVzXG4gKiBAcGFyYW0ge1VuaXR8dW5kZWZpbmVkfSBbbWFqb3JVbml0XVxuICogQHJldHVybiB7b2JqZWN0W119XG4gKi9cbmZ1bmN0aW9uIHRpY2tzRnJvbVRpbWVzdGFtcHMoc2NhbGUsIHZhbHVlcywgbWFqb3JVbml0KSB7XG4gIGNvbnN0IHRpY2tzID0gW107XG4gIC8qKiBAdHlwZSB7T2JqZWN0PG51bWJlcixvYmplY3Q+fSAqL1xuICBjb25zdCBtYXAgPSB7fTtcbiAgY29uc3QgaWxlbiA9IHZhbHVlcy5sZW5ndGg7XG4gIGxldCBpLCB2YWx1ZTtcblxuICBmb3IgKGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgbWFwW3ZhbHVlXSA9IGk7XG5cbiAgICB0aWNrcy5wdXNoKHtcbiAgICAgIHZhbHVlLFxuICAgICAgbWFqb3I6IGZhbHNlXG4gICAgfSk7XG4gIH1cblxuICAvLyBXZSBzZXQgdGhlIG1ham9yIHRpY2tzIHNlcGFyYXRlbHkgZnJvbSB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIGNhbGxpbmcgc3RhcnRPZiBmb3IgZXZlcnkgdGlja1xuICAvLyBpcyBleHBlbnNpdmUgd2hlbiB0aGVyZSBpcyBhIGxhcmdlIG51bWJlciBvZiB0aWNrc1xuICByZXR1cm4gKGlsZW4gPT09IDAgfHwgIW1ham9yVW5pdCkgPyB0aWNrcyA6IHNldE1ham9yVGlja3Moc2NhbGUsIHRpY2tzLCBtYXAsIG1ham9yVW5pdCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbWVTY2FsZSBleHRlbmRzIFNjYWxlIHtcblxuICBzdGF0aWMgaWQgPSAndGltZSc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgLyoqXG4gICAgICogU2NhbGUgYm91bmRhcnkgc3RyYXRlZ3kgKGJ5cGFzc2VkIGJ5IG1pbi9tYXggdGltZSBvcHRpb25zKVxuICAgICAqIC0gYGRhdGFgOiBtYWtlIHN1cmUgZGF0YSBhcmUgZnVsbHkgdmlzaWJsZSwgdGlja3Mgb3V0c2lkZSBhcmUgcmVtb3ZlZFxuICAgICAqIC0gYHRpY2tzYDogbWFrZSBzdXJlIHRpY2tzIGFyZSBmdWxseSB2aXNpYmxlLCBkYXRhIG91dHNpZGUgYXJlIHRydW5jYXRlZFxuICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvcHVsbC80NTU2XG4gICAgICogQHNpbmNlIDIuNy4wXG4gICAgICovXG4gICAgYm91bmRzOiAnZGF0YScsXG5cbiAgICBhZGFwdGVyczoge30sXG4gICAgdGltZToge1xuICAgICAgcGFyc2VyOiBmYWxzZSwgLy8gZmFsc2UgPT0gYSBwYXR0ZXJuIHN0cmluZyBmcm9tIG9yIGEgY3VzdG9tIGNhbGxiYWNrIHRoYXQgY29udmVydHMgaXRzIGFyZ3VtZW50IHRvIGEgdGltZXN0YW1wXG4gICAgICB1bml0OiBmYWxzZSwgLy8gZmFsc2UgPT0gYXV0b21hdGljIG9yIG92ZXJyaWRlIHdpdGggd2VlaywgbW9udGgsIHllYXIsIGV0Yy5cbiAgICAgIHJvdW5kOiBmYWxzZSwgLy8gbm9uZSwgb3Igb3ZlcnJpZGUgd2l0aCB3ZWVrLCBtb250aCwgeWVhciwgZXRjLlxuICAgICAgaXNvV2Vla2RheTogZmFsc2UsIC8vIG92ZXJyaWRlIHdlZWsgc3RhcnQgZGF5XG4gICAgICBtaW5Vbml0OiAnbWlsbGlzZWNvbmQnLFxuICAgICAgZGlzcGxheUZvcm1hdHM6IHt9XG4gICAgfSxcbiAgICB0aWNrczoge1xuICAgICAgLyoqXG4gICAgICAgKiBUaWNrcyBnZW5lcmF0aW9uIGlucHV0IHZhbHVlczpcbiAgICAgICAqIC0gJ2F1dG8nOiBnZW5lcmF0ZXMgXCJvcHRpbWFsXCIgdGlja3MgYmFzZWQgb24gc2NhbGUgc2l6ZSBhbmQgdGltZSBvcHRpb25zLlxuICAgICAgICogLSAnZGF0YSc6IGdlbmVyYXRlcyB0aWNrcyBmcm9tIGRhdGEgKGluY2x1ZGluZyBsYWJlbHMgZnJvbSBkYXRhIHt0fHh8eX0gb2JqZWN0cykuXG4gICAgICAgKiAtICdsYWJlbHMnOiBnZW5lcmF0ZXMgdGlja3MgZnJvbSB1c2VyIGdpdmVuIGBkYXRhLmxhYmVsc2AgdmFsdWVzIE9OTFkuXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL3B1bGwvNDUwN1xuICAgICAgICogQHNpbmNlIDIuNy4wXG4gICAgICAgKi9cbiAgICAgIHNvdXJjZTogJ2F1dG8nLFxuXG4gICAgICBjYWxsYmFjazogZmFsc2UsXG5cbiAgICAgIG1ham9yOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcblx0ICovXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuXG4gICAgLyoqIEB0eXBlIHt7ZGF0YTogbnVtYmVyW10sIGxhYmVsczogbnVtYmVyW10sIGFsbDogbnVtYmVyW119fSAqL1xuICAgIHRoaXMuX2NhY2hlID0ge1xuICAgICAgZGF0YTogW10sXG4gICAgICBsYWJlbHM6IFtdLFxuICAgICAgYWxsOiBbXVxuICAgIH07XG5cbiAgICAvKiogQHR5cGUge1VuaXR9ICovXG4gICAgdGhpcy5fdW5pdCA9ICdkYXknO1xuICAgIC8qKiBAdHlwZSB7VW5pdD19ICovXG4gICAgdGhpcy5fbWFqb3JVbml0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX29mZnNldHMgPSB7fTtcbiAgICB0aGlzLl9ub3JtYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5fcGFyc2VPcHRzID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaW5pdChzY2FsZU9wdHMsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IHRpbWUgPSBzY2FsZU9wdHMudGltZSB8fCAoc2NhbGVPcHRzLnRpbWUgPSB7fSk7XG4gICAgLyoqIEB0eXBlIHtEYXRlQWRhcHRlcn0gKi9cbiAgICBjb25zdCBhZGFwdGVyID0gdGhpcy5fYWRhcHRlciA9IG5ldyBhZGFwdGVycy5fZGF0ZShzY2FsZU9wdHMuYWRhcHRlcnMuZGF0ZSk7XG5cbiAgICBhZGFwdGVyLmluaXQob3B0cyk7XG5cbiAgICAvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5OiBiZWZvcmUgaW50cm9kdWNpbmcgYWRhcHRlciwgYGRpc3BsYXlGb3JtYXRzYCB3YXNcbiAgICAvLyBzdXBwb3NlZCB0byBjb250YWluICphbGwqIHVuaXQvc3RyaW5nIHBhaXJzIGJ1dCB0aGlzIGNhbid0IGJlIHJlc29sdmVkXG4gICAgLy8gd2hlbiBsb2FkaW5nIHRoZSBzY2FsZSAoYWRhcHRlcnMgYXJlIGxvYWRlZCBhZnRlcndhcmQpLCBzbyBsZXQncyBwb3B1bGF0ZVxuICAgIC8vIG1pc3NpbmcgZm9ybWF0cyBvbiB1cGRhdGVcbiAgICBtZXJnZUlmKHRpbWUuZGlzcGxheUZvcm1hdHMsIGFkYXB0ZXIuZm9ybWF0cygpKTtcblxuICAgIHRoaXMuX3BhcnNlT3B0cyA9IHtcbiAgICAgIHBhcnNlcjogdGltZS5wYXJzZXIsXG4gICAgICByb3VuZDogdGltZS5yb3VuZCxcbiAgICAgIGlzb1dlZWtkYXk6IHRpbWUuaXNvV2Vla2RheVxuICAgIH07XG5cbiAgICBzdXBlci5pbml0KHNjYWxlT3B0cyk7XG5cbiAgICB0aGlzLl9ub3JtYWxpemVkID0gb3B0cy5ub3JtYWxpemVkO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7Kn0gcmF3XG5cdCAqIEBwYXJhbSB7bnVtYmVyP30gW2luZGV4XVxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBwYXJzZShyYXcsIGluZGV4KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICBpZiAocmF3ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2UodGhpcywgcmF3KTtcbiAgfVxuXG4gIGJlZm9yZUxheW91dCgpIHtcbiAgICBzdXBlci5iZWZvcmVMYXlvdXQoKTtcbiAgICB0aGlzLl9jYWNoZSA9IHtcbiAgICAgIGRhdGE6IFtdLFxuICAgICAgbGFiZWxzOiBbXSxcbiAgICAgIGFsbDogW11cbiAgICB9O1xuICB9XG5cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzLl9hZGFwdGVyO1xuICAgIGNvbnN0IHVuaXQgPSBvcHRpb25zLnRpbWUudW5pdCB8fCAnZGF5JztcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG4gICAgbGV0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcblxuICAgIC8qKlxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBib3VuZHNcblx0XHQgKi9cbiAgICBmdW5jdGlvbiBfYXBwbHlCb3VuZHMoYm91bmRzKSB7XG4gICAgICBpZiAoIW1pbkRlZmluZWQgJiYgIWlzTmFOKGJvdW5kcy5taW4pKSB7XG4gICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgYm91bmRzLm1pbik7XG4gICAgICB9XG4gICAgICBpZiAoIW1heERlZmluZWQgJiYgIWlzTmFOKGJvdW5kcy5tYXgpKSB7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgYm91bmRzLm1heCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgaGF2ZSB1c2VyIHByb3ZpZGVkIGBtaW5gIGFuZCBgbWF4YCBsYWJlbHMgLyBkYXRhIGJvdW5kcyBjYW4gYmUgaWdub3JlZFxuICAgIGlmICghbWluRGVmaW5lZCB8fCAhbWF4RGVmaW5lZCkge1xuICAgICAgLy8gTGFiZWxzIGFyZSBhbHdheXMgY29uc2lkZXJlZCwgd2hlbiB1c2VyIGRpZCBub3QgZm9yY2UgYm91bmRzXG4gICAgICBfYXBwbHlCb3VuZHModGhpcy5fZ2V0TGFiZWxCb3VuZHMoKSk7XG5cbiAgICAgIC8vIElmIGBib3VuZHNgIGlzIGAndGlja3MnYCBhbmQgYHRpY2tzLnNvdXJjZWAgaXMgYCdsYWJlbHMnYCxcbiAgICAgIC8vIGRhdGEgYm91bmRzIGFyZSBpZ25vcmVkIChhbmQgZG9uJ3QgbmVlZCB0byBiZSBkZXRlcm1pbmVkKVxuICAgICAgaWYgKG9wdGlvbnMuYm91bmRzICE9PSAndGlja3MnIHx8IG9wdGlvbnMudGlja3Muc291cmNlICE9PSAnbGFiZWxzJykge1xuICAgICAgICBfYXBwbHlCb3VuZHModGhpcy5nZXRNaW5NYXgoZmFsc2UpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtaW4gPSBpc0Zpbml0ZShtaW4pICYmICFpc05hTihtaW4pID8gbWluIDogK2FkYXB0ZXIuc3RhcnRPZihEYXRlLm5vdygpLCB1bml0KTtcbiAgICBtYXggPSBpc0Zpbml0ZShtYXgpICYmICFpc05hTihtYXgpID8gbWF4IDogK2FkYXB0ZXIuZW5kT2YoRGF0ZS5ub3coKSwgdW5pdCkgKyAxO1xuXG4gICAgLy8gTWFrZSBzdXJlIHRoYXQgbWF4IGlzIHN0cmljdGx5IGhpZ2hlciB0aGFuIG1pbiAocmVxdWlyZWQgYnkgdGhlIHRpbWVzZXJpZXMgbG9va3VwIHRhYmxlKVxuICAgIHRoaXMubWluID0gTWF0aC5taW4obWluLCBtYXggLSAxKTtcbiAgICB0aGlzLm1heCA9IE1hdGgubWF4KG1pbiArIDEsIG1heCk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRMYWJlbEJvdW5kcygpIHtcbiAgICBjb25zdCBhcnIgPSB0aGlzLmdldExhYmVsVGltZXN0YW1wcygpO1xuICAgIGxldCBtaW4gPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgbGV0IG1heCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcblxuICAgIGlmIChhcnIubGVuZ3RoKSB7XG4gICAgICBtaW4gPSBhcnJbMF07XG4gICAgICBtYXggPSBhcnJbYXJyLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICByZXR1cm4ge21pbiwgbWF4fTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtvYmplY3RbXX1cblx0ICovXG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aW1lT3B0cyA9IG9wdGlvbnMudGltZTtcbiAgICBjb25zdCB0aWNrT3B0cyA9IG9wdGlvbnMudGlja3M7XG4gICAgY29uc3QgdGltZXN0YW1wcyA9IHRpY2tPcHRzLnNvdXJjZSA9PT0gJ2xhYmVscycgPyB0aGlzLmdldExhYmVsVGltZXN0YW1wcygpIDogdGhpcy5fZ2VuZXJhdGUoKTtcblxuICAgIGlmIChvcHRpb25zLmJvdW5kcyA9PT0gJ3RpY2tzJyAmJiB0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgdGhpcy5taW4gPSB0aGlzLl91c2VyTWluIHx8IHRpbWVzdGFtcHNbMF07XG4gICAgICB0aGlzLm1heCA9IHRoaXMuX3VzZXJNYXggfHwgdGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDFdO1xuICAgIH1cblxuICAgIGNvbnN0IG1pbiA9IHRoaXMubWluO1xuICAgIGNvbnN0IG1heCA9IHRoaXMubWF4O1xuXG4gICAgY29uc3QgdGlja3MgPSBfZmlsdGVyQmV0d2Vlbih0aW1lc3RhbXBzLCBtaW4sIG1heCk7XG5cbiAgICAvLyBQUklWQVRFXG4gICAgLy8gZGV0ZXJtaW5lVW5pdEZvckZvcm1hdHRpbmcgcmVsaWVzIG9uIHRoZSBudW1iZXIgb2YgdGlja3Mgc28gd2UgZG9uJ3QgdXNlIGl0IHdoZW5cbiAgICAvLyBhdXRvU2tpcCBpcyBlbmFibGVkIGJlY2F1c2Ugd2UgZG9uJ3QgeWV0IGtub3cgd2hhdCB0aGUgZmluYWwgbnVtYmVyIG9mIHRpY2tzIHdpbGwgYmVcbiAgICB0aGlzLl91bml0ID0gdGltZU9wdHMudW5pdCB8fCAodGlja09wdHMuYXV0b1NraXBcbiAgICAgID8gZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyh0aW1lT3B0cy5taW5Vbml0LCB0aGlzLm1pbiwgdGhpcy5tYXgsIHRoaXMuX2dldExhYmVsQ2FwYWNpdHkobWluKSlcbiAgICAgIDogZGV0ZXJtaW5lVW5pdEZvckZvcm1hdHRpbmcodGhpcywgdGlja3MubGVuZ3RoLCB0aW1lT3B0cy5taW5Vbml0LCB0aGlzLm1pbiwgdGhpcy5tYXgpKTtcbiAgICB0aGlzLl9tYWpvclVuaXQgPSAhdGlja09wdHMubWFqb3IuZW5hYmxlZCB8fCB0aGlzLl91bml0ID09PSAneWVhcicgPyB1bmRlZmluZWRcbiAgICAgIDogZGV0ZXJtaW5lTWFqb3JVbml0KHRoaXMuX3VuaXQpO1xuICAgIHRoaXMuaW5pdE9mZnNldHModGltZXN0YW1wcyk7XG5cbiAgICBpZiAob3B0aW9ucy5yZXZlcnNlKSB7XG4gICAgICB0aWNrcy5yZXZlcnNlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRpY2tzRnJvbVRpbWVzdGFtcHModGhpcywgdGlja3MsIHRoaXMuX21ham9yVW5pdCk7XG4gIH1cblxuICBhZnRlckF1dG9Ta2lwKCkge1xuICAgIC8vIE9mZnNldHMgZm9yIGJhciBjaGFydHMgbmVlZCB0byBiZSBoYW5kbGVkIHdpdGggdGhlIGF1dG8gc2tpcHBlZFxuICAgIC8vIHRpY2tzLiBPbmNlIHRpY2tzIGhhdmUgYmVlbiBza2lwcGVkLCB3ZSByZS1jb21wdXRlIHRoZSBvZmZzZXRzLlxuICAgIGlmICh0aGlzLm9wdGlvbnMub2Zmc2V0QWZ0ZXJBdXRvc2tpcCkge1xuICAgICAgdGhpcy5pbml0T2Zmc2V0cyh0aGlzLnRpY2tzLm1hcCh0aWNrID0+ICt0aWNrLnZhbHVlKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIHN0YXJ0IGFuZCBlbmQgb2Zmc2V0cyBmcm9tIGVkZ2VzIGluIHRoZSBmb3JtIG9mIHtzdGFydCwgZW5kfVxuXHQgKiB3aGVyZSBlYWNoIHZhbHVlIGlzIGEgcmVsYXRpdmUgd2lkdGggdG8gdGhlIHNjYWxlIGFuZCByYW5nZXMgYmV0d2VlbiAwIGFuZCAxLlxuXHQgKiBUaGV5IGFkZCBleHRyYSBtYXJnaW5zIG9uIHRoZSBib3RoIHNpZGVzIGJ5IHNjYWxpbmcgZG93biB0aGUgb3JpZ2luYWwgc2NhbGUuXG5cdCAqIE9mZnNldHMgYXJlIGFkZGVkIHdoZW4gdGhlIGBvZmZzZXRgIG9wdGlvbiBpcyB0cnVlLlxuXHQgKiBAcGFyYW0ge251bWJlcltdfSB0aW1lc3RhbXBzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGluaXRPZmZzZXRzKHRpbWVzdGFtcHMgPSBbXSkge1xuICAgIGxldCBzdGFydCA9IDA7XG4gICAgbGV0IGVuZCA9IDA7XG4gICAgbGV0IGZpcnN0LCBsYXN0O1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5vZmZzZXQgJiYgdGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIGZpcnN0ID0gdGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodGltZXN0YW1wc1swXSk7XG4gICAgICBpZiAodGltZXN0YW1wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgc3RhcnQgPSAxIC0gZmlyc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydCA9ICh0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0aW1lc3RhbXBzWzFdKSAtIGZpcnN0KSAvIDI7XG4gICAgICB9XG4gICAgICBsYXN0ID0gdGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDFdKTtcbiAgICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBlbmQgPSBsYXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kID0gKGxhc3QgLSB0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMl0pKSAvIDI7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGxpbWl0ID0gdGltZXN0YW1wcy5sZW5ndGggPCAzID8gMC41IDogMC4yNTtcbiAgICBzdGFydCA9IF9saW1pdFZhbHVlKHN0YXJ0LCAwLCBsaW1pdCk7XG4gICAgZW5kID0gX2xpbWl0VmFsdWUoZW5kLCAwLCBsaW1pdCk7XG5cbiAgICB0aGlzLl9vZmZzZXRzID0ge3N0YXJ0LCBlbmQsIGZhY3RvcjogMSAvIChzdGFydCArIDEgKyBlbmQpfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBHZW5lcmF0ZXMgYSBtYXhpbXVtIG9mIGBjYXBhY2l0eWAgdGltZXN0YW1wcyBiZXR3ZWVuIG1pbiBhbmQgbWF4LCByb3VuZGVkIHRvIHRoZVxuXHQgKiBgbWlub3JgIHVuaXQgdXNpbmcgdGhlIGdpdmVuIHNjYWxlIHRpbWUgYG9wdGlvbnNgLlxuXHQgKiBJbXBvcnRhbnQ6IHRoaXMgbWV0aG9kIGNhbiByZXR1cm4gdGlja3Mgb3V0c2lkZSB0aGUgbWluIGFuZCBtYXggcmFuZ2UsIGl0J3MgdGhlXG5cdCAqIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSBjYWxsaW5nIGNvZGUgdG8gY2xhbXAgdmFsdWVzIGlmIG5lZWRlZC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgX2dlbmVyYXRlKCkge1xuICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzLl9hZGFwdGVyO1xuICAgIGNvbnN0IG1pbiA9IHRoaXMubWluO1xuICAgIGNvbnN0IG1heCA9IHRoaXMubWF4O1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGltZU9wdHMgPSBvcHRpb25zLnRpbWU7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IG1pbm9yID0gdGltZU9wdHMudW5pdCB8fCBkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzKHRpbWVPcHRzLm1pblVuaXQsIG1pbiwgbWF4LCB0aGlzLl9nZXRMYWJlbENhcGFjaXR5KG1pbikpO1xuICAgIGNvbnN0IHN0ZXBTaXplID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy50aWNrcy5zdGVwU2l6ZSwgMSk7XG4gICAgY29uc3Qgd2Vla2RheSA9IG1pbm9yID09PSAnd2VlaycgPyB0aW1lT3B0cy5pc29XZWVrZGF5IDogZmFsc2U7XG4gICAgY29uc3QgaGFzV2Vla2RheSA9IGlzTnVtYmVyKHdlZWtkYXkpIHx8IHdlZWtkYXkgPT09IHRydWU7XG4gICAgY29uc3QgdGlja3MgPSB7fTtcbiAgICBsZXQgZmlyc3QgPSBtaW47XG4gICAgbGV0IHRpbWUsIGNvdW50O1xuXG4gICAgLy8gRm9yICd3ZWVrJyB1bml0LCBoYW5kbGUgdGhlIGZpcnN0IGRheSBvZiB3ZWVrIG9wdGlvblxuICAgIGlmIChoYXNXZWVrZGF5KSB7XG4gICAgICBmaXJzdCA9ICthZGFwdGVyLnN0YXJ0T2YoZmlyc3QsICdpc29XZWVrJywgd2Vla2RheSk7XG4gICAgfVxuXG4gICAgLy8gQWxpZ24gZmlyc3QgdGlja3Mgb24gdW5pdFxuICAgIGZpcnN0ID0gK2FkYXB0ZXIuc3RhcnRPZihmaXJzdCwgaGFzV2Vla2RheSA/ICdkYXknIDogbWlub3IpO1xuXG4gICAgLy8gUHJldmVudCBicm93c2VyIGZyb20gZnJlZXppbmcgaW4gY2FzZSB1c2VyIG9wdGlvbnMgcmVxdWVzdCBtaWxsaW9ucyBvZiBtaWxsaXNlY29uZHNcbiAgICBpZiAoYWRhcHRlci5kaWZmKG1heCwgbWluLCBtaW5vcikgPiAxMDAwMDAgKiBzdGVwU2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1pbiArICcgYW5kICcgKyBtYXggKyAnIGFyZSB0b28gZmFyIGFwYXJ0IHdpdGggc3RlcFNpemUgb2YgJyArIHN0ZXBTaXplICsgJyAnICsgbWlub3IpO1xuICAgIH1cblxuICAgIGNvbnN0IHRpbWVzdGFtcHMgPSBvcHRpb25zLnRpY2tzLnNvdXJjZSA9PT0gJ2RhdGEnICYmIHRoaXMuZ2V0RGF0YVRpbWVzdGFtcHMoKTtcbiAgICBmb3IgKHRpbWUgPSBmaXJzdCwgY291bnQgPSAwOyB0aW1lIDwgbWF4OyB0aW1lID0gK2FkYXB0ZXIuYWRkKHRpbWUsIHN0ZXBTaXplLCBtaW5vciksIGNvdW50KyspIHtcbiAgICAgIGFkZFRpY2sodGlja3MsIHRpbWUsIHRpbWVzdGFtcHMpO1xuICAgIH1cblxuICAgIGlmICh0aW1lID09PSBtYXggfHwgb3B0aW9ucy5ib3VuZHMgPT09ICd0aWNrcycgfHwgY291bnQgPT09IDEpIHtcbiAgICAgIGFkZFRpY2sodGlja3MsIHRpbWUsIHRpbWVzdGFtcHMpO1xuICAgIH1cblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGlja3MpLnNvcnQoc29ydGVyKS5tYXAoeCA9PiAreCk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG4gIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBhZGFwdGVyID0gdGhpcy5fYWRhcHRlcjtcbiAgICBjb25zdCB0aW1lT3B0cyA9IHRoaXMub3B0aW9ucy50aW1lO1xuXG4gICAgaWYgKHRpbWVPcHRzLnRvb2x0aXBGb3JtYXQpIHtcbiAgICAgIHJldHVybiBhZGFwdGVyLmZvcm1hdCh2YWx1ZSwgdGltZU9wdHMudG9vbHRpcEZvcm1hdCk7XG4gICAgfVxuICAgIHJldHVybiBhZGFwdGVyLmZvcm1hdCh2YWx1ZSwgdGltZU9wdHMuZGlzcGxheUZvcm1hdHMuZGF0ZXRpbWUpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuXHQgKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IGZvcm1hdFxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuICBmb3JtYXQodmFsdWUsIGZvcm1hdCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgZm9ybWF0cyA9IG9wdGlvbnMudGltZS5kaXNwbGF5Rm9ybWF0cztcbiAgICBjb25zdCB1bml0ID0gdGhpcy5fdW5pdDtcbiAgICBjb25zdCBmbXQgPSBmb3JtYXQgfHwgZm9ybWF0c1t1bml0XTtcbiAgICByZXR1cm4gdGhpcy5fYWRhcHRlci5mb3JtYXQodmFsdWUsIGZtdCk7XG4gIH1cblxuICAvKipcblx0ICogRnVuY3Rpb24gdG8gZm9ybWF0IGFuIGluZGl2aWR1YWwgdGljayBtYXJrXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuXHQgKiBAcGFyYW0ge29iamVjdFtdfSB0aWNrc1xuXHQgKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IFtmb3JtYXRdXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF90aWNrRm9ybWF0RnVuY3Rpb24odGltZSwgaW5kZXgsIHRpY2tzLCBmb3JtYXQpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGZvcm1hdHRlciA9IG9wdGlvbnMudGlja3MuY2FsbGJhY2s7XG5cbiAgICBpZiAoZm9ybWF0dGVyKSB7XG4gICAgICByZXR1cm4gY2FsbChmb3JtYXR0ZXIsIFt0aW1lLCBpbmRleCwgdGlja3NdLCB0aGlzKTtcbiAgICB9XG5cbiAgICBjb25zdCBmb3JtYXRzID0gb3B0aW9ucy50aW1lLmRpc3BsYXlGb3JtYXRzO1xuICAgIGNvbnN0IHVuaXQgPSB0aGlzLl91bml0O1xuICAgIGNvbnN0IG1ham9yVW5pdCA9IHRoaXMuX21ham9yVW5pdDtcbiAgICBjb25zdCBtaW5vckZvcm1hdCA9IHVuaXQgJiYgZm9ybWF0c1t1bml0XTtcbiAgICBjb25zdCBtYWpvckZvcm1hdCA9IG1ham9yVW5pdCAmJiBmb3JtYXRzW21ham9yVW5pdF07XG4gICAgY29uc3QgdGljayA9IHRpY2tzW2luZGV4XTtcbiAgICBjb25zdCBtYWpvciA9IG1ham9yVW5pdCAmJiBtYWpvckZvcm1hdCAmJiB0aWNrICYmIHRpY2subWFqb3I7XG5cbiAgICByZXR1cm4gdGhpcy5fYWRhcHRlci5mb3JtYXQodGltZSwgZm9ybWF0IHx8IChtYWpvciA/IG1ham9yRm9ybWF0IDogbWlub3JGb3JtYXQpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge29iamVjdFtdfSB0aWNrc1xuXHQgKi9cbiAgZ2VuZXJhdGVUaWNrTGFiZWxzKHRpY2tzKSB7XG4gICAgbGV0IGksIGlsZW4sIHRpY2s7XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aWNrID0gdGlja3NbaV07XG4gICAgICB0aWNrLmxhYmVsID0gdGhpcy5fdGlja0Zvcm1hdEZ1bmN0aW9uKHRpY2sudmFsdWUsIGksIHRpY2tzKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gTWlsbGlzZWNvbmRzIHNpbmNlIGVwb2NoICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldERlY2ltYWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IE5hTiA6ICh2YWx1ZSAtIHRoaXMubWluKSAvICh0aGlzLm1heCAtIHRoaXMubWluKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBNaWxsaXNlY29uZHMgc2luY2UgZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQylcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cbiAgZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IG9mZnNldHMgPSB0aGlzLl9vZmZzZXRzO1xuICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvckRlY2ltYWwoKG9mZnNldHMuc3RhcnQgKyBwb3MpICogb2Zmc2V0cy5mYWN0b3IpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgY29uc3Qgb2Zmc2V0cyA9IHRoaXMuX29mZnNldHM7XG4gICAgY29uc3QgcG9zID0gdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpIC8gb2Zmc2V0cy5mYWN0b3IgLSBvZmZzZXRzLmVuZDtcbiAgICByZXR1cm4gdGhpcy5taW4gKyBwb3MgKiAodGhpcy5tYXggLSB0aGlzLm1pbik7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGxhYmVsXG5cdCAqIEByZXR1cm4ge3t3Om51bWJlciwgaDpudW1iZXJ9fVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldExhYmVsU2l6ZShsYWJlbCkge1xuICAgIGNvbnN0IHRpY2tzT3B0cyA9IHRoaXMub3B0aW9ucy50aWNrcztcbiAgICBjb25zdCB0aWNrTGFiZWxXaWR0aCA9IHRoaXMuY3R4Lm1lYXN1cmVUZXh0KGxhYmVsKS53aWR0aDtcbiAgICBjb25zdCBhbmdsZSA9IHRvUmFkaWFucyh0aGlzLmlzSG9yaXpvbnRhbCgpID8gdGlja3NPcHRzLm1heFJvdGF0aW9uIDogdGlja3NPcHRzLm1pblJvdGF0aW9uKTtcbiAgICBjb25zdCBjb3NSb3RhdGlvbiA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICBjb25zdCBzaW5Sb3RhdGlvbiA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICBjb25zdCB0aWNrRm9udFNpemUgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKDApLnNpemU7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdzogKHRpY2tMYWJlbFdpZHRoICogY29zUm90YXRpb24pICsgKHRpY2tGb250U2l6ZSAqIHNpblJvdGF0aW9uKSxcbiAgICAgIGg6ICh0aWNrTGFiZWxXaWR0aCAqIHNpblJvdGF0aW9uKSArICh0aWNrRm9udFNpemUgKiBjb3NSb3RhdGlvbilcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBleGFtcGxlVGltZVxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0TGFiZWxDYXBhY2l0eShleGFtcGxlVGltZSkge1xuICAgIGNvbnN0IHRpbWVPcHRzID0gdGhpcy5vcHRpb25zLnRpbWU7XG4gICAgY29uc3QgZGlzcGxheUZvcm1hdHMgPSB0aW1lT3B0cy5kaXNwbGF5Rm9ybWF0cztcblxuICAgIC8vIHBpY2sgdGhlIGxvbmdlc3QgZm9ybWF0IChtaWxsaXNlY29uZHMpIGZvciBndWVzc3RpbWF0aW9uXG4gICAgY29uc3QgZm9ybWF0ID0gZGlzcGxheUZvcm1hdHNbdGltZU9wdHMudW5pdF0gfHwgZGlzcGxheUZvcm1hdHMubWlsbGlzZWNvbmQ7XG4gICAgY29uc3QgZXhhbXBsZUxhYmVsID0gdGhpcy5fdGlja0Zvcm1hdEZ1bmN0aW9uKGV4YW1wbGVUaW1lLCAwLCB0aWNrc0Zyb21UaW1lc3RhbXBzKHRoaXMsIFtleGFtcGxlVGltZV0sIHRoaXMuX21ham9yVW5pdCksIGZvcm1hdCk7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuX2dldExhYmVsU2l6ZShleGFtcGxlTGFiZWwpO1xuICAgIC8vIHN1YnRyYWN0IDEgLSBpZiBvZmZzZXQgdGhlbiB0aGVyZSdzIG9uZSBsZXNzIGxhYmVsIHRoYW4gdGlja1xuICAgIC8vIGlmIG5vdCBvZmZzZXQgdGhlbiBvbmUgaGFsZiBsYWJlbCBwYWRkaW5nIGlzIGFkZGVkIHRvIGVhY2ggZW5kIGxlYXZpbmcgcm9vbSBmb3Igb25lIGxlc3MgbGFiZWxcbiAgICBjb25zdCBjYXBhY2l0eSA9IE1hdGguZmxvb3IodGhpcy5pc0hvcml6b250YWwoKSA/IHRoaXMud2lkdGggLyBzaXplLncgOiB0aGlzLmhlaWdodCAvIHNpemUuaCkgLSAxO1xuICAgIHJldHVybiBjYXBhY2l0eSA+IDAgPyBjYXBhY2l0eSA6IDE7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0RGF0YVRpbWVzdGFtcHMoKSB7XG4gICAgbGV0IHRpbWVzdGFtcHMgPSB0aGlzLl9jYWNoZS5kYXRhIHx8IFtdO1xuICAgIGxldCBpLCBpbGVuO1xuXG4gICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGltZXN0YW1wcztcbiAgICB9XG5cbiAgICBjb25zdCBtZXRhcyA9IHRoaXMuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoKTtcblxuICAgIGlmICh0aGlzLl9ub3JtYWxpemVkICYmIG1ldGFzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuICh0aGlzLl9jYWNoZS5kYXRhID0gbWV0YXNbMF0uY29udHJvbGxlci5nZXRBbGxQYXJzZWRWYWx1ZXModGhpcykpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBtZXRhcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRpbWVzdGFtcHMgPSB0aW1lc3RhbXBzLmNvbmNhdChtZXRhc1tpXS5jb250cm9sbGVyLmdldEFsbFBhcnNlZFZhbHVlcyh0aGlzKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuICh0aGlzLl9jYWNoZS5kYXRhID0gdGhpcy5ub3JtYWxpemUodGltZXN0YW1wcykpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldExhYmVsVGltZXN0YW1wcygpIHtcbiAgICBjb25zdCB0aW1lc3RhbXBzID0gdGhpcy5fY2FjaGUubGFiZWxzIHx8IFtdO1xuICAgIGxldCBpLCBpbGVuO1xuXG4gICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGltZXN0YW1wcztcbiAgICB9XG5cbiAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBsYWJlbHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aW1lc3RhbXBzLnB1c2gocGFyc2UodGhpcywgbGFiZWxzW2ldKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuICh0aGlzLl9jYWNoZS5sYWJlbHMgPSB0aGlzLl9ub3JtYWxpemVkID8gdGltZXN0YW1wcyA6IHRoaXMubm9ybWFsaXplKHRpbWVzdGFtcHMpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcltdfSB2YWx1ZXNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgbm9ybWFsaXplKHZhbHVlcykge1xuICAgIC8vIEl0IHNlZW1zIHRvIGJlIHNvbWV3aGF0IGZhc3RlciB0byBkbyBzb3J0aW5nIGZpcnN0XG4gICAgcmV0dXJuIF9hcnJheVVuaXF1ZSh2YWx1ZXMuc29ydChzb3J0ZXIpKTtcbiAgfVxufVxuIiwiaW1wb3J0IFRpbWVTY2FsZSBmcm9tICcuL3NjYWxlLnRpbWUuanMnO1xuaW1wb3J0IHtfbG9va3VwQnlLZXl9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb2xsZWN0aW9uLmpzJztcblxuLyoqXG4gKiBMaW5lYXJseSBpbnRlcnBvbGF0ZXMgdGhlIGdpdmVuIHNvdXJjZSBgdmFsYCB1c2luZyB0aGUgdGFibGUuIElmIHZhbHVlIGlzIG91dCBvZiBib3VuZHMsIHZhbHVlc1xuICogYXQgZWRnZXMgYXJlIHVzZWQgZm9yIHRoZSBpbnRlcnBvbGF0aW9uLlxuICogQHBhcmFtIHtvYmplY3R9IHRhYmxlXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXZlcnNlXSBsb29rdXAgdGltZSBiYXNlZCBvbiBwb3NpdGlvbiBpbnN0ZWFkIG9mIHZpY2UgdmVyc2FcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gaW50ZXJwb2xhdGUodGFibGUsIHZhbCwgcmV2ZXJzZSkge1xuICBsZXQgbG8gPSAwO1xuICBsZXQgaGkgPSB0YWJsZS5sZW5ndGggLSAxO1xuICBsZXQgcHJldlNvdXJjZSwgbmV4dFNvdXJjZSwgcHJldlRhcmdldCwgbmV4dFRhcmdldDtcbiAgaWYgKHJldmVyc2UpIHtcbiAgICBpZiAodmFsID49IHRhYmxlW2xvXS5wb3MgJiYgdmFsIDw9IHRhYmxlW2hpXS5wb3MpIHtcbiAgICAgICh7bG8sIGhpfSA9IF9sb29rdXBCeUtleSh0YWJsZSwgJ3BvcycsIHZhbCkpO1xuICAgIH1cbiAgICAoe3BvczogcHJldlNvdXJjZSwgdGltZTogcHJldlRhcmdldH0gPSB0YWJsZVtsb10pO1xuICAgICh7cG9zOiBuZXh0U291cmNlLCB0aW1lOiBuZXh0VGFyZ2V0fSA9IHRhYmxlW2hpXSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZhbCA+PSB0YWJsZVtsb10udGltZSAmJiB2YWwgPD0gdGFibGVbaGldLnRpbWUpIHtcbiAgICAgICh7bG8sIGhpfSA9IF9sb29rdXBCeUtleSh0YWJsZSwgJ3RpbWUnLCB2YWwpKTtcbiAgICB9XG4gICAgKHt0aW1lOiBwcmV2U291cmNlLCBwb3M6IHByZXZUYXJnZXR9ID0gdGFibGVbbG9dKTtcbiAgICAoe3RpbWU6IG5leHRTb3VyY2UsIHBvczogbmV4dFRhcmdldH0gPSB0YWJsZVtoaV0pO1xuICB9XG5cbiAgY29uc3Qgc3BhbiA9IG5leHRTb3VyY2UgLSBwcmV2U291cmNlO1xuICByZXR1cm4gc3BhbiA/IHByZXZUYXJnZXQgKyAobmV4dFRhcmdldCAtIHByZXZUYXJnZXQpICogKHZhbCAtIHByZXZTb3VyY2UpIC8gc3BhbiA6IHByZXZUYXJnZXQ7XG59XG5cbmNsYXNzIFRpbWVTZXJpZXNTY2FsZSBleHRlbmRzIFRpbWVTY2FsZSB7XG5cbiAgc3RhdGljIGlkID0gJ3RpbWVzZXJpZXMnO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0gVGltZVNjYWxlLmRlZmF1bHRzO1xuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcblx0ICovXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuXG4gICAgLyoqIEB0eXBlIHtvYmplY3RbXX0gKi9cbiAgICB0aGlzLl90YWJsZSA9IFtdO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuX21pblBvcyA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLl90YWJsZVJhbmdlID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGluaXRPZmZzZXRzKCkge1xuICAgIGNvbnN0IHRpbWVzdGFtcHMgPSB0aGlzLl9nZXRUaW1lc3RhbXBzRm9yVGFibGUoKTtcbiAgICBjb25zdCB0YWJsZSA9IHRoaXMuX3RhYmxlID0gdGhpcy5idWlsZExvb2t1cFRhYmxlKHRpbWVzdGFtcHMpO1xuICAgIHRoaXMuX21pblBvcyA9IGludGVycG9sYXRlKHRhYmxlLCB0aGlzLm1pbik7XG4gICAgdGhpcy5fdGFibGVSYW5nZSA9IGludGVycG9sYXRlKHRhYmxlLCB0aGlzLm1heCkgLSB0aGlzLl9taW5Qb3M7XG4gICAgc3VwZXIuaW5pdE9mZnNldHModGltZXN0YW1wcyk7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyBhbiBhcnJheSBvZiB7dGltZSwgcG9zfSBvYmplY3RzIHVzZWQgdG8gaW50ZXJwb2xhdGUgYSBzcGVjaWZpYyBgdGltZWAgb3IgcG9zaXRpb25cblx0ICogKGBwb3NgKSBvbiB0aGUgc2NhbGUsIGJ5IHNlYXJjaGluZyBlbnRyaWVzIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIHJlcXVlc3RlZCB2YWx1ZS4gYHBvc2AgaXNcblx0ICogYSBkZWNpbWFsIGJldHdlZW4gMCBhbmQgMTogMCBiZWluZyB0aGUgc3RhcnQgb2YgdGhlIHNjYWxlIChsZWZ0IG9yIHRvcCkgYW5kIDEgdGhlIG90aGVyXG5cdCAqIGV4dHJlbWl0eSAobGVmdCArIHdpZHRoIG9yIHRvcCArIGhlaWdodCkuIE5vdGUgdGhhdCBpdCB3b3VsZCBiZSBtb3JlIG9wdGltaXplZCB0byBkaXJlY3RseVxuXHQgKiBzdG9yZSBwcmUtY29tcHV0ZWQgcGl4ZWxzLCBidXQgdGhlIHNjYWxlIGRpbWVuc2lvbnMgYXJlIG5vdCBndWFyYW50ZWVkIGF0IHRoZSB0aW1lIHdlIG5lZWRcblx0ICogdG8gY3JlYXRlIHRoZSBsb29rdXAgdGFibGUuIFRoZSB0YWJsZSBBTFdBWVMgY29udGFpbnMgYXQgbGVhc3QgdHdvIGl0ZW1zOiBtaW4gYW5kIG1heC5cblx0ICogQHBhcmFtIHtudW1iZXJbXX0gdGltZXN0YW1wc1xuXHQgKiBAcmV0dXJuIHtvYmplY3RbXX1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgYnVpbGRMb29rdXBUYWJsZSh0aW1lc3RhbXBzKSB7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXM7XG4gICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICBjb25zdCB0YWJsZSA9IFtdO1xuICAgIGxldCBpLCBpbGVuLCBwcmV2LCBjdXJyLCBuZXh0O1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRpbWVzdGFtcHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjdXJyID0gdGltZXN0YW1wc1tpXTtcbiAgICAgIGlmIChjdXJyID49IG1pbiAmJiBjdXJyIDw9IG1heCkge1xuICAgICAgICBpdGVtcy5wdXNoKGN1cnIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpdGVtcy5sZW5ndGggPCAyKSB7XG4gICAgICAvLyBJbiBjYXNlIHRoZXJlIGlzIGxlc3MgdGhhdCAyIHRpbWVzdGFtcHMgYmV0d2VlbiBtaW4gYW5kIG1heCwgdGhlIHNjYWxlIGlzIGRlZmluZWQgYnkgbWluIGFuZCBtYXhcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHt0aW1lOiBtaW4sIHBvczogMH0sXG4gICAgICAgIHt0aW1lOiBtYXgsIHBvczogMX1cbiAgICAgIF07XG4gICAgfVxuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgbmV4dCA9IGl0ZW1zW2kgKyAxXTtcbiAgICAgIHByZXYgPSBpdGVtc1tpIC0gMV07XG4gICAgICBjdXJyID0gaXRlbXNbaV07XG5cbiAgICAgIC8vIG9ubHkgYWRkIHBvaW50cyB0aGF0IGJyZWFrcyB0aGUgc2NhbGUgbGluZWFyaXR5XG4gICAgICBpZiAoTWF0aC5yb3VuZCgobmV4dCArIHByZXYpIC8gMikgIT09IGN1cnIpIHtcbiAgICAgICAgdGFibGUucHVzaCh7dGltZTogY3VyciwgcG9zOiBpIC8gKGlsZW4gLSAxKX0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFibGU7XG4gIH1cblxuICAvKipcbiAgICAqIEdlbmVyYXRlcyBhbGwgdGltZXN0YW1wcyBkZWZpbmVkIGluIHRoZSBkYXRhLlxuICAgICogSW1wb3J0YW50OiB0aGlzIG1ldGhvZCBjYW4gcmV0dXJuIHRpY2tzIG91dHNpZGUgdGhlIG1pbiBhbmQgbWF4IHJhbmdlLCBpdCdzIHRoZVxuICAgICogcmVzcG9uc2liaWxpdHkgb2YgdGhlIGNhbGxpbmcgY29kZSB0byBjbGFtcCB2YWx1ZXMgaWYgbmVlZGVkLlxuICAgICogQHByb3RlY3RlZFxuICAgICovXG4gIF9nZW5lcmF0ZSgpIHtcbiAgICBjb25zdCBtaW4gPSB0aGlzLm1pbjtcbiAgICBjb25zdCBtYXggPSB0aGlzLm1heDtcbiAgICBsZXQgdGltZXN0YW1wcyA9IHN1cGVyLmdldERhdGFUaW1lc3RhbXBzKCk7XG4gICAgaWYgKCF0aW1lc3RhbXBzLmluY2x1ZGVzKG1pbikgfHwgIXRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICB0aW1lc3RhbXBzLnNwbGljZSgwLCAwLCBtaW4pO1xuICAgIH1cbiAgICBpZiAoIXRpbWVzdGFtcHMuaW5jbHVkZXMobWF4KSB8fCB0aW1lc3RhbXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdGltZXN0YW1wcy5wdXNoKG1heCk7XG4gICAgfVxuICAgIHJldHVybiB0aW1lc3RhbXBzLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIGFsbCB0aW1lc3RhbXBzXG5cdCAqIEByZXR1cm4ge251bWJlcltdfVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldFRpbWVzdGFtcHNGb3JUYWJsZSgpIHtcbiAgICBsZXQgdGltZXN0YW1wcyA9IHRoaXMuX2NhY2hlLmFsbCB8fCBbXTtcblxuICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRpbWVzdGFtcHM7XG4gICAgfVxuXG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0RGF0YVRpbWVzdGFtcHMoKTtcbiAgICBjb25zdCBsYWJlbCA9IHRoaXMuZ2V0TGFiZWxUaW1lc3RhbXBzKCk7XG4gICAgaWYgKGRhdGEubGVuZ3RoICYmIGxhYmVsLmxlbmd0aCkge1xuICAgICAgLy8gSWYgY29tYmluaW5nIGxhYmVscyBhbmQgZGF0YSAoZGF0YSBtaWdodCBub3QgY29udGFpbiBhbGwgbGFiZWxzKSxcbiAgICAgIC8vIHdlIG5lZWQgdG8gcmVjaGVjayB1bmlxdWVuZXNzIGFuZCBzb3J0XG4gICAgICB0aW1lc3RhbXBzID0gdGhpcy5ub3JtYWxpemUoZGF0YS5jb25jYXQobGFiZWwpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGltZXN0YW1wcyA9IGRhdGEubGVuZ3RoID8gZGF0YSA6IGxhYmVsO1xuICAgIH1cbiAgICB0aW1lc3RhbXBzID0gdGhpcy5fY2FjaGUuYWxsID0gdGltZXN0YW1wcztcblxuICAgIHJldHVybiB0aW1lc3RhbXBzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIE1pbGxpc2Vjb25kcyBzaW5jZSBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKVxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXREZWNpbWFsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gKGludGVycG9sYXRlKHRoaXMuX3RhYmxlLCB2YWx1ZSkgLSB0aGlzLl9taW5Qb3MpIC8gdGhpcy5fdGFibGVSYW5nZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xuICAgIGNvbnN0IG9mZnNldHMgPSB0aGlzLl9vZmZzZXRzO1xuICAgIGNvbnN0IGRlY2ltYWwgPSB0aGlzLmdldERlY2ltYWxGb3JQaXhlbChwaXhlbCkgLyBvZmZzZXRzLmZhY3RvciAtIG9mZnNldHMuZW5kO1xuICAgIHJldHVybiBpbnRlcnBvbGF0ZSh0aGlzLl90YWJsZSwgZGVjaW1hbCAqIHRoaXMuX3RhYmxlUmFuZ2UgKyB0aGlzLl9taW5Qb3MsIHRydWUpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRpbWVTZXJpZXNTY2FsZTtcbiIsImV4cG9ydCAqIGZyb20gJy4vY29udHJvbGxlcnMvaW5kZXguanMnO1xuZXhwb3J0ICogZnJvbSAnLi9jb3JlL2luZGV4LmpzJztcbmV4cG9ydCAqIGZyb20gJy4vZWxlbWVudHMvaW5kZXguanMnO1xuZXhwb3J0ICogZnJvbSAnLi9wbGF0Zm9ybS9pbmRleC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3BsdWdpbnMvaW5kZXguanMnO1xuZXhwb3J0ICogZnJvbSAnLi9zY2FsZXMvaW5kZXguanMnO1xuXG5pbXBvcnQgKiBhcyBjb250cm9sbGVycyBmcm9tICcuL2NvbnRyb2xsZXJzL2luZGV4LmpzJztcbmltcG9ydCAqIGFzIGVsZW1lbnRzIGZyb20gJy4vZWxlbWVudHMvaW5kZXguanMnO1xuaW1wb3J0ICogYXMgcGx1Z2lucyBmcm9tICcuL3BsdWdpbnMvaW5kZXguanMnO1xuaW1wb3J0ICogYXMgc2NhbGVzIGZyb20gJy4vc2NhbGVzL2luZGV4LmpzJztcblxuZXhwb3J0IHtcbiAgY29udHJvbGxlcnMsXG4gIGVsZW1lbnRzLFxuICBwbHVnaW5zLFxuICBzY2FsZXMsXG59O1xuXG5leHBvcnQgY29uc3QgcmVnaXN0ZXJhYmxlcyA9IFtcbiAgY29udHJvbGxlcnMsXG4gIGVsZW1lbnRzLFxuICBwbHVnaW5zLFxuICBzY2FsZXMsXG5dO1xuIl0sIm5hbWVzIjpbIkFuaW1hdG9yIiwiY29uc3RydWN0b3IiLCJfcmVxdWVzdCIsIl9jaGFydHMiLCJNYXAiLCJfcnVubmluZyIsIl9sYXN0RGF0ZSIsInVuZGVmaW5lZCIsIl9ub3RpZnkiLCJjaGFydCIsImFuaW1zIiwiZGF0ZSIsInR5cGUiLCJjYWxsYmFja3MiLCJsaXN0ZW5lcnMiLCJudW1TdGVwcyIsImR1cmF0aW9uIiwiZm9yRWFjaCIsImZuIiwiaW5pdGlhbCIsImN1cnJlbnRTdGVwIiwiTWF0aCIsIm1pbiIsInN0YXJ0IiwiX3JlZnJlc2giLCJyZXF1ZXN0QW5pbUZyYW1lIiwiY2FsbCIsIndpbmRvdyIsIl91cGRhdGUiLCJEYXRlIiwibm93IiwicmVtYWluaW5nIiwicnVubmluZyIsIml0ZW1zIiwibGVuZ3RoIiwiaSIsImRyYXciLCJpdGVtIiwiX2FjdGl2ZSIsIl90b3RhbCIsInRpY2siLCJwb3AiLCJfZ2V0QW5pbXMiLCJjaGFydHMiLCJnZXQiLCJjb21wbGV0ZSIsInByb2dyZXNzIiwic2V0IiwibGlzdGVuIiwiZXZlbnQiLCJjYiIsInB1c2giLCJhZGQiLCJoYXMiLCJyZWR1Y2UiLCJhY2MiLCJjdXIiLCJtYXgiLCJfZHVyYXRpb24iLCJzdG9wIiwiY2FuY2VsIiwicmVtb3ZlIiwiZGVsZXRlIiwidHJhbnNwYXJlbnQiLCJpbnRlcnBvbGF0b3JzIiwiYm9vbGVhbiIsImZyb20iLCJ0byIsImZhY3RvciIsImNvbG9yIiwiYzAiLCJoZWxwZXJzQ29sb3IiLCJjMSIsInZhbGlkIiwibWl4IiwiaGV4U3RyaW5nIiwibnVtYmVyIiwiQW5pbWF0aW9uIiwiY2ZnIiwidGFyZ2V0IiwicHJvcCIsImN1cnJlbnRWYWx1ZSIsInJlc29sdmUiLCJfZm4iLCJfZWFzaW5nIiwiZWZmZWN0cyIsImVhc2luZyIsImxpbmVhciIsIl9zdGFydCIsImZsb29yIiwiZGVsYXkiLCJfbG9vcCIsImxvb3AiLCJfdGFyZ2V0IiwiX3Byb3AiLCJfZnJvbSIsIl90byIsIl9wcm9taXNlcyIsImFjdGl2ZSIsInVwZGF0ZSIsImVsYXBzZWQiLCJyZW1haW4iLCJ3YWl0IiwicHJvbWlzZXMiLCJQcm9taXNlIiwicmVzIiwicmVqIiwicmVzb2x2ZWQiLCJtZXRob2QiLCJBbmltYXRpb25zIiwiY29uZmlnIiwiX2NoYXJ0IiwiX3Byb3BlcnRpZXMiLCJjb25maWd1cmUiLCJpc09iamVjdCIsImFuaW1hdGlvbk9wdGlvbnMiLCJPYmplY3QiLCJrZXlzIiwiZGVmYXVsdHMiLCJhbmltYXRpb24iLCJhbmltYXRlZFByb3BzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImtleSIsIm9wdGlvbiIsImlzQXJyYXkiLCJwcm9wZXJ0aWVzIiwiX2FuaW1hdGVPcHRpb25zIiwidmFsdWVzIiwibmV3T3B0aW9ucyIsIm9wdGlvbnMiLCJyZXNvbHZlVGFyZ2V0T3B0aW9ucyIsImFuaW1hdGlvbnMiLCJfY3JlYXRlQW5pbWF0aW9ucyIsIiRzaGFyZWQiLCJhd2FpdEFsbCIsIiRhbmltYXRpb25zIiwidGhlbiIsInByb3BzIiwiY2hhckF0IiwidmFsdWUiLCJzaXplIiwiYXNzaWduIiwiYW5pbWF0b3IiLCJhbmltIiwiYWxsIiwic2NhbGVDbGlwIiwic2NhbGUiLCJhbGxvd2VkT3ZlcmZsb3ciLCJvcHRzIiwicmV2ZXJzZSIsImVuZCIsImRlZmF1bHRDbGlwIiwieFNjYWxlIiwieVNjYWxlIiwieCIsInkiLCJ0b3AiLCJyaWdodCIsImJvdHRvbSIsImxlZnQiLCJ0b0NsaXAiLCJ0IiwiciIsImIiLCJsIiwiZGlzYWJsZWQiLCJnZXRTb3J0ZWREYXRhc2V0SW5kaWNlcyIsImZpbHRlclZpc2libGUiLCJtZXRhc2V0cyIsIl9nZXRTb3J0ZWREYXRhc2V0TWV0YXMiLCJpbGVuIiwiaW5kZXgiLCJhcHBseVN0YWNrIiwic3RhY2siLCJkc0luZGV4Iiwic2luZ2xlTW9kZSIsIm1vZGUiLCJkYXRhc2V0SW5kZXgiLCJvdGhlclZhbHVlIiwiZm91bmQiLCJpc0Zpbml0ZSIsInNpZ24iLCJjb252ZXJ0T2JqZWN0RGF0YVRvQXJyYXkiLCJkYXRhIiwibWV0YSIsImlTY2FsZSIsInZTY2FsZSIsImlBeGlzS2V5IiwiYXhpcyIsInZBeGlzS2V5IiwiYWRhdGEiLCJBcnJheSIsImlzU3RhY2tlZCIsInN0YWNrZWQiLCJnZXRTdGFja0tleSIsImluZGV4U2NhbGUiLCJ2YWx1ZVNjYWxlIiwiaWQiLCJnZXRVc2VyQm91bmRzIiwibWluRGVmaW5lZCIsIm1heERlZmluZWQiLCJOdW1iZXIiLCJORUdBVElWRV9JTkZJTklUWSIsIlBPU0lUSVZFX0lORklOSVRZIiwiZ2V0T3JDcmVhdGVTdGFjayIsInN0YWNrcyIsInN0YWNrS2V5IiwiaW5kZXhWYWx1ZSIsInN1YlN0YWNrIiwiZ2V0TGFzdEluZGV4SW5TdGFjayIsInBvc2l0aXZlIiwiZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMiLCJ1cGRhdGVTdGFja3MiLCJjb250cm9sbGVyIiwicGFyc2VkIiwiX2NhY2hlZE1ldGEiLCJfc3RhY2tzIiwiaUF4aXMiLCJ2QXhpcyIsIml0ZW1TdGFja3MiLCJfdG9wIiwiX2JvdHRvbSIsInZpc3VhbFZhbHVlcyIsIl92aXN1YWxWYWx1ZXMiLCJnZXRGaXJzdFNjYWxlSWQiLCJzY2FsZXMiLCJmaWx0ZXIiLCJzaGlmdCIsImNyZWF0ZURhdGFzZXRDb250ZXh0IiwicGFyZW50IiwiY3JlYXRlQ29udGV4dCIsImRhdGFzZXQiLCJjcmVhdGVEYXRhQ29udGV4dCIsImVsZW1lbnQiLCJkYXRhSW5kZXgiLCJyYXciLCJjbGVhclN0YWNrcyIsIl9wYXJzZWQiLCJpc0RpcmVjdFVwZGF0ZU1vZGUiLCJjbG9uZUlmTm90U2hhcmVkIiwiY2FjaGVkIiwic2hhcmVkIiwiY3JlYXRlU3RhY2siLCJjYW5TdGFjayIsImhpZGRlbiIsIl9zdGFja2VkIiwiRGF0YXNldENvbnRyb2xsZXIiLCJkYXRhc2V0RWxlbWVudFR5cGUiLCJkYXRhRWxlbWVudFR5cGUiLCJfY3R4IiwiY3R4IiwiX2NhY2hlZERhdGFPcHRzIiwiZ2V0TWV0YSIsIl90eXBlIiwiX3BhcnNpbmciLCJfZGF0YSIsIl9vYmplY3REYXRhIiwiX3NoYXJlZE9wdGlvbnMiLCJfZHJhd1N0YXJ0IiwiX2RyYXdDb3VudCIsImVuYWJsZU9wdGlvblNoYXJpbmciLCJzdXBwb3J0c0RlY2ltYXRpb24iLCIkY29udGV4dCIsIl9zeW5jTGlzdCIsImluaXRpYWxpemUiLCJsaW5rU2NhbGVzIiwiYWRkRWxlbWVudHMiLCJmaWxsIiwiaXNQbHVnaW5FbmFibGVkIiwiY29uc29sZSIsIndhcm4iLCJ1cGRhdGVJbmRleCIsImdldERhdGFzZXQiLCJjaG9vc2VJZCIsInhpZCIsInhBeGlzSUQiLCJ2YWx1ZU9yRGVmYXVsdCIsInlpZCIsInlBeGlzSUQiLCJyaWQiLCJyQXhpc0lEIiwiaW5kZXhBeGlzIiwiaWlkIiwiaUF4aXNJRCIsInZpZCIsInZBeGlzSUQiLCJnZXRTY2FsZUZvcklkIiwiclNjYWxlIiwiZGF0YXNldHMiLCJnZXREYXRhc2V0TWV0YSIsInNjYWxlSUQiLCJfZ2V0T3RoZXJTY2FsZSIsInJlc2V0IiwiX2Rlc3Ryb3kiLCJ1bmxpc3RlbkFycmF5RXZlbnRzIiwiX2RhdGFDaGVjayIsImlzRXh0ZW5zaWJsZSIsImxpc3RlbkFycmF5RXZlbnRzIiwiYnVpbGRPclVwZGF0ZUVsZW1lbnRzIiwicmVzZXROZXdFbGVtZW50cyIsInN0YWNrQ2hhbmdlZCIsIm9sZFN0YWNrZWQiLCJfcmVzeW5jRWxlbWVudHMiLCJzY29wZUtleXMiLCJkYXRhc2V0U2NvcGVLZXlzIiwic2NvcGVzIiwiZ2V0T3B0aW9uU2NvcGVzIiwiY3JlYXRlUmVzb2x2ZXIiLCJnZXRDb250ZXh0IiwicGFyc2luZyIsInBhcnNlIiwiY291bnQiLCJzb3J0ZWQiLCJfc29ydGVkIiwicHJldiIsInBhcnNlQXJyYXlEYXRhIiwicGFyc2VPYmplY3REYXRhIiwicGFyc2VQcmltaXRpdmVEYXRhIiwiaXNOb3RJbk9yZGVyQ29tcGFyZWRUb1ByZXYiLCJsYWJlbHMiLCJnZXRMYWJlbHMiLCJzaW5nbGVTY2FsZSIsInhBeGlzS2V5IiwieUF4aXNLZXkiLCJyZXNvbHZlT2JqZWN0S2V5IiwiZ2V0UGFyc2VkIiwiZ2V0RGF0YUVsZW1lbnQiLCJ1cGRhdGVSYW5nZUZyb21QYXJzZWQiLCJyYW5nZSIsInBhcnNlZFZhbHVlIiwiTmFOIiwiZ2V0TWluTWF4Iiwib3RoZXJTY2FsZSIsIm90aGVyTWluIiwib3RoZXJNYXgiLCJfc2tpcCIsImdldEFsbFBhcnNlZFZhbHVlcyIsImdldE1heE92ZXJmbG93IiwiZ2V0TGFiZWxBbmRWYWx1ZSIsImxhYmVsIiwiZ2V0TGFiZWxGb3JWYWx1ZSIsIl9jbGlwIiwiY2xpcCIsImVsZW1lbnRzIiwiYXJlYSIsImNoYXJ0QXJlYSIsImRyYXdBY3RpdmVFbGVtZW50c09uVG9wIiwiZ2V0U3R5bGUiLCJyZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zIiwicmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyIsImNvbnRleHQiLCJfcmVzb2x2ZUVsZW1lbnRPcHRpb25zIiwiZWxlbWVudFR5cGUiLCJjYWNoZSIsImNhY2hlS2V5Iiwic2hhcmluZyIsImRlZmluZWQiLCJkYXRhc2V0RWxlbWVudFNjb3BlS2V5cyIsInByZWZpeGVzIiwibmFtZXMiLCJyZXNvbHZlTmFtZWRPcHRpb25zIiwiZnJlZXplIiwiX3Jlc29sdmVBbmltYXRpb25zIiwidHJhbnNpdGlvbiIsImRhdGFzZXRBbmltYXRpb25TY29wZUtleXMiLCJfY2FjaGVhYmxlIiwiZ2V0U2hhcmVkT3B0aW9ucyIsImluY2x1ZGVPcHRpb25zIiwic2hhcmVkT3B0aW9ucyIsIl9hbmltYXRpb25zRGlzYWJsZWQiLCJfZ2V0U2hhcmVkT3B0aW9ucyIsImZpcnN0T3B0cyIsInByZXZpb3VzbHlTaGFyZWRPcHRpb25zIiwidXBkYXRlU2hhcmVkT3B0aW9ucyIsInVwZGF0ZUVsZW1lbnQiLCJfc2V0U3R5bGUiLCJyZW1vdmVIb3ZlclN0eWxlIiwic2V0SG92ZXJTdHlsZSIsIl9yZW1vdmVEYXRhc2V0SG92ZXJTdHlsZSIsIl9zZXREYXRhc2V0SG92ZXJTdHlsZSIsImFyZzEiLCJhcmcyIiwibnVtTWV0YSIsIm51bURhdGEiLCJfaW5zZXJ0RWxlbWVudHMiLCJfcmVtb3ZlRWxlbWVudHMiLCJtb3ZlIiwiYXJyIiwidXBkYXRlRWxlbWVudHMiLCJyZW1vdmVkIiwic3BsaWNlIiwiX3N5bmMiLCJhcmdzIiwiX2RhdGFDaGFuZ2VzIiwiX29uRGF0YVB1c2giLCJhcmd1bWVudHMiLCJfb25EYXRhUG9wIiwiX29uRGF0YVNoaWZ0IiwiX29uRGF0YVNwbGljZSIsIm5ld0NvdW50IiwiX29uRGF0YVVuc2hpZnQiLCJnZXRBbGxTY2FsZVZhbHVlcyIsIl9jYWNoZSIsIiRiYXIiLCJ2aXNpYmxlTWV0YXMiLCJjb25jYXQiLCJfYXJyYXlVbmlxdWUiLCJzb3J0IiwiYSIsImNvbXB1dGVNaW5TYW1wbGVTaXplIiwiX2xlbmd0aCIsImN1cnIiLCJ1cGRhdGVNaW5BbmRQcmV2IiwiYWJzIiwiZ2V0UGl4ZWxGb3JWYWx1ZSIsInRpY2tzIiwiZ2V0UGl4ZWxGb3JUaWNrIiwiY29tcHV0ZUZpdENhdGVnb3J5VHJhaXRzIiwicnVsZXIiLCJzdGFja0NvdW50IiwidGhpY2tuZXNzIiwiYmFyVGhpY2tuZXNzIiwicmF0aW8iLCJpc051bGxPclVuZGVmIiwiY2F0ZWdvcnlQZXJjZW50YWdlIiwiYmFyUGVyY2VudGFnZSIsImNodW5rIiwicGl4ZWxzIiwiY29tcHV0ZUZsZXhDYXRlZ29yeVRyYWl0cyIsIm5leHQiLCJwZXJjZW50IiwicGFyc2VGbG9hdEJhciIsImVudHJ5Iiwic3RhcnRWYWx1ZSIsImVuZFZhbHVlIiwiYmFyU3RhcnQiLCJiYXJFbmQiLCJfY3VzdG9tIiwicGFyc2VWYWx1ZSIsInBhcnNlQXJyYXlPclByaW1pdGl2ZSIsImlzRmxvYXRCYXIiLCJjdXN0b20iLCJiYXJTaWduIiwiYWN0dWFsQmFzZSIsImlzSG9yaXpvbnRhbCIsImJvcmRlclByb3BzIiwiaG9yaXpvbnRhbCIsImJhc2UiLCJzZXRCb3JkZXJTa2lwcGVkIiwiZWRnZSIsImJvcmRlclNraXBwZWQiLCJlbmFibGVCb3JkZXJSYWRpdXMiLCJwYXJzZUVkZ2UiLCJzd2FwIiwic3RhcnRFbmQiLCJvcmlnIiwidjEiLCJ2MiIsInYiLCJzZXRJbmZsYXRlQW1vdW50IiwiaW5mbGF0ZUFtb3VudCIsIkJhckNvbnRyb2xsZXIiLCJncm91cGVkIiwibnVtYmVycyIsIm92ZXJyaWRlcyIsIl9pbmRleF8iLCJvZmZzZXQiLCJncmlkIiwiX3ZhbHVlXyIsImJlZ2luQXRaZXJvIiwib2JqIiwiYmFycyIsImdldEJhc2VQaXhlbCIsIl9nZXRSdWxlciIsInZwaXhlbHMiLCJoZWFkIiwiX2NhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzIiwiaXBpeGVscyIsIl9jYWxjdWxhdGVCYXJJbmRleFBpeGVscyIsImNlbnRlciIsImhlaWdodCIsIndpZHRoIiwiX2dldFN0YWNrcyIsImxhc3QiLCJjdXJyZW50UGFyc2VkIiwiaVNjYWxlVmFsdWUiLCJza2lwTnVsbCIsImZpbmQiLCJ2YWwiLCJpc05hTiIsImluZGV4T2YiLCJfZ2V0U3RhY2tDb3VudCIsIl9nZXRBeGlzQ291bnQiLCJfZ2V0QXhpcyIsImdldEZpcnN0U2NhbGVJZEZvckluZGV4QXhpcyIsImluZGV4U2NhbGVJZCIsImZpcnN0U2NhbGVBeGlzSWQiLCJfZ2V0U3RhY2tJbmRleCIsIm5hbWUiLCJfc3RhcnRQaXhlbCIsIl9lbmRQaXhlbCIsImJhc2VWYWx1ZSIsIm1pbkJhckxlbmd0aCIsImZsb2F0aW5nIiwiZ2V0RGF0YVZpc2liaWxpdHkiLCJzdGFydFBpeGVsIiwiZ2V0UGl4ZWxGb3JEZWNpbWFsIiwiZW5kUGl4ZWwiLCJnZXRWYWx1ZUZvclBpeGVsIiwiaGFsZkdyaWQiLCJnZXRMaW5lV2lkdGhGb3JWYWx1ZSIsIm1heEJhclRoaWNrbmVzcyIsIkluZmluaXR5IiwiYXhpc0NvdW50IiwiYXhpc0lEIiwiYXhpc051bWJlciIsInN0YWNrSW5kZXgiLCJyZWN0cyIsIkJ1YmJsZUNvbnRyb2xsZXIiLCJyYWRpdXMiLCJwb2ludHMiLCJwb2ludCIsImlQaXhlbCIsInZQaXhlbCIsInNraXAiLCJnZXRSYXRpb0FuZE9mZnNldCIsInJvdGF0aW9uIiwiY2lyY3VtZmVyZW5jZSIsImN1dG91dCIsInJhdGlvWCIsInJhdGlvWSIsIm9mZnNldFgiLCJvZmZzZXRZIiwiVEFVIiwic3RhcnRBbmdsZSIsImVuZEFuZ2xlIiwic3RhcnRYIiwiY29zIiwic3RhcnRZIiwic2luIiwiZW5kWCIsImVuZFkiLCJjYWxjTWF4IiwiYW5nbGUiLCJfYW5nbGVCZXR3ZWVuIiwiY2FsY01pbiIsIm1heFgiLCJtYXhZIiwiSEFMRl9QSSIsIm1pblgiLCJQSSIsIm1pblkiLCJEb3VnaG51dENvbnRyb2xsZXIiLCJhbmltYXRlUm90YXRlIiwiYW5pbWF0ZVNjYWxlIiwic3BhY2luZyIsImRlc2NyaXB0b3JzIiwiX3NjcmlwdGFibGUiLCJfaW5kZXhhYmxlIiwic3RhcnRzV2l0aCIsImFzcGVjdFJhdGlvIiwicGx1Z2lucyIsImxlZ2VuZCIsImdlbmVyYXRlTGFiZWxzIiwicG9pbnRTdHlsZSIsInRleHRBbGlnbiIsInVzZUJvcmRlclJhZGl1cyIsImJvcmRlclJhZGl1cyIsIm1hcCIsInN0eWxlIiwidGV4dCIsImZpbGxTdHlsZSIsImJhY2tncm91bmRDb2xvciIsImZvbnRDb2xvciIsImxpbmVEYXNoIiwiYm9yZGVyRGFzaCIsImxpbmVEYXNoT2Zmc2V0IiwiYm9yZGVyRGFzaE9mZnNldCIsImxpbmVKb2luIiwiYm9yZGVySm9pblN0eWxlIiwibGluZVdpZHRoIiwiYm9yZGVyV2lkdGgiLCJzdHJva2VTdHlsZSIsImJvcmRlckNvbG9yIiwib25DbGljayIsImUiLCJsZWdlbmRJdGVtIiwidG9nZ2xlRGF0YVZpc2liaWxpdHkiLCJpbm5lclJhZGl1cyIsIm91dGVyUmFkaXVzIiwiZ2V0dGVyIiwiX2dldFJvdGF0aW9uIiwidG9SYWRpYW5zIiwiX2dldENpcmN1bWZlcmVuY2UiLCJfZ2V0Um90YXRpb25FeHRlbnRzIiwiaXNEYXRhc2V0VmlzaWJsZSIsImFyY3MiLCJnZXRNYXhCb3JkZXJXaWR0aCIsImdldE1heE9mZnNldCIsIm1heFNpemUiLCJ0b1BlcmNlbnRhZ2UiLCJjaGFydFdlaWdodCIsIl9nZXRSaW5nV2VpZ2h0IiwibWF4V2lkdGgiLCJtYXhIZWlnaHQiLCJtYXhSYWRpdXMiLCJ0b0RpbWVuc2lvbiIsInJhZGl1c0xlbmd0aCIsIl9nZXRWaXNpYmxlRGF0YXNldFdlaWdodFRvdGFsIiwidG90YWwiLCJjYWxjdWxhdGVUb3RhbCIsIl9nZXRSaW5nV2VpZ2h0T2Zmc2V0IiwiX2NpcmN1bWZlcmVuY2UiLCJjYWxjdWxhdGVDaXJjdW1mZXJlbmNlIiwiYW5pbWF0aW9uT3B0cyIsImNlbnRlclgiLCJjZW50ZXJZIiwiYXJjIiwibWV0YURhdGEiLCJmb3JtYXROdW1iZXIiLCJsb2NhbGUiLCJib3JkZXJBbGlnbiIsImhvdmVyQm9yZGVyV2lkdGgiLCJob3Zlck9mZnNldCIsInJpbmdXZWlnaHRPZmZzZXQiLCJ3ZWlnaHQiLCJMaW5lQ29udHJvbGxlciIsInNob3dMaW5lIiwic3BhbkdhcHMiLCJsaW5lIiwiX2RhdGFzZXQiLCJhbmltYXRpb25zRGlzYWJsZWQiLCJfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cyIsIl9zY2FsZVJhbmdlc0NoYW5nZWQiLCJfZGF0YXNldEluZGV4IiwiX2RlY2ltYXRlZCIsInNlZ21lbnQiLCJhbmltYXRlZCIsIm1heEdhcExlbmd0aCIsImlzTnVtYmVyIiwiZGlyZWN0VXBkYXRlIiwicG9pbnRzQ291bnQiLCJwcmV2UGFyc2VkIiwibnVsbERhdGEiLCJib3JkZXIiLCJmaXJzdFBvaW50IiwibGFzdFBvaW50IiwidXBkYXRlQ29udHJvbFBvaW50cyIsIlBvbGFyQXJlYUNvbnRyb2xsZXIiLCJhbmdsZUxpbmVzIiwiZGlzcGxheSIsImNpcmN1bGFyIiwicG9pbnRMYWJlbHMiLCJfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGUiLCJiaW5kIiwiX3VwZGF0ZVJhZGl1cyIsIm1pblNpemUiLCJjdXRvdXRQZXJjZW50YWdlIiwiZ2V0VmlzaWJsZURhdGFzZXRDb3VudCIsInhDZW50ZXIiLCJ5Q2VudGVyIiwiZGF0YXNldFN0YXJ0QW5nbGUiLCJnZXRJbmRleEFuZ2xlIiwiZGVmYXVsdEFuZ2xlIiwiY291bnRWaXNpYmxlRWxlbWVudHMiLCJfY29tcHV0ZUFuZ2xlIiwiZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUiLCJQaWVDb250cm9sbGVyIiwiUmFkYXJDb250cm9sbGVyIiwiX2Z1bGxMb29wIiwicG9pbnRQb3NpdGlvbiIsImdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZSIsIlNjYXR0ZXJDb250cm9sbGVyIiwiaW50ZXJhY3Rpb24iLCJyZWdpc3RyeSIsImdldEVsZW1lbnQiLCJhYnN0cmFjdCIsIkVycm9yIiwiRGF0ZUFkYXB0ZXJCYXNlIiwib3ZlcnJpZGUiLCJtZW1iZXJzIiwicHJvdG90eXBlIiwiaW5pdCIsImZvcm1hdHMiLCJmb3JtYXQiLCJkaWZmIiwic3RhcnRPZiIsImVuZE9mIiwiX2RhdGUiLCJiaW5hcnlTZWFyY2giLCJtZXRhc2V0IiwiaW50ZXJzZWN0IiwibG9va3VwTWV0aG9kIiwiX3JldmVyc2VQaXhlbHMiLCJfcmxvb2t1cEJ5S2V5IiwiX2xvb2t1cEJ5S2V5IiwicmVzdWx0IiwiZGlzdGFuY2VUb0RlZmluZWRMbyIsInNsaWNlIiwibG8iLCJmaW5kSW5kZXgiLCJkaXN0YW5jZVRvRGVmaW5lZEhpIiwiaGkiLCJlbCIsImdldFJhbmdlIiwiZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zIiwicG9zaXRpb24iLCJoYW5kbGVyIiwiZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcyIsImoiLCJnZXREaXN0YW5jZU1ldHJpY0ZvckF4aXMiLCJ1c2VYIiwidXNlWSIsInB0MSIsInB0MiIsImRlbHRhWCIsImRlbHRhWSIsInNxcnQiLCJwb3ciLCJnZXRJbnRlcnNlY3RJdGVtcyIsInVzZUZpbmFsUG9zaXRpb24iLCJpbmNsdWRlSW52aXNpYmxlIiwiaXNQb2ludEluQXJlYSIsImV2YWx1YXRpb25GdW5jIiwiX2lzUG9pbnRJbkFyZWEiLCJpblJhbmdlIiwiZ2V0TmVhcmVzdFJhZGlhbEl0ZW1zIiwiZ2V0UHJvcHMiLCJnZXRBbmdsZUZyb21Qb2ludCIsImdldE5lYXJlc3RDYXJ0ZXNpYW5JdGVtcyIsImRpc3RhbmNlTWV0cmljIiwibWluRGlzdGFuY2UiLCJnZXRDZW50ZXJQb2ludCIsInBvaW50SW5BcmVhIiwiZGlzdGFuY2UiLCJnZXROZWFyZXN0SXRlbXMiLCJnZXRBeGlzSXRlbXMiLCJyYW5nZU1ldGhvZCIsImludGVyc2VjdHNJdGVtIiwibW9kZXMiLCJnZXRSZWxhdGl2ZVBvc2l0aW9uIiwibmVhcmVzdCIsIlNUQVRJQ19QT1NJVElPTlMiLCJmaWx0ZXJCeVBvc2l0aW9uIiwiYXJyYXkiLCJwb3MiLCJmaWx0ZXJEeW5hbWljUG9zaXRpb25CeUF4aXMiLCJib3giLCJzb3J0QnlXZWlnaHQiLCJ2MCIsIndyYXBCb3hlcyIsImJveGVzIiwibGF5b3V0Qm94ZXMiLCJzdGFja1dlaWdodCIsImJ1aWxkU3RhY2tzIiwibGF5b3V0cyIsIndyYXAiLCJpbmNsdWRlcyIsIl9zdGFjayIsInBsYWNlZCIsInNldExheW91dERpbXMiLCJwYXJhbXMiLCJ2Qm94TWF4V2lkdGgiLCJoQm94TWF4SGVpZ2h0IiwibGF5b3V0IiwiZnVsbFNpemUiLCJhdmFpbGFibGVXaWR0aCIsImF2YWlsYWJsZUhlaWdodCIsImJ1aWxkTGF5b3V0Qm94ZXMiLCJjZW50ZXJIb3Jpem9udGFsIiwiY2VudGVyVmVydGljYWwiLCJsZWZ0QW5kVG9wIiwicmlnaHRBbmRCb3R0b20iLCJ2ZXJ0aWNhbCIsImdldENvbWJpbmVkTWF4IiwibWF4UGFkZGluZyIsInVwZGF0ZU1heFBhZGRpbmciLCJib3hQYWRkaW5nIiwidXBkYXRlRGltcyIsImdldFBhZGRpbmciLCJuZXdXaWR0aCIsIm91dGVyV2lkdGgiLCJuZXdIZWlnaHQiLCJvdXRlckhlaWdodCIsIndpZHRoQ2hhbmdlZCIsInciLCJoZWlnaHRDaGFuZ2VkIiwiaCIsInNhbWUiLCJvdGhlciIsImhhbmRsZU1heFBhZGRpbmciLCJ1cGRhdGVQb3MiLCJjaGFuZ2UiLCJnZXRNYXJnaW5zIiwibWFyZ2luRm9yUG9zaXRpb25zIiwicG9zaXRpb25zIiwibWFyZ2luIiwiZml0Qm94ZXMiLCJyZWZpdEJveGVzIiwicmVmaXQiLCJjaGFuZ2VkIiwic2V0Qm94RGltcyIsInBsYWNlQm94ZXMiLCJ1c2VyUGFkZGluZyIsInBhZGRpbmciLCJhZGRCb3giLCJfbGF5ZXJzIiwieiIsInJlbW92ZUJveCIsImxheW91dEl0ZW0iLCJtaW5QYWRkaW5nIiwidG9QYWRkaW5nIiwidmVydGljYWxCb3hlcyIsImhvcml6b250YWxCb3hlcyIsImVhY2giLCJiZWZvcmVMYXlvdXQiLCJ2aXNpYmxlVmVydGljYWxCb3hDb3VudCIsIkJhc2VQbGF0Zm9ybSIsImFjcXVpcmVDb250ZXh0IiwiY2FudmFzIiwicmVsZWFzZUNvbnRleHQiLCJhZGRFdmVudExpc3RlbmVyIiwibGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZ2V0RGV2aWNlUGl4ZWxSYXRpbyIsImdldE1heGltdW1TaXplIiwiaXNBdHRhY2hlZCIsInVwZGF0ZUNvbmZpZyIsIkJhc2ljUGxhdGZvcm0iLCJFWFBBTkRPX0tFWSIsIkVWRU5UX1RZUEVTIiwidG91Y2hzdGFydCIsInRvdWNobW92ZSIsInRvdWNoZW5kIiwicG9pbnRlcmVudGVyIiwicG9pbnRlcmRvd24iLCJwb2ludGVybW92ZSIsInBvaW50ZXJ1cCIsInBvaW50ZXJsZWF2ZSIsInBvaW50ZXJvdXQiLCJpc051bGxPckVtcHR5IiwiaW5pdENhbnZhcyIsInJlbmRlckhlaWdodCIsImdldEF0dHJpYnV0ZSIsInJlbmRlcldpZHRoIiwiYm94U2l6aW5nIiwiZGlzcGxheVdpZHRoIiwicmVhZFVzZWRTaXplIiwiZGlzcGxheUhlaWdodCIsImV2ZW50TGlzdGVuZXJPcHRpb25zIiwic3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucyIsInBhc3NpdmUiLCJhZGRMaXN0ZW5lciIsIm5vZGUiLCJyZW1vdmVMaXN0ZW5lciIsImZyb21OYXRpdmVFdmVudCIsIm5hdGl2ZSIsIm5vZGVMaXN0Q29udGFpbnMiLCJub2RlTGlzdCIsImNvbnRhaW5zIiwiY3JlYXRlQXR0YWNoT2JzZXJ2ZXIiLCJvYnNlcnZlciIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJlbnRyaWVzIiwidHJpZ2dlciIsImFkZGVkTm9kZXMiLCJyZW1vdmVkTm9kZXMiLCJvYnNlcnZlIiwiZG9jdW1lbnQiLCJjaGlsZExpc3QiLCJzdWJ0cmVlIiwiY3JlYXRlRGV0YWNoT2JzZXJ2ZXIiLCJkcnBMaXN0ZW5pbmdDaGFydHMiLCJvbGREZXZpY2VQaXhlbFJhdGlvIiwib25XaW5kb3dSZXNpemUiLCJkcHIiLCJkZXZpY2VQaXhlbFJhdGlvIiwicmVzaXplIiwiY3VycmVudERldmljZVBpeGVsUmF0aW8iLCJsaXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyIsInVubGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMiLCJjcmVhdGVSZXNpemVPYnNlcnZlciIsImNvbnRhaW5lciIsIl9nZXRQYXJlbnROb2RlIiwidGhyb3R0bGVkIiwiY2xpZW50V2lkdGgiLCJSZXNpemVPYnNlcnZlciIsImNvbnRlbnRSZWN0IiwicmVsZWFzZU9ic2VydmVyIiwiZGlzY29ubmVjdCIsImNyZWF0ZVByb3h5QW5kTGlzdGVuIiwicHJveHkiLCJEb21QbGF0Zm9ybSIsInJlbW92ZUF0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZSIsInByb3hpZXMiLCIkcHJveGllcyIsImhhbmRsZXJzIiwiYXR0YWNoIiwiZGV0YWNoIiwiaXNDb25uZWN0ZWQiLCJfZGV0ZWN0UGxhdGZvcm0iLCJfaXNEb21TdXBwb3J0ZWQiLCJPZmZzY3JlZW5DYW52YXMiLCJFbGVtZW50IiwiZGVmYXVsdFJvdXRlcyIsInRvb2x0aXBQb3NpdGlvbiIsImhhc1ZhbHVlIiwiZmluYWwiLCJyZXQiLCJhdXRvU2tpcCIsInRpY2tPcHRzIiwiZGV0ZXJtaW5lZE1heFRpY2tzIiwiZGV0ZXJtaW5lTWF4VGlja3MiLCJ0aWNrc0xpbWl0IiwibWF4VGlja3NMaW1pdCIsIm1ham9ySW5kaWNlcyIsIm1ham9yIiwiZW5hYmxlZCIsImdldE1ham9ySW5kaWNlcyIsIm51bU1ham9ySW5kaWNlcyIsImZpcnN0IiwibmV3VGlja3MiLCJza2lwTWFqb3JzIiwiY2FsY3VsYXRlU3BhY2luZyIsImF2Z01ham9yU3BhY2luZyIsInJvdW5kIiwidGlja0xlbmd0aCIsIl90aWNrU2l6ZSIsIm1heFNjYWxlIiwibWF4Q2hhcnQiLCJfbWF4TGVuZ3RoIiwiZXZlbk1ham9yU3BhY2luZyIsImdldEV2ZW5TcGFjaW5nIiwiZmFjdG9ycyIsIl9mYWN0b3JpemUiLCJjZWlsIiwibWFqb3JTdGFydCIsIm1ham9yRW5kIiwibGVuIiwicmV2ZXJzZUFsaWduIiwiYWxpZ24iLCJvZmZzZXRGcm9tRWRnZSIsImdldFRpY2tzTGltaXQiLCJ0aWNrc0xlbmd0aCIsInNhbXBsZSIsIm51bUl0ZW1zIiwiaW5jcmVtZW50IiwiZ2V0UGl4ZWxGb3JHcmlkTGluZSIsIm9mZnNldEdyaWRMaW5lcyIsInZhbGlkSW5kZXgiLCJlcHNpbG9uIiwibGluZVZhbHVlIiwiZ2FyYmFnZUNvbGxlY3QiLCJjYWNoZXMiLCJnYyIsImdjTGVuIiwiZ2V0VGlja01hcmtMZW5ndGgiLCJkcmF3VGlja3MiLCJnZXRUaXRsZUhlaWdodCIsImZhbGxiYWNrIiwiZm9udCIsInRvRm9udCIsImxpbmVzIiwibGluZUhlaWdodCIsImNyZWF0ZVNjYWxlQ29udGV4dCIsImNyZWF0ZVRpY2tDb250ZXh0IiwidGl0bGVBbGlnbiIsIl90b0xlZnRSaWdodENlbnRlciIsInRpdGxlQXJncyIsInRpdGxlWCIsInRpdGxlWSIsIl9hbGlnblN0YXJ0RW5kIiwicG9zaXRpb25BeGlzSUQiLCJTY2FsZSIsIl9tYXJnaW5zIiwicGFkZGluZ1RvcCIsInBhZGRpbmdCb3R0b20iLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdSaWdodCIsImxhYmVsUm90YXRpb24iLCJfcmFuZ2UiLCJfZ3JpZExpbmVJdGVtcyIsIl9sYWJlbEl0ZW1zIiwiX2xhYmVsU2l6ZXMiLCJfbG9uZ2VzdFRleHRDYWNoZSIsIl91c2VyTWF4IiwiX3VzZXJNaW4iLCJfc3VnZ2VzdGVkTWF4IiwiX3N1Z2dlc3RlZE1pbiIsIl90aWNrc0xlbmd0aCIsIl9ib3JkZXJWYWx1ZSIsIl9kYXRhTGltaXRzQ2FjaGVkIiwic2V0Q29udGV4dCIsInN1Z2dlc3RlZE1pbiIsInN1Z2dlc3RlZE1heCIsImZpbml0ZU9yRGVmYXVsdCIsIm1ldGFzIiwiZ2V0VGlja3MiLCJ4TGFiZWxzIiwieUxhYmVscyIsImdldExhYmVsSXRlbXMiLCJfY29tcHV0ZUxhYmVsSXRlbXMiLCJiZWZvcmVVcGRhdGUiLCJtYXJnaW5zIiwiZ3JhY2UiLCJzYW1wbGVTaXplIiwiYmVmb3JlU2V0RGltZW5zaW9ucyIsInNldERpbWVuc2lvbnMiLCJhZnRlclNldERpbWVuc2lvbnMiLCJiZWZvcmVEYXRhTGltaXRzIiwiZGV0ZXJtaW5lRGF0YUxpbWl0cyIsImFmdGVyRGF0YUxpbWl0cyIsIl9hZGRHcmFjZSIsImJlZm9yZUJ1aWxkVGlja3MiLCJidWlsZFRpY2tzIiwiYWZ0ZXJCdWlsZFRpY2tzIiwic2FtcGxpbmdFbmFibGVkIiwiX2NvbnZlcnRUaWNrc1RvTGFiZWxzIiwiYmVmb3JlQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbiIsImNhbGN1bGF0ZUxhYmVsUm90YXRpb24iLCJhZnRlckNhbGN1bGF0ZUxhYmVsUm90YXRpb24iLCJzb3VyY2UiLCJhZnRlckF1dG9Ta2lwIiwiYmVmb3JlRml0IiwiZml0IiwiYWZ0ZXJGaXQiLCJhZnRlclVwZGF0ZSIsInJldmVyc2VQaXhlbHMiLCJfYWxpZ25Ub1BpeGVscyIsImFsaWduVG9QaXhlbHMiLCJfY2FsbEhvb2tzIiwibm90aWZ5UGx1Z2lucyIsImJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbiIsImdlbmVyYXRlVGlja0xhYmVscyIsImNhbGxiYWNrIiwiYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24iLCJudW1UaWNrcyIsIm1pblJvdGF0aW9uIiwibWF4Um90YXRpb24iLCJ0aWNrV2lkdGgiLCJtYXhMYWJlbERpYWdvbmFsIiwiX2lzVmlzaWJsZSIsImxhYmVsU2l6ZXMiLCJfZ2V0TGFiZWxTaXplcyIsIm1heExhYmVsV2lkdGgiLCJ3aWRlc3QiLCJtYXhMYWJlbEhlaWdodCIsImhpZ2hlc3QiLCJfbGltaXRWYWx1ZSIsInRpdGxlIiwidG9EZWdyZWVzIiwiYXNpbiIsInRpdGxlT3B0cyIsImdyaWRPcHRzIiwidGl0bGVIZWlnaHQiLCJ0aWNrUGFkZGluZyIsImFuZ2xlUmFkaWFucyIsImxhYmVsSGVpZ2h0IiwibWlycm9yIiwibGFiZWxXaWR0aCIsIl9jYWxjdWxhdGVQYWRkaW5nIiwiX2hhbmRsZU1hcmdpbnMiLCJpc1JvdGF0ZWQiLCJsYWJlbHNCZWxvd1RpY2tzIiwib2Zmc2V0TGVmdCIsIm9mZnNldFJpZ2h0IiwiaXNGdWxsU2l6ZSIsIl9jb21wdXRlTGFiZWxTaXplcyIsIndpZHRocyIsImhlaWdodHMiLCJ3aWRlc3RMYWJlbFNpemUiLCJoaWdoZXN0TGFiZWxTaXplIiwiamxlbiIsInRpY2tGb250IiwiZm9udFN0cmluZyIsIm5lc3RlZExhYmVsIiwiX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMiLCJzdHJpbmciLCJfbWVhc3VyZVRleHQiLCJ2YWx1ZUF0IiwiaWR4IiwicGl4ZWwiLCJkZWNpbWFsIiwiX2ludDE2UmFuZ2UiLCJfYWxpZ25QaXhlbCIsImdldERlY2ltYWxGb3JQaXhlbCIsImdldEJhc2VWYWx1ZSIsIm9wdGlvblRpY2tzIiwicm90IiwiYXV0b1NraXBQYWRkaW5nIiwiX2NvbXB1dGVHcmlkTGluZUl0ZW1zIiwidGwiLCJib3JkZXJPcHRzIiwiYXhpc1dpZHRoIiwiYXhpc0hhbGZXaWR0aCIsImFsaWduQm9yZGVyVmFsdWUiLCJib3JkZXJWYWx1ZSIsImFsaWduZWRMaW5lVmFsdWUiLCJ0eDEiLCJ0eTEiLCJ0eDIiLCJ0eTIiLCJ4MSIsInkxIiwieDIiLCJ5MiIsImxpbWl0Iiwic3RlcCIsIm9wdHNBdEluZGV4Iiwib3B0c0F0SW5kZXhCb3JkZXIiLCJsaW5lQ29sb3IiLCJkYXNoIiwiZGFzaE9mZnNldCIsInRpY2tDb2xvciIsInRpY2tCb3JkZXJEYXNoIiwidGlja0JvcmRlckRhc2hPZmZzZXQiLCJjcm9zc0FsaWduIiwidGlja0FuZFBhZGRpbmciLCJoVGlja0FuZFBhZGRpbmciLCJsaW5lQ291bnQiLCJ0ZXh0T2Zmc2V0IiwidGV4dEJhc2VsaW5lIiwiX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQiLCJfZ2V0WUF4aXNMYWJlbEFsaWdubWVudCIsImxhYmVsT2Zmc2V0IiwiaGFsZkNvdW50Iiwic3Ryb2tlQ29sb3IiLCJ0ZXh0U3Ryb2tlQ29sb3IiLCJzdHJva2VXaWR0aCIsInRleHRTdHJva2VXaWR0aCIsInRpY2tUZXh0QWxpZ24iLCJzaG93TGFiZWxCYWNrZHJvcCIsImJhY2tkcm9wIiwibGFiZWxQYWRkaW5nIiwiYmFja2Ryb3BQYWRkaW5nIiwiYmFja2Ryb3BDb2xvciIsInRyYW5zbGF0aW9uIiwiX2NvbXB1dGVMYWJlbEFyZWEiLCJkcmF3QmFja2dyb3VuZCIsInNhdmUiLCJmaWxsUmVjdCIsInJlc3RvcmUiLCJkcmF3R3JpZCIsImRyYXdMaW5lIiwicDEiLCJwMiIsInNldExpbmVEYXNoIiwiYmVnaW5QYXRoIiwibW92ZVRvIiwibGluZVRvIiwic3Ryb2tlIiwiZHJhd09uQ2hhcnRBcmVhIiwiZHJhd0JvcmRlciIsImxhc3RMaW5lV2lkdGgiLCJkcmF3TGFiZWxzIiwiY2xpcEFyZWEiLCJyZW5kZXJUZXh0T3B0aW9ucyIsInJlbmRlclRleHQiLCJ1bmNsaXBBcmVhIiwiZHJhd1RpdGxlIiwidHoiLCJneiIsImJ6IiwiX21heERpZ2l0cyIsImZvbnRTaXplIiwiVHlwZWRSZWdpc3RyeSIsInNjb3BlIiwiY3JlYXRlIiwiaXNGb3JUeXBlIiwiaXNQcm90b3R5cGVPZiIsInJlZ2lzdGVyIiwicHJvdG8iLCJnZXRQcm90b3R5cGVPZiIsInBhcmVudFNjb3BlIiwiaXNJQ2hhcnRDb21wb25lbnQiLCJyZWdpc3RlckRlZmF1bHRzIiwidW5yZWdpc3RlciIsIml0ZW1EZWZhdWx0cyIsIm1lcmdlIiwicm91dGVEZWZhdWx0cyIsImRlc2NyaWJlIiwicm91dGVzIiwicHJvcGVydHkiLCJwcm9wZXJ0eVBhcnRzIiwic3BsaXQiLCJzb3VyY2VOYW1lIiwic291cmNlU2NvcGUiLCJqb2luIiwicGFydHMiLCJ0YXJnZXROYW1lIiwidGFyZ2V0U2NvcGUiLCJyb3V0ZSIsIlJlZ2lzdHJ5IiwiY29udHJvbGxlcnMiLCJfdHlwZWRSZWdpc3RyaWVzIiwiX2VhY2giLCJhZGRDb250cm9sbGVycyIsImFkZFBsdWdpbnMiLCJhZGRTY2FsZXMiLCJnZXRDb250cm9sbGVyIiwiX2dldCIsImdldFBsdWdpbiIsImdldFNjYWxlIiwicmVtb3ZlQ29udHJvbGxlcnMiLCJyZW1vdmVFbGVtZW50cyIsInJlbW92ZVBsdWdpbnMiLCJyZW1vdmVTY2FsZXMiLCJ0eXBlZFJlZ2lzdHJ5IiwiYXJnIiwicmVnIiwiX2dldFJlZ2lzdHJ5Rm9yVHlwZSIsIl9leGVjIiwiaXRlbVJlZyIsImNvbXBvbmVudCIsImNhbWVsTWV0aG9kIiwiX2NhcGl0YWxpemUiLCJQbHVnaW5TZXJ2aWNlIiwiX2luaXQiLCJub3RpZnkiLCJob29rIiwiX2NyZWF0ZURlc2NyaXB0b3JzIiwiX2Rlc2NyaXB0b3JzIiwiZGVzY3JpcHRvciIsInBsdWdpbiIsImNhbGxDYWxsYmFjayIsImNhbmNlbGFibGUiLCJpbnZhbGlkYXRlIiwiX29sZENhY2hlIiwiX25vdGlmeVN0YXRlQ2hhbmdlcyIsImFsbFBsdWdpbnMiLCJjcmVhdGVEZXNjcmlwdG9ycyIsInByZXZpb3VzRGVzY3JpcHRvcnMiLCJzb21lIiwibG9jYWxJZHMiLCJsb2NhbCIsImdldE9wdHMiLCJwbHVnaW5PcHRzIiwicGx1Z2luU2NvcGVLZXlzIiwic2NyaXB0YWJsZSIsImluZGV4YWJsZSIsImFsbEtleXMiLCJnZXRJbmRleEF4aXMiLCJkYXRhc2V0RGVmYXVsdHMiLCJkYXRhc2V0T3B0aW9ucyIsImdldEF4aXNGcm9tRGVmYXVsdFNjYWxlSUQiLCJnZXREZWZhdWx0U2NhbGVJREZyb21BeGlzIiwiaWRNYXRjaGVzQXhpcyIsImF4aXNGcm9tUG9zaXRpb24iLCJkZXRlcm1pbmVBeGlzIiwic2NhbGVPcHRpb25zIiwidG9Mb3dlckNhc2UiLCJnZXRBeGlzRnJvbURhdGFzZXQiLCJyZXRyaWV2ZUF4aXNGcm9tRGF0YXNldHMiLCJib3VuZERzIiwiZCIsIm1lcmdlU2NhbGVDb25maWciLCJjaGFydERlZmF1bHRzIiwiY29uZmlnU2NhbGVzIiwiY2hhcnRJbmRleEF4aXMiLCJzY2FsZUNvbmYiLCJlcnJvciIsIl9wcm94eSIsImRlZmF1bHRJZCIsImRlZmF1bHRTY2FsZU9wdGlvbnMiLCJtZXJnZUlmIiwiZGVmYXVsdElEIiwiaW5pdE9wdGlvbnMiLCJpbml0RGF0YSIsImluaXRDb25maWciLCJrZXlDYWNoZSIsImtleXNDYWNoZWQiLCJTZXQiLCJjYWNoZWRLZXlzIiwiZ2VuZXJhdGUiLCJhZGRJZkZvdW5kIiwiQ29uZmlnIiwiX2NvbmZpZyIsIl9zY29wZUNhY2hlIiwiX3Jlc29sdmVyQ2FjaGUiLCJwbGF0Zm9ybSIsImNsZWFyQ2FjaGUiLCJjbGVhciIsImRhdGFzZXRUeXBlIiwiYWRkaXRpb25hbE9wdGlvblNjb3BlcyIsIl9jYWNoZWRTY29wZXMiLCJtYWluU2NvcGUiLCJyZXNldENhY2hlIiwia2V5TGlzdHMiLCJjaGFydE9wdGlvblNjb3BlcyIsInJlc29sdmVyIiwic3ViUHJlZml4ZXMiLCJnZXRSZXNvbHZlciIsIm5lZWRDb250ZXh0IiwiaXNGdW5jdGlvbiIsInN1YlJlc29sdmVyIiwiX2F0dGFjaENvbnRleHQiLCJkZXNjcmlwdG9yRGVmYXVsdHMiLCJyZXNvbHZlckNhY2hlIiwiX2NyZWF0ZVJlc29sdmVyIiwicCIsImhhc0Z1bmN0aW9uIiwiaXNTY3JpcHRhYmxlIiwiaXNJbmRleGFibGUiLCJLTk9XTl9QT1NJVElPTlMiLCJwb3NpdGlvbklzSG9yaXpvbnRhbCIsImNvbXBhcmUyTGV2ZWwiLCJsMSIsImwyIiwib25BbmltYXRpb25zQ29tcGxldGUiLCJvbkNvbXBsZXRlIiwib25BbmltYXRpb25Qcm9ncmVzcyIsIm9uUHJvZ3Jlc3MiLCJnZXRDYW52YXMiLCJnZXRFbGVtZW50QnlJZCIsImluc3RhbmNlcyIsImdldENoYXJ0IiwiYyIsIm1vdmVOdW1lcmljS2V5cyIsImludEtleSIsImRldGVybWluZUxhc3RFdmVudCIsImxhc3RFdmVudCIsImluQ2hhcnRBcmVhIiwiaXNDbGljayIsIkNoYXJ0IiwidmVyc2lvbiIsImludmFsaWRhdGVQbHVnaW5zIiwidXNlckNvbmZpZyIsImluaXRpYWxDYW52YXMiLCJleGlzdGluZ0NoYXJ0IiwidWlkIiwiX29wdGlvbnMiLCJfYXNwZWN0UmF0aW8iLCJfbWV0YXNldHMiLCJfbGFzdEV2ZW50IiwiX2xpc3RlbmVycyIsIl9yZXNwb25zaXZlTGlzdGVuZXJzIiwiX3NvcnRlZE1ldGFzZXRzIiwiX3BsdWdpbnMiLCJfaGlkZGVuSW5kaWNlcyIsImF0dGFjaGVkIiwiX2RvUmVzaXplIiwiZGVib3VuY2UiLCJyZXNpemVEZWxheSIsIl9pbml0aWFsaXplIiwibWFpbnRhaW5Bc3BlY3RSYXRpbyIsInJlc3BvbnNpdmUiLCJyZXRpbmFTY2FsZSIsImJpbmRFdmVudHMiLCJjbGVhckNhbnZhcyIsIl9yZXNpemUiLCJfcmVzaXplQmVmb3JlRHJhdyIsIm5ld1NpemUiLCJuZXdSYXRpbyIsIm9uUmVzaXplIiwicmVuZGVyIiwiZW5zdXJlU2NhbGVzSGF2ZUlEcyIsInNjYWxlc09wdGlvbnMiLCJheGlzT3B0aW9ucyIsImJ1aWxkT3JVcGRhdGVTY2FsZXMiLCJzY2FsZU9wdHMiLCJ1cGRhdGVkIiwiaXNSYWRpYWwiLCJkcG9zaXRpb24iLCJkdHlwZSIsInNjYWxlVHlwZSIsInNjYWxlQ2xhc3MiLCJoYXNVcGRhdGVkIiwiX3VwZGF0ZU1ldGFzZXRzIiwiX2Rlc3Ryb3lEYXRhc2V0TWV0YSIsIl9yZW1vdmVVbnJlZmVyZW5jZWRNZXRhc2V0cyIsImJ1aWxkT3JVcGRhdGVDb250cm9sbGVycyIsIm5ld0NvbnRyb2xsZXJzIiwib3JkZXIiLCJ2aXNpYmxlIiwiQ29udHJvbGxlckNsYXNzIiwiX3Jlc2V0RWxlbWVudHMiLCJhbmltc0Rpc2FibGVkIiwiX3VwZGF0ZVNjYWxlcyIsIl9jaGVja0V2ZW50QmluZGluZ3MiLCJfdXBkYXRlSGlkZGVuSW5kaWNlcyIsIl9taW5QYWRkaW5nIiwiYXV0b1BhZGRpbmciLCJfdXBkYXRlTGF5b3V0IiwiX3VwZGF0ZURhdGFzZXRzIiwiX2V2ZW50SGFuZGxlciIsIl91cGRhdGVIb3ZlclN0eWxlcyIsImV4aXN0aW5nRXZlbnRzIiwibmV3RXZlbnRzIiwiZXZlbnRzIiwic2V0c0VxdWFsIiwidW5iaW5kRXZlbnRzIiwiY2hhbmdlcyIsIl9nZXRVbmlmb3JtRGF0YUNoYW5nZXMiLCJkYXRhc2V0Q291bnQiLCJtYWtlU2V0IiwiY2hhbmdlU2V0Iiwibm9BcmVhIiwiX2lkeCIsIl91cGRhdGVEYXRhc2V0IiwibGF5ZXJzIiwiX2RyYXdEYXRhc2V0cyIsIl9kcmF3RGF0YXNldCIsImdldERhdGFzZXRDbGlwQXJlYSIsImdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUiLCJJbnRlcmFjdGlvbiIsInNldERhdGFzZXRWaXNpYmlsaXR5IiwiX3VwZGF0ZVZpc2liaWxpdHkiLCJoaWRlIiwic2hvdyIsIl9zdG9wIiwiZGVzdHJveSIsInRvQmFzZTY0SW1hZ2UiLCJ0b0RhdGFVUkwiLCJiaW5kVXNlckV2ZW50cyIsImJpbmRSZXNwb25zaXZlRXZlbnRzIiwiX2FkZCIsIl9yZW1vdmUiLCJkZXRhY2hlZCIsInVwZGF0ZUhvdmVyU3R5bGUiLCJwcmVmaXgiLCJnZXRBY3RpdmVFbGVtZW50cyIsInNldEFjdGl2ZUVsZW1lbnRzIiwiYWN0aXZlRWxlbWVudHMiLCJsYXN0QWN0aXZlIiwiX2VsZW1lbnRzRXF1YWwiLCJwbHVnaW5JZCIsInJlcGxheSIsImhvdmVyT3B0aW9ucyIsImhvdmVyIiwiZGVhY3RpdmF0ZWQiLCJhY3RpdmF0ZWQiLCJldmVudEZpbHRlciIsIl9oYW5kbGVFdmVudCIsIl9nZXRBY3RpdmVFbGVtZW50cyIsIl9pc0NsaWNrRXZlbnQiLCJvbkhvdmVyIiwiY2xpcFNlbGYiLCJvdXRlckFuZ2xlQ2xpcCIsIl9ub3JtYWxpemVBbmdsZSIsImlubmVyQW5nbGVDbGlwIiwiY2xpcFdpZHRoIiwiY2xvc2VQYXRoIiwicmVjdCIsImNsaXBBcmMiLCJwaXhlbE1hcmdpbiIsImFuZ2xlTWFyZ2luIiwidG9SYWRpdXNDb3JuZXJzIiwiX3JlYWRWYWx1ZVRvUHJvcHMiLCJwYXJzZUJvcmRlclJhZGl1cyIsImFuZ2xlRGVsdGEiLCJvIiwiaGFsZlRoaWNrbmVzcyIsImlubmVyTGltaXQiLCJjb21wdXRlT3V0ZXJMaW1pdCIsIm91dGVyQXJjTGltaXQiLCJvdXRlclN0YXJ0Iiwib3V0ZXJFbmQiLCJpbm5lclN0YXJ0IiwiaW5uZXJFbmQiLCJyVGhldGFUb1hZIiwidGhldGEiLCJwYXRoQXJjIiwiaW5uZXJSIiwic3BhY2luZ09mZnNldCIsImFscGhhIiwibm9TcGFjaW5nSW5uZXJSYWRpdXMiLCJub1NwYWNpbmdPdXRlclJhZGl1cyIsImF2Tm9nU3BhY2luZ1JhZGl1cyIsImFkanVzdGVkQW5nbGUiLCJiZXRhIiwiYW5nbGVPZmZzZXQiLCJvdXRlclN0YXJ0QWRqdXN0ZWRSYWRpdXMiLCJvdXRlckVuZEFkanVzdGVkUmFkaXVzIiwib3V0ZXJTdGFydEFkanVzdGVkQW5nbGUiLCJvdXRlckVuZEFkanVzdGVkQW5nbGUiLCJpbm5lclN0YXJ0QWRqdXN0ZWRSYWRpdXMiLCJpbm5lckVuZEFkanVzdGVkUmFkaXVzIiwiaW5uZXJTdGFydEFkanVzdGVkQW5nbGUiLCJpbm5lckVuZEFkanVzdGVkQW5nbGUiLCJvdXRlck1pZEFkanVzdGVkQW5nbGUiLCJwQ2VudGVyIiwicDQiLCJpbm5lck1pZEFkanVzdGVkQW5nbGUiLCJwOCIsIm91dGVyU3RhcnRYIiwib3V0ZXJTdGFydFkiLCJvdXRlckVuZFgiLCJvdXRlckVuZFkiLCJkcmF3QXJjIiwiZnVsbENpcmNsZXMiLCJpbm5lciIsInNlbGZKb2luIiwiQXJjRWxlbWVudCIsImNoYXJ0WCIsImNoYXJ0WSIsInJBZGp1c3QiLCJub25aZXJvQmV0d2VlbiIsImJldHdlZW5BbmdsZXMiLCJ3aXRoaW5SYWRpdXMiLCJfaXNCZXR3ZWVuIiwiaGFsZkFuZ2xlIiwiaGFsZlJhZGl1cyIsInRyYW5zbGF0ZSIsImZpeCIsInJhZGl1c09mZnNldCIsInNldFN0eWxlIiwibGluZUNhcCIsImJvcmRlckNhcFN0eWxlIiwicHJldmlvdXMiLCJnZXRMaW5lTWV0aG9kIiwic3RlcHBlZCIsIl9zdGVwcGVkTGluZVRvIiwidGVuc2lvbiIsImN1YmljSW50ZXJwb2xhdGlvbk1vZGUiLCJfYmV6aWVyQ3VydmVUbyIsInBhdGhWYXJzIiwicGFyYW1zU3RhcnQiLCJwYXJhbXNFbmQiLCJzZWdtZW50U3RhcnQiLCJzZWdtZW50RW5kIiwib3V0c2lkZSIsInBhdGhTZWdtZW50IiwibGluZU1ldGhvZCIsImZhc3RQYXRoU2VnbWVudCIsImF2Z1giLCJjb3VudFgiLCJwcmV2WCIsImxhc3RZIiwicG9pbnRJbmRleCIsImRyYXdYIiwidHJ1bmNYIiwiX2dldFNlZ21lbnRNZXRob2QiLCJ1c2VGYXN0UGF0aCIsIl9nZXRJbnRlcnBvbGF0aW9uTWV0aG9kIiwiX3N0ZXBwZWRJbnRlcnBvbGF0aW9uIiwiX2JlemllckludGVycG9sYXRpb24iLCJfcG9pbnRJbkxpbmUiLCJzdHJva2VQYXRoV2l0aENhY2hlIiwicGF0aCIsIl9wYXRoIiwiUGF0aDJEIiwic3Ryb2tlUGF0aERpcmVjdCIsInNlZ21lbnRzIiwic2VnbWVudE1ldGhvZCIsInVzZVBhdGgyRCIsIkxpbmVFbGVtZW50IiwiY2FwQmV6aWVyUG9pbnRzIiwiX3BvaW50cyIsIl9zZWdtZW50cyIsIl9wb2ludHNVcGRhdGVkIiwiX3VwZGF0ZUJlemllckNvbnRyb2xQb2ludHMiLCJfY29tcHV0ZVNlZ21lbnRzIiwiaW50ZXJwb2xhdGUiLCJfYm91bmRTZWdtZW50cyIsIl9pbnRlcnBvbGF0ZSIsImludGVycG9sYXRlZCIsImhpdFJhZGl1cyIsIlBvaW50RWxlbWVudCIsImhvdmVyUmFkaXVzIiwibW91c2VYIiwibW91c2VZIiwiaW5YUmFuZ2UiLCJpbllSYW5nZSIsImRyYXdQb2ludCIsImdldEJhckJvdW5kcyIsImJhciIsImhhbGYiLCJza2lwT3JMaW1pdCIsInBhcnNlQm9yZGVyV2lkdGgiLCJtYXhXIiwibWF4SCIsInRvVFJCTCIsInRvVFJCTENvcm5lcnMiLCJtYXhSIiwiZW5hYmxlQm9yZGVyIiwidG9wTGVmdCIsInRvcFJpZ2h0IiwiYm90dG9tTGVmdCIsImJvdHRvbVJpZ2h0IiwiYm91bmRpbmdSZWN0cyIsImJvdW5kcyIsIm91dGVyIiwic2tpcFgiLCJza2lwWSIsInNraXBCb3RoIiwiaGFzUmFkaXVzIiwiYWRkTm9ybWFsUmVjdFBhdGgiLCJpbmZsYXRlUmVjdCIsImFtb3VudCIsInJlZlJlY3QiLCJCYXJFbGVtZW50IiwiYWRkUmVjdFBhdGgiLCJhZGRSb3VuZGVkUmVjdFBhdGgiLCJCT1JERVJfQ09MT1JTIiwiQkFDS0dST1VORF9DT0xPUlMiLCJyZXBsYWNlIiwiZ2V0Qm9yZGVyQ29sb3IiLCJnZXRCYWNrZ3JvdW5kQ29sb3IiLCJjb2xvcml6ZURlZmF1bHREYXRhc2V0IiwiY29sb3JpemVEb3VnaG51dERhdGFzZXQiLCJjb2xvcml6ZVBvbGFyQXJlYURhdGFzZXQiLCJnZXRDb2xvcml6ZXIiLCJjb250YWluc0NvbG9yc0RlZmluaXRpb25zIiwiayIsImNvbnRhaW5zQ29sb3JzRGVmaW5pdGlvbiIsImNvbnRhaW5zRGVmYXVsdENvbG9yc0RlZmVuaXRpb25zIiwiZm9yY2VPdmVycmlkZSIsIl9hcmdzIiwiY2hhcnRPcHRpb25zIiwiY29udGFpbnNDb2xvckRlZmVuaXRpb24iLCJjb2xvcml6ZXIiLCJsdHRiRGVjaW1hdGlvbiIsInNhbXBsZXMiLCJkZWNpbWF0ZWQiLCJidWNrZXRXaWR0aCIsInNhbXBsZWRJbmRleCIsImVuZEluZGV4IiwibWF4QXJlYVBvaW50IiwibWF4QXJlYSIsIm5leHRBIiwiYXZnWSIsImF2Z1JhbmdlU3RhcnQiLCJhdmdSYW5nZUVuZCIsImF2Z1JhbmdlTGVuZ3RoIiwicmFuZ2VPZmZzIiwicmFuZ2VUbyIsInBvaW50QXgiLCJwb2ludEF5IiwibWluTWF4RGVjaW1hdGlvbiIsIm1pbkluZGV4IiwibWF4SW5kZXgiLCJzdGFydEluZGV4IiwieE1pbiIsInhNYXgiLCJkeCIsImxhc3RJbmRleCIsImludGVybWVkaWF0ZUluZGV4MSIsImludGVybWVkaWF0ZUluZGV4MiIsImNsZWFuRGVjaW1hdGVkRGF0YXNldCIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwiY2xlYW5EZWNpbWF0ZWREYXRhIiwiZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50c1NpbXBsaWZpZWQiLCJwb2ludENvdW50IiwiYWxnb3JpdGhtIiwiYmVmb3JlRWxlbWVudHNVcGRhdGUiLCJ4QXhpcyIsInRocmVzaG9sZCIsInRwb2ludHMiLCJfZmluZFNlZ21lbnRFbmQiLCJfZ2V0Qm91bmRzIiwidGFyZ2V0U2VnbWVudHMiLCJ0Z3QiLCJzdWJCb3VuZHMiLCJmaWxsU291cmNlcyIsIl9ib3VuZFNlZ21lbnQiLCJmaWxsU291cmNlIiwiX2dldEVkZ2UiLCJfcG9pbnRzRnJvbVNlZ21lbnRzIiwiYm91bmRhcnkiLCJsaW5lUG9pbnRzIiwiX2NyZWF0ZUJvdW5kYXJ5TGluZSIsIl9zaG91bGRBcHBseUZpbGwiLCJfcmVzb2x2ZVRhcmdldCIsInNvdXJjZXMiLCJwcm9wYWdhdGUiLCJ2aXNpdGVkIiwiX2RlY29kZUZpbGwiLCJwYXJzZUZpbGxPcHRpb24iLCJwYXJzZUZsb2F0IiwiZGVjb2RlVGFyZ2V0SW5kZXgiLCJmaXJzdENoIiwiX2dldFRhcmdldFBpeGVsIiwiX2dldFRhcmdldFZhbHVlIiwiZmlsbE9wdGlvbiIsIl9idWlsZFN0YWNrTGluZSIsInNvdXJjZVBvaW50cyIsImxpbmVzQmVsb3ciLCJnZXRMaW5lc0JlbG93IiwiYWRkUG9pbnRzQmVsb3ciLCJiZWxvdyIsInVuc2hpZnQiLCJzb3VyY2VQb2ludCIsInBvc3Rwb25lZCIsImZpbmRQb2ludCIsInBvaW50VmFsdWUiLCJmaXJzdFZhbHVlIiwibGFzdFZhbHVlIiwic2ltcGxlQXJjIiwiX2dldFRhcmdldCIsImdldExpbmVCeUluZGV4IiwiY29tcHV0ZUJvdW5kYXJ5IiwiY29tcHV0ZUNpcmN1bGFyQm91bmRhcnkiLCJjb21wdXRlTGluZWFyQm91bmRhcnkiLCJfZHJhd2ZpbGwiLCJsaW5lT3B0cyIsImFib3ZlIiwiZG9GaWxsIiwiZmlsbENvbG9yIiwiY2xpcFZlcnRpY2FsIiwiY2xpcEhvcml6b250YWwiLCJjbGlwWSIsImxpbmVMb29wIiwiY2xpcFgiLCJzcmMiLCJub3RTaGFwZSIsImNsaXBCb3VuZHMiLCJpbnRlcnBvbGF0ZWRMaW5lVG8iLCJ0YXJnZXRMb29wIiwiaW50ZXJwb2xhdGVkUG9pbnQiLCJhZnRlckRhdGFzZXRzVXBkYXRlIiwiJGZpbGxlciIsImJlZm9yZURyYXciLCJkcmF3VGltZSIsImJlZm9yZURhdGFzZXRzRHJhdyIsImJlZm9yZURhdGFzZXREcmF3IiwiZ2V0Qm94U2l6ZSIsImxhYmVsT3B0cyIsImJveEhlaWdodCIsImJveFdpZHRoIiwidXNlUG9pbnRTdHlsZSIsInBvaW50U3R5bGVXaWR0aCIsIml0ZW1IZWlnaHQiLCJpdGVtc0VxdWFsIiwiTGVnZW5kIiwiX2FkZGVkIiwibGVnZW5kSGl0Qm94ZXMiLCJfaG92ZXJlZEl0ZW0iLCJkb3VnaG51dE1vZGUiLCJsZWdlbmRJdGVtcyIsImNvbHVtblNpemVzIiwibGluZVdpZHRocyIsImJ1aWxkTGFiZWxzIiwibGFiZWxGb250IiwiX2NvbXB1dGVUaXRsZUhlaWdodCIsIl9maXRSb3dzIiwiX2ZpdENvbHMiLCJoaXRib3hlcyIsInRvdGFsSGVpZ2h0Iiwicm93IiwiaXRlbVdpZHRoIiwibWVhc3VyZVRleHQiLCJfaXRlbUhlaWdodCIsImhlaWdodExpbWl0IiwidG90YWxXaWR0aCIsImN1cnJlbnRDb2xXaWR0aCIsImN1cnJlbnRDb2xIZWlnaHQiLCJjb2wiLCJjYWxjdWxhdGVJdGVtU2l6ZSIsImFkanVzdEhpdEJveGVzIiwicnRsIiwicnRsSGVscGVyIiwiZ2V0UnRsQWRhcHRlciIsImhpdGJveCIsImxlZnRGb3JMdHIiLCJfZHJhdyIsImRlZmF1bHRDb2xvciIsImhhbGZGb250U2l6ZSIsImN1cnNvciIsImRyYXdMZWdlbmRCb3giLCJkcmF3T3B0aW9ucyIsIlNRUlQyIiwieFBsdXMiLCJkcmF3UG9pbnRMZWdlbmQiLCJ5Qm94VG9wIiwieEJveExlZnQiLCJmaWxsVGV4dCIsInN0cmlrZXRocm91Z2giLCJvdmVycmlkZVRleHREaXJlY3Rpb24iLCJ0ZXh0RGlyZWN0aW9uIiwidGV4dFdpZHRoIiwic2V0V2lkdGgiLCJyZWFsWCIsIl90ZXh0WCIsImZvbnRMaW5lSGVpZ2h0IiwiY2FsY3VsYXRlTGVnZW5kSXRlbUhlaWdodCIsInJlc3RvcmVUZXh0RGlyZWN0aW9uIiwidGl0bGVGb250IiwidGl0bGVQYWRkaW5nIiwidG9wUGFkZGluZ1BsdXNIYWxmRm9udFNpemUiLCJfZ2V0TGVnZW5kSXRlbUF0IiwiaGl0Qm94IiwibGgiLCJoYW5kbGVFdmVudCIsImlzTGlzdGVuZWQiLCJob3ZlcmVkSXRlbSIsInNhbWVJdGVtIiwib25MZWF2ZSIsImNhbGN1bGF0ZUl0ZW1XaWR0aCIsImNhbGN1bGF0ZUl0ZW1IZWlnaHQiLCJsZWdlbmRJdGVtVGV4dCIsIl9lbGVtZW50IiwiYWZ0ZXJFdmVudCIsImNpIiwiVGl0bGUiLCJfcGFkZGluZyIsInRleHRTaXplIiwiX2RyYXdBcmdzIiwiZm9udE9wdHMiLCJjcmVhdGVUaXRsZSIsInRpdGxlQmxvY2siLCJXZWFrTWFwIiwicG9zaXRpb25lcnMiLCJhdmVyYWdlIiwieFNldCIsInhBdmVyYWdlIiwiZXZlbnRQb3NpdGlvbiIsIm5lYXJlc3RFbGVtZW50IiwiZGlzdGFuY2VCZXR3ZWVuUG9pbnRzIiwidHAiLCJwdXNoT3JDb25jYXQiLCJ0b1B1c2giLCJhcHBseSIsInNwbGl0TmV3bGluZXMiLCJzdHIiLCJTdHJpbmciLCJjcmVhdGVUb29sdGlwSXRlbSIsImZvcm1hdHRlZFZhbHVlIiwiZ2V0VG9vbHRpcFNpemUiLCJ0b29sdGlwIiwiYm9keSIsImZvb3RlciIsImJvZHlGb250IiwiZm9vdGVyRm9udCIsInRpdGxlTGluZUNvdW50IiwiZm9vdGVyTGluZUNvdW50IiwiYm9keUxpbmVJdGVtQ291bnQiLCJjb21iaW5lZEJvZHlMZW5ndGgiLCJib2R5SXRlbSIsImJlZm9yZSIsImFmdGVyIiwiYmVmb3JlQm9keSIsImFmdGVyQm9keSIsInRpdGxlU3BhY2luZyIsInRpdGxlTWFyZ2luQm90dG9tIiwiYm9keUxpbmVIZWlnaHQiLCJkaXNwbGF5Q29sb3JzIiwiYm9keVNwYWNpbmciLCJmb290ZXJNYXJnaW5Ub3AiLCJmb290ZXJTcGFjaW5nIiwid2lkdGhQYWRkaW5nIiwibWF4TGluZVdpZHRoIiwiZGV0ZXJtaW5lWUFsaWduIiwiZG9lc05vdEZpdFdpdGhBbGlnbiIsInhBbGlnbiIsImNhcmV0IiwiY2FyZXRTaXplIiwiY2FyZXRQYWRkaW5nIiwiZGV0ZXJtaW5lWEFsaWduIiwieUFsaWduIiwiY2hhcnRXaWR0aCIsImRldGVybWluZUFsaWdubWVudCIsImFsaWduWCIsImFsaWduWSIsInBhZGRpbmdBbmRTaXplIiwiZ2V0QmFja2dyb3VuZFBvaW50IiwiYWxpZ25tZW50IiwiY29ybmVyUmFkaXVzIiwiZ2V0QWxpZ25lZFgiLCJnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyIsImNyZWF0ZVRvb2x0aXBDb250ZXh0IiwidG9vbHRpcEl0ZW1zIiwib3ZlcnJpZGVDYWxsYmFja3MiLCJkZWZhdWx0Q2FsbGJhY2tzIiwiYmVmb3JlVGl0bGUiLCJub29wIiwibGFiZWxDb3VudCIsImFmdGVyVGl0bGUiLCJiZWZvcmVMYWJlbCIsInRvb2x0aXBJdGVtIiwibGFiZWxDb2xvciIsImxhYmVsVGV4dENvbG9yIiwiYm9keUNvbG9yIiwibGFiZWxQb2ludFN0eWxlIiwiYWZ0ZXJMYWJlbCIsImJlZm9yZUZvb3RlciIsImFmdGVyRm9vdGVyIiwiaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2siLCJUb29sdGlwIiwib3BhY2l0eSIsIl9ldmVudFBvc2l0aW9uIiwiX3NpemUiLCJfY2FjaGVkQW5pbWF0aW9ucyIsIl90b29sdGlwSXRlbXMiLCJkYXRhUG9pbnRzIiwiY2FyZXRYIiwiY2FyZXRZIiwibGFiZWxDb2xvcnMiLCJsYWJlbFBvaW50U3R5bGVzIiwibGFiZWxUZXh0Q29sb3JzIiwiZ2V0VGl0bGUiLCJnZXRCZWZvcmVCb2R5IiwiZ2V0Qm9keSIsImJvZHlJdGVtcyIsInNjb3BlZCIsImdldEFmdGVyQm9keSIsImdldEZvb3RlciIsIl9jcmVhdGVJdGVtcyIsIml0ZW1Tb3J0IiwicG9zaXRpb25BbmRTaXplIiwiYmFja2dyb3VuZFBvaW50IiwiZXh0ZXJuYWwiLCJkcmF3Q2FyZXQiLCJ0b29sdGlwUG9pbnQiLCJjYXJldFBvc2l0aW9uIiwiZ2V0Q2FyZXRQb3NpdGlvbiIsIngzIiwieTMiLCJwdFgiLCJwdFkiLCJwdCIsInRpdGxlQ29sb3IiLCJfZHJhd0NvbG9yQm94IiwiY29sb3JYIiwicnRsQ29sb3JYIiwieU9mZlNldCIsImNvbG9yWSIsIm11bHRpS2V5QmFja2dyb3VuZCIsIm91dGVyWCIsImlubmVyWCIsInN0cm9rZVJlY3QiLCJkcmF3Qm9keSIsImJvZHlBbGlnbiIsInhMaW5lUGFkZGluZyIsImZpbGxMaW5lT2ZUZXh0IiwiYm9keUFsaWduRm9yQ2FsY3VsYXRpb24iLCJ0ZXh0Q29sb3IiLCJkcmF3Rm9vdGVyIiwiZm9vdGVyQWxpZ24iLCJmb290ZXJDb2xvciIsInRvb2x0aXBTaXplIiwicXVhZHJhdGljQ3VydmVUbyIsIl91cGRhdGVBbmltYXRpb25UYXJnZXQiLCJhbmltWCIsImFuaW1ZIiwiX3dpbGxSZW5kZXIiLCJoYXNUb29sdGlwQ29udGVudCIsImdsb2JhbEFscGhhIiwicG9zaXRpb25DaGFuZ2VkIiwiX3Bvc2l0aW9uQ2hhbmdlZCIsIl9pZ25vcmVSZXBsYXlFdmVudHMiLCJhZnRlckluaXQiLCJhZnRlckRyYXciLCJfZmFsbGJhY2siLCJhZGRJZlN0cmluZyIsImFkZGVkTGFiZWxzIiwiZmluZE9yQWRkTGFiZWwiLCJsYXN0SW5kZXhPZiIsIl9nZXRMYWJlbEZvclZhbHVlIiwiQ2F0ZWdvcnlTY2FsZSIsIl9zdGFydFZhbHVlIiwiX3ZhbHVlUmFuZ2UiLCJfYWRkZWRMYWJlbHMiLCJhZGRlZCIsImdlbmVyYXRlVGlja3MiLCJnZW5lcmF0aW9uT3B0aW9ucyIsImRhdGFSYW5nZSIsIk1JTl9TUEFDSU5HIiwicHJlY2lzaW9uIiwibWF4VGlja3MiLCJtYXhEaWdpdHMiLCJpbmNsdWRlQm91bmRzIiwidW5pdCIsIm1heFNwYWNlcyIsInJtaW4iLCJybWF4IiwiY291bnREZWZpbmVkIiwibWluU3BhY2luZyIsIm5pY2VOdW0iLCJuaWNlTWluIiwibmljZU1heCIsIm51bVNwYWNlcyIsImFsbW9zdFdob2xlIiwiYWxtb3N0RXF1YWxzIiwiZGVjaW1hbFBsYWNlcyIsIl9kZWNpbWFsUGxhY2VzIiwicmVsYXRpdmVMYWJlbFNpemUiLCJ0aWNrVmFsdWUiLCJyYWQiLCJMaW5lYXJTY2FsZUJhc2UiLCJfZW5kVmFsdWUiLCJoYW5kbGVUaWNrUmFuZ2VPcHRpb25zIiwic2V0TWluIiwic2V0TWF4IiwibWluU2lnbiIsIm1heFNpZ24iLCJnZXRUaWNrTGltaXQiLCJzdGVwU2l6ZSIsImNvbXB1dGVUaWNrTGltaXQiLCJudW1lcmljR2VuZXJhdG9yT3B0aW9ucyIsIl9zZXRNaW5BbmRNYXhCeUtleSIsIkxpbmVhclNjYWxlIiwiVGlja3MiLCJmb3JtYXR0ZXJzIiwibnVtZXJpYyIsImxvZzEwRmxvb3IiLCJsb2cxMCIsImNoYW5nZUV4cG9uZW50IiwibSIsImlzTWFqb3IiLCJ0aWNrVmFsIiwic3RlcHMiLCJyYW5nZUV4cCIsInJhbmdlU3RlcCIsInN0YXJ0RXhwIiwibWluRXhwIiwiZXhwIiwic2lnbmlmaWNhbmQiLCJsYXN0VGljayIsIkxvZ2FyaXRobWljU2NhbGUiLCJsb2dhcml0aG1pYyIsIl96ZXJvIiwiZ2V0VGlja0JhY2tkcm9wSGVpZ2h0IiwibWVhc3VyZUxhYmVsU2l6ZSIsIl9sb25nZXN0VGV4dCIsImRldGVybWluZUxpbWl0cyIsImZpdFdpdGhQb2ludExhYmVscyIsImxpbWl0cyIsInZhbHVlQ291bnQiLCJfcG9pbnRMYWJlbHMiLCJwb2ludExhYmVsT3B0cyIsImFkZGl0aW9uYWxBbmdsZSIsImNlbnRlclBvaW50TGFiZWxzIiwiZ2V0UG9pbnRMYWJlbENvbnRleHQiLCJnZXRQb2ludFBvc2l0aW9uIiwiZHJhd2luZ0FyZWEiLCJwbEZvbnQiLCJoTGltaXRzIiwidkxpbWl0cyIsInVwZGF0ZUxpbWl0cyIsInNldENlbnRlclBvaW50IiwiX3BvaW50TGFiZWxJdGVtcyIsImJ1aWxkUG9pbnRMYWJlbEl0ZW1zIiwiY3JlYXRlUG9pbnRMYWJlbEl0ZW0iLCJpdGVtT3B0cyIsIm91dGVyRGlzdGFuY2UiLCJleHRyYSIsInBvaW50TGFiZWxQb3NpdGlvbiIsInlGb3JBbmdsZSIsImdldFRleHRBbGlnbkZvckFuZ2xlIiwibGVmdEZvclRleHRBbGlnbiIsImlzTm90T3ZlcmxhcHBlZCIsImFwZXhlc0luQXJlYSIsImRyYXdQb2ludExhYmVsQm94IiwiYmFja2Ryb3BMZWZ0IiwiYmFja2Ryb3BUb3AiLCJiYWNrZHJvcFdpZHRoIiwiYmFja2Ryb3BIZWlnaHQiLCJkcmF3UG9pbnRMYWJlbHMiLCJwYXRoUmFkaXVzTGluZSIsImRyYXdSYWRpdXNMaW5lIiwiZ3JpZExpbmVPcHRzIiwiY3JlYXRlUG9pbnRMYWJlbENvbnRleHQiLCJSYWRpYWxMaW5lYXJTY2FsZSIsImFuaW1hdGUiLCJsZWZ0TW92ZW1lbnQiLCJyaWdodE1vdmVtZW50IiwidG9wTW92ZW1lbnQiLCJib3R0b21Nb3ZlbWVudCIsImFuZ2xlTXVsdGlwbGllciIsInNjYWxpbmdGYWN0b3IiLCJnZXRWYWx1ZUZvckRpc3RhbmNlRnJvbUNlbnRlciIsInNjYWxlZERpc3RhbmNlIiwicG9pbnRMYWJlbCIsImRpc3RhbmNlRnJvbUNlbnRlciIsImdldEJhc2VQb3NpdGlvbiIsImdldFBvaW50TGFiZWxQb3NpdGlvbiIsInJvdGF0ZSIsIklOVEVSVkFMUyIsIm1pbGxpc2Vjb25kIiwiY29tbW9uIiwic2Vjb25kIiwibWludXRlIiwiaG91ciIsImRheSIsIndlZWsiLCJtb250aCIsInF1YXJ0ZXIiLCJ5ZWFyIiwiVU5JVFMiLCJzb3J0ZXIiLCJpbnB1dCIsImFkYXB0ZXIiLCJfYWRhcHRlciIsInBhcnNlciIsImlzb1dlZWtkYXkiLCJfcGFyc2VPcHRzIiwiZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyIsIm1pblVuaXQiLCJjYXBhY2l0eSIsImludGVydmFsIiwiTUFYX1NBRkVfSU5URUdFUiIsImRldGVybWluZVVuaXRGb3JGb3JtYXR0aW5nIiwiZGV0ZXJtaW5lTWFqb3JVbml0IiwiYWRkVGljayIsInRpbWUiLCJ0aW1lc3RhbXBzIiwiX2xvb2t1cCIsInRpbWVzdGFtcCIsInNldE1ham9yVGlja3MiLCJtYWpvclVuaXQiLCJ0aWNrc0Zyb21UaW1lc3RhbXBzIiwiVGltZVNjYWxlIiwiYWRhcHRlcnMiLCJkaXNwbGF5Rm9ybWF0cyIsIl91bml0IiwiX21ham9yVW5pdCIsIl9vZmZzZXRzIiwiX25vcm1hbGl6ZWQiLCJub3JtYWxpemVkIiwiX2FwcGx5Qm91bmRzIiwiX2dldExhYmVsQm91bmRzIiwiZ2V0TGFiZWxUaW1lc3RhbXBzIiwidGltZU9wdHMiLCJfZ2VuZXJhdGUiLCJfZmlsdGVyQmV0d2VlbiIsIl9nZXRMYWJlbENhcGFjaXR5IiwiaW5pdE9mZnNldHMiLCJvZmZzZXRBZnRlckF1dG9za2lwIiwiZ2V0RGVjaW1hbEZvclZhbHVlIiwibWlub3IiLCJ3ZWVrZGF5IiwiaGFzV2Vla2RheSIsImdldERhdGFUaW1lc3RhbXBzIiwidG9vbHRpcEZvcm1hdCIsImRhdGV0aW1lIiwiZm10IiwiX3RpY2tGb3JtYXRGdW5jdGlvbiIsImZvcm1hdHRlciIsIm1pbm9yRm9ybWF0IiwibWFqb3JGb3JtYXQiLCJvZmZzZXRzIiwiX2dldExhYmVsU2l6ZSIsInRpY2tzT3B0cyIsInRpY2tMYWJlbFdpZHRoIiwiY29zUm90YXRpb24iLCJzaW5Sb3RhdGlvbiIsInRpY2tGb250U2l6ZSIsImV4YW1wbGVUaW1lIiwiZXhhbXBsZUxhYmVsIiwibm9ybWFsaXplIiwidGFibGUiLCJwcmV2U291cmNlIiwibmV4dFNvdXJjZSIsInByZXZUYXJnZXQiLCJuZXh0VGFyZ2V0Iiwic3BhbiIsIlRpbWVTZXJpZXNTY2FsZSIsIl90YWJsZSIsIl9taW5Qb3MiLCJfdGFibGVSYW5nZSIsIl9nZXRUaW1lc3RhbXBzRm9yVGFibGUiLCJidWlsZExvb2t1cFRhYmxlIiwicmVnaXN0ZXJhYmxlcyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chart.js/dist/chart.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/chart.js/dist/chunks/helpers.dataset.js":
/*!**************************************************************!*\
  !*** ./node_modules/chart.js/dist/chunks/helpers.dataset.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $: () => (/* binding */ unclipArea),\n/* harmony export */   A: () => (/* binding */ _rlookupByKey),\n/* harmony export */   B: () => (/* binding */ _lookupByKey),\n/* harmony export */   C: () => (/* binding */ _isPointInArea),\n/* harmony export */   D: () => (/* binding */ getAngleFromPoint),\n/* harmony export */   E: () => (/* binding */ toPadding),\n/* harmony export */   F: () => (/* binding */ each),\n/* harmony export */   G: () => (/* binding */ getMaximumSize),\n/* harmony export */   H: () => (/* binding */ HALF_PI),\n/* harmony export */   I: () => (/* binding */ _getParentNode),\n/* harmony export */   J: () => (/* binding */ readUsedSize),\n/* harmony export */   K: () => (/* binding */ supportsEventListenerOptions),\n/* harmony export */   L: () => (/* binding */ throttled),\n/* harmony export */   M: () => (/* binding */ _isDomSupported),\n/* harmony export */   N: () => (/* binding */ _factorize),\n/* harmony export */   O: () => (/* binding */ finiteOrDefault),\n/* harmony export */   P: () => (/* binding */ PI),\n/* harmony export */   Q: () => (/* binding */ callback),\n/* harmony export */   R: () => (/* binding */ _addGrace),\n/* harmony export */   S: () => (/* binding */ _limitValue),\n/* harmony export */   T: () => (/* binding */ TAU),\n/* harmony export */   U: () => (/* binding */ toDegrees),\n/* harmony export */   V: () => (/* binding */ _measureText),\n/* harmony export */   W: () => (/* binding */ _int16Range),\n/* harmony export */   X: () => (/* binding */ _alignPixel),\n/* harmony export */   Y: () => (/* binding */ clipArea),\n/* harmony export */   Z: () => (/* binding */ renderText),\n/* harmony export */   _: () => (/* binding */ _arrayUnique),\n/* harmony export */   a: () => (/* binding */ resolve),\n/* harmony export */   a$: () => (/* binding */ getStyle),\n/* harmony export */   a0: () => (/* binding */ toFont),\n/* harmony export */   a1: () => (/* binding */ _toLeftRightCenter),\n/* harmony export */   a2: () => (/* binding */ _alignStartEnd),\n/* harmony export */   a3: () => (/* binding */ overrides),\n/* harmony export */   a4: () => (/* binding */ merge),\n/* harmony export */   a5: () => (/* binding */ _capitalize),\n/* harmony export */   a6: () => (/* binding */ descriptors),\n/* harmony export */   a7: () => (/* binding */ isFunction),\n/* harmony export */   a8: () => (/* binding */ _attachContext),\n/* harmony export */   a9: () => (/* binding */ _createResolver),\n/* harmony export */   aA: () => (/* binding */ getRtlAdapter),\n/* harmony export */   aB: () => (/* binding */ overrideTextDirection),\n/* harmony export */   aC: () => (/* binding */ _textX),\n/* harmony export */   aD: () => (/* binding */ restoreTextDirection),\n/* harmony export */   aE: () => (/* binding */ drawPointLegend),\n/* harmony export */   aF: () => (/* binding */ distanceBetweenPoints),\n/* harmony export */   aG: () => (/* binding */ noop),\n/* harmony export */   aH: () => (/* binding */ _setMinAndMaxByKey),\n/* harmony export */   aI: () => (/* binding */ niceNum),\n/* harmony export */   aJ: () => (/* binding */ almostWhole),\n/* harmony export */   aK: () => (/* binding */ almostEquals),\n/* harmony export */   aL: () => (/* binding */ _decimalPlaces),\n/* harmony export */   aM: () => (/* binding */ Ticks),\n/* harmony export */   aN: () => (/* binding */ log10),\n/* harmony export */   aO: () => (/* binding */ _longestText),\n/* harmony export */   aP: () => (/* binding */ _filterBetween),\n/* harmony export */   aQ: () => (/* binding */ _lookup),\n/* harmony export */   aR: () => (/* binding */ isPatternOrGradient),\n/* harmony export */   aS: () => (/* binding */ getHoverColor),\n/* harmony export */   aT: () => (/* binding */ clone),\n/* harmony export */   aU: () => (/* binding */ _merger),\n/* harmony export */   aV: () => (/* binding */ _mergerIf),\n/* harmony export */   aW: () => (/* binding */ _deprecated),\n/* harmony export */   aX: () => (/* binding */ _splitKey),\n/* harmony export */   aY: () => (/* binding */ toFontString),\n/* harmony export */   aZ: () => (/* binding */ splineCurve),\n/* harmony export */   a_: () => (/* binding */ splineCurveMonotone),\n/* harmony export */   aa: () => (/* binding */ _descriptors),\n/* harmony export */   ab: () => (/* binding */ mergeIf),\n/* harmony export */   ac: () => (/* binding */ uid),\n/* harmony export */   ad: () => (/* binding */ debounce),\n/* harmony export */   ae: () => (/* binding */ retinaScale),\n/* harmony export */   af: () => (/* binding */ clearCanvas),\n/* harmony export */   ag: () => (/* binding */ setsEqual),\n/* harmony export */   ah: () => (/* binding */ getDatasetClipArea),\n/* harmony export */   ai: () => (/* binding */ _elementsEqual),\n/* harmony export */   aj: () => (/* binding */ _isClickEvent),\n/* harmony export */   ak: () => (/* binding */ _isBetween),\n/* harmony export */   al: () => (/* binding */ _normalizeAngle),\n/* harmony export */   am: () => (/* binding */ _readValueToProps),\n/* harmony export */   an: () => (/* binding */ _updateBezierControlPoints),\n/* harmony export */   ao: () => (/* binding */ _computeSegments),\n/* harmony export */   ap: () => (/* binding */ _boundSegments),\n/* harmony export */   aq: () => (/* binding */ _steppedInterpolation),\n/* harmony export */   ar: () => (/* binding */ _bezierInterpolation),\n/* harmony export */   as: () => (/* binding */ _pointInLine),\n/* harmony export */   at: () => (/* binding */ _steppedLineTo),\n/* harmony export */   au: () => (/* binding */ _bezierCurveTo),\n/* harmony export */   av: () => (/* binding */ drawPoint),\n/* harmony export */   aw: () => (/* binding */ addRoundedRectPath),\n/* harmony export */   ax: () => (/* binding */ toTRBL),\n/* harmony export */   ay: () => (/* binding */ toTRBLCorners),\n/* harmony export */   az: () => (/* binding */ _boundSegment),\n/* harmony export */   b: () => (/* binding */ isArray),\n/* harmony export */   b0: () => (/* binding */ fontString),\n/* harmony export */   b1: () => (/* binding */ toLineHeight),\n/* harmony export */   b2: () => (/* binding */ PITAU),\n/* harmony export */   b3: () => (/* binding */ INFINITY),\n/* harmony export */   b4: () => (/* binding */ RAD_PER_DEG),\n/* harmony export */   b5: () => (/* binding */ QUARTER_PI),\n/* harmony export */   b6: () => (/* binding */ TWO_THIRDS_PI),\n/* harmony export */   b7: () => (/* binding */ _angleDiff),\n/* harmony export */   c: () => (/* binding */ color),\n/* harmony export */   d: () => (/* binding */ defaults),\n/* harmony export */   e: () => (/* binding */ effects),\n/* harmony export */   f: () => (/* binding */ resolveObjectKey),\n/* harmony export */   g: () => (/* binding */ isNumberFinite),\n/* harmony export */   h: () => (/* binding */ defined),\n/* harmony export */   i: () => (/* binding */ isObject),\n/* harmony export */   j: () => (/* binding */ createContext),\n/* harmony export */   k: () => (/* binding */ isNullOrUndef),\n/* harmony export */   l: () => (/* binding */ listenArrayEvents),\n/* harmony export */   m: () => (/* binding */ toPercentage),\n/* harmony export */   n: () => (/* binding */ toDimension),\n/* harmony export */   o: () => (/* binding */ formatNumber),\n/* harmony export */   p: () => (/* binding */ _angleBetween),\n/* harmony export */   q: () => (/* binding */ _getStartAndCountOfVisiblePoints),\n/* harmony export */   r: () => (/* binding */ requestAnimFrame),\n/* harmony export */   s: () => (/* binding */ sign),\n/* harmony export */   t: () => (/* binding */ toRadians),\n/* harmony export */   u: () => (/* binding */ unlistenArrayEvents),\n/* harmony export */   v: () => (/* binding */ valueOrDefault),\n/* harmony export */   w: () => (/* binding */ _scaleRangesChanged),\n/* harmony export */   x: () => (/* binding */ isNumber),\n/* harmony export */   y: () => (/* binding */ _parseObjectDataRadialScale),\n/* harmony export */   z: () => (/* binding */ getRelativePosition)\n/* harmony export */ });\n/* harmony import */ var _kurkle_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @kurkle/color */ \"(ssr)/./node_modules/@kurkle/color/dist/color.esm.js\");\n/*!\n * Chart.js v4.5.1\n * https://www.chartjs.org\n * (c) 2025 Chart.js Contributors\n * Released under the MIT License\n */ \n/**\n * @namespace Chart.helpers\n */ /**\n * An empty function that can be used, for example, for optional callback.\n */ function noop() {\n/* noop */ }\n/**\n * Returns a unique id, sequentially generated from a global variable.\n */ const uid = (()=>{\n    let id = 0;\n    return ()=>id++;\n})();\n/**\n * Returns true if `value` is neither null nor undefined, else returns false.\n * @param value - The value to test.\n * @since 2.7.0\n */ function isNullOrUndef(value) {\n    return value === null || value === undefined;\n}\n/**\n * Returns true if `value` is an array (including typed arrays), else returns false.\n * @param value - The value to test.\n * @function\n */ function isArray(value) {\n    if (Array.isArray && Array.isArray(value)) {\n        return true;\n    }\n    const type = Object.prototype.toString.call(value);\n    if (type.slice(0, 7) === '[object' && type.slice(-6) === 'Array]') {\n        return true;\n    }\n    return false;\n}\n/**\n * Returns true if `value` is an object (excluding null), else returns false.\n * @param value - The value to test.\n * @since 2.7.0\n */ function isObject(value) {\n    return value !== null && Object.prototype.toString.call(value) === '[object Object]';\n}\n/**\n * Returns true if `value` is a finite number, else returns false\n * @param value  - The value to test.\n */ function isNumberFinite(value) {\n    return (typeof value === 'number' || value instanceof Number) && isFinite(+value);\n}\n/**\n * Returns `value` if finite, else returns `defaultValue`.\n * @param value - The value to return if defined.\n * @param defaultValue - The value to return if `value` is not finite.\n */ function finiteOrDefault(value, defaultValue) {\n    return isNumberFinite(value) ? value : defaultValue;\n}\n/**\n * Returns `value` if defined, else returns `defaultValue`.\n * @param value - The value to return if defined.\n * @param defaultValue - The value to return if `value` is undefined.\n */ function valueOrDefault(value, defaultValue) {\n    return typeof value === 'undefined' ? defaultValue : value;\n}\nconst toPercentage = (value, dimension)=>typeof value === 'string' && value.endsWith('%') ? parseFloat(value) / 100 : +value / dimension;\nconst toDimension = (value, dimension)=>typeof value === 'string' && value.endsWith('%') ? parseFloat(value) / 100 * dimension : +value;\n/**\n * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the\n * value returned by `fn`. If `fn` is not a function, this method returns undefined.\n * @param fn - The function to call.\n * @param args - The arguments with which `fn` should be called.\n * @param [thisArg] - The value of `this` provided for the call to `fn`.\n */ function callback(fn, args, thisArg) {\n    if (fn && typeof fn.call === 'function') {\n        return fn.apply(thisArg, args);\n    }\n}\nfunction each(loopable, fn, thisArg, reverse) {\n    let i, len, keys;\n    if (isArray(loopable)) {\n        len = loopable.length;\n        if (reverse) {\n            for(i = len - 1; i >= 0; i--){\n                fn.call(thisArg, loopable[i], i);\n            }\n        } else {\n            for(i = 0; i < len; i++){\n                fn.call(thisArg, loopable[i], i);\n            }\n        }\n    } else if (isObject(loopable)) {\n        keys = Object.keys(loopable);\n        len = keys.length;\n        for(i = 0; i < len; i++){\n            fn.call(thisArg, loopable[keys[i]], keys[i]);\n        }\n    }\n}\n/**\n * Returns true if the `a0` and `a1` arrays have the same content, else returns false.\n * @param a0 - The array to compare\n * @param a1 - The array to compare\n * @private\n */ function _elementsEqual(a0, a1) {\n    let i, ilen, v0, v1;\n    if (!a0 || !a1 || a0.length !== a1.length) {\n        return false;\n    }\n    for(i = 0, ilen = a0.length; i < ilen; ++i){\n        v0 = a0[i];\n        v1 = a1[i];\n        if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Returns a deep copy of `source` without keeping references on objects and arrays.\n * @param source - The value to clone.\n */ function clone(source) {\n    if (isArray(source)) {\n        return source.map(clone);\n    }\n    if (isObject(source)) {\n        const target = Object.create(null);\n        const keys = Object.keys(source);\n        const klen = keys.length;\n        let k = 0;\n        for(; k < klen; ++k){\n            target[keys[k]] = clone(source[keys[k]]);\n        }\n        return target;\n    }\n    return source;\n}\nfunction isValidKey(key) {\n    return [\n        '__proto__',\n        'prototype',\n        'constructor'\n    ].indexOf(key) === -1;\n}\n/**\n * The default merger when Chart.helpers.merge is called without merger option.\n * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.\n * @private\n */ function _merger(key, target, source, options) {\n    if (!isValidKey(key)) {\n        return;\n    }\n    const tval = target[key];\n    const sval = source[key];\n    if (isObject(tval) && isObject(sval)) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        merge(tval, sval, options);\n    } else {\n        target[key] = clone(sval);\n    }\n}\nfunction merge(target, source, options) {\n    const sources = isArray(source) ? source : [\n        source\n    ];\n    const ilen = sources.length;\n    if (!isObject(target)) {\n        return target;\n    }\n    options = options || {};\n    const merger = options.merger || _merger;\n    let current;\n    for(let i = 0; i < ilen; ++i){\n        current = sources[i];\n        if (!isObject(current)) {\n            continue;\n        }\n        const keys = Object.keys(current);\n        for(let k = 0, klen = keys.length; k < klen; ++k){\n            merger(keys[k], target, current, options);\n        }\n    }\n    return target;\n}\nfunction mergeIf(target, source) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return merge(target, source, {\n        merger: _mergerIf\n    });\n}\n/**\n * Merges source[key] in target[key] only if target[key] is undefined.\n * @private\n */ function _mergerIf(key, target, source) {\n    if (!isValidKey(key)) {\n        return;\n    }\n    const tval = target[key];\n    const sval = source[key];\n    if (isObject(tval) && isObject(sval)) {\n        mergeIf(tval, sval);\n    } else if (!Object.prototype.hasOwnProperty.call(target, key)) {\n        target[key] = clone(sval);\n    }\n}\n/**\n * @private\n */ function _deprecated(scope, value, previous, current) {\n    if (value !== undefined) {\n        console.warn(scope + ': \"' + previous + '\" is deprecated. Please use \"' + current + '\" instead');\n    }\n}\n// resolveObjectKey resolver cache\nconst keyResolvers = {\n    // Chart.helpers.core resolveObjectKey should resolve empty key to root object\n    '': (v)=>v,\n    // default resolvers\n    x: (o)=>o.x,\n    y: (o)=>o.y\n};\n/**\n * @private\n */ function _splitKey(key) {\n    const parts = key.split('.');\n    const keys = [];\n    let tmp = '';\n    for (const part of parts){\n        tmp += part;\n        if (tmp.endsWith('\\\\')) {\n            tmp = tmp.slice(0, -1) + '.';\n        } else {\n            keys.push(tmp);\n            tmp = '';\n        }\n    }\n    return keys;\n}\nfunction _getKeyResolver(key) {\n    const keys = _splitKey(key);\n    return (obj)=>{\n        for (const k of keys){\n            if (k === '') {\n                break;\n            }\n            obj = obj && obj[k];\n        }\n        return obj;\n    };\n}\nfunction resolveObjectKey(obj, key) {\n    const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));\n    return resolver(obj);\n}\n/**\n * @private\n */ function _capitalize(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n}\nconst defined = (value)=>typeof value !== 'undefined';\nconst isFunction = (value)=>typeof value === 'function';\n// Adapted from https://stackoverflow.com/questions/31128855/comparing-ecma6-sets-for-equality#31129384\nconst setsEqual = (a, b)=>{\n    if (a.size !== b.size) {\n        return false;\n    }\n    for (const item of a){\n        if (!b.has(item)) {\n            return false;\n        }\n    }\n    return true;\n};\n/**\n * @param e - The event\n * @private\n */ function _isClickEvent(e) {\n    return e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu';\n}\n/**\n * @alias Chart.helpers.math\n * @namespace\n */ const PI = Math.PI;\nconst TAU = 2 * PI;\nconst PITAU = TAU + PI;\nconst INFINITY = Number.POSITIVE_INFINITY;\nconst RAD_PER_DEG = PI / 180;\nconst HALF_PI = PI / 2;\nconst QUARTER_PI = PI / 4;\nconst TWO_THIRDS_PI = PI * 2 / 3;\nconst log10 = Math.log10;\nconst sign = Math.sign;\nfunction almostEquals(x, y, epsilon) {\n    return Math.abs(x - y) < epsilon;\n}\n/**\n * Implementation of the nice number algorithm used in determining where axis labels will go\n */ function niceNum(range) {\n    const roundedRange = Math.round(range);\n    range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;\n    const niceRange = Math.pow(10, Math.floor(log10(range)));\n    const fraction = range / niceRange;\n    const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;\n    return niceFraction * niceRange;\n}\n/**\n * Returns an array of factors sorted from 1 to sqrt(value)\n * @private\n */ function _factorize(value) {\n    const result = [];\n    const sqrt = Math.sqrt(value);\n    let i;\n    for(i = 1; i < sqrt; i++){\n        if (value % i === 0) {\n            result.push(i);\n            result.push(value / i);\n        }\n    }\n    if (sqrt === (sqrt | 0)) {\n        result.push(sqrt);\n    }\n    result.sort((a, b)=>a - b).pop();\n    return result;\n}\n/**\n * Verifies that attempting to coerce n to string or number won't throw a TypeError.\n */ function isNonPrimitive(n) {\n    return typeof n === 'symbol' || typeof n === 'object' && n !== null && !(Symbol.toPrimitive in n || 'toString' in n || 'valueOf' in n);\n}\nfunction isNumber(n) {\n    return !isNonPrimitive(n) && !isNaN(parseFloat(n)) && isFinite(n);\n}\nfunction almostWhole(x, epsilon) {\n    const rounded = Math.round(x);\n    return rounded - epsilon <= x && rounded + epsilon >= x;\n}\n/**\n * @private\n */ function _setMinAndMaxByKey(array, target, property) {\n    let i, ilen, value;\n    for(i = 0, ilen = array.length; i < ilen; i++){\n        value = array[i][property];\n        if (!isNaN(value)) {\n            target.min = Math.min(target.min, value);\n            target.max = Math.max(target.max, value);\n        }\n    }\n}\nfunction toRadians(degrees) {\n    return degrees * (PI / 180);\n}\nfunction toDegrees(radians) {\n    return radians * (180 / PI);\n}\n/**\n * Returns the number of decimal places\n * i.e. the number of digits after the decimal point, of the value of this Number.\n * @param x - A number.\n * @returns The number of decimal places.\n * @private\n */ function _decimalPlaces(x) {\n    if (!isNumberFinite(x)) {\n        return;\n    }\n    let e = 1;\n    let p = 0;\n    while(Math.round(x * e) / e !== x){\n        e *= 10;\n        p++;\n    }\n    return p;\n}\n// Gets the angle from vertical upright to the point about a centre.\nfunction getAngleFromPoint(centrePoint, anglePoint) {\n    const distanceFromXCenter = anglePoint.x - centrePoint.x;\n    const distanceFromYCenter = anglePoint.y - centrePoint.y;\n    const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n    let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n    if (angle < -0.5 * PI) {\n        angle += TAU; // make sure the returned angle is in the range of (-PI/2, 3PI/2]\n    }\n    return {\n        angle,\n        distance: radialDistanceFromCenter\n    };\n}\nfunction distanceBetweenPoints(pt1, pt2) {\n    return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n}\n/**\n * Shortest distance between angles, in either direction.\n * @private\n */ function _angleDiff(a, b) {\n    return (a - b + PITAU) % TAU - PI;\n}\n/**\n * Normalize angle to be between 0 and 2*PI\n * @private\n */ function _normalizeAngle(a) {\n    return (a % TAU + TAU) % TAU;\n}\n/**\n * @private\n */ function _angleBetween(angle, start, end, sameAngleIsFullCircle) {\n    const a = _normalizeAngle(angle);\n    const s = _normalizeAngle(start);\n    const e = _normalizeAngle(end);\n    const angleToStart = _normalizeAngle(s - a);\n    const angleToEnd = _normalizeAngle(e - a);\n    const startToAngle = _normalizeAngle(a - s);\n    const endToAngle = _normalizeAngle(a - e);\n    return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;\n}\n/**\n * Limit `value` between `min` and `max`\n * @param value\n * @param min\n * @param max\n * @private\n */ function _limitValue(value, min, max) {\n    return Math.max(min, Math.min(max, value));\n}\n/**\n * @param {number} value\n * @private\n */ function _int16Range(value) {\n    return _limitValue(value, -32768, 32767);\n}\n/**\n * @param value\n * @param start\n * @param end\n * @param [epsilon]\n * @private\n */ function _isBetween(value, start, end, epsilon = 1e-6) {\n    return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;\n}\nfunction _lookup(table, value, cmp) {\n    cmp = cmp || ((index)=>table[index] < value);\n    let hi = table.length - 1;\n    let lo = 0;\n    let mid;\n    while(hi - lo > 1){\n        mid = lo + hi >> 1;\n        if (cmp(mid)) {\n            lo = mid;\n        } else {\n            hi = mid;\n        }\n    }\n    return {\n        lo,\n        hi\n    };\n}\n/**\n * Binary search\n * @param table - the table search. must be sorted!\n * @param key - property name for the value in each entry\n * @param value - value to find\n * @param last - lookup last index\n * @private\n */ const _lookupByKey = (table, key, value, last)=>_lookup(table, value, last ? (index)=>{\n        const ti = table[index][key];\n        return ti < value || ti === value && table[index + 1][key] === value;\n    } : (index)=>table[index][key] < value);\n/**\n * Reverse binary search\n * @param table - the table search. must be sorted!\n * @param key - property name for the value in each entry\n * @param value - value to find\n * @private\n */ const _rlookupByKey = (table, key, value)=>_lookup(table, value, (index)=>table[index][key] >= value);\n/**\n * Return subset of `values` between `min` and `max` inclusive.\n * Values are assumed to be in sorted order.\n * @param values - sorted array of values\n * @param min - min value\n * @param max - max value\n */ function _filterBetween(values, min, max) {\n    let start = 0;\n    let end = values.length;\n    while(start < end && values[start] < min){\n        start++;\n    }\n    while(end > start && values[end - 1] > max){\n        end--;\n    }\n    return start > 0 || end < values.length ? values.slice(start, end) : values;\n}\nconst arrayEvents = [\n    'push',\n    'pop',\n    'shift',\n    'splice',\n    'unshift'\n];\nfunction listenArrayEvents(array, listener) {\n    if (array._chartjs) {\n        array._chartjs.listeners.push(listener);\n        return;\n    }\n    Object.defineProperty(array, '_chartjs', {\n        configurable: true,\n        enumerable: false,\n        value: {\n            listeners: [\n                listener\n            ]\n        }\n    });\n    arrayEvents.forEach((key)=>{\n        const method = '_onData' + _capitalize(key);\n        const base = array[key];\n        Object.defineProperty(array, key, {\n            configurable: true,\n            enumerable: false,\n            value (...args) {\n                const res = base.apply(this, args);\n                array._chartjs.listeners.forEach((object)=>{\n                    if (typeof object[method] === 'function') {\n                        object[method](...args);\n                    }\n                });\n                return res;\n            }\n        });\n    });\n}\nfunction unlistenArrayEvents(array, listener) {\n    const stub = array._chartjs;\n    if (!stub) {\n        return;\n    }\n    const listeners = stub.listeners;\n    const index = listeners.indexOf(listener);\n    if (index !== -1) {\n        listeners.splice(index, 1);\n    }\n    if (listeners.length > 0) {\n        return;\n    }\n    arrayEvents.forEach((key)=>{\n        delete array[key];\n    });\n    delete array._chartjs;\n}\n/**\n * @param items\n */ function _arrayUnique(items) {\n    const set = new Set(items);\n    if (set.size === items.length) {\n        return items;\n    }\n    return Array.from(set);\n}\nfunction fontString(pixelSize, fontStyle, fontFamily) {\n    return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\n}\n/**\n* Request animation polyfill\n*/ const requestAnimFrame = function() {\n    if (true) {\n        return function(callback) {\n            return callback();\n        };\n    }\n    return window.requestAnimationFrame;\n}();\n/**\n * Throttles calling `fn` once per animation frame\n * Latest arguments are used on the actual call\n */ function throttled(fn, thisArg) {\n    let argsToUse = [];\n    let ticking = false;\n    return function(...args) {\n        // Save the args for use later\n        argsToUse = args;\n        if (!ticking) {\n            ticking = true;\n            requestAnimFrame.call(window, ()=>{\n                ticking = false;\n                fn.apply(thisArg, argsToUse);\n            });\n        }\n    };\n}\n/**\n * Debounces calling `fn` for `delay` ms\n */ function debounce(fn, delay) {\n    let timeout;\n    return function(...args) {\n        if (delay) {\n            clearTimeout(timeout);\n            timeout = setTimeout(fn, delay, args);\n        } else {\n            fn.apply(this, args);\n        }\n        return delay;\n    };\n}\n/**\n * Converts 'start' to 'left', 'end' to 'right' and others to 'center'\n * @private\n */ const _toLeftRightCenter = (align)=>align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';\n/**\n * Returns `start`, `end` or `(start + end) / 2` depending on `align`. Defaults to `center`\n * @private\n */ const _alignStartEnd = (align, start, end)=>align === 'start' ? start : align === 'end' ? end : (start + end) / 2;\n/**\n * Returns `left`, `right` or `(left + right) / 2` depending on `align`. Defaults to `left`\n * @private\n */ const _textX = (align, left, right, rtl)=>{\n    const check = rtl ? 'left' : 'right';\n    return align === check ? right : align === 'center' ? (left + right) / 2 : left;\n};\n/**\n * Return start and count of visible points.\n * @private\n */ function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {\n    const pointCount = points.length;\n    let start = 0;\n    let count = pointCount;\n    if (meta._sorted) {\n        const { iScale, vScale, _parsed } = meta;\n        const spanGaps = meta.dataset ? meta.dataset.options ? meta.dataset.options.spanGaps : null : null;\n        const axis = iScale.axis;\n        const { min, max, minDefined, maxDefined } = iScale.getUserBounds();\n        if (minDefined) {\n            start = Math.min(_lookupByKey(_parsed, axis, min).lo, animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo);\n            if (spanGaps) {\n                const distanceToDefinedLo = _parsed.slice(0, start + 1).reverse().findIndex((point)=>!isNullOrUndef(point[vScale.axis]));\n                start -= Math.max(0, distanceToDefinedLo);\n            }\n            start = _limitValue(start, 0, pointCount - 1);\n        }\n        if (maxDefined) {\n            let end = Math.max(_lookupByKey(_parsed, iScale.axis, max, true).hi + 1, animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1);\n            if (spanGaps) {\n                const distanceToDefinedHi = _parsed.slice(end - 1).findIndex((point)=>!isNullOrUndef(point[vScale.axis]));\n                end += Math.max(0, distanceToDefinedHi);\n            }\n            count = _limitValue(end, start, pointCount) - start;\n        } else {\n            count = pointCount - start;\n        }\n    }\n    return {\n        start,\n        count\n    };\n}\n/**\n * Checks if the scale ranges have changed.\n * @param {object} meta - dataset meta.\n * @returns {boolean}\n * @private\n */ function _scaleRangesChanged(meta) {\n    const { xScale, yScale, _scaleRanges } = meta;\n    const newRanges = {\n        xmin: xScale.min,\n        xmax: xScale.max,\n        ymin: yScale.min,\n        ymax: yScale.max\n    };\n    if (!_scaleRanges) {\n        meta._scaleRanges = newRanges;\n        return true;\n    }\n    const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;\n    Object.assign(_scaleRanges, newRanges);\n    return changed;\n}\nconst atEdge = (t)=>t === 0 || t === 1;\nconst elasticIn = (t, s, p)=>-(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));\nconst elasticOut = (t, s, p)=>Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;\n/**\n * Easing functions adapted from Robert Penner's easing equations.\n * @namespace Chart.helpers.easing.effects\n * @see http://www.robertpenner.com/easing/\n */ const effects = {\n    linear: (t)=>t,\n    easeInQuad: (t)=>t * t,\n    easeOutQuad: (t)=>-t * (t - 2),\n    easeInOutQuad: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),\n    easeInCubic: (t)=>t * t * t,\n    easeOutCubic: (t)=>(t -= 1) * t * t + 1,\n    easeInOutCubic: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),\n    easeInQuart: (t)=>t * t * t * t,\n    easeOutQuart: (t)=>-((t -= 1) * t * t * t - 1),\n    easeInOutQuart: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),\n    easeInQuint: (t)=>t * t * t * t * t,\n    easeOutQuint: (t)=>(t -= 1) * t * t * t * t + 1,\n    easeInOutQuint: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),\n    easeInSine: (t)=>-Math.cos(t * HALF_PI) + 1,\n    easeOutSine: (t)=>Math.sin(t * HALF_PI),\n    easeInOutSine: (t)=>-0.5 * (Math.cos(PI * t) - 1),\n    easeInExpo: (t)=>t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),\n    easeOutExpo: (t)=>t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,\n    easeInOutExpo: (t)=>atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),\n    easeInCirc: (t)=>t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),\n    easeOutCirc: (t)=>Math.sqrt(1 - (t -= 1) * t),\n    easeInOutCirc: (t)=>(t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),\n    easeInElastic: (t)=>atEdge(t) ? t : elasticIn(t, 0.075, 0.3),\n    easeOutElastic: (t)=>atEdge(t) ? t : elasticOut(t, 0.075, 0.3),\n    easeInOutElastic (t) {\n        const s = 0.1125;\n        const p = 0.45;\n        return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);\n    },\n    easeInBack (t) {\n        const s = 1.70158;\n        return t * t * ((s + 1) * t - s);\n    },\n    easeOutBack (t) {\n        const s = 1.70158;\n        return (t -= 1) * t * ((s + 1) * t + s) + 1;\n    },\n    easeInOutBack (t) {\n        let s = 1.70158;\n        if ((t /= 0.5) < 1) {\n            return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));\n        }\n        return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);\n    },\n    easeInBounce: (t)=>1 - effects.easeOutBounce(1 - t),\n    easeOutBounce (t) {\n        const m = 7.5625;\n        const d = 2.75;\n        if (t < 1 / d) {\n            return m * t * t;\n        }\n        if (t < 2 / d) {\n            return m * (t -= 1.5 / d) * t + 0.75;\n        }\n        if (t < 2.5 / d) {\n            return m * (t -= 2.25 / d) * t + 0.9375;\n        }\n        return m * (t -= 2.625 / d) * t + 0.984375;\n    },\n    easeInOutBounce: (t)=>t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5\n};\nfunction isPatternOrGradient(value) {\n    if (value && typeof value === 'object') {\n        const type = value.toString();\n        return type === '[object CanvasPattern]' || type === '[object CanvasGradient]';\n    }\n    return false;\n}\nfunction color(value) {\n    return isPatternOrGradient(value) ? value : new _kurkle_color__WEBPACK_IMPORTED_MODULE_0__.Color(value);\n}\nfunction getHoverColor(value) {\n    return isPatternOrGradient(value) ? value : new _kurkle_color__WEBPACK_IMPORTED_MODULE_0__.Color(value).saturate(0.5).darken(0.1).hexString();\n}\nconst numbers = [\n    'x',\n    'y',\n    'borderWidth',\n    'radius',\n    'tension'\n];\nconst colors = [\n    'color',\n    'borderColor',\n    'backgroundColor'\n];\nfunction applyAnimationsDefaults(defaults) {\n    defaults.set('animation', {\n        delay: undefined,\n        duration: 1000,\n        easing: 'easeOutQuart',\n        fn: undefined,\n        from: undefined,\n        loop: undefined,\n        to: undefined,\n        type: undefined\n    });\n    defaults.describe('animation', {\n        _fallback: false,\n        _indexable: false,\n        _scriptable: (name)=>name !== 'onProgress' && name !== 'onComplete' && name !== 'fn'\n    });\n    defaults.set('animations', {\n        colors: {\n            type: 'color',\n            properties: colors\n        },\n        numbers: {\n            type: 'number',\n            properties: numbers\n        }\n    });\n    defaults.describe('animations', {\n        _fallback: 'animation'\n    });\n    defaults.set('transitions', {\n        active: {\n            animation: {\n                duration: 400\n            }\n        },\n        resize: {\n            animation: {\n                duration: 0\n            }\n        },\n        show: {\n            animations: {\n                colors: {\n                    from: 'transparent'\n                },\n                visible: {\n                    type: 'boolean',\n                    duration: 0\n                }\n            }\n        },\n        hide: {\n            animations: {\n                colors: {\n                    to: 'transparent'\n                },\n                visible: {\n                    type: 'boolean',\n                    easing: 'linear',\n                    fn: (v)=>v | 0\n                }\n            }\n        }\n    });\n}\nfunction applyLayoutsDefaults(defaults) {\n    defaults.set('layout', {\n        autoPadding: true,\n        padding: {\n            top: 0,\n            right: 0,\n            bottom: 0,\n            left: 0\n        }\n    });\n}\nconst intlCache = new Map();\nfunction getNumberFormat(locale, options) {\n    options = options || {};\n    const cacheKey = locale + JSON.stringify(options);\n    let formatter = intlCache.get(cacheKey);\n    if (!formatter) {\n        formatter = new Intl.NumberFormat(locale, options);\n        intlCache.set(cacheKey, formatter);\n    }\n    return formatter;\n}\nfunction formatNumber(num, locale, options) {\n    return getNumberFormat(locale, options).format(num);\n}\nconst formatters = {\n    values (value) {\n        return isArray(value) ? value : '' + value;\n    },\n    numeric (tickValue, index, ticks) {\n        if (tickValue === 0) {\n            return '0';\n        }\n        const locale = this.chart.options.locale;\n        let notation;\n        let delta = tickValue;\n        if (ticks.length > 1) {\n            const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));\n            if (maxTick < 1e-4 || maxTick > 1e+15) {\n                notation = 'scientific';\n            }\n            delta = calculateDelta(tickValue, ticks);\n        }\n        const logDelta = log10(Math.abs(delta));\n        const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);\n        const options = {\n            notation,\n            minimumFractionDigits: numDecimal,\n            maximumFractionDigits: numDecimal\n        };\n        Object.assign(options, this.options.ticks.format);\n        return formatNumber(tickValue, locale, options);\n    },\n    logarithmic (tickValue, index, ticks) {\n        if (tickValue === 0) {\n            return '0';\n        }\n        const remain = ticks[index].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));\n        if ([\n            1,\n            2,\n            3,\n            5,\n            10,\n            15\n        ].includes(remain) || index > 0.8 * ticks.length) {\n            return formatters.numeric.call(this, tickValue, index, ticks);\n        }\n        return '';\n    }\n};\nfunction calculateDelta(tickValue, ticks) {\n    let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;\n    if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {\n        delta = tickValue - Math.floor(tickValue);\n    }\n    return delta;\n}\nvar Ticks = {\n    formatters\n};\nfunction applyScaleDefaults(defaults) {\n    defaults.set('scale', {\n        display: true,\n        offset: false,\n        reverse: false,\n        beginAtZero: false,\n        bounds: 'ticks',\n        clip: true,\n        grace: 0,\n        grid: {\n            display: true,\n            lineWidth: 1,\n            drawOnChartArea: true,\n            drawTicks: true,\n            tickLength: 8,\n            tickWidth: (_ctx, options)=>options.lineWidth,\n            tickColor: (_ctx, options)=>options.color,\n            offset: false\n        },\n        border: {\n            display: true,\n            dash: [],\n            dashOffset: 0.0,\n            width: 1\n        },\n        title: {\n            display: false,\n            text: '',\n            padding: {\n                top: 4,\n                bottom: 4\n            }\n        },\n        ticks: {\n            minRotation: 0,\n            maxRotation: 50,\n            mirror: false,\n            textStrokeWidth: 0,\n            textStrokeColor: '',\n            padding: 3,\n            display: true,\n            autoSkip: true,\n            autoSkipPadding: 3,\n            labelOffset: 0,\n            callback: Ticks.formatters.values,\n            minor: {},\n            major: {},\n            align: 'center',\n            crossAlign: 'near',\n            showLabelBackdrop: false,\n            backdropColor: 'rgba(255, 255, 255, 0.75)',\n            backdropPadding: 2\n        }\n    });\n    defaults.route('scale.ticks', 'color', '', 'color');\n    defaults.route('scale.grid', 'color', '', 'borderColor');\n    defaults.route('scale.border', 'color', '', 'borderColor');\n    defaults.route('scale.title', 'color', '', 'color');\n    defaults.describe('scale', {\n        _fallback: false,\n        _scriptable: (name)=>!name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser',\n        _indexable: (name)=>name !== 'borderDash' && name !== 'tickBorderDash' && name !== 'dash'\n    });\n    defaults.describe('scales', {\n        _fallback: 'scale'\n    });\n    defaults.describe('scale.ticks', {\n        _scriptable: (name)=>name !== 'backdropPadding' && name !== 'callback',\n        _indexable: (name)=>name !== 'backdropPadding'\n    });\n}\nconst overrides = Object.create(null);\nconst descriptors = Object.create(null);\nfunction getScope$1(node, key) {\n    if (!key) {\n        return node;\n    }\n    const keys = key.split('.');\n    for(let i = 0, n = keys.length; i < n; ++i){\n        const k = keys[i];\n        node = node[k] || (node[k] = Object.create(null));\n    }\n    return node;\n}\nfunction set(root, scope, values) {\n    if (typeof scope === 'string') {\n        return merge(getScope$1(root, scope), values);\n    }\n    return merge(getScope$1(root, ''), scope);\n}\nclass Defaults {\n    constructor(_descriptors, _appliers){\n        this.animation = undefined;\n        this.backgroundColor = 'rgba(0,0,0,0.1)';\n        this.borderColor = 'rgba(0,0,0,0.1)';\n        this.color = '#666';\n        this.datasets = {};\n        this.devicePixelRatio = (context)=>context.chart.platform.getDevicePixelRatio();\n        this.elements = {};\n        this.events = [\n            'mousemove',\n            'mouseout',\n            'click',\n            'touchstart',\n            'touchmove'\n        ];\n        this.font = {\n            family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n            size: 12,\n            style: 'normal',\n            lineHeight: 1.2,\n            weight: null\n        };\n        this.hover = {};\n        this.hoverBackgroundColor = (ctx, options)=>getHoverColor(options.backgroundColor);\n        this.hoverBorderColor = (ctx, options)=>getHoverColor(options.borderColor);\n        this.hoverColor = (ctx, options)=>getHoverColor(options.color);\n        this.indexAxis = 'x';\n        this.interaction = {\n            mode: 'nearest',\n            intersect: true,\n            includeInvisible: false\n        };\n        this.maintainAspectRatio = true;\n        this.onHover = null;\n        this.onClick = null;\n        this.parsing = true;\n        this.plugins = {};\n        this.responsive = true;\n        this.scale = undefined;\n        this.scales = {};\n        this.showLine = true;\n        this.drawActiveElementsOnTop = true;\n        this.describe(_descriptors);\n        this.apply(_appliers);\n    }\n    set(scope, values) {\n        return set(this, scope, values);\n    }\n    get(scope) {\n        return getScope$1(this, scope);\n    }\n    describe(scope, values) {\n        return set(descriptors, scope, values);\n    }\n    override(scope, values) {\n        return set(overrides, scope, values);\n    }\n    route(scope, name, targetScope, targetName) {\n        const scopeObject = getScope$1(this, scope);\n        const targetScopeObject = getScope$1(this, targetScope);\n        const privateName = '_' + name;\n        Object.defineProperties(scopeObject, {\n            [privateName]: {\n                value: scopeObject[name],\n                writable: true\n            },\n            [name]: {\n                enumerable: true,\n                get () {\n                    const local = this[privateName];\n                    const target = targetScopeObject[targetName];\n                    if (isObject(local)) {\n                        return Object.assign({}, target, local);\n                    }\n                    return valueOrDefault(local, target);\n                },\n                set (value) {\n                    this[privateName] = value;\n                }\n            }\n        });\n    }\n    apply(appliers) {\n        appliers.forEach((apply)=>apply(this));\n    }\n}\nvar defaults = /* #__PURE__ */ new Defaults({\n    _scriptable: (name)=>!name.startsWith('on'),\n    _indexable: (name)=>name !== 'events',\n    hover: {\n        _fallback: 'interaction'\n    },\n    interaction: {\n        _scriptable: false,\n        _indexable: false\n    }\n}, [\n    applyAnimationsDefaults,\n    applyLayoutsDefaults,\n    applyScaleDefaults\n]);\n/**\n * Converts the given font object into a CSS font string.\n * @param font - A font object.\n * @return The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font\n * @private\n */ function toFontString(font) {\n    if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {\n        return null;\n    }\n    return (font.style ? font.style + ' ' : '') + (font.weight ? font.weight + ' ' : '') + font.size + 'px ' + font.family;\n}\n/**\n * @private\n */ function _measureText(ctx, data, gc, longest, string) {\n    let textWidth = data[string];\n    if (!textWidth) {\n        textWidth = data[string] = ctx.measureText(string).width;\n        gc.push(string);\n    }\n    if (textWidth > longest) {\n        longest = textWidth;\n    }\n    return longest;\n}\n/**\n * @private\n */ // eslint-disable-next-line complexity\nfunction _longestText(ctx, font, arrayOfThings, cache) {\n    cache = cache || {};\n    let data = cache.data = cache.data || {};\n    let gc = cache.garbageCollect = cache.garbageCollect || [];\n    if (cache.font !== font) {\n        data = cache.data = {};\n        gc = cache.garbageCollect = [];\n        cache.font = font;\n    }\n    ctx.save();\n    ctx.font = font;\n    let longest = 0;\n    const ilen = arrayOfThings.length;\n    let i, j, jlen, thing, nestedThing;\n    for(i = 0; i < ilen; i++){\n        thing = arrayOfThings[i];\n        // Undefined strings and arrays should not be measured\n        if (thing !== undefined && thing !== null && !isArray(thing)) {\n            longest = _measureText(ctx, data, gc, longest, thing);\n        } else if (isArray(thing)) {\n            // if it is an array lets measure each element\n            // to do maybe simplify this function a bit so we can do this more recursively?\n            for(j = 0, jlen = thing.length; j < jlen; j++){\n                nestedThing = thing[j];\n                // Undefined strings and arrays should not be measured\n                if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {\n                    longest = _measureText(ctx, data, gc, longest, nestedThing);\n                }\n            }\n        }\n    }\n    ctx.restore();\n    const gcLen = gc.length / 2;\n    if (gcLen > arrayOfThings.length) {\n        for(i = 0; i < gcLen; i++){\n            delete data[gc[i]];\n        }\n        gc.splice(0, gcLen);\n    }\n    return longest;\n}\n/**\n * Returns the aligned pixel value to avoid anti-aliasing blur\n * @param chart - The chart instance.\n * @param pixel - A pixel value.\n * @param width - The width of the element.\n * @returns The aligned pixel value.\n * @private\n */ function _alignPixel(chart, pixel, width) {\n    const devicePixelRatio = chart.currentDevicePixelRatio;\n    const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;\n    return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;\n}\n/**\n * Clears the entire canvas.\n */ function clearCanvas(canvas, ctx) {\n    if (!ctx && !canvas) {\n        return;\n    }\n    ctx = ctx || canvas.getContext('2d');\n    ctx.save();\n    // canvas.width and canvas.height do not consider the canvas transform,\n    // while clearRect does\n    ctx.resetTransform();\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.restore();\n}\nfunction drawPoint(ctx, options, x, y) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    drawPointLegend(ctx, options, x, y, null);\n}\n// eslint-disable-next-line complexity\nfunction drawPointLegend(ctx, options, x, y, w) {\n    let type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;\n    const style = options.pointStyle;\n    const rotation = options.rotation;\n    const radius = options.radius;\n    let rad = (rotation || 0) * RAD_PER_DEG;\n    if (style && typeof style === 'object') {\n        type = style.toString();\n        if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\n            ctx.save();\n            ctx.translate(x, y);\n            ctx.rotate(rad);\n            ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\n            ctx.restore();\n            return;\n        }\n    }\n    if (isNaN(radius) || radius <= 0) {\n        return;\n    }\n    ctx.beginPath();\n    switch(style){\n        // Default includes circle\n        default:\n            if (w) {\n                ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);\n            } else {\n                ctx.arc(x, y, radius, 0, TAU);\n            }\n            ctx.closePath();\n            break;\n        case 'triangle':\n            width = w ? w / 2 : radius;\n            ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n            rad += TWO_THIRDS_PI;\n            ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n            rad += TWO_THIRDS_PI;\n            ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n            ctx.closePath();\n            break;\n        case 'rectRounded':\n            // NOTE: the rounded rect implementation changed to use `arc` instead of\n            // `quadraticCurveTo` since it generates better results when rect is\n            // almost a circle. 0.516 (instead of 0.5) produces results with visually\n            // closer proportion to the previous impl and it is inscribed in the\n            // circle with `radius`. For more details, see the following PRs:\n            // https://github.com/chartjs/Chart.js/issues/5597\n            // https://github.com/chartjs/Chart.js/issues/5858\n            cornerRadius = radius * 0.516;\n            size = radius - cornerRadius;\n            xOffset = Math.cos(rad + QUARTER_PI) * size;\n            xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\n            yOffset = Math.sin(rad + QUARTER_PI) * size;\n            yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\n            ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\n            ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);\n            ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);\n            ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\n            ctx.closePath();\n            break;\n        case 'rect':\n            if (!rotation) {\n                size = Math.SQRT1_2 * radius;\n                width = w ? w / 2 : size;\n                ctx.rect(x - width, y - size, 2 * width, 2 * size);\n                break;\n            }\n            rad += QUARTER_PI;\n        /* falls through */ case 'rectRot':\n            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n            ctx.moveTo(x - xOffsetW, y - yOffset);\n            ctx.lineTo(x + yOffsetW, y - xOffset);\n            ctx.lineTo(x + xOffsetW, y + yOffset);\n            ctx.lineTo(x - yOffsetW, y + xOffset);\n            ctx.closePath();\n            break;\n        case 'crossRot':\n            rad += QUARTER_PI;\n        /* falls through */ case 'cross':\n            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n            ctx.moveTo(x - xOffsetW, y - yOffset);\n            ctx.lineTo(x + xOffsetW, y + yOffset);\n            ctx.moveTo(x + yOffsetW, y - xOffset);\n            ctx.lineTo(x - yOffsetW, y + xOffset);\n            break;\n        case 'star':\n            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n            ctx.moveTo(x - xOffsetW, y - yOffset);\n            ctx.lineTo(x + xOffsetW, y + yOffset);\n            ctx.moveTo(x + yOffsetW, y - xOffset);\n            ctx.lineTo(x - yOffsetW, y + xOffset);\n            rad += QUARTER_PI;\n            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n            ctx.moveTo(x - xOffsetW, y - yOffset);\n            ctx.lineTo(x + xOffsetW, y + yOffset);\n            ctx.moveTo(x + yOffsetW, y - xOffset);\n            ctx.lineTo(x - yOffsetW, y + xOffset);\n            break;\n        case 'line':\n            xOffset = w ? w / 2 : Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            ctx.moveTo(x - xOffset, y - yOffset);\n            ctx.lineTo(x + xOffset, y + yOffset);\n            break;\n        case 'dash':\n            ctx.moveTo(x, y);\n            ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);\n            break;\n        case false:\n            ctx.closePath();\n            break;\n    }\n    ctx.fill();\n    if (options.borderWidth > 0) {\n        ctx.stroke();\n    }\n}\n/**\n * Returns true if the point is inside the rectangle\n * @param point - The point to test\n * @param area - The rectangle\n * @param margin - allowed margin\n * @private\n */ function _isPointInArea(point, area, margin) {\n    margin = margin || 0.5; // margin - default is to match rounded decimals\n    return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;\n}\nfunction clipArea(ctx, area) {\n    ctx.save();\n    ctx.beginPath();\n    ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n    ctx.clip();\n}\nfunction unclipArea(ctx) {\n    ctx.restore();\n}\n/**\n * @private\n */ function _steppedLineTo(ctx, previous, target, flip, mode) {\n    if (!previous) {\n        return ctx.lineTo(target.x, target.y);\n    }\n    if (mode === 'middle') {\n        const midpoint = (previous.x + target.x) / 2.0;\n        ctx.lineTo(midpoint, previous.y);\n        ctx.lineTo(midpoint, target.y);\n    } else if (mode === 'after' !== !!flip) {\n        ctx.lineTo(previous.x, target.y);\n    } else {\n        ctx.lineTo(target.x, previous.y);\n    }\n    ctx.lineTo(target.x, target.y);\n}\n/**\n * @private\n */ function _bezierCurveTo(ctx, previous, target, flip) {\n    if (!previous) {\n        return ctx.lineTo(target.x, target.y);\n    }\n    ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);\n}\nfunction setRenderOpts(ctx, opts) {\n    if (opts.translation) {\n        ctx.translate(opts.translation[0], opts.translation[1]);\n    }\n    if (!isNullOrUndef(opts.rotation)) {\n        ctx.rotate(opts.rotation);\n    }\n    if (opts.color) {\n        ctx.fillStyle = opts.color;\n    }\n    if (opts.textAlign) {\n        ctx.textAlign = opts.textAlign;\n    }\n    if (opts.textBaseline) {\n        ctx.textBaseline = opts.textBaseline;\n    }\n}\nfunction decorateText(ctx, x, y, line, opts) {\n    if (opts.strikethrough || opts.underline) {\n        /**\n     * Now that IE11 support has been dropped, we can use more\n     * of the TextMetrics object. The actual bounding boxes\n     * are unflagged in Chrome, Firefox, Edge, and Safari so they\n     * can be safely used.\n     * See https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics#Browser_compatibility\n     */ const metrics = ctx.measureText(line);\n        const left = x - metrics.actualBoundingBoxLeft;\n        const right = x + metrics.actualBoundingBoxRight;\n        const top = y - metrics.actualBoundingBoxAscent;\n        const bottom = y + metrics.actualBoundingBoxDescent;\n        const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;\n        ctx.strokeStyle = ctx.fillStyle;\n        ctx.beginPath();\n        ctx.lineWidth = opts.decorationWidth || 2;\n        ctx.moveTo(left, yDecoration);\n        ctx.lineTo(right, yDecoration);\n        ctx.stroke();\n    }\n}\nfunction drawBackdrop(ctx, opts) {\n    const oldColor = ctx.fillStyle;\n    ctx.fillStyle = opts.color;\n    ctx.fillRect(opts.left, opts.top, opts.width, opts.height);\n    ctx.fillStyle = oldColor;\n}\n/**\n * Render text onto the canvas\n */ function renderText(ctx, text, x, y, font, opts = {}) {\n    const lines = isArray(text) ? text : [\n        text\n    ];\n    const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';\n    let i, line;\n    ctx.save();\n    ctx.font = font.string;\n    setRenderOpts(ctx, opts);\n    for(i = 0; i < lines.length; ++i){\n        line = lines[i];\n        if (opts.backdrop) {\n            drawBackdrop(ctx, opts.backdrop);\n        }\n        if (stroke) {\n            if (opts.strokeColor) {\n                ctx.strokeStyle = opts.strokeColor;\n            }\n            if (!isNullOrUndef(opts.strokeWidth)) {\n                ctx.lineWidth = opts.strokeWidth;\n            }\n            ctx.strokeText(line, x, y, opts.maxWidth);\n        }\n        ctx.fillText(line, x, y, opts.maxWidth);\n        decorateText(ctx, x, y, line, opts);\n        y += Number(font.lineHeight);\n    }\n    ctx.restore();\n}\n/**\n * Add a path of a rectangle with rounded corners to the current sub-path\n * @param ctx - Context\n * @param rect - Bounding rect\n */ function addRoundedRectPath(ctx, rect) {\n    const { x, y, w, h, radius } = rect;\n    // top left arc\n    ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);\n    // line from top left to bottom left\n    ctx.lineTo(x, y + h - radius.bottomLeft);\n    // bottom left arc\n    ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);\n    // line from bottom left to bottom right\n    ctx.lineTo(x + w - radius.bottomRight, y + h);\n    // bottom right arc\n    ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);\n    // line from bottom right to top right\n    ctx.lineTo(x + w, y + radius.topRight);\n    // top right arc\n    ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);\n    // line from top right to top left\n    ctx.lineTo(x + radius.topLeft, y);\n}\nconst LINE_HEIGHT = /^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/;\nconst FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;\n/**\n * @alias Chart.helpers.options\n * @namespace\n */ /**\n * Converts the given line height `value` in pixels for a specific font `size`.\n * @param value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').\n * @param size - The font size (in pixels) used to resolve relative `value`.\n * @returns The effective line height in pixels (size * 1.2 if value is invalid).\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height\n * @since 2.7.0\n */ function toLineHeight(value, size) {\n    const matches = ('' + value).match(LINE_HEIGHT);\n    if (!matches || matches[1] === 'normal') {\n        return size * 1.2;\n    }\n    value = +matches[2];\n    switch(matches[3]){\n        case 'px':\n            return value;\n        case '%':\n            value /= 100;\n            break;\n    }\n    return size * value;\n}\nconst numberOrZero = (v)=>+v || 0;\nfunction _readValueToProps(value, props) {\n    const ret = {};\n    const objProps = isObject(props);\n    const keys = objProps ? Object.keys(props) : props;\n    const read = isObject(value) ? objProps ? (prop)=>valueOrDefault(value[prop], value[props[prop]]) : (prop)=>value[prop] : ()=>value;\n    for (const prop of keys){\n        ret[prop] = numberOrZero(read(prop));\n    }\n    return ret;\n}\n/**\n * Converts the given value into a TRBL object.\n * @param value - If a number, set the value to all TRBL component,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n *  x / y are shorthands for same value for left/right and top/bottom.\n * @returns The padding values (top, right, bottom, left)\n * @since 3.0.0\n */ function toTRBL(value) {\n    return _readValueToProps(value, {\n        top: 'y',\n        right: 'x',\n        bottom: 'y',\n        left: 'x'\n    });\n}\n/**\n * Converts the given value into a TRBL corners object (similar with css border-radius).\n * @param value - If a number, set the value to all TRBL corner components,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n * @returns The TRBL corner values (topLeft, topRight, bottomLeft, bottomRight)\n * @since 3.0.0\n */ function toTRBLCorners(value) {\n    return _readValueToProps(value, [\n        'topLeft',\n        'topRight',\n        'bottomLeft',\n        'bottomRight'\n    ]);\n}\n/**\n * Converts the given value into a padding object with pre-computed width/height.\n * @param value - If a number, set the value to all TRBL component,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n *  x / y are shorthands for same value for left/right and top/bottom.\n * @returns The padding values (top, right, bottom, left, width, height)\n * @since 2.7.0\n */ function toPadding(value) {\n    const obj = toTRBL(value);\n    obj.width = obj.left + obj.right;\n    obj.height = obj.top + obj.bottom;\n    return obj;\n}\n/**\n * Parses font options and returns the font object.\n * @param options - A object that contains font options to be parsed.\n * @param fallback - A object that contains fallback font options.\n * @return The font object.\n * @private\n */ function toFont(options, fallback) {\n    options = options || {};\n    fallback = fallback || defaults.font;\n    let size = valueOrDefault(options.size, fallback.size);\n    if (typeof size === 'string') {\n        size = parseInt(size, 10);\n    }\n    let style = valueOrDefault(options.style, fallback.style);\n    if (style && !('' + style).match(FONT_STYLE)) {\n        console.warn('Invalid font style specified: \"' + style + '\"');\n        style = undefined;\n    }\n    const font = {\n        family: valueOrDefault(options.family, fallback.family),\n        lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),\n        size,\n        style,\n        weight: valueOrDefault(options.weight, fallback.weight),\n        string: ''\n    };\n    font.string = toFontString(font);\n    return font;\n}\n/**\n * Evaluates the given `inputs` sequentially and returns the first defined value.\n * @param inputs - An array of values, falling back to the last value.\n * @param context - If defined and the current value is a function, the value\n * is called with `context` as first argument and the result becomes the new input.\n * @param index - If defined and the current value is an array, the value\n * at `index` become the new input.\n * @param info - object to return information about resolution in\n * @param info.cacheable - Will be set to `false` if option is not cacheable.\n * @since 2.7.0\n */ function resolve(inputs, context, index, info) {\n    let cacheable = true;\n    let i, ilen, value;\n    for(i = 0, ilen = inputs.length; i < ilen; ++i){\n        value = inputs[i];\n        if (value === undefined) {\n            continue;\n        }\n        if (context !== undefined && typeof value === 'function') {\n            value = value(context);\n            cacheable = false;\n        }\n        if (index !== undefined && isArray(value)) {\n            value = value[index % value.length];\n            cacheable = false;\n        }\n        if (value !== undefined) {\n            if (info && !cacheable) {\n                info.cacheable = false;\n            }\n            return value;\n        }\n    }\n}\n/**\n * @param minmax\n * @param grace\n * @param beginAtZero\n * @private\n */ function _addGrace(minmax, grace, beginAtZero) {\n    const { min, max } = minmax;\n    const change = toDimension(grace, (max - min) / 2);\n    const keepZero = (value, add)=>beginAtZero && value === 0 ? 0 : value + add;\n    return {\n        min: keepZero(min, -Math.abs(change)),\n        max: keepZero(max, change)\n    };\n}\nfunction createContext(parentContext, context) {\n    return Object.assign(Object.create(parentContext), context);\n}\n/**\n * Creates a Proxy for resolving raw values for options.\n * @param scopes - The option scopes to look for values, in resolution order\n * @param prefixes - The prefixes for values, in resolution order.\n * @param rootScopes - The root option scopes\n * @param fallback - Parent scopes fallback\n * @param getTarget - callback for getting the target for changed values\n * @returns Proxy\n * @private\n */ function _createResolver(scopes, prefixes = [\n    ''\n], rootScopes, fallback, getTarget = ()=>scopes[0]) {\n    const finalRootScopes = rootScopes || scopes;\n    if (typeof fallback === 'undefined') {\n        fallback = _resolve('_fallback', scopes);\n    }\n    const cache = {\n        [Symbol.toStringTag]: 'Object',\n        _cacheable: true,\n        _scopes: scopes,\n        _rootScopes: finalRootScopes,\n        _fallback: fallback,\n        _getTarget: getTarget,\n        override: (scope)=>_createResolver([\n                scope,\n                ...scopes\n            ], prefixes, finalRootScopes, fallback)\n    };\n    return new Proxy(cache, {\n        /**\n     * A trap for the delete operator.\n     */ deleteProperty (target, prop) {\n            delete target[prop]; // remove from cache\n            delete target._keys; // remove cached keys\n            delete scopes[0][prop]; // remove from top level scope\n            return true;\n        },\n        /**\n     * A trap for getting property values.\n     */ get (target, prop) {\n            return _cached(target, prop, ()=>_resolveWithPrefixes(prop, prefixes, scopes, target));\n        },\n        /**\n     * A trap for Object.getOwnPropertyDescriptor.\n     * Also used by Object.hasOwnProperty.\n     */ getOwnPropertyDescriptor (target, prop) {\n            return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);\n        },\n        /**\n     * A trap for Object.getPrototypeOf.\n     */ getPrototypeOf () {\n            return Reflect.getPrototypeOf(scopes[0]);\n        },\n        /**\n     * A trap for the in operator.\n     */ has (target, prop) {\n            return getKeysFromAllScopes(target).includes(prop);\n        },\n        /**\n     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.\n     */ ownKeys (target) {\n            return getKeysFromAllScopes(target);\n        },\n        /**\n     * A trap for setting property values.\n     */ set (target, prop, value) {\n            const storage = target._storage || (target._storage = getTarget());\n            target[prop] = storage[prop] = value; // set to top level scope + cache\n            delete target._keys; // remove cached keys\n            return true;\n        }\n    });\n}\n/**\n * Returns an Proxy for resolving option values with context.\n * @param proxy - The Proxy returned by `_createResolver`\n * @param context - Context object for scriptable/indexable options\n * @param subProxy - The proxy provided for scriptable options\n * @param descriptorDefaults - Defaults for descriptors\n * @private\n */ function _attachContext(proxy, context, subProxy, descriptorDefaults) {\n    const cache = {\n        _cacheable: false,\n        _proxy: proxy,\n        _context: context,\n        _subProxy: subProxy,\n        _stack: new Set(),\n        _descriptors: _descriptors(proxy, descriptorDefaults),\n        setContext: (ctx)=>_attachContext(proxy, ctx, subProxy, descriptorDefaults),\n        override: (scope)=>_attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)\n    };\n    return new Proxy(cache, {\n        /**\n     * A trap for the delete operator.\n     */ deleteProperty (target, prop) {\n            delete target[prop]; // remove from cache\n            delete proxy[prop]; // remove from proxy\n            return true;\n        },\n        /**\n     * A trap for getting property values.\n     */ get (target, prop, receiver) {\n            return _cached(target, prop, ()=>_resolveWithContext(target, prop, receiver));\n        },\n        /**\n     * A trap for Object.getOwnPropertyDescriptor.\n     * Also used by Object.hasOwnProperty.\n     */ getOwnPropertyDescriptor (target, prop) {\n            return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {\n                enumerable: true,\n                configurable: true\n            } : undefined : Reflect.getOwnPropertyDescriptor(proxy, prop);\n        },\n        /**\n     * A trap for Object.getPrototypeOf.\n     */ getPrototypeOf () {\n            return Reflect.getPrototypeOf(proxy);\n        },\n        /**\n     * A trap for the in operator.\n     */ has (target, prop) {\n            return Reflect.has(proxy, prop);\n        },\n        /**\n     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.\n     */ ownKeys () {\n            return Reflect.ownKeys(proxy);\n        },\n        /**\n     * A trap for setting property values.\n     */ set (target, prop, value) {\n            proxy[prop] = value; // set to proxy\n            delete target[prop]; // remove from cache\n            return true;\n        }\n    });\n}\n/**\n * @private\n */ function _descriptors(proxy, defaults = {\n    scriptable: true,\n    indexable: true\n}) {\n    const { _scriptable = defaults.scriptable, _indexable = defaults.indexable, _allKeys = defaults.allKeys } = proxy;\n    return {\n        allKeys: _allKeys,\n        scriptable: _scriptable,\n        indexable: _indexable,\n        isScriptable: isFunction(_scriptable) ? _scriptable : ()=>_scriptable,\n        isIndexable: isFunction(_indexable) ? _indexable : ()=>_indexable\n    };\n}\nconst readKey = (prefix, name)=>prefix ? prefix + _capitalize(name) : name;\nconst needsSubResolver = (prop, value)=>isObject(value) && prop !== 'adapters' && (Object.getPrototypeOf(value) === null || value.constructor === Object);\nfunction _cached(target, prop, resolve) {\n    if (Object.prototype.hasOwnProperty.call(target, prop) || prop === 'constructor') {\n        return target[prop];\n    }\n    const value = resolve();\n    // cache the resolved value\n    target[prop] = value;\n    return value;\n}\nfunction _resolveWithContext(target, prop, receiver) {\n    const { _proxy, _context, _subProxy, _descriptors: descriptors } = target;\n    let value = _proxy[prop]; // resolve from proxy\n    // resolve with context\n    if (isFunction(value) && descriptors.isScriptable(prop)) {\n        value = _resolveScriptable(prop, value, target, receiver);\n    }\n    if (isArray(value) && value.length) {\n        value = _resolveArray(prop, value, target, descriptors.isIndexable);\n    }\n    if (needsSubResolver(prop, value)) {\n        // if the resolved value is an object, create a sub resolver for it\n        value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);\n    }\n    return value;\n}\nfunction _resolveScriptable(prop, getValue, target, receiver) {\n    const { _proxy, _context, _subProxy, _stack } = target;\n    if (_stack.has(prop)) {\n        throw new Error('Recursion detected: ' + Array.from(_stack).join('->') + '->' + prop);\n    }\n    _stack.add(prop);\n    let value = getValue(_context, _subProxy || receiver);\n    _stack.delete(prop);\n    if (needsSubResolver(prop, value)) {\n        // When scriptable option returns an object, create a resolver on that.\n        value = createSubResolver(_proxy._scopes, _proxy, prop, value);\n    }\n    return value;\n}\nfunction _resolveArray(prop, value, target, isIndexable) {\n    const { _proxy, _context, _subProxy, _descriptors: descriptors } = target;\n    if (typeof _context.index !== 'undefined' && isIndexable(prop)) {\n        return value[_context.index % value.length];\n    } else if (isObject(value[0])) {\n        // Array of objects, return array or resolvers\n        const arr = value;\n        const scopes = _proxy._scopes.filter((s)=>s !== arr);\n        value = [];\n        for (const item of arr){\n            const resolver = createSubResolver(scopes, _proxy, prop, item);\n            value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));\n        }\n    }\n    return value;\n}\nfunction resolveFallback(fallback, prop, value) {\n    return isFunction(fallback) ? fallback(prop, value) : fallback;\n}\nconst getScope = (key, parent)=>key === true ? parent : typeof key === 'string' ? resolveObjectKey(parent, key) : undefined;\nfunction addScopes(set, parentScopes, key, parentFallback, value) {\n    for (const parent of parentScopes){\n        const scope = getScope(key, parent);\n        if (scope) {\n            set.add(scope);\n            const fallback = resolveFallback(scope._fallback, key, value);\n            if (typeof fallback !== 'undefined' && fallback !== key && fallback !== parentFallback) {\n                // When we reach the descriptor that defines a new _fallback, return that.\n                // The fallback will resume to that new scope.\n                return fallback;\n            }\n        } else if (scope === false && typeof parentFallback !== 'undefined' && key !== parentFallback) {\n            // Fallback to `false` results to `false`, when falling back to different key.\n            // For example `interaction` from `hover` or `plugins.tooltip` and `animation` from `animations`\n            return null;\n        }\n    }\n    return false;\n}\nfunction createSubResolver(parentScopes, resolver, prop, value) {\n    const rootScopes = resolver._rootScopes;\n    const fallback = resolveFallback(resolver._fallback, prop, value);\n    const allScopes = [\n        ...parentScopes,\n        ...rootScopes\n    ];\n    const set = new Set();\n    set.add(value);\n    let key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);\n    if (key === null) {\n        return false;\n    }\n    if (typeof fallback !== 'undefined' && fallback !== prop) {\n        key = addScopesFromKey(set, allScopes, fallback, key, value);\n        if (key === null) {\n            return false;\n        }\n    }\n    return _createResolver(Array.from(set), [\n        ''\n    ], rootScopes, fallback, ()=>subGetTarget(resolver, prop, value));\n}\nfunction addScopesFromKey(set, allScopes, key, fallback, item) {\n    while(key){\n        key = addScopes(set, allScopes, key, fallback, item);\n    }\n    return key;\n}\nfunction subGetTarget(resolver, prop, value) {\n    const parent = resolver._getTarget();\n    if (!(prop in parent)) {\n        parent[prop] = {};\n    }\n    const target = parent[prop];\n    if (isArray(target) && isObject(value)) {\n        // For array of objects, the object is used to store updated values\n        return value;\n    }\n    return target || {};\n}\nfunction _resolveWithPrefixes(prop, prefixes, scopes, proxy) {\n    let value;\n    for (const prefix of prefixes){\n        value = _resolve(readKey(prefix, prop), scopes);\n        if (typeof value !== 'undefined') {\n            return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;\n        }\n    }\n}\nfunction _resolve(key, scopes) {\n    for (const scope of scopes){\n        if (!scope) {\n            continue;\n        }\n        const value = scope[key];\n        if (typeof value !== 'undefined') {\n            return value;\n        }\n    }\n}\nfunction getKeysFromAllScopes(target) {\n    let keys = target._keys;\n    if (!keys) {\n        keys = target._keys = resolveKeysFromAllScopes(target._scopes);\n    }\n    return keys;\n}\nfunction resolveKeysFromAllScopes(scopes) {\n    const set = new Set();\n    for (const scope of scopes){\n        for (const key of Object.keys(scope).filter((k)=>!k.startsWith('_'))){\n            set.add(key);\n        }\n    }\n    return Array.from(set);\n}\nfunction _parseObjectDataRadialScale(meta, data, start, count) {\n    const { iScale } = meta;\n    const { key = 'r' } = this._parsing;\n    const parsed = new Array(count);\n    let i, ilen, index, item;\n    for(i = 0, ilen = count; i < ilen; ++i){\n        index = i + start;\n        item = data[index];\n        parsed[i] = {\n            r: iScale.parse(resolveObjectKey(item, key), index)\n        };\n    }\n    return parsed;\n}\nconst EPSILON = Number.EPSILON || 1e-14;\nconst getPoint = (points, i)=>i < points.length && !points[i].skip && points[i];\nconst getValueAxis = (indexAxis)=>indexAxis === 'x' ? 'y' : 'x';\nfunction splineCurve(firstPoint, middlePoint, afterPoint, t) {\n    // Props to Rob Spencer at scaled innovation for his post on splining between points\n    // http://scaledinnovation.com/analytics/splines/aboutSplines.html\n    // This function must also respect \"skipped\" points\n    const previous = firstPoint.skip ? middlePoint : firstPoint;\n    const current = middlePoint;\n    const next = afterPoint.skip ? middlePoint : afterPoint;\n    const d01 = distanceBetweenPoints(current, previous);\n    const d12 = distanceBetweenPoints(next, current);\n    let s01 = d01 / (d01 + d12);\n    let s12 = d12 / (d01 + d12);\n    // If all points are the same, s01 & s02 will be inf\n    s01 = isNaN(s01) ? 0 : s01;\n    s12 = isNaN(s12) ? 0 : s12;\n    const fa = t * s01; // scaling factor for triangle Ta\n    const fb = t * s12;\n    return {\n        previous: {\n            x: current.x - fa * (next.x - previous.x),\n            y: current.y - fa * (next.y - previous.y)\n        },\n        next: {\n            x: current.x + fb * (next.x - previous.x),\n            y: current.y + fb * (next.y - previous.y)\n        }\n    };\n}\n/**\n * Adjust tangents to ensure monotonic properties\n */ function monotoneAdjust(points, deltaK, mK) {\n    const pointsLen = points.length;\n    let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;\n    let pointAfter = getPoint(points, 0);\n    for(let i = 0; i < pointsLen - 1; ++i){\n        pointCurrent = pointAfter;\n        pointAfter = getPoint(points, i + 1);\n        if (!pointCurrent || !pointAfter) {\n            continue;\n        }\n        if (almostEquals(deltaK[i], 0, EPSILON)) {\n            mK[i] = mK[i + 1] = 0;\n            continue;\n        }\n        alphaK = mK[i] / deltaK[i];\n        betaK = mK[i + 1] / deltaK[i];\n        squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n        if (squaredMagnitude <= 9) {\n            continue;\n        }\n        tauK = 3 / Math.sqrt(squaredMagnitude);\n        mK[i] = alphaK * tauK * deltaK[i];\n        mK[i + 1] = betaK * tauK * deltaK[i];\n    }\n}\nfunction monotoneCompute(points, mK, indexAxis = 'x') {\n    const valueAxis = getValueAxis(indexAxis);\n    const pointsLen = points.length;\n    let delta, pointBefore, pointCurrent;\n    let pointAfter = getPoint(points, 0);\n    for(let i = 0; i < pointsLen; ++i){\n        pointBefore = pointCurrent;\n        pointCurrent = pointAfter;\n        pointAfter = getPoint(points, i + 1);\n        if (!pointCurrent) {\n            continue;\n        }\n        const iPixel = pointCurrent[indexAxis];\n        const vPixel = pointCurrent[valueAxis];\n        if (pointBefore) {\n            delta = (iPixel - pointBefore[indexAxis]) / 3;\n            pointCurrent[`cp1${indexAxis}`] = iPixel - delta;\n            pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];\n        }\n        if (pointAfter) {\n            delta = (pointAfter[indexAxis] - iPixel) / 3;\n            pointCurrent[`cp2${indexAxis}`] = iPixel + delta;\n            pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];\n        }\n    }\n}\n/**\n * This function calculates Bzier control points in a similar way than |splineCurve|,\n * but preserves monotonicity of the provided data and ensures no local extremums are added\n * between the dataset discrete points due to the interpolation.\n * See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation\n */ function splineCurveMonotone(points, indexAxis = 'x') {\n    const valueAxis = getValueAxis(indexAxis);\n    const pointsLen = points.length;\n    const deltaK = Array(pointsLen).fill(0);\n    const mK = Array(pointsLen);\n    // Calculate slopes (deltaK) and initialize tangents (mK)\n    let i, pointBefore, pointCurrent;\n    let pointAfter = getPoint(points, 0);\n    for(i = 0; i < pointsLen; ++i){\n        pointBefore = pointCurrent;\n        pointCurrent = pointAfter;\n        pointAfter = getPoint(points, i + 1);\n        if (!pointCurrent) {\n            continue;\n        }\n        if (pointAfter) {\n            const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];\n            // In the case of two points that appear at the same x pixel, slopeDeltaX is 0\n            deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;\n        }\n        mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;\n    }\n    monotoneAdjust(points, deltaK, mK);\n    monotoneCompute(points, mK, indexAxis);\n}\nfunction capControlPoint(pt, min, max) {\n    return Math.max(Math.min(pt, max), min);\n}\nfunction capBezierPoints(points, area) {\n    let i, ilen, point, inArea, inAreaPrev;\n    let inAreaNext = _isPointInArea(points[0], area);\n    for(i = 0, ilen = points.length; i < ilen; ++i){\n        inAreaPrev = inArea;\n        inArea = inAreaNext;\n        inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);\n        if (!inArea) {\n            continue;\n        }\n        point = points[i];\n        if (inAreaPrev) {\n            point.cp1x = capControlPoint(point.cp1x, area.left, area.right);\n            point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);\n        }\n        if (inAreaNext) {\n            point.cp2x = capControlPoint(point.cp2x, area.left, area.right);\n            point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);\n        }\n    }\n}\n/**\n * @private\n */ function _updateBezierControlPoints(points, options, area, loop, indexAxis) {\n    let i, ilen, point, controlPoints;\n    // Only consider points that are drawn in case the spanGaps option is used\n    if (options.spanGaps) {\n        points = points.filter((pt)=>!pt.skip);\n    }\n    if (options.cubicInterpolationMode === 'monotone') {\n        splineCurveMonotone(points, indexAxis);\n    } else {\n        let prev = loop ? points[points.length - 1] : points[0];\n        for(i = 0, ilen = points.length; i < ilen; ++i){\n            point = points[i];\n            controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);\n            point.cp1x = controlPoints.previous.x;\n            point.cp1y = controlPoints.previous.y;\n            point.cp2x = controlPoints.next.x;\n            point.cp2y = controlPoints.next.y;\n            prev = point;\n        }\n    }\n    if (options.capBezierPoints) {\n        capBezierPoints(points, area);\n    }\n}\n/**\n * @private\n */ function _isDomSupported() {\n    return  false && 0;\n}\n/**\n * @private\n */ function _getParentNode(domNode) {\n    let parent = domNode.parentNode;\n    if (parent && parent.toString() === '[object ShadowRoot]') {\n        parent = parent.host;\n    }\n    return parent;\n}\n/**\n * convert max-width/max-height values that may be percentages into a number\n * @private\n */ function parseMaxStyle(styleValue, node, parentProperty) {\n    let valueInPixels;\n    if (typeof styleValue === 'string') {\n        valueInPixels = parseInt(styleValue, 10);\n        if (styleValue.indexOf('%') !== -1) {\n            // percentage * size in dimension\n            valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\n        }\n    } else {\n        valueInPixels = styleValue;\n    }\n    return valueInPixels;\n}\nconst getComputedStyle = (element)=>element.ownerDocument.defaultView.getComputedStyle(element, null);\nfunction getStyle(el, property) {\n    return getComputedStyle(el).getPropertyValue(property);\n}\nconst positions = [\n    'top',\n    'right',\n    'bottom',\n    'left'\n];\nfunction getPositionedStyle(styles, style, suffix) {\n    const result = {};\n    suffix = suffix ? '-' + suffix : '';\n    for(let i = 0; i < 4; i++){\n        const pos = positions[i];\n        result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;\n    }\n    result.width = result.left + result.right;\n    result.height = result.top + result.bottom;\n    return result;\n}\nconst useOffsetPos = (x, y, target)=>(x > 0 || y > 0) && (!target || !target.shadowRoot);\n/**\n * @param e\n * @param canvas\n * @returns Canvas position\n */ function getCanvasPosition(e, canvas) {\n    const touches = e.touches;\n    const source = touches && touches.length ? touches[0] : e;\n    const { offsetX, offsetY } = source;\n    let box = false;\n    let x, y;\n    if (useOffsetPos(offsetX, offsetY, e.target)) {\n        x = offsetX;\n        y = offsetY;\n    } else {\n        const rect = canvas.getBoundingClientRect();\n        x = source.clientX - rect.left;\n        y = source.clientY - rect.top;\n        box = true;\n    }\n    return {\n        x,\n        y,\n        box\n    };\n}\n/**\n * Gets an event's x, y coordinates, relative to the chart area\n * @param event\n * @param chart\n * @returns x and y coordinates of the event\n */ function getRelativePosition(event, chart) {\n    if ('native' in event) {\n        return event;\n    }\n    const { canvas, currentDevicePixelRatio } = chart;\n    const style = getComputedStyle(canvas);\n    const borderBox = style.boxSizing === 'border-box';\n    const paddings = getPositionedStyle(style, 'padding');\n    const borders = getPositionedStyle(style, 'border', 'width');\n    const { x, y, box } = getCanvasPosition(event, canvas);\n    const xOffset = paddings.left + (box && borders.left);\n    const yOffset = paddings.top + (box && borders.top);\n    let { width, height } = chart;\n    if (borderBox) {\n        width -= paddings.width + borders.width;\n        height -= paddings.height + borders.height;\n    }\n    return {\n        x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),\n        y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)\n    };\n}\nfunction getContainerSize(canvas, width, height) {\n    let maxWidth, maxHeight;\n    if (width === undefined || height === undefined) {\n        const container = canvas && _getParentNode(canvas);\n        if (!container) {\n            width = canvas.clientWidth;\n            height = canvas.clientHeight;\n        } else {\n            const rect = container.getBoundingClientRect(); // this is the border box of the container\n            const containerStyle = getComputedStyle(container);\n            const containerBorder = getPositionedStyle(containerStyle, 'border', 'width');\n            const containerPadding = getPositionedStyle(containerStyle, 'padding');\n            width = rect.width - containerPadding.width - containerBorder.width;\n            height = rect.height - containerPadding.height - containerBorder.height;\n            maxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');\n            maxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');\n        }\n    }\n    return {\n        width,\n        height,\n        maxWidth: maxWidth || INFINITY,\n        maxHeight: maxHeight || INFINITY\n    };\n}\nconst round1 = (v)=>Math.round(v * 10) / 10;\n// eslint-disable-next-line complexity\nfunction getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {\n    const style = getComputedStyle(canvas);\n    const margins = getPositionedStyle(style, 'margin');\n    const maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;\n    const maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;\n    const containerSize = getContainerSize(canvas, bbWidth, bbHeight);\n    let { width, height } = containerSize;\n    if (style.boxSizing === 'content-box') {\n        const borders = getPositionedStyle(style, 'border', 'width');\n        const paddings = getPositionedStyle(style, 'padding');\n        width -= paddings.width + borders.width;\n        height -= paddings.height + borders.height;\n    }\n    width = Math.max(0, width - margins.width);\n    height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);\n    width = round1(Math.min(width, maxWidth, containerSize.maxWidth));\n    height = round1(Math.min(height, maxHeight, containerSize.maxHeight));\n    if (width && !height) {\n        // https://github.com/chartjs/Chart.js/issues/4659\n        // If the canvas has width, but no height, default to aspectRatio of 2 (canvas default)\n        height = round1(width / 2);\n    }\n    const maintainHeight = bbWidth !== undefined || bbHeight !== undefined;\n    if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {\n        height = containerSize.height;\n        width = round1(Math.floor(height * aspectRatio));\n    }\n    return {\n        width,\n        height\n    };\n}\n/**\n * @param chart\n * @param forceRatio\n * @param forceStyle\n * @returns True if the canvas context size or transformation has changed.\n */ function retinaScale(chart, forceRatio, forceStyle) {\n    const pixelRatio = forceRatio || 1;\n    const deviceHeight = round1(chart.height * pixelRatio);\n    const deviceWidth = round1(chart.width * pixelRatio);\n    chart.height = round1(chart.height);\n    chart.width = round1(chart.width);\n    const canvas = chart.canvas;\n    // If no style has been set on the canvas, the render size is used as display size,\n    // making the chart visually bigger, so let's enforce it to the \"correct\" values.\n    // See https://github.com/chartjs/Chart.js/issues/3575\n    if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {\n        canvas.style.height = `${chart.height}px`;\n        canvas.style.width = `${chart.width}px`;\n    }\n    if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {\n        chart.currentDevicePixelRatio = pixelRatio;\n        canvas.height = deviceHeight;\n        canvas.width = deviceWidth;\n        chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n        return true;\n    }\n    return false;\n}\n/**\n * Detects support for options object argument in addEventListener.\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\n * @private\n */ const supportsEventListenerOptions = function() {\n    let passiveSupported = false;\n    try {\n        const options = {\n            get passive () {\n                passiveSupported = true;\n                return false;\n            }\n        };\n        if (_isDomSupported()) {\n            window.addEventListener('test', null, options);\n            window.removeEventListener('test', null, options);\n        }\n    } catch (e) {\n    // continue regardless of error\n    }\n    return passiveSupported;\n}();\n/**\n * The \"used\" size is the final value of a dimension property after all calculations have\n * been performed. This method uses the computed style of `element` but returns undefined\n * if the computed style is not expressed in pixels. That can happen in some cases where\n * `element` has a size relative to its parent and this last one is not yet displayed,\n * for example because of `display: none` on a parent node.\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\n * @returns Size in pixels or undefined if unknown.\n */ function readUsedSize(element, property) {\n    const value = getStyle(element, property);\n    const matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\n    return matches ? +matches[1] : undefined;\n}\n/**\n * @private\n */ function _pointInLine(p1, p2, t, mode) {\n    return {\n        x: p1.x + t * (p2.x - p1.x),\n        y: p1.y + t * (p2.y - p1.y)\n    };\n}\n/**\n * @private\n */ function _steppedInterpolation(p1, p2, t, mode) {\n    return {\n        x: p1.x + t * (p2.x - p1.x),\n        y: mode === 'middle' ? t < 0.5 ? p1.y : p2.y : mode === 'after' ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y\n    };\n}\n/**\n * @private\n */ function _bezierInterpolation(p1, p2, t, mode) {\n    const cp1 = {\n        x: p1.cp2x,\n        y: p1.cp2y\n    };\n    const cp2 = {\n        x: p2.cp1x,\n        y: p2.cp1y\n    };\n    const a = _pointInLine(p1, cp1, t);\n    const b = _pointInLine(cp1, cp2, t);\n    const c = _pointInLine(cp2, p2, t);\n    const d = _pointInLine(a, b, t);\n    const e = _pointInLine(b, c, t);\n    return _pointInLine(d, e, t);\n}\nconst getRightToLeftAdapter = function(rectX, width) {\n    return {\n        x (x) {\n            return rectX + rectX + width - x;\n        },\n        setWidth (w) {\n            width = w;\n        },\n        textAlign (align) {\n            if (align === 'center') {\n                return align;\n            }\n            return align === 'right' ? 'left' : 'right';\n        },\n        xPlus (x, value) {\n            return x - value;\n        },\n        leftForLtr (x, itemWidth) {\n            return x - itemWidth;\n        }\n    };\n};\nconst getLeftToRightAdapter = function() {\n    return {\n        x (x) {\n            return x;\n        },\n        setWidth (w) {},\n        textAlign (align) {\n            return align;\n        },\n        xPlus (x, value) {\n            return x + value;\n        },\n        leftForLtr (x, _itemWidth) {\n            return x;\n        }\n    };\n};\nfunction getRtlAdapter(rtl, rectX, width) {\n    return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();\n}\nfunction overrideTextDirection(ctx, direction) {\n    let style, original;\n    if (direction === 'ltr' || direction === 'rtl') {\n        style = ctx.canvas.style;\n        original = [\n            style.getPropertyValue('direction'),\n            style.getPropertyPriority('direction')\n        ];\n        style.setProperty('direction', direction, 'important');\n        ctx.prevTextDirection = original;\n    }\n}\nfunction restoreTextDirection(ctx, original) {\n    if (original !== undefined) {\n        delete ctx.prevTextDirection;\n        ctx.canvas.style.setProperty('direction', original[0], original[1]);\n    }\n}\nfunction propertyFn(property) {\n    if (property === 'angle') {\n        return {\n            between: _angleBetween,\n            compare: _angleDiff,\n            normalize: _normalizeAngle\n        };\n    }\n    return {\n        between: _isBetween,\n        compare: (a, b)=>a - b,\n        normalize: (x)=>x\n    };\n}\nfunction normalizeSegment({ start, end, count, loop, style }) {\n    return {\n        start: start % count,\n        end: end % count,\n        loop: loop && (end - start + 1) % count === 0,\n        style\n    };\n}\nfunction getSegment(segment, points, bounds) {\n    const { property, start: startBound, end: endBound } = bounds;\n    const { between, normalize } = propertyFn(property);\n    const count = points.length;\n    let { start, end, loop } = segment;\n    let i, ilen;\n    if (loop) {\n        start += count;\n        end += count;\n        for(i = 0, ilen = count; i < ilen; ++i){\n            if (!between(normalize(points[start % count][property]), startBound, endBound)) {\n                break;\n            }\n            start--;\n            end--;\n        }\n        start %= count;\n        end %= count;\n    }\n    if (end < start) {\n        end += count;\n    }\n    return {\n        start,\n        end,\n        loop,\n        style: segment.style\n    };\n}\nfunction _boundSegment(segment, points, bounds) {\n    if (!bounds) {\n        return [\n            segment\n        ];\n    }\n    const { property, start: startBound, end: endBound } = bounds;\n    const count = points.length;\n    const { compare, between, normalize } = propertyFn(property);\n    const { start, end, loop, style } = getSegment(segment, points, bounds);\n    const result = [];\n    let inside = false;\n    let subStart = null;\n    let value, point, prevValue;\n    const startIsBefore = ()=>between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;\n    const endIsBefore = ()=>compare(endBound, value) === 0 || between(endBound, prevValue, value);\n    const shouldStart = ()=>inside || startIsBefore();\n    const shouldStop = ()=>!inside || endIsBefore();\n    for(let i = start, prev = start; i <= end; ++i){\n        point = points[i % count];\n        if (point.skip) {\n            continue;\n        }\n        value = normalize(point[property]);\n        if (value === prevValue) {\n            continue;\n        }\n        inside = between(value, startBound, endBound);\n        if (subStart === null && shouldStart()) {\n            subStart = compare(value, startBound) === 0 ? i : prev;\n        }\n        if (subStart !== null && shouldStop()) {\n            result.push(normalizeSegment({\n                start: subStart,\n                end: i,\n                loop,\n                count,\n                style\n            }));\n            subStart = null;\n        }\n        prev = i;\n        prevValue = value;\n    }\n    if (subStart !== null) {\n        result.push(normalizeSegment({\n            start: subStart,\n            end,\n            loop,\n            count,\n            style\n        }));\n    }\n    return result;\n}\nfunction _boundSegments(line, bounds) {\n    const result = [];\n    const segments = line.segments;\n    for(let i = 0; i < segments.length; i++){\n        const sub = _boundSegment(segments[i], line.points, bounds);\n        if (sub.length) {\n            result.push(...sub);\n        }\n    }\n    return result;\n}\nfunction findStartAndEnd(points, count, loop, spanGaps) {\n    let start = 0;\n    let end = count - 1;\n    if (loop && !spanGaps) {\n        while(start < count && !points[start].skip){\n            start++;\n        }\n    }\n    while(start < count && points[start].skip){\n        start++;\n    }\n    start %= count;\n    if (loop) {\n        end += start;\n    }\n    while(end > start && points[end % count].skip){\n        end--;\n    }\n    end %= count;\n    return {\n        start,\n        end\n    };\n}\nfunction solidSegments(points, start, max, loop) {\n    const count = points.length;\n    const result = [];\n    let last = start;\n    let prev = points[start];\n    let end;\n    for(end = start + 1; end <= max; ++end){\n        const cur = points[end % count];\n        if (cur.skip || cur.stop) {\n            if (!prev.skip) {\n                loop = false;\n                result.push({\n                    start: start % count,\n                    end: (end - 1) % count,\n                    loop\n                });\n                start = last = cur.stop ? end : null;\n            }\n        } else {\n            last = end;\n            if (prev.skip) {\n                start = end;\n            }\n        }\n        prev = cur;\n    }\n    if (last !== null) {\n        result.push({\n            start: start % count,\n            end: last % count,\n            loop\n        });\n    }\n    return result;\n}\nfunction _computeSegments(line, segmentOptions) {\n    const points = line.points;\n    const spanGaps = line.options.spanGaps;\n    const count = points.length;\n    if (!count) {\n        return [];\n    }\n    const loop = !!line._loop;\n    const { start, end } = findStartAndEnd(points, count, loop, spanGaps);\n    if (spanGaps === true) {\n        return splitByStyles(line, [\n            {\n                start,\n                end,\n                loop\n            }\n        ], points, segmentOptions);\n    }\n    const max = end < start ? end + count : end;\n    const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;\n    return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);\n}\nfunction splitByStyles(line, segments, points, segmentOptions) {\n    if (!segmentOptions || !segmentOptions.setContext || !points) {\n        return segments;\n    }\n    return doSplitByStyles(line, segments, points, segmentOptions);\n}\nfunction doSplitByStyles(line, segments, points, segmentOptions) {\n    const chartContext = line._chart.getContext();\n    const baseStyle = readStyle(line.options);\n    const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;\n    const count = points.length;\n    const result = [];\n    let prevStyle = baseStyle;\n    let start = segments[0].start;\n    let i = start;\n    function addStyle(s, e, l, st) {\n        const dir = spanGaps ? -1 : 1;\n        if (s === e) {\n            return;\n        }\n        s += count;\n        while(points[s % count].skip){\n            s -= dir;\n        }\n        while(points[e % count].skip){\n            e += dir;\n        }\n        if (s % count !== e % count) {\n            result.push({\n                start: s % count,\n                end: e % count,\n                loop: l,\n                style: st\n            });\n            prevStyle = st;\n            start = e % count;\n        }\n    }\n    for (const segment of segments){\n        start = spanGaps ? start : segment.start;\n        let prev = points[start % count];\n        let style;\n        for(i = start + 1; i <= segment.end; i++){\n            const pt = points[i % count];\n            style = readStyle(segmentOptions.setContext(createContext(chartContext, {\n                type: 'segment',\n                p0: prev,\n                p1: pt,\n                p0DataIndex: (i - 1) % count,\n                p1DataIndex: i % count,\n                datasetIndex\n            })));\n            if (styleChanged(style, prevStyle)) {\n                addStyle(start, i - 1, segment.loop, prevStyle);\n            }\n            prev = pt;\n            prevStyle = style;\n        }\n        if (start < i - 1) {\n            addStyle(start, i - 1, segment.loop, prevStyle);\n        }\n    }\n    return result;\n}\nfunction readStyle(options) {\n    return {\n        backgroundColor: options.backgroundColor,\n        borderCapStyle: options.borderCapStyle,\n        borderDash: options.borderDash,\n        borderDashOffset: options.borderDashOffset,\n        borderJoinStyle: options.borderJoinStyle,\n        borderWidth: options.borderWidth,\n        borderColor: options.borderColor\n    };\n}\nfunction styleChanged(style, prevStyle) {\n    if (!prevStyle) {\n        return false;\n    }\n    const cache = [];\n    const replacer = function(key, value) {\n        if (!isPatternOrGradient(value)) {\n            return value;\n        }\n        if (!cache.includes(value)) {\n            cache.push(value);\n        }\n        return cache.indexOf(value);\n    };\n    return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);\n}\nfunction getSizeForArea(scale, chartArea, field) {\n    return scale.options.clip ? scale[field] : chartArea[field];\n}\nfunction getDatasetArea(meta, chartArea) {\n    const { xScale, yScale } = meta;\n    if (xScale && yScale) {\n        return {\n            left: getSizeForArea(xScale, chartArea, 'left'),\n            right: getSizeForArea(xScale, chartArea, 'right'),\n            top: getSizeForArea(yScale, chartArea, 'top'),\n            bottom: getSizeForArea(yScale, chartArea, 'bottom')\n        };\n    }\n    return chartArea;\n}\nfunction getDatasetClipArea(chart, meta) {\n    const clip = meta._clip;\n    if (clip.disabled) {\n        return false;\n    }\n    const area = getDatasetArea(meta, chart.chartArea);\n    return {\n        left: clip.left === false ? 0 : area.left - (clip.left === true ? 0 : clip.left),\n        right: clip.right === false ? chart.width : area.right + (clip.right === true ? 0 : clip.right),\n        top: clip.top === false ? 0 : area.top - (clip.top === true ? 0 : clip.top),\n        bottom: clip.bottom === false ? chart.height : area.bottom + (clip.bottom === true ? 0 : clip.bottom)\n    };\n}\n //# sourceMappingURL=helpers.dataset.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvZGlzdC9jaHVua3MvaGVscGVycy5kYXRhc2V0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7OztJQVVPLFNBQVNBLElBQU87QUFDckIsWUFDRDtBQUVEOztDQUVDLEdBQ00sTUFBTUMsR0FBTSxHQUFDLEtBQU07SUFDeEIsSUFBSUMsRUFBSztJQUNULE9BQU8sSUFBTUEsRUFBQUEsRUFBQUEsQ0FBQUE7Q0FDZjtBQUVBOzs7O0NBSUMsR0FDTSxTQUFTQyxhQUFjQyxDQUFBQSxLQUFjLEVBQTZCO0lBQ3ZFLE9BQU9BLEtBQUFBLEtBQVUsSUFBSSxJQUFJQSxLQUFVQyxLQUFBQSxTQUFBQSxDQUFBQTtBQUNyQyxDQUFDO0FBRUQ7Ozs7Q0FJQyxHQUNNLFNBQVNDLE9BQXFCRixDQUFBQSxLQUFjLEVBQWdCO0lBQ2pFLElBQUlHLE1BQU1ELE9BQU8sSUFBSUMsS0FBTUQsQ0FBQUEsT0FBTyxDQUFDRixLQUFRO1FBQ3pDLE9BQU8sSUFBSTtLQUNaO0lBQ0QsTUFBTUksT0FBT0MsTUFBT0MsQ0FBQUEsU0FBUyxDQUFDQyxRQUFRLENBQUNDLElBQUksQ0FBQ1IsS0FBQUEsQ0FBQUEsQ0FBQUE7SUFDNUMsSUFBSUksSUFBQUEsQ0FBS0ssS0FBSyxDQUFDLENBQUcsU0FBTyxTQUFhTCxJQUFBQSxJQUFBQSxDQUFLSyxLQUFLLENBQUMsQ0FBQyxPQUFPLFFBQVU7UUFDakUsT0FBTyxJQUFJO0tBQ1o7SUFDRCxPQUFPLEtBQUs7QUFDZCxDQUFDO0FBRUQ7Ozs7Q0FJQyxHQUNNLFNBQVNDLFFBQVNWLENBQUFBLEtBQWMsRUFBc0I7SUFDM0QsT0FBT0EsS0FBQUEsS0FBVSxJQUFJLElBQUlL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T25lRHJpdmUgLSBKYWZmZXIgQnVzaW5lc3MgU3lzdGVtcyAoUHJpdmF0ZSkgTGltaXRlZFxcRGVza3RvcFxcUHJvamVjdHNcXEJpZF9SZXZpZXdfU3lzdGVtLW1hc3Rlclxcc3JjXFxoZWxwZXJzXFxoZWxwZXJzLmNvcmUudHMiLCJDOlxcVXNlcnNcXEZhaXphbkphbWlsXFxPbmVEcml2ZSAtIEphZmZlciBCdXNpbmVzcyBTeXN0ZW1zIChQcml2YXRlKSBMaW1pdGVkXFxEZXNrdG9wXFxQcm9qZWN0c1xcQmlkX1Jldmlld19TeXN0ZW0tbWFzdGVyXFxzcmNcXGhlbHBlcnNcXGhlbHBlcnMubWF0aC50cyIsIkM6XFxVc2Vyc1xcRmFpemFuSmFtaWxcXE9uZURyaXZlIC0gSmFmZmVyIEJ1c2luZXNzIFN5c3RlbXMgKFByaXZhdGUpIExpbWl0ZWRcXERlc2t0b3BcXFByb2plY3RzXFxCaWRfUmV2aWV3X1N5c3RlbS1tYXN0ZXJcXHNyY1xcaGVscGVyc1xcaGVscGVycy5jb2xsZWN0aW9uLnRzIiwiQzpcXFVzZXJzXFxGYWl6YW5KYW1pbFxcT25lRHJpdmUgLSBKYWZmZXIgQnVzaW5lc3MgU3lzdGVtcyAoUHJpdmF0ZSkgTGltaXRlZFxcRGVza3RvcFxcUHJvamVjdHNcXEJpZF9SZXZpZXdfU3lzdGVtLW1hc3Rlclxcc3JjXFxoZWxwZXJzXFxoZWxwZXJzLmV4dHJhcy50cyIsIkM6XFxVc2Vyc1xcRmFpemFuSmFtaWxcXE9uZURyaXZlIC0gSmFmZmVyIEJ1c2luZXNzIFN5c3RlbXMgKFByaXZhdGUpIExpbWl0ZWRcXERlc2t0b3BcXFByb2plY3RzXFxCaWRfUmV2aWV3X1N5c3RlbS1tYXN0ZXJcXHNyY1xcaGVscGVyc1xcaGVscGVycy5lYXNpbmcudHMiLCJDOlxcVXNlcnNcXEZhaXphbkphbWlsXFxPbmVEcml2ZSAtIEphZmZlciBCdXNpbmVzcyBTeXN0ZW1zIChQcml2YXRlKSBMaW1pdGVkXFxEZXNrdG9wXFxQcm9qZWN0c1xcQmlkX1Jldmlld19TeXN0ZW0tbWFzdGVyXFxzcmNcXGhlbHBlcnNcXGhlbHBlcnMuY29sb3IudHMiLCJDOlxcVXNlcnNcXEZhaXphbkphbWlsXFxPbmVEcml2ZSAtIEphZmZlciBCdXNpbmVzcyBTeXN0ZW1zIChQcml2YXRlKSBMaW1pdGVkXFxEZXNrdG9wXFxQcm9qZWN0c1xcQmlkX1Jldmlld19TeXN0ZW0tbWFzdGVyXFxzcmNcXGNvcmVcXGNvcmUuYW5pbWF0aW9ucy5kZWZhdWx0cy5qcyIsIkM6XFxVc2Vyc1xcRmFpemFuSmFtaWxcXE9uZURyaXZlIC0gSmFmZmVyIEJ1c2luZXNzIFN5c3RlbXMgKFByaXZhdGUpIExpbWl0ZWRcXERlc2t0b3BcXFByb2plY3RzXFxCaWRfUmV2aWV3X1N5c3RlbS1tYXN0ZXJcXHNyY1xcY29yZVxcY29yZS5sYXlvdXRzLmRlZmF1bHRzLmpzIiwiQzpcXFVzZXJzXFxGYWl6YW5KYW1pbFxcT25lRHJpdmUgLSBKYWZmZXIgQnVzaW5lc3MgU3lzdGVtcyAoUHJpdmF0ZSkgTGltaXRlZFxcRGVza3RvcFxcUHJvamVjdHNcXEJpZF9SZXZpZXdfU3lzdGVtLW1hc3Rlclxcc3JjXFxoZWxwZXJzXFxoZWxwZXJzLmludGwudHMiLCJDOlxcVXNlcnNcXEZhaXphbkphbWlsXFxPbmVEcml2ZSAtIEphZmZlciBCdXNpbmVzcyBTeXN0ZW1zIChQcml2YXRlKSBMaW1pdGVkXFxEZXNrdG9wXFxQcm9qZWN0c1xcQmlkX1Jldmlld19TeXN0ZW0tbWFzdGVyXFxzcmNcXGNvcmVcXGNvcmUudGlja3MuanMiLCJDOlxcVXNlcnNcXEZhaXphbkphbWlsXFxPbmVEcml2ZSAtIEphZmZlciBCdXNpbmVzcyBTeXN0ZW1zIChQcml2YXRlKSBMaW1pdGVkXFxEZXNrdG9wXFxQcm9qZWN0c1xcQmlkX1Jldmlld19TeXN0ZW0tbWFzdGVyXFxzcmNcXGNvcmVcXGNvcmUuc2NhbGUuZGVmYXVsdHMuanMiLCJDOlxcVXNlcnNcXEZhaXphbkphbWlsXFxPbmVEcml2ZSAtIEphZmZlciBCdXNpbmVzcyBTeXN0ZW1zIChQcml2YXRlKSBMaW1pdGVkXFxEZXNrdG9wXFxQcm9qZWN0c1xcQmlkX1Jldmlld19TeXN0ZW0tbWFzdGVyXFxzcmNcXGNvcmVcXGNvcmUuZGVmYXVsdHMuanMiLCJDOlxcVXNlcnNcXEZhaXphbkphbWlsXFxPbmVEcml2ZSAtIEphZmZlciBCdXNpbmVzcyBTeXN0ZW1zIChQcml2YXRlKSBMaW1pdGVkXFxEZXNrdG9wXFxQcm9qZWN0c1xcQmlkX1Jldmlld19TeXN0ZW0tbWFzdGVyXFxzcmNcXGhlbHBlcnNcXGhlbHBlcnMuY2FudmFzLnRzIiwiQzpcXFVzZXJzXFxGYWl6YW5KYW1pbFxcT25lRHJpdmUgLSBKYWZmZXIgQnVzaW5lc3MgU3lzdGVtcyAoUHJpdmF0ZSkgTGltaXRlZFxcRGVza3RvcFxcUHJvamVjdHNcXEJpZF9SZXZpZXdfU3lzdGVtLW1hc3Rlclxcc3JjXFxoZWxwZXJzXFxoZWxwZXJzLm9wdGlvbnMudHMiLCJDOlxcVXNlcnNcXEZhaXphbkphbWlsXFxPbmVEcml2ZSAtIEphZmZlciBCdXNpbmVzcyBTeXN0ZW1zIChQcml2YXRlKSBMaW1pdGVkXFxEZXNrdG9wXFxQcm9qZWN0c1xcQmlkX1Jldmlld19TeXN0ZW0tbWFzdGVyXFxzcmNcXGhlbHBlcnNcXGhlbHBlcnMuY29uZmlnLnRzIiwiQzpcXFVzZXJzXFxGYWl6YW5KYW1pbFxcT25lRHJpdmUgLSBKYWZmZXIgQnVzaW5lc3MgU3lzdGVtcyAoUHJpdmF0ZSkgTGltaXRlZFxcRGVza3RvcFxcUHJvamVjdHNcXEJpZF9SZXZpZXdfU3lzdGVtLW1hc3Rlclxcc3JjXFxoZWxwZXJzXFxoZWxwZXJzLmN1cnZlLnRzIiwiQzpcXFVzZXJzXFxGYWl6YW5KYW1pbFxcT25lRHJpdmUgLSBKYWZmZXIgQnVzaW5lc3MgU3lzdGVtcyAoUHJpdmF0ZSkgTGltaXRlZFxcRGVza3RvcFxcUHJvamVjdHNcXEJpZF9SZXZpZXdfU3lzdGVtLW1hc3Rlclxcc3JjXFxoZWxwZXJzXFxoZWxwZXJzLmRvbS50cyIsIkM6XFxVc2Vyc1xcRmFpemFuSmFtaWxcXE9uZURyaXZlIC0gSmFmZmVyIEJ1c2luZXNzIFN5c3RlbXMgKFByaXZhdGUpIExpbWl0ZWRcXERlc2t0b3BcXFByb2plY3RzXFxCaWRfUmV2aWV3X1N5c3RlbS1tYXN0ZXJcXHNyY1xcaGVscGVyc1xcaGVscGVycy5pbnRlcnBvbGF0aW9uLnRzIiwiQzpcXFVzZXJzXFxGYWl6YW5KYW1pbFxcT25lRHJpdmUgLSBKYWZmZXIgQnVzaW5lc3MgU3lzdGVtcyAoUHJpdmF0ZSkgTGltaXRlZFxcRGVza3RvcFxcUHJvamVjdHNcXEJpZF9SZXZpZXdfU3lzdGVtLW1hc3Rlclxcc3JjXFxoZWxwZXJzXFxoZWxwZXJzLnJ0bC50cyIsIkM6XFxVc2Vyc1xcRmFpemFuSmFtaWxcXE9uZURyaXZlIC0gSmFmZmVyIEJ1c2luZXNzIFN5c3RlbXMgKFByaXZhdGUpIExpbWl0ZWRcXERlc2t0b3BcXFByb2plY3RzXFxCaWRfUmV2aWV3X1N5c3RlbS1tYXN0ZXJcXHNyY1xcaGVscGVyc1xcaGVscGVycy5zZWdtZW50LmpzIiwiQzpcXFVzZXJzXFxGYWl6YW5KYW1pbFxcT25lRHJpdmUgLSBKYWZmZXIgQnVzaW5lc3MgU3lzdGVtcyAoUHJpdmF0ZSkgTGltaXRlZFxcRGVza3RvcFxcUHJvamVjdHNcXEJpZF9SZXZpZXdfU3lzdGVtLW1hc3Rlclxcc3JjXFxoZWxwZXJzXFxoZWxwZXJzLmRhdGFzZXQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbmFtZXNwYWNlIENoYXJ0LmhlbHBlcnNcbiAqL1xuXG5pbXBvcnQgdHlwZSB7QW55T2JqZWN0fSBmcm9tICcuLi90eXBlcy9iYXNpYy5qcyc7XG5pbXBvcnQgdHlwZSB7QWN0aXZlRGF0YVBvaW50LCBDaGFydEV2ZW50fSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5cbi8qKlxuICogQW4gZW1wdHkgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCwgZm9yIGV4YW1wbGUsIGZvciBvcHRpb25hbCBjYWxsYmFjay5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vb3AoKSB7XG4gIC8qIG5vb3AgKi9cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgdW5pcXVlIGlkLCBzZXF1ZW50aWFsbHkgZ2VuZXJhdGVkIGZyb20gYSBnbG9iYWwgdmFyaWFibGUuXG4gKi9cbmV4cG9ydCBjb25zdCB1aWQgPSAoKCkgPT4ge1xuICBsZXQgaWQgPSAwO1xuICByZXR1cm4gKCkgPT4gaWQrKztcbn0pKCk7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgbmVpdGhlciBudWxsIG5vciB1bmRlZmluZWQsIGVsc2UgcmV0dXJucyBmYWxzZS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICogQHNpbmNlIDIuNy4wXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc051bGxPclVuZGVmKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgbnVsbCB8IHVuZGVmaW5lZCB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGFuIGFycmF5IChpbmNsdWRpbmcgdHlwZWQgYXJyYXlzKSwgZWxzZSByZXR1cm5zIGZhbHNlLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHRlc3QuXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQXJyYXk8VCA9IHVua25vd24+KHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgVFtdIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCB0eXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHR5cGUuc2xpY2UoMCwgNykgPT09ICdbb2JqZWN0JyAmJiB0eXBlLnNsaWNlKC02KSA9PT0gJ0FycmF5XScpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0IChleGNsdWRpbmcgbnVsbCksIGVsc2UgcmV0dXJucyBmYWxzZS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICogQHNpbmNlIDIuNy4wXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIEFueU9iamVjdCB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBhIGZpbml0ZSBudW1iZXIsIGVsc2UgcmV0dXJucyBmYWxzZVxuICogQHBhcmFtIHZhbHVlICAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICovXG5mdW5jdGlvbiBpc051bWJlckZpbml0ZSh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIG51bWJlciB7XG4gIHJldHVybiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIE51bWJlcikgJiYgaXNGaW5pdGUoK3ZhbHVlKTtcbn1cbmV4cG9ydCB7XG4gIGlzTnVtYmVyRmluaXRlIGFzIGlzRmluaXRlLFxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGB2YWx1ZWAgaWYgZmluaXRlLCBlbHNlIHJldHVybnMgYGRlZmF1bHRWYWx1ZWAuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gcmV0dXJuIGlmIGRlZmluZWQuXG4gKiBAcGFyYW0gZGVmYXVsdFZhbHVlIC0gVGhlIHZhbHVlIHRvIHJldHVybiBpZiBgdmFsdWVgIGlzIG5vdCBmaW5pdGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5pdGVPckRlZmF1bHQodmFsdWU6IHVua25vd24sIGRlZmF1bHRWYWx1ZTogbnVtYmVyKSB7XG4gIHJldHVybiBpc051bWJlckZpbml0ZSh2YWx1ZSkgPyB2YWx1ZSA6IGRlZmF1bHRWYWx1ZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGB2YWx1ZWAgaWYgZGVmaW5lZCwgZWxzZSByZXR1cm5zIGBkZWZhdWx0VmFsdWVgLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHJldHVybiBpZiBkZWZpbmVkLlxuICogQHBhcmFtIGRlZmF1bHRWYWx1ZSAtIFRoZSB2YWx1ZSB0byByZXR1cm4gaWYgYHZhbHVlYCBpcyB1bmRlZmluZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWx1ZU9yRGVmYXVsdDxUPih2YWx1ZTogVCB8IHVuZGVmaW5lZCwgZGVmYXVsdFZhbHVlOiBUKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gZGVmYXVsdFZhbHVlIDogdmFsdWU7XG59XG5cbmV4cG9ydCBjb25zdCB0b1BlcmNlbnRhZ2UgPSAodmFsdWU6IG51bWJlciB8IHN0cmluZywgZGltZW5zaW9uOiBudW1iZXIpID0+XG4gIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUuZW5kc1dpdGgoJyUnKSA/XG4gICAgcGFyc2VGbG9hdCh2YWx1ZSkgLyAxMDBcbiAgICA6ICt2YWx1ZSAvIGRpbWVuc2lvbjtcblxuZXhwb3J0IGNvbnN0IHRvRGltZW5zaW9uID0gKHZhbHVlOiBudW1iZXIgfCBzdHJpbmcsIGRpbWVuc2lvbjogbnVtYmVyKSA9PlxuICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmVuZHNXaXRoKCclJykgP1xuICAgIHBhcnNlRmxvYXQodmFsdWUpIC8gMTAwICogZGltZW5zaW9uXG4gICAgOiArdmFsdWU7XG5cbi8qKlxuICogQ2FsbHMgYGZuYCB3aXRoIHRoZSBnaXZlbiBgYXJnc2AgaW4gdGhlIHNjb3BlIGRlZmluZWQgYnkgYHRoaXNBcmdgIGFuZCByZXR1cm5zIHRoZVxuICogdmFsdWUgcmV0dXJuZWQgYnkgYGZuYC4gSWYgYGZuYCBpcyBub3QgYSBmdW5jdGlvbiwgdGhpcyBtZXRob2QgcmV0dXJucyB1bmRlZmluZWQuXG4gKiBAcGFyYW0gZm4gLSBUaGUgZnVuY3Rpb24gdG8gY2FsbC5cbiAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyB3aXRoIHdoaWNoIGBmbmAgc2hvdWxkIGJlIGNhbGxlZC5cbiAqIEBwYXJhbSBbdGhpc0FyZ10gLSBUaGUgdmFsdWUgb2YgYHRoaXNgIHByb3ZpZGVkIGZvciB0aGUgY2FsbCB0byBgZm5gLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsbGJhY2s8VCBleHRlbmRzICh0aGlzOiBUQSwgLi4ucmVzdEFyZ3M6IHVua25vd25bXSkgPT4gUiwgVEEsIFI+KFxuICBmbjogVCB8IHVuZGVmaW5lZCxcbiAgYXJnczogdW5rbm93bltdLFxuICB0aGlzQXJnPzogVEFcbik6IFIgfCB1bmRlZmluZWQge1xuICBpZiAoZm4gJiYgdHlwZW9mIGZuLmNhbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJncyk7XG4gIH1cbn1cblxuLyoqXG4gKiBOb3RlKFNCKSBmb3IgcGVyZm9ybWFuY2Ugc2FrZSwgdGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgdXNlZCB3aGVuIGxvb3BhYmxlIHR5cGVcbiAqIGlzIHVua25vd24gb3IgaW4gbm9uZSBpbnRlbnNpdmUgY29kZSAobm90IGNhbGxlZCBvZnRlbiBhbmQgc21hbGwgbG9vcGFibGUpLiBFbHNlXG4gKiBpdCdzIHByZWZlcmFibGUgdG8gdXNlIGEgcmVndWxhciBmb3IoKSBsb29wIGFuZCBzYXZlIGV4dHJhIGZ1bmN0aW9uIGNhbGxzLlxuICogQHBhcmFtIGxvb3BhYmxlIC0gVGhlIG9iamVjdCBvciBhcnJheSB0byBiZSBpdGVyYXRlZC5cbiAqIEBwYXJhbSBmbiAtIFRoZSBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIGl0ZW0uXG4gKiBAcGFyYW0gW3RoaXNBcmddIC0gVGhlIHZhbHVlIG9mIGB0aGlzYCBwcm92aWRlZCBmb3IgdGhlIGNhbGwgdG8gYGZuYC5cbiAqIEBwYXJhbSBbcmV2ZXJzZV0gLSBJZiB0cnVlLCBpdGVyYXRlcyBiYWNrd2FyZCBvbiB0aGUgbG9vcGFibGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlYWNoPFQsIFRBPihcbiAgbG9vcGFibGU6IFJlY29yZDxzdHJpbmcsIFQ+LFxuICBmbjogKHRoaXM6IFRBLCB2OiBULCBpOiBzdHJpbmcpID0+IHZvaWQsXG4gIHRoaXNBcmc/OiBUQSxcbiAgcmV2ZXJzZT86IGJvb2xlYW5cbik6IHZvaWQ7XG5leHBvcnQgZnVuY3Rpb24gZWFjaDxULCBUQT4oXG4gIGxvb3BhYmxlOiBUW10sXG4gIGZuOiAodGhpczogVEEsIHY6IFQsIGk6IG51bWJlcikgPT4gdm9pZCxcbiAgdGhpc0FyZz86IFRBLFxuICByZXZlcnNlPzogYm9vbGVhblxuKTogdm9pZDtcbmV4cG9ydCBmdW5jdGlvbiBlYWNoPFQsIFRBPihcbiAgbG9vcGFibGU6IFRbXSB8IFJlY29yZDxzdHJpbmcsIFQ+LFxuICBmbjogKHRoaXM6IFRBLCB2OiBULCBpOiBhbnkpID0+IHZvaWQsXG4gIHRoaXNBcmc/OiBUQSxcbiAgcmV2ZXJzZT86IGJvb2xlYW5cbikge1xuICBsZXQgaTogbnVtYmVyLCBsZW46IG51bWJlciwga2V5czogc3RyaW5nW107XG4gIGlmIChpc0FycmF5KGxvb3BhYmxlKSkge1xuICAgIGxlbiA9IGxvb3BhYmxlLmxlbmd0aDtcbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgZm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtpXSwgaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBmbi5jYWxsKHRoaXNBcmcsIGxvb3BhYmxlW2ldLCBpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobG9vcGFibGUpKSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGxvb3BhYmxlKTtcbiAgICBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGZuLmNhbGwodGhpc0FyZywgbG9vcGFibGVba2V5c1tpXV0sIGtleXNbaV0pO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYGEwYCBhbmQgYGExYCBhcnJheXMgaGF2ZSB0aGUgc2FtZSBjb250ZW50LCBlbHNlIHJldHVybnMgZmFsc2UuXG4gKiBAcGFyYW0gYTAgLSBUaGUgYXJyYXkgdG8gY29tcGFyZVxuICogQHBhcmFtIGExIC0gVGhlIGFycmF5IHRvIGNvbXBhcmVcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZWxlbWVudHNFcXVhbChhMDogQWN0aXZlRGF0YVBvaW50W10sIGExOiBBY3RpdmVEYXRhUG9pbnRbXSkge1xuICBsZXQgaTogbnVtYmVyLCBpbGVuOiBudW1iZXIsIHYwOiBBY3RpdmVEYXRhUG9pbnQsIHYxOiBBY3RpdmVEYXRhUG9pbnQ7XG5cbiAgaWYgKCFhMCB8fCAhYTEgfHwgYTAubGVuZ3RoICE9PSBhMS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKGkgPSAwLCBpbGVuID0gYTAubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgdjAgPSBhMFtpXTtcbiAgICB2MSA9IGExW2ldO1xuXG4gICAgaWYgKHYwLmRhdGFzZXRJbmRleCAhPT0gdjEuZGF0YXNldEluZGV4IHx8IHYwLmluZGV4ICE9PSB2MS5pbmRleCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBkZWVwIGNvcHkgb2YgYHNvdXJjZWAgd2l0aG91dCBrZWVwaW5nIHJlZmVyZW5jZXMgb24gb2JqZWN0cyBhbmQgYXJyYXlzLlxuICogQHBhcmFtIHNvdXJjZSAtIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lPFQ+KHNvdXJjZTogVCk6IFQge1xuICBpZiAoaXNBcnJheShzb3VyY2UpKSB7XG4gICAgcmV0dXJuIHNvdXJjZS5tYXAoY2xvbmUpIGFzIHVua25vd24gYXMgVDtcbiAgfVxuXG4gIGlmIChpc09iamVjdChzb3VyY2UpKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICBjb25zdCBrbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgbGV0IGsgPSAwO1xuXG4gICAgZm9yICg7IGsgPCBrbGVuOyArK2spIHtcbiAgICAgIHRhcmdldFtrZXlzW2tdXSA9IGNsb25lKHNvdXJjZVtrZXlzW2tdXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIHJldHVybiBzb3VyY2U7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRLZXkoa2V5OiBzdHJpbmcpIHtcbiAgcmV0dXJuIFsnX19wcm90b19fJywgJ3Byb3RvdHlwZScsICdjb25zdHJ1Y3RvciddLmluZGV4T2Yoa2V5KSA9PT0gLTE7XG59XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgbWVyZ2VyIHdoZW4gQ2hhcnQuaGVscGVycy5tZXJnZSBpcyBjYWxsZWQgd2l0aG91dCBtZXJnZXIgb3B0aW9uLlxuICogTm90ZShTQik6IGFsc28gdXNlZCBieSBtZXJnZUNvbmZpZyBhbmQgbWVyZ2VTY2FsZUNvbmZpZyBhcyBmYWxsYmFjay5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfbWVyZ2VyKGtleTogc3RyaW5nLCB0YXJnZXQ6IEFueU9iamVjdCwgc291cmNlOiBBbnlPYmplY3QsIG9wdGlvbnM6IEFueU9iamVjdCkge1xuICBpZiAoIWlzVmFsaWRLZXkoa2V5KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHR2YWwgPSB0YXJnZXRba2V5XTtcbiAgY29uc3Qgc3ZhbCA9IHNvdXJjZVtrZXldO1xuXG4gIGlmIChpc09iamVjdCh0dmFsKSAmJiBpc09iamVjdChzdmFsKSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICBtZXJnZSh0dmFsLCBzdmFsLCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXRba2V5XSA9IGNsb25lKHN2YWwpO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWVyZ2VPcHRpb25zIHtcbiAgbWVyZ2VyPzogKGtleTogc3RyaW5nLCB0YXJnZXQ6IEFueU9iamVjdCwgc291cmNlOiBBbnlPYmplY3QsIG9wdGlvbnM/OiBBbnlPYmplY3QpID0+IHZvaWQ7XG59XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgZGVlcCBjb3BpZXMgYHNvdXJjZWAgcHJvcGVydGllcyBpbnRvIGB0YXJnZXRgIHdpdGggdGhlIGdpdmVuIGBvcHRpb25zYC5cbiAqIElNUE9SVEFOVDogYHRhcmdldGAgaXMgbm90IGNsb25lZCBhbmQgd2lsbCBiZSB1cGRhdGVkIHdpdGggYHNvdXJjZWAgcHJvcGVydGllcy5cbiAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG9iamVjdCBpbiB3aGljaCBhbGwgc291cmNlcyBhcmUgbWVyZ2VkIGludG8uXG4gKiBAcGFyYW0gc291cmNlIC0gT2JqZWN0KHMpIHRvIG1lcmdlIGludG8gYHRhcmdldGAuXG4gKiBAcGFyYW0gW29wdGlvbnNdIC0gTWVyZ2luZyBvcHRpb25zOlxuICogQHBhcmFtIFtvcHRpb25zLm1lcmdlcl0gLSBUaGUgbWVyZ2UgbWV0aG9kIChrZXksIHRhcmdldCwgc291cmNlLCBvcHRpb25zKVxuICogQHJldHVybnMgVGhlIGB0YXJnZXRgIG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlPFQ+KHRhcmdldDogVCwgc291cmNlOiBbXSwgb3B0aW9ucz86IE1lcmdlT3B0aW9ucyk6IFQ7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2U8VCwgUzE+KHRhcmdldDogVCwgc291cmNlOiBTMSwgb3B0aW9ucz86IE1lcmdlT3B0aW9ucyk6IFQgJiBTMTtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZTxULCBTMT4odGFyZ2V0OiBULCBzb3VyY2U6IFtTMV0sIG9wdGlvbnM/OiBNZXJnZU9wdGlvbnMpOiBUICYgUzE7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2U8VCwgUzEsIFMyPih0YXJnZXQ6IFQsIHNvdXJjZTogW1MxLCBTMl0sIG9wdGlvbnM/OiBNZXJnZU9wdGlvbnMpOiBUICYgUzEgJiBTMjtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZTxULCBTMSwgUzIsIFMzPih0YXJnZXQ6IFQsIHNvdXJjZTogW1MxLCBTMiwgUzNdLCBvcHRpb25zPzogTWVyZ2VPcHRpb25zKTogVCAmIFMxICYgUzIgJiBTMztcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZTxULCBTMSwgUzIsIFMzLCBTND4oXG4gIHRhcmdldDogVCxcbiAgc291cmNlOiBbUzEsIFMyLCBTMywgUzRdLFxuICBvcHRpb25zPzogTWVyZ2VPcHRpb25zXG4pOiBUICYgUzEgJiBTMiAmIFMzICYgUzQ7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2U8VD4odGFyZ2V0OiBULCBzb3VyY2U6IEFueU9iamVjdFtdLCBvcHRpb25zPzogTWVyZ2VPcHRpb25zKTogQW55T2JqZWN0O1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlPFQ+KHRhcmdldDogVCwgc291cmNlOiBBbnlPYmplY3RbXSwgb3B0aW9ucz86IE1lcmdlT3B0aW9ucyk6IEFueU9iamVjdCB7XG4gIGNvbnN0IHNvdXJjZXMgPSBpc0FycmF5KHNvdXJjZSkgPyBzb3VyY2UgOiBbc291cmNlXTtcbiAgY29uc3QgaWxlbiA9IHNvdXJjZXMubGVuZ3RoO1xuXG4gIGlmICghaXNPYmplY3QodGFyZ2V0KSkge1xuICAgIHJldHVybiB0YXJnZXQgYXMgQW55T2JqZWN0O1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IG1lcmdlciA9IG9wdGlvbnMubWVyZ2VyIHx8IF9tZXJnZXI7XG4gIGxldCBjdXJyZW50OiBBbnlPYmplY3Q7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBjdXJyZW50ID0gc291cmNlc1tpXTtcbiAgICBpZiAoIWlzT2JqZWN0KGN1cnJlbnQpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoY3VycmVudCk7XG4gICAgZm9yIChsZXQgayA9IDAsIGtsZW4gPSBrZXlzLmxlbmd0aDsgayA8IGtsZW47ICsraykge1xuICAgICAgbWVyZ2VyKGtleXNba10sIHRhcmdldCwgY3VycmVudCwgb3B0aW9ucyBhcyBBbnlPYmplY3QpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgZGVlcCBjb3BpZXMgYHNvdXJjZWAgcHJvcGVydGllcyBpbnRvIGB0YXJnZXRgICpvbmx5KiBpZiBub3QgZGVmaW5lZCBpbiB0YXJnZXQuXG4gKiBJTVBPUlRBTlQ6IGB0YXJnZXRgIGlzIG5vdCBjbG9uZWQgYW5kIHdpbGwgYmUgdXBkYXRlZCB3aXRoIGBzb3VyY2VgIHByb3BlcnRpZXMuXG4gKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIHRhcmdldCBvYmplY3QgaW4gd2hpY2ggYWxsIHNvdXJjZXMgYXJlIG1lcmdlZCBpbnRvLlxuICogQHBhcmFtIHNvdXJjZSAtIE9iamVjdChzKSB0byBtZXJnZSBpbnRvIGB0YXJnZXRgLlxuICogQHJldHVybnMgVGhlIGB0YXJnZXRgIG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSWY8VD4odGFyZ2V0OiBULCBzb3VyY2U6IFtdKTogVDtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUlmPFQsIFMxPih0YXJnZXQ6IFQsIHNvdXJjZTogUzEpOiBUICYgUzE7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VJZjxULCBTMT4odGFyZ2V0OiBULCBzb3VyY2U6IFtTMV0pOiBUICYgUzE7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VJZjxULCBTMSwgUzI+KHRhcmdldDogVCwgc291cmNlOiBbUzEsIFMyXSk6IFQgJiBTMSAmIFMyO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSWY8VCwgUzEsIFMyLCBTMz4odGFyZ2V0OiBULCBzb3VyY2U6IFtTMSwgUzIsIFMzXSk6IFQgJiBTMSAmIFMyICYgUzM7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VJZjxULCBTMSwgUzIsIFMzLCBTND4odGFyZ2V0OiBULCBzb3VyY2U6IFtTMSwgUzIsIFMzLCBTNF0pOiBUICYgUzEgJiBTMiAmIFMzICYgUzQ7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VJZjxUPih0YXJnZXQ6IFQsIHNvdXJjZTogQW55T2JqZWN0W10pOiBBbnlPYmplY3Q7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VJZjxUPih0YXJnZXQ6IFQsIHNvdXJjZTogQW55T2JqZWN0W10pOiBBbnlPYmplY3Qge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gIHJldHVybiBtZXJnZTxUPih0YXJnZXQsIHNvdXJjZSwge21lcmdlcjogX21lcmdlcklmfSk7XG59XG5cbi8qKlxuICogTWVyZ2VzIHNvdXJjZVtrZXldIGluIHRhcmdldFtrZXldIG9ubHkgaWYgdGFyZ2V0W2tleV0gaXMgdW5kZWZpbmVkLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9tZXJnZXJJZihrZXk6IHN0cmluZywgdGFyZ2V0OiBBbnlPYmplY3QsIHNvdXJjZTogQW55T2JqZWN0KSB7XG4gIGlmICghaXNWYWxpZEtleShrZXkpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgdHZhbCA9IHRhcmdldFtrZXldO1xuICBjb25zdCBzdmFsID0gc291cmNlW2tleV07XG5cbiAgaWYgKGlzT2JqZWN0KHR2YWwpICYmIGlzT2JqZWN0KHN2YWwpKSB7XG4gICAgbWVyZ2VJZih0dmFsLCBzdmFsKTtcbiAgfSBlbHNlIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwga2V5KSkge1xuICAgIHRhcmdldFtrZXldID0gY2xvbmUoc3ZhbCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2RlcHJlY2F0ZWQoc2NvcGU6IHN0cmluZywgdmFsdWU6IHVua25vd24sIHByZXZpb3VzOiBzdHJpbmcsIGN1cnJlbnQ6IHN0cmluZykge1xuICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnNvbGUud2FybihzY29wZSArICc6IFwiJyArIHByZXZpb3VzICtcbiAgICAgICdcIiBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFwiJyArIGN1cnJlbnQgKyAnXCIgaW5zdGVhZCcpO1xuICB9XG59XG5cbi8vIHJlc29sdmVPYmplY3RLZXkgcmVzb2x2ZXIgY2FjaGVcbmNvbnN0IGtleVJlc29sdmVycyA9IHtcbiAgLy8gQ2hhcnQuaGVscGVycy5jb3JlIHJlc29sdmVPYmplY3RLZXkgc2hvdWxkIHJlc29sdmUgZW1wdHkga2V5IHRvIHJvb3Qgb2JqZWN0XG4gICcnOiB2ID0+IHYsXG4gIC8vIGRlZmF1bHQgcmVzb2x2ZXJzXG4gIHg6IG8gPT4gby54LFxuICB5OiBvID0+IG8ueVxufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX3NwbGl0S2V5KGtleTogc3RyaW5nKSB7XG4gIGNvbnN0IHBhcnRzID0ga2V5LnNwbGl0KCcuJyk7XG4gIGNvbnN0IGtleXM6IHN0cmluZ1tdID0gW107XG4gIGxldCB0bXAgPSAnJztcbiAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgdG1wICs9IHBhcnQ7XG4gICAgaWYgKHRtcC5lbmRzV2l0aCgnXFxcXCcpKSB7XG4gICAgICB0bXAgPSB0bXAuc2xpY2UoMCwgLTEpICsgJy4nO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzLnB1c2godG1wKTtcbiAgICAgIHRtcCA9ICcnO1xuICAgIH1cbiAgfVxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gX2dldEtleVJlc29sdmVyKGtleTogc3RyaW5nKSB7XG4gIGNvbnN0IGtleXMgPSBfc3BsaXRLZXkoa2V5KTtcbiAgcmV0dXJuIG9iaiA9PiB7XG4gICAgZm9yIChjb25zdCBrIG9mIGtleXMpIHtcbiAgICAgIGlmIChrID09PSAnJykge1xuICAgICAgICAvLyBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eTpcbiAgICAgICAgLy8gQ2hhcnQuaGVscGVycy5jb3JlIHJlc29sdmVPYmplY3RLZXkgc2hvdWxkIGJyZWFrIGF0IGVtcHR5IGtleVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG9iaiA9IG9iaiAmJiBvYmpba107XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlT2JqZWN0S2V5KG9iajogQW55T2JqZWN0LCBrZXk6IHN0cmluZyk6IGFueSB7XG4gIGNvbnN0IHJlc29sdmVyID0ga2V5UmVzb2x2ZXJzW2tleV0gfHwgKGtleVJlc29sdmVyc1trZXldID0gX2dldEtleVJlc29sdmVyKGtleSkpO1xuICByZXR1cm4gcmVzb2x2ZXIob2JqKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2NhcGl0YWxpemUoc3RyOiBzdHJpbmcpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn1cblxuXG5leHBvcnQgY29uc3QgZGVmaW5lZCA9ICh2YWx1ZTogdW5rbm93bikgPT4gdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJztcblxuZXhwb3J0IGNvbnN0IGlzRnVuY3Rpb24gPSAodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyAoLi4uYXJnczogYW55W10pID0+IGFueSA9PiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG5cbi8vIEFkYXB0ZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zMTEyODg1NS9jb21wYXJpbmctZWNtYTYtc2V0cy1mb3ItZXF1YWxpdHkjMzExMjkzODRcbmV4cG9ydCBjb25zdCBzZXRzRXF1YWwgPSA8VD4oYTogU2V0PFQ+LCBiOiBTZXQ8VD4pID0+IHtcbiAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChjb25zdCBpdGVtIG9mIGEpIHtcbiAgICBpZiAoIWIuaGFzKGl0ZW0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEBwYXJhbSBlIC0gVGhlIGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2lzQ2xpY2tFdmVudChlOiBDaGFydEV2ZW50KSB7XG4gIHJldHVybiBlLnR5cGUgPT09ICdtb3VzZXVwJyB8fCBlLnR5cGUgPT09ICdjbGljaycgfHwgZS50eXBlID09PSAnY29udGV4dG1lbnUnO1xufVxuIiwiaW1wb3J0IHR5cGUge1BvaW50fSBmcm9tICcuLi90eXBlcy9nZW9tZXRyaWMuanMnO1xuaW1wb3J0IHtpc0Zpbml0ZSBhcyBpc0Zpbml0ZU51bWJlcn0gZnJvbSAnLi9oZWxwZXJzLmNvcmUuanMnO1xuXG4vKipcbiAqIEBhbGlhcyBDaGFydC5oZWxwZXJzLm1hdGhcbiAqIEBuYW1lc3BhY2VcbiAqL1xuXG5leHBvcnQgY29uc3QgUEkgPSBNYXRoLlBJO1xuZXhwb3J0IGNvbnN0IFRBVSA9IDIgKiBQSTtcbmV4cG9ydCBjb25zdCBQSVRBVSA9IFRBVSArIFBJO1xuZXhwb3J0IGNvbnN0IElORklOSVRZID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuZXhwb3J0IGNvbnN0IFJBRF9QRVJfREVHID0gUEkgLyAxODA7XG5leHBvcnQgY29uc3QgSEFMRl9QSSA9IFBJIC8gMjtcbmV4cG9ydCBjb25zdCBRVUFSVEVSX1BJID0gUEkgLyA0O1xuZXhwb3J0IGNvbnN0IFRXT19USElSRFNfUEkgPSBQSSAqIDIgLyAzO1xuXG5leHBvcnQgY29uc3QgbG9nMTAgPSBNYXRoLmxvZzEwO1xuZXhwb3J0IGNvbnN0IHNpZ24gPSBNYXRoLnNpZ247XG5cbmV4cG9ydCBmdW5jdGlvbiBhbG1vc3RFcXVhbHMoeDogbnVtYmVyLCB5OiBudW1iZXIsIGVwc2lsb246IG51bWJlcikge1xuICByZXR1cm4gTWF0aC5hYnMoeCAtIHkpIDwgZXBzaWxvbjtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgbmljZSBudW1iZXIgYWxnb3JpdGhtIHVzZWQgaW4gZGV0ZXJtaW5pbmcgd2hlcmUgYXhpcyBsYWJlbHMgd2lsbCBnb1xuICovXG5leHBvcnQgZnVuY3Rpb24gbmljZU51bShyYW5nZTogbnVtYmVyKSB7XG4gIGNvbnN0IHJvdW5kZWRSYW5nZSA9IE1hdGgucm91bmQocmFuZ2UpO1xuICByYW5nZSA9IGFsbW9zdEVxdWFscyhyYW5nZSwgcm91bmRlZFJhbmdlLCByYW5nZSAvIDEwMDApID8gcm91bmRlZFJhbmdlIDogcmFuZ2U7XG4gIGNvbnN0IG5pY2VSYW5nZSA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKHJhbmdlKSkpO1xuICBjb25zdCBmcmFjdGlvbiA9IHJhbmdlIC8gbmljZVJhbmdlO1xuICBjb25zdCBuaWNlRnJhY3Rpb24gPSBmcmFjdGlvbiA8PSAxID8gMSA6IGZyYWN0aW9uIDw9IDIgPyAyIDogZnJhY3Rpb24gPD0gNSA/IDUgOiAxMDtcbiAgcmV0dXJuIG5pY2VGcmFjdGlvbiAqIG5pY2VSYW5nZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIGZhY3RvcnMgc29ydGVkIGZyb20gMSB0byBzcXJ0KHZhbHVlKVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9mYWN0b3JpemUodmFsdWU6IG51bWJlcikge1xuICBjb25zdCByZXN1bHQ6IG51bWJlcltdID0gW107XG4gIGNvbnN0IHNxcnQgPSBNYXRoLnNxcnQodmFsdWUpO1xuICBsZXQgaTogbnVtYmVyO1xuXG4gIGZvciAoaSA9IDE7IGkgPCBzcXJ0OyBpKyspIHtcbiAgICBpZiAodmFsdWUgJSBpID09PSAwKSB7XG4gICAgICByZXN1bHQucHVzaChpKTtcbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlIC8gaSk7XG4gICAgfVxuICB9XG4gIGlmIChzcXJ0ID09PSAoc3FydCB8IDApKSB7IC8vIGlmIHZhbHVlIGlzIGEgc3F1YXJlIG51bWJlclxuICAgIHJlc3VsdC5wdXNoKHNxcnQpO1xuICB9XG5cbiAgcmVzdWx0LnNvcnQoKGEsIGIpID0+IGEgLSBiKS5wb3AoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBWZXJpZmllcyB0aGF0IGF0dGVtcHRpbmcgdG8gY29lcmNlIG4gdG8gc3RyaW5nIG9yIG51bWJlciB3b24ndCB0aHJvdyBhIFR5cGVFcnJvci5cbiAqL1xuZnVuY3Rpb24gaXNOb25QcmltaXRpdmUobjogdW5rbm93bikge1xuICByZXR1cm4gdHlwZW9mIG4gPT09ICdzeW1ib2wnIHx8ICh0eXBlb2YgbiA9PT0gJ29iamVjdCcgJiYgbiAhPT0gbnVsbCAmJiAhKFN5bWJvbC50b1ByaW1pdGl2ZSBpbiBuIHx8ICd0b1N0cmluZycgaW4gbiB8fCAndmFsdWVPZicgaW4gbikpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNOdW1iZXIobjogdW5rbm93bik6IG4gaXMgbnVtYmVyIHtcbiAgcmV0dXJuICFpc05vblByaW1pdGl2ZShuKSAmJiAhaXNOYU4ocGFyc2VGbG9hdChuIGFzIHN0cmluZykpICYmIGlzRmluaXRlKG4gYXMgbnVtYmVyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFsbW9zdFdob2xlKHg6IG51bWJlciwgZXBzaWxvbjogbnVtYmVyKSB7XG4gIGNvbnN0IHJvdW5kZWQgPSBNYXRoLnJvdW5kKHgpO1xuICByZXR1cm4gKChyb3VuZGVkIC0gZXBzaWxvbikgPD0geCkgJiYgKChyb3VuZGVkICsgZXBzaWxvbikgPj0geCk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9zZXRNaW5BbmRNYXhCeUtleShcbiAgYXJyYXk6IFJlY29yZDxzdHJpbmcsIG51bWJlcj5bXSxcbiAgdGFyZ2V0OiB7IG1pbjogbnVtYmVyLCBtYXg6IG51bWJlciB9LFxuICBwcm9wZXJ0eTogc3RyaW5nXG4pIHtcbiAgbGV0IGk6IG51bWJlciwgaWxlbjogbnVtYmVyLCB2YWx1ZTogbnVtYmVyO1xuXG4gIGZvciAoaSA9IDAsIGlsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICB2YWx1ZSA9IGFycmF5W2ldW3Byb3BlcnR5XTtcbiAgICBpZiAoIWlzTmFOKHZhbHVlKSkge1xuICAgICAgdGFyZ2V0Lm1pbiA9IE1hdGgubWluKHRhcmdldC5taW4sIHZhbHVlKTtcbiAgICAgIHRhcmdldC5tYXggPSBNYXRoLm1heCh0YXJnZXQubWF4LCB2YWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b1JhZGlhbnMoZGVncmVlczogbnVtYmVyKSB7XG4gIHJldHVybiBkZWdyZWVzICogKFBJIC8gMTgwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvRGVncmVlcyhyYWRpYW5zOiBudW1iZXIpIHtcbiAgcmV0dXJuIHJhZGlhbnMgKiAoMTgwIC8gUEkpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlc1xuICogaS5lLiB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBhZnRlciB0aGUgZGVjaW1hbCBwb2ludCwgb2YgdGhlIHZhbHVlIG9mIHRoaXMgTnVtYmVyLlxuICogQHBhcmFtIHggLSBBIG51bWJlci5cbiAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2RlY2ltYWxQbGFjZXMoeDogbnVtYmVyKSB7XG4gIGlmICghaXNGaW5pdGVOdW1iZXIoeCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IGUgPSAxO1xuICBsZXQgcCA9IDA7XG4gIHdoaWxlIChNYXRoLnJvdW5kKHggKiBlKSAvIGUgIT09IHgpIHtcbiAgICBlICo9IDEwO1xuICAgIHArKztcbiAgfVxuICByZXR1cm4gcDtcbn1cblxuLy8gR2V0cyB0aGUgYW5nbGUgZnJvbSB2ZXJ0aWNhbCB1cHJpZ2h0IHRvIHRoZSBwb2ludCBhYm91dCBhIGNlbnRyZS5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbmdsZUZyb21Qb2ludChcbiAgY2VudHJlUG9pbnQ6IFBvaW50LFxuICBhbmdsZVBvaW50OiBQb2ludFxuKSB7XG4gIGNvbnN0IGRpc3RhbmNlRnJvbVhDZW50ZXIgPSBhbmdsZVBvaW50LnggLSBjZW50cmVQb2ludC54O1xuICBjb25zdCBkaXN0YW5jZUZyb21ZQ2VudGVyID0gYW5nbGVQb2ludC55IC0gY2VudHJlUG9pbnQueTtcbiAgY29uc3QgcmFkaWFsRGlzdGFuY2VGcm9tQ2VudGVyID0gTWF0aC5zcXJ0KGRpc3RhbmNlRnJvbVhDZW50ZXIgKiBkaXN0YW5jZUZyb21YQ2VudGVyICsgZGlzdGFuY2VGcm9tWUNlbnRlciAqIGRpc3RhbmNlRnJvbVlDZW50ZXIpO1xuXG4gIGxldCBhbmdsZSA9IE1hdGguYXRhbjIoZGlzdGFuY2VGcm9tWUNlbnRlciwgZGlzdGFuY2VGcm9tWENlbnRlcik7XG5cbiAgaWYgKGFuZ2xlIDwgKC0wLjUgKiBQSSkpIHtcbiAgICBhbmdsZSArPSBUQVU7IC8vIG1ha2Ugc3VyZSB0aGUgcmV0dXJuZWQgYW5nbGUgaXMgaW4gdGhlIHJhbmdlIG9mICgtUEkvMiwgM1BJLzJdXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGFuZ2xlLFxuICAgIGRpc3RhbmNlOiByYWRpYWxEaXN0YW5jZUZyb21DZW50ZXJcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpc3RhbmNlQmV0d2VlblBvaW50cyhwdDE6IFBvaW50LCBwdDI6IFBvaW50KSB7XG4gIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3cocHQyLnggLSBwdDEueCwgMikgKyBNYXRoLnBvdyhwdDIueSAtIHB0MS55LCAyKSk7XG59XG5cbi8qKlxuICogU2hvcnRlc3QgZGlzdGFuY2UgYmV0d2VlbiBhbmdsZXMsIGluIGVpdGhlciBkaXJlY3Rpb24uXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2FuZ2xlRGlmZihhOiBudW1iZXIsIGI6IG51bWJlcikge1xuICByZXR1cm4gKGEgLSBiICsgUElUQVUpICUgVEFVIC0gUEk7XG59XG5cbi8qKlxuICogTm9ybWFsaXplIGFuZ2xlIHRvIGJlIGJldHdlZW4gMCBhbmQgMipQSVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9ub3JtYWxpemVBbmdsZShhOiBudW1iZXIpIHtcbiAgcmV0dXJuIChhICUgVEFVICsgVEFVKSAlIFRBVTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2FuZ2xlQmV0d2VlbihhbmdsZTogbnVtYmVyLCBzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlciwgc2FtZUFuZ2xlSXNGdWxsQ2lyY2xlPzogYm9vbGVhbikge1xuICBjb25zdCBhID0gX25vcm1hbGl6ZUFuZ2xlKGFuZ2xlKTtcbiAgY29uc3QgcyA9IF9ub3JtYWxpemVBbmdsZShzdGFydCk7XG4gIGNvbnN0IGUgPSBfbm9ybWFsaXplQW5nbGUoZW5kKTtcbiAgY29uc3QgYW5nbGVUb1N0YXJ0ID0gX25vcm1hbGl6ZUFuZ2xlKHMgLSBhKTtcbiAgY29uc3QgYW5nbGVUb0VuZCA9IF9ub3JtYWxpemVBbmdsZShlIC0gYSk7XG4gIGNvbnN0IHN0YXJ0VG9BbmdsZSA9IF9ub3JtYWxpemVBbmdsZShhIC0gcyk7XG4gIGNvbnN0IGVuZFRvQW5nbGUgPSBfbm9ybWFsaXplQW5nbGUoYSAtIGUpO1xuICByZXR1cm4gYSA9PT0gcyB8fCBhID09PSBlIHx8IChzYW1lQW5nbGVJc0Z1bGxDaXJjbGUgJiYgcyA9PT0gZSlcbiAgICB8fCAoYW5nbGVUb1N0YXJ0ID4gYW5nbGVUb0VuZCAmJiBzdGFydFRvQW5nbGUgPCBlbmRUb0FuZ2xlKTtcbn1cblxuLyoqXG4gKiBMaW1pdCBgdmFsdWVgIGJldHdlZW4gYG1pbmAgYW5kIGBtYXhgXG4gKiBAcGFyYW0gdmFsdWVcbiAqIEBwYXJhbSBtaW5cbiAqIEBwYXJhbSBtYXhcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfbGltaXRWYWx1ZSh2YWx1ZTogbnVtYmVyLCBtaW46IG51bWJlciwgbWF4OiBudW1iZXIpIHtcbiAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB2YWx1ZSkpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9pbnQxNlJhbmdlKHZhbHVlOiBudW1iZXIpIHtcbiAgcmV0dXJuIF9saW1pdFZhbHVlKHZhbHVlLCAtMzI3NjgsIDMyNzY3KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gdmFsdWVcbiAqIEBwYXJhbSBzdGFydFxuICogQHBhcmFtIGVuZFxuICogQHBhcmFtIFtlcHNpbG9uXVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9pc0JldHdlZW4odmFsdWU6IG51bWJlciwgc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIsIGVwc2lsb24gPSAxZS02KSB7XG4gIHJldHVybiB2YWx1ZSA+PSBNYXRoLm1pbihzdGFydCwgZW5kKSAtIGVwc2lsb24gJiYgdmFsdWUgPD0gTWF0aC5tYXgoc3RhcnQsIGVuZCkgKyBlcHNpbG9uO1xufVxuIiwiaW1wb3J0IHtfY2FwaXRhbGl6ZX0gZnJvbSAnLi9oZWxwZXJzLmNvcmUuanMnO1xuXG4vKipcbiAqIEJpbmFyeSBzZWFyY2hcbiAqIEBwYXJhbSB0YWJsZSAtIHRoZSB0YWJsZSBzZWFyY2guIG11c3QgYmUgc29ydGVkIVxuICogQHBhcmFtIHZhbHVlIC0gdmFsdWUgdG8gZmluZFxuICogQHBhcmFtIGNtcFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9sb29rdXAoXG4gIHRhYmxlOiBudW1iZXJbXSxcbiAgdmFsdWU6IG51bWJlcixcbiAgY21wPzogKHZhbHVlOiBudW1iZXIpID0+IGJvb2xlYW5cbik6IHtsbzogbnVtYmVyLCBoaTogbnVtYmVyfTtcbmV4cG9ydCBmdW5jdGlvbiBfbG9va3VwPFQ+KFxuICB0YWJsZTogVFtdLFxuICB2YWx1ZTogbnVtYmVyLFxuICBjbXA6ICh2YWx1ZTogbnVtYmVyKSA9PiBib29sZWFuXG4pOiB7bG86IG51bWJlciwgaGk6IG51bWJlcn07XG5leHBvcnQgZnVuY3Rpb24gX2xvb2t1cChcbiAgdGFibGU6IHVua25vd25bXSxcbiAgdmFsdWU6IG51bWJlcixcbiAgY21wPzogKHZhbHVlOiBudW1iZXIpID0+IGJvb2xlYW5cbikge1xuICBjbXAgPSBjbXAgfHwgKChpbmRleCkgPT4gdGFibGVbaW5kZXhdIDwgdmFsdWUpO1xuICBsZXQgaGkgPSB0YWJsZS5sZW5ndGggLSAxO1xuICBsZXQgbG8gPSAwO1xuICBsZXQgbWlkOiBudW1iZXI7XG5cbiAgd2hpbGUgKGhpIC0gbG8gPiAxKSB7XG4gICAgbWlkID0gKGxvICsgaGkpID4+IDE7XG4gICAgaWYgKGNtcChtaWQpKSB7XG4gICAgICBsbyA9IG1pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgaGkgPSBtaWQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtsbywgaGl9O1xufVxuXG4vKipcbiAqIEJpbmFyeSBzZWFyY2hcbiAqIEBwYXJhbSB0YWJsZSAtIHRoZSB0YWJsZSBzZWFyY2guIG11c3QgYmUgc29ydGVkIVxuICogQHBhcmFtIGtleSAtIHByb3BlcnR5IG5hbWUgZm9yIHRoZSB2YWx1ZSBpbiBlYWNoIGVudHJ5XG4gKiBAcGFyYW0gdmFsdWUgLSB2YWx1ZSB0byBmaW5kXG4gKiBAcGFyYW0gbGFzdCAtIGxvb2t1cCBsYXN0IGluZGV4XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgX2xvb2t1cEJ5S2V5ID0gKFxuICB0YWJsZTogUmVjb3JkPHN0cmluZywgbnVtYmVyPltdLFxuICBrZXk6IHN0cmluZyxcbiAgdmFsdWU6IG51bWJlcixcbiAgbGFzdD86IGJvb2xlYW5cbikgPT5cbiAgX2xvb2t1cCh0YWJsZSwgdmFsdWUsIGxhc3RcbiAgICA/IGluZGV4ID0+IHtcbiAgICAgIGNvbnN0IHRpID0gdGFibGVbaW5kZXhdW2tleV07XG4gICAgICByZXR1cm4gdGkgPCB2YWx1ZSB8fCB0aSA9PT0gdmFsdWUgJiYgdGFibGVbaW5kZXggKyAxXVtrZXldID09PSB2YWx1ZTtcbiAgICB9XG4gICAgOiBpbmRleCA9PiB0YWJsZVtpbmRleF1ba2V5XSA8IHZhbHVlKTtcblxuLyoqXG4gKiBSZXZlcnNlIGJpbmFyeSBzZWFyY2hcbiAqIEBwYXJhbSB0YWJsZSAtIHRoZSB0YWJsZSBzZWFyY2guIG11c3QgYmUgc29ydGVkIVxuICogQHBhcmFtIGtleSAtIHByb3BlcnR5IG5hbWUgZm9yIHRoZSB2YWx1ZSBpbiBlYWNoIGVudHJ5XG4gKiBAcGFyYW0gdmFsdWUgLSB2YWx1ZSB0byBmaW5kXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgX3Jsb29rdXBCeUtleSA9IChcbiAgdGFibGU6IFJlY29yZDxzdHJpbmcsIG51bWJlcj5bXSxcbiAga2V5OiBzdHJpbmcsXG4gIHZhbHVlOiBudW1iZXJcbikgPT5cbiAgX2xvb2t1cCh0YWJsZSwgdmFsdWUsIGluZGV4ID0+IHRhYmxlW2luZGV4XVtrZXldID49IHZhbHVlKTtcblxuLyoqXG4gKiBSZXR1cm4gc3Vic2V0IG9mIGB2YWx1ZXNgIGJldHdlZW4gYG1pbmAgYW5kIGBtYXhgIGluY2x1c2l2ZS5cbiAqIFZhbHVlcyBhcmUgYXNzdW1lZCB0byBiZSBpbiBzb3J0ZWQgb3JkZXIuXG4gKiBAcGFyYW0gdmFsdWVzIC0gc29ydGVkIGFycmF5IG9mIHZhbHVlc1xuICogQHBhcmFtIG1pbiAtIG1pbiB2YWx1ZVxuICogQHBhcmFtIG1heCAtIG1heCB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2ZpbHRlckJldHdlZW4odmFsdWVzOiBudW1iZXJbXSwgbWluOiBudW1iZXIsIG1heDogbnVtYmVyKSB7XG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBlbmQgPSB2YWx1ZXMubGVuZ3RoO1xuXG4gIHdoaWxlIChzdGFydCA8IGVuZCAmJiB2YWx1ZXNbc3RhcnRdIDwgbWluKSB7XG4gICAgc3RhcnQrKztcbiAgfVxuICB3aGlsZSAoZW5kID4gc3RhcnQgJiYgdmFsdWVzW2VuZCAtIDFdID4gbWF4KSB7XG4gICAgZW5kLS07XG4gIH1cblxuICByZXR1cm4gc3RhcnQgPiAwIHx8IGVuZCA8IHZhbHVlcy5sZW5ndGhcbiAgICA/IHZhbHVlcy5zbGljZShzdGFydCwgZW5kKVxuICAgIDogdmFsdWVzO1xufVxuXG5jb25zdCBhcnJheUV2ZW50cyA9IFsncHVzaCcsICdwb3AnLCAnc2hpZnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXSBhcyBjb25zdDtcblxuZXhwb3J0IGludGVyZmFjZSBBcnJheUxpc3RlbmVyPFQ+IHtcbiAgX29uRGF0YVB1c2g/KC4uLml0ZW06IFRbXSk6IHZvaWQ7XG4gIF9vbkRhdGFQb3A/KCk6IHZvaWQ7XG4gIF9vbkRhdGFTaGlmdD8oKTogdm9pZDtcbiAgX29uRGF0YVNwbGljZT8oaW5kZXg6IG51bWJlciwgZGVsZXRlQ291bnQ6IG51bWJlciwgLi4uaXRlbXM6IFRbXSk6IHZvaWQ7XG4gIF9vbkRhdGFVbnNoaWZ0PyguLi5pdGVtOiBUW10pOiB2b2lkO1xufVxuXG4vKipcbiAqIEhvb2tzIHRoZSBhcnJheSBtZXRob2RzIHRoYXQgYWRkIG9yIHJlbW92ZSB2YWx1ZXMgKCdwdXNoJywgcG9wJywgJ3NoaWZ0JywgJ3NwbGljZScsXG4gKiAndW5zaGlmdCcpIGFuZCBub3RpZnkgdGhlIGxpc3RlbmVyIEFGVEVSIHRoZSBhcnJheSBoYXMgYmVlbiBhbHRlcmVkLiBMaXN0ZW5lcnMgYXJlXG4gKiBjYWxsZWQgb24gdGhlICdfb25EYXRhKicgY2FsbGJhY2tzIChlLmcuIF9vbkRhdGFQdXNoLCBldGMuKSB3aXRoIHNhbWUgYXJndW1lbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGlzdGVuQXJyYXlFdmVudHM8VD4oYXJyYXk6IFRbXSwgbGlzdGVuZXI6IEFycmF5TGlzdGVuZXI8VD4pOiB2b2lkO1xuZXhwb3J0IGZ1bmN0aW9uIGxpc3RlbkFycmF5RXZlbnRzKGFycmF5LCBsaXN0ZW5lcikge1xuICBpZiAoYXJyYXkuX2NoYXJ0anMpIHtcbiAgICBhcnJheS5fY2hhcnRqcy5saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFycmF5LCAnX2NoYXJ0anMnLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiB7XG4gICAgICBsaXN0ZW5lcnM6IFtsaXN0ZW5lcl1cbiAgICB9XG4gIH0pO1xuXG4gIGFycmF5RXZlbnRzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGNvbnN0IG1ldGhvZCA9ICdfb25EYXRhJyArIF9jYXBpdGFsaXplKGtleSk7XG4gICAgY29uc3QgYmFzZSA9IGFycmF5W2tleV07XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXJyYXksIGtleSwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZSguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJhc2UuYXBwbHkodGhpcywgYXJncyk7XG5cbiAgICAgICAgYXJyYXkuX2NoYXJ0anMubGlzdGVuZXJzLmZvckVhY2goKG9iamVjdCkgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0W21ldGhvZF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9iamVjdFttZXRob2RdKC4uLmFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBnaXZlbiBhcnJheSBldmVudCBsaXN0ZW5lciBhbmQgY2xlYW51cCBleHRyYSBhdHRhY2hlZCBwcm9wZXJ0aWVzIChzdWNoIGFzXG4gKiB0aGUgX2NoYXJ0anMgc3R1YiBhbmQgb3ZlcnJpZGRlbiBtZXRob2RzKSBpZiBhcnJheSBkb2Vzbid0IGhhdmUgYW55IG1vcmUgbGlzdGVuZXJzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5saXN0ZW5BcnJheUV2ZW50czxUPihhcnJheTogVFtdLCBsaXN0ZW5lcjogQXJyYXlMaXN0ZW5lcjxUPik6IHZvaWQ7XG5leHBvcnQgZnVuY3Rpb24gdW5saXN0ZW5BcnJheUV2ZW50cyhhcnJheSwgbGlzdGVuZXIpIHtcbiAgY29uc3Qgc3R1YiA9IGFycmF5Ll9jaGFydGpzO1xuICBpZiAoIXN0dWIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBsaXN0ZW5lcnMgPSBzdHViLmxpc3RlbmVycztcbiAgY29uc3QgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxuXG4gIGlmIChsaXN0ZW5lcnMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGFycmF5RXZlbnRzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGRlbGV0ZSBhcnJheVtrZXldO1xuICB9KTtcblxuICBkZWxldGUgYXJyYXkuX2NoYXJ0anM7XG59XG5cbi8qKlxuICogQHBhcmFtIGl0ZW1zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYXJyYXlVbmlxdWU8VD4oaXRlbXM6IFRbXSkge1xuICBjb25zdCBzZXQgPSBuZXcgU2V0PFQ+KGl0ZW1zKTtcblxuICBpZiAoc2V0LnNpemUgPT09IGl0ZW1zLmxlbmd0aCkge1xuICAgIHJldHVybiBpdGVtcztcbiAgfVxuXG4gIHJldHVybiBBcnJheS5mcm9tKHNldCk7XG59XG4iLCJpbXBvcnQgdHlwZSB7Q2hhcnRNZXRhLCBQb2ludEVsZW1lbnR9IGZyb20gJy4uL3R5cGVzL2luZGV4LmpzJztcblxuaW1wb3J0IHtfbGltaXRWYWx1ZX0gZnJvbSAnLi9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IHtfbG9va3VwQnlLZXl9IGZyb20gJy4vaGVscGVycy5jb2xsZWN0aW9uLmpzJztcbmltcG9ydCB7aXNOdWxsT3JVbmRlZn0gZnJvbSAnLi9oZWxwZXJzLmNvcmUuanMnO1xuXG5leHBvcnQgZnVuY3Rpb24gZm9udFN0cmluZyhwaXhlbFNpemU6IG51bWJlciwgZm9udFN0eWxlOiBzdHJpbmcsIGZvbnRGYW1pbHk6IHN0cmluZykge1xuICByZXR1cm4gZm9udFN0eWxlICsgJyAnICsgcGl4ZWxTaXplICsgJ3B4ICcgKyBmb250RmFtaWx5O1xufVxuXG4vKipcbiogUmVxdWVzdCBhbmltYXRpb24gcG9seWZpbGxcbiovXG5leHBvcnQgY29uc3QgcmVxdWVzdEFuaW1GcmFtZSA9IChmdW5jdGlvbigpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xufSgpKTtcblxuLyoqXG4gKiBUaHJvdHRsZXMgY2FsbGluZyBgZm5gIG9uY2UgcGVyIGFuaW1hdGlvbiBmcmFtZVxuICogTGF0ZXN0IGFyZ3VtZW50cyBhcmUgdXNlZCBvbiB0aGUgYWN0dWFsIGNhbGxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRocm90dGxlZDxUQXJncyBleHRlbmRzIEFycmF5PGFueT4+KFxuICBmbjogKC4uLmFyZ3M6IFRBcmdzKSA9PiB2b2lkLFxuICB0aGlzQXJnOiBhbnksXG4pIHtcbiAgbGV0IGFyZ3NUb1VzZSA9IFtdIGFzIFRBcmdzO1xuICBsZXQgdGlja2luZyA9IGZhbHNlO1xuXG4gIHJldHVybiBmdW5jdGlvbiguLi5hcmdzOiBUQXJncykge1xuICAgIC8vIFNhdmUgdGhlIGFyZ3MgZm9yIHVzZSBsYXRlclxuICAgIGFyZ3NUb1VzZSA9IGFyZ3M7XG4gICAgaWYgKCF0aWNraW5nKSB7XG4gICAgICB0aWNraW5nID0gdHJ1ZTtcbiAgICAgIHJlcXVlc3RBbmltRnJhbWUuY2FsbCh3aW5kb3csICgpID0+IHtcbiAgICAgICAgdGlja2luZyA9IGZhbHNlO1xuICAgICAgICBmbi5hcHBseSh0aGlzQXJnLCBhcmdzVG9Vc2UpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIERlYm91bmNlcyBjYWxsaW5nIGBmbmAgZm9yIGBkZWxheWAgbXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlYm91bmNlPFRBcmdzIGV4dGVuZHMgQXJyYXk8YW55Pj4oZm46ICguLi5hcmdzOiBUQXJncykgPT4gdm9pZCwgZGVsYXk6IG51bWJlcikge1xuICBsZXQgdGltZW91dDtcbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3M6IFRBcmdzKSB7XG4gICAgaWYgKGRlbGF5KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmbiwgZGVsYXksIGFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlbGF5O1xuICB9O1xufVxuXG4vKipcbiAqIENvbnZlcnRzICdzdGFydCcgdG8gJ2xlZnQnLCAnZW5kJyB0byAncmlnaHQnIGFuZCBvdGhlcnMgdG8gJ2NlbnRlcidcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBfdG9MZWZ0UmlnaHRDZW50ZXIgPSAoYWxpZ246ICdzdGFydCcgfCAnZW5kJyB8ICdjZW50ZXInKSA9PiBhbGlnbiA9PT0gJ3N0YXJ0JyA/ICdsZWZ0JyA6IGFsaWduID09PSAnZW5kJyA/ICdyaWdodCcgOiAnY2VudGVyJztcblxuLyoqXG4gKiBSZXR1cm5zIGBzdGFydGAsIGBlbmRgIG9yIGAoc3RhcnQgKyBlbmQpIC8gMmAgZGVwZW5kaW5nIG9uIGBhbGlnbmAuIERlZmF1bHRzIHRvIGBjZW50ZXJgXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgX2FsaWduU3RhcnRFbmQgPSAoYWxpZ246ICdzdGFydCcgfCAnZW5kJyB8ICdjZW50ZXInLCBzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcikgPT4gYWxpZ24gPT09ICdzdGFydCcgPyBzdGFydCA6IGFsaWduID09PSAnZW5kJyA/IGVuZCA6IChzdGFydCArIGVuZCkgLyAyO1xuXG4vKipcbiAqIFJldHVybnMgYGxlZnRgLCBgcmlnaHRgIG9yIGAobGVmdCArIHJpZ2h0KSAvIDJgIGRlcGVuZGluZyBvbiBgYWxpZ25gLiBEZWZhdWx0cyB0byBgbGVmdGBcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBfdGV4dFggPSAoYWxpZ246ICdsZWZ0JyB8ICdyaWdodCcgfCAnY2VudGVyJywgbGVmdDogbnVtYmVyLCByaWdodDogbnVtYmVyLCBydGw6IGJvb2xlYW4pID0+IHtcbiAgY29uc3QgY2hlY2sgPSBydGwgPyAnbGVmdCcgOiAncmlnaHQnO1xuICByZXR1cm4gYWxpZ24gPT09IGNoZWNrID8gcmlnaHQgOiBhbGlnbiA9PT0gJ2NlbnRlcicgPyAobGVmdCArIHJpZ2h0KSAvIDIgOiBsZWZ0O1xufTtcblxuLyoqXG4gKiBSZXR1cm4gc3RhcnQgYW5kIGNvdW50IG9mIHZpc2libGUgcG9pbnRzLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9nZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzKG1ldGE6IENoYXJ0TWV0YTwnbGluZScgfCAnc2NhdHRlcic+LCBwb2ludHM6IFBvaW50RWxlbWVudFtdLCBhbmltYXRpb25zRGlzYWJsZWQ6IGJvb2xlYW4pIHtcbiAgY29uc3QgcG9pbnRDb3VudCA9IHBvaW50cy5sZW5ndGg7XG5cbiAgbGV0IHN0YXJ0ID0gMDtcbiAgbGV0IGNvdW50ID0gcG9pbnRDb3VudDtcblxuICBpZiAobWV0YS5fc29ydGVkKSB7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlLCBfcGFyc2VkfSA9IG1ldGE7XG4gICAgY29uc3Qgc3BhbkdhcHMgPSBtZXRhLmRhdGFzZXQgPyBtZXRhLmRhdGFzZXQub3B0aW9ucyA/IG1ldGEuZGF0YXNldC5vcHRpb25zLnNwYW5HYXBzIDogbnVsbCA6IG51bGw7XG4gICAgY29uc3QgYXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSBpU2NhbGUuZ2V0VXNlckJvdW5kcygpO1xuXG4gICAgaWYgKG1pbkRlZmluZWQpIHtcbiAgICAgIHN0YXJ0ID0gTWF0aC5taW4oXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgTmVlZCB0byB0eXBlIF9wYXJzZWRcbiAgICAgICAgX2xvb2t1cEJ5S2V5KF9wYXJzZWQsIGF4aXMsIG1pbikubG8sXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgTmVlZCB0byBmaXggdHlwZXMgb24gX2xvb2t1cEJ5S2V5XG4gICAgICAgIGFuaW1hdGlvbnNEaXNhYmxlZCA/IHBvaW50Q291bnQgOiBfbG9va3VwQnlLZXkocG9pbnRzLCBheGlzLCBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShtaW4pKS5sbyk7XG4gICAgICBpZiAoc3BhbkdhcHMpIHtcbiAgICAgICAgY29uc3QgZGlzdGFuY2VUb0RlZmluZWRMbyA9IChfcGFyc2VkXG4gICAgICAgICAgLnNsaWNlKDAsIHN0YXJ0ICsgMSlcbiAgICAgICAgICAucmV2ZXJzZSgpXG4gICAgICAgICAgLmZpbmRJbmRleChcbiAgICAgICAgICAgIHBvaW50ID0+ICFpc051bGxPclVuZGVmKHBvaW50W3ZTY2FsZS5heGlzXSkpKTtcbiAgICAgICAgc3RhcnQgLT0gTWF0aC5tYXgoMCwgZGlzdGFuY2VUb0RlZmluZWRMbyk7XG4gICAgICB9XG4gICAgICBzdGFydCA9IF9saW1pdFZhbHVlKHN0YXJ0LCAwLCBwb2ludENvdW50IC0gMSk7XG4gICAgfVxuICAgIGlmIChtYXhEZWZpbmVkKSB7XG4gICAgICBsZXQgZW5kID0gTWF0aC5tYXgoXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgTmVlZCB0byB0eXBlIF9wYXJzZWRcbiAgICAgICAgX2xvb2t1cEJ5S2V5KF9wYXJzZWQsIGlTY2FsZS5heGlzLCBtYXgsIHRydWUpLmhpICsgMSxcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBOZWVkIHRvIGZpeCB0eXBlcyBvbiBfbG9va3VwQnlLZXlcbiAgICAgICAgYW5pbWF0aW9uc0Rpc2FibGVkID8gMCA6IF9sb29rdXBCeUtleShwb2ludHMsIGF4aXMsIGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKG1heCksIHRydWUpLmhpICsgMSk7XG4gICAgICBpZiAoc3BhbkdhcHMpIHtcbiAgICAgICAgY29uc3QgZGlzdGFuY2VUb0RlZmluZWRIaSA9IChfcGFyc2VkXG4gICAgICAgICAgLnNsaWNlKGVuZCAtIDEpXG4gICAgICAgICAgLmZpbmRJbmRleChcbiAgICAgICAgICAgIHBvaW50ID0+ICFpc051bGxPclVuZGVmKHBvaW50W3ZTY2FsZS5heGlzXSkpKTtcbiAgICAgICAgZW5kICs9IE1hdGgubWF4KDAsIGRpc3RhbmNlVG9EZWZpbmVkSGkpO1xuICAgICAgfVxuICAgICAgY291bnQgPSBfbGltaXRWYWx1ZShlbmQsIHN0YXJ0LCBwb2ludENvdW50KSAtIHN0YXJ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCA9IHBvaW50Q291bnQgLSBzdGFydDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge3N0YXJ0LCBjb3VudH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBzY2FsZSByYW5nZXMgaGF2ZSBjaGFuZ2VkLlxuICogQHBhcmFtIHtvYmplY3R9IG1ldGEgLSBkYXRhc2V0IG1ldGEuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfc2NhbGVSYW5nZXNDaGFuZ2VkKG1ldGEpIHtcbiAgY29uc3Qge3hTY2FsZSwgeVNjYWxlLCBfc2NhbGVSYW5nZXN9ID0gbWV0YTtcbiAgY29uc3QgbmV3UmFuZ2VzID0ge1xuICAgIHhtaW46IHhTY2FsZS5taW4sXG4gICAgeG1heDogeFNjYWxlLm1heCxcbiAgICB5bWluOiB5U2NhbGUubWluLFxuICAgIHltYXg6IHlTY2FsZS5tYXhcbiAgfTtcbiAgaWYgKCFfc2NhbGVSYW5nZXMpIHtcbiAgICBtZXRhLl9zY2FsZVJhbmdlcyA9IG5ld1JhbmdlcztcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBjaGFuZ2VkID0gX3NjYWxlUmFuZ2VzLnhtaW4gIT09IHhTY2FsZS5taW5cblx0XHR8fCBfc2NhbGVSYW5nZXMueG1heCAhPT0geFNjYWxlLm1heFxuXHRcdHx8IF9zY2FsZVJhbmdlcy55bWluICE9PSB5U2NhbGUubWluXG5cdFx0fHwgX3NjYWxlUmFuZ2VzLnltYXggIT09IHlTY2FsZS5tYXg7XG5cbiAgT2JqZWN0LmFzc2lnbihfc2NhbGVSYW5nZXMsIG5ld1Jhbmdlcyk7XG4gIHJldHVybiBjaGFuZ2VkO1xufVxuIiwiaW1wb3J0IHtQSSwgVEFVLCBIQUxGX1BJfSBmcm9tICcuL2hlbHBlcnMubWF0aC5qcyc7XG5cbmNvbnN0IGF0RWRnZSA9ICh0OiBudW1iZXIpID0+IHQgPT09IDAgfHwgdCA9PT0gMTtcbmNvbnN0IGVsYXN0aWNJbiA9ICh0OiBudW1iZXIsIHM6IG51bWJlciwgcDogbnVtYmVyKSA9PiAtKE1hdGgucG93KDIsIDEwICogKHQgLT0gMSkpICogTWF0aC5zaW4oKHQgLSBzKSAqIFRBVSAvIHApKTtcbmNvbnN0IGVsYXN0aWNPdXQgPSAodDogbnVtYmVyLCBzOiBudW1iZXIsIHA6IG51bWJlcikgPT4gTWF0aC5wb3coMiwgLTEwICogdCkgKiBNYXRoLnNpbigodCAtIHMpICogVEFVIC8gcCkgKyAxO1xuXG4vKipcbiAqIEVhc2luZyBmdW5jdGlvbnMgYWRhcHRlZCBmcm9tIFJvYmVydCBQZW5uZXIncyBlYXNpbmcgZXF1YXRpb25zLlxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzLmVhc2luZy5lZmZlY3RzXG4gKiBAc2VlIGh0dHA6Ly93d3cucm9iZXJ0cGVubmVyLmNvbS9lYXNpbmcvXG4gKi9cbmNvbnN0IGVmZmVjdHMgPSB7XG4gIGxpbmVhcjogKHQ6IG51bWJlcikgPT4gdCxcblxuICBlYXNlSW5RdWFkOiAodDogbnVtYmVyKSA9PiB0ICogdCxcblxuICBlYXNlT3V0UXVhZDogKHQ6IG51bWJlcikgPT4gLXQgKiAodCAtIDIpLFxuXG4gIGVhc2VJbk91dFF1YWQ6ICh0OiBudW1iZXIpID0+ICgodCAvPSAwLjUpIDwgMSlcbiAgICA/IDAuNSAqIHQgKiB0XG4gICAgOiAtMC41ICogKCgtLXQpICogKHQgLSAyKSAtIDEpLFxuXG4gIGVhc2VJbkN1YmljOiAodDogbnVtYmVyKSA9PiB0ICogdCAqIHQsXG5cbiAgZWFzZU91dEN1YmljOiAodDogbnVtYmVyKSA9PiAodCAtPSAxKSAqIHQgKiB0ICsgMSxcblxuICBlYXNlSW5PdXRDdWJpYzogKHQ6IG51bWJlcikgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gMC41ICogdCAqIHQgKiB0XG4gICAgOiAwLjUgKiAoKHQgLT0gMikgKiB0ICogdCArIDIpLFxuXG4gIGVhc2VJblF1YXJ0OiAodDogbnVtYmVyKSA9PiB0ICogdCAqIHQgKiB0LFxuXG4gIGVhc2VPdXRRdWFydDogKHQ6IG51bWJlcikgPT4gLSgodCAtPSAxKSAqIHQgKiB0ICogdCAtIDEpLFxuXG4gIGVhc2VJbk91dFF1YXJ0OiAodDogbnVtYmVyKSA9PiAoKHQgLz0gMC41KSA8IDEpXG4gICAgPyAwLjUgKiB0ICogdCAqIHQgKiB0XG4gICAgOiAtMC41ICogKCh0IC09IDIpICogdCAqIHQgKiB0IC0gMiksXG5cbiAgZWFzZUluUXVpbnQ6ICh0OiBudW1iZXIpID0+IHQgKiB0ICogdCAqIHQgKiB0LFxuXG4gIGVhc2VPdXRRdWludDogKHQ6IG51bWJlcikgPT4gKHQgLT0gMSkgKiB0ICogdCAqIHQgKiB0ICsgMSxcblxuICBlYXNlSW5PdXRRdWludDogKHQ6IG51bWJlcikgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gMC41ICogdCAqIHQgKiB0ICogdCAqIHRcbiAgICA6IDAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICogdCAqIHQgKyAyKSxcblxuICBlYXNlSW5TaW5lOiAodDogbnVtYmVyKSA9PiAtTWF0aC5jb3ModCAqIEhBTEZfUEkpICsgMSxcblxuICBlYXNlT3V0U2luZTogKHQ6IG51bWJlcikgPT4gTWF0aC5zaW4odCAqIEhBTEZfUEkpLFxuXG4gIGVhc2VJbk91dFNpbmU6ICh0OiBudW1iZXIpID0+IC0wLjUgKiAoTWF0aC5jb3MoUEkgKiB0KSAtIDEpLFxuXG4gIGVhc2VJbkV4cG86ICh0OiBudW1iZXIpID0+ICh0ID09PSAwKSA/IDAgOiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpLFxuXG4gIGVhc2VPdXRFeHBvOiAodDogbnVtYmVyKSA9PiAodCA9PT0gMSkgPyAxIDogLU1hdGgucG93KDIsIC0xMCAqIHQpICsgMSxcblxuICBlYXNlSW5PdXRFeHBvOiAodDogbnVtYmVyKSA9PiBhdEVkZ2UodCkgPyB0IDogdCA8IDAuNVxuICAgID8gMC41ICogTWF0aC5wb3coMiwgMTAgKiAodCAqIDIgLSAxKSlcbiAgICA6IDAuNSAqICgtTWF0aC5wb3coMiwgLTEwICogKHQgKiAyIC0gMSkpICsgMiksXG5cbiAgZWFzZUluQ2lyYzogKHQ6IG51bWJlcikgPT4gKHQgPj0gMSkgPyB0IDogLShNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpLFxuXG4gIGVhc2VPdXRDaXJjOiAodDogbnVtYmVyKSA9PiBNYXRoLnNxcnQoMSAtICh0IC09IDEpICogdCksXG5cbiAgZWFzZUluT3V0Q2lyYzogKHQ6IG51bWJlcikgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gLTAuNSAqIChNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpXG4gICAgOiAwLjUgKiAoTWF0aC5zcXJ0KDEgLSAodCAtPSAyKSAqIHQpICsgMSksXG5cbiAgZWFzZUluRWxhc3RpYzogKHQ6IG51bWJlcikgPT4gYXRFZGdlKHQpID8gdCA6IGVsYXN0aWNJbih0LCAwLjA3NSwgMC4zKSxcblxuICBlYXNlT3V0RWxhc3RpYzogKHQ6IG51bWJlcikgPT4gYXRFZGdlKHQpID8gdCA6IGVsYXN0aWNPdXQodCwgMC4wNzUsIDAuMyksXG5cbiAgZWFzZUluT3V0RWxhc3RpYyh0OiBudW1iZXIpIHtcbiAgICBjb25zdCBzID0gMC4xMTI1O1xuICAgIGNvbnN0IHAgPSAwLjQ1O1xuICAgIHJldHVybiBhdEVkZ2UodCkgPyB0IDpcbiAgICAgIHQgPCAwLjVcbiAgICAgICAgPyAwLjUgKiBlbGFzdGljSW4odCAqIDIsIHMsIHApXG4gICAgICAgIDogMC41ICsgMC41ICogZWxhc3RpY091dCh0ICogMiAtIDEsIHMsIHApO1xuICB9LFxuXG4gIGVhc2VJbkJhY2sodDogbnVtYmVyKSB7XG4gICAgY29uc3QgcyA9IDEuNzAxNTg7XG4gICAgcmV0dXJuIHQgKiB0ICogKChzICsgMSkgKiB0IC0gcyk7XG4gIH0sXG5cbiAgZWFzZU91dEJhY2sodDogbnVtYmVyKSB7XG4gICAgY29uc3QgcyA9IDEuNzAxNTg7XG4gICAgcmV0dXJuICh0IC09IDEpICogdCAqICgocyArIDEpICogdCArIHMpICsgMTtcbiAgfSxcblxuICBlYXNlSW5PdXRCYWNrKHQ6IG51bWJlcikge1xuICAgIGxldCBzID0gMS43MDE1ODtcbiAgICBpZiAoKHQgLz0gMC41KSA8IDEpIHtcbiAgICAgIHJldHVybiAwLjUgKiAodCAqIHQgKiAoKChzICo9ICgxLjUyNSkpICsgMSkgKiB0IC0gcykpO1xuICAgIH1cbiAgICByZXR1cm4gMC41ICogKCh0IC09IDIpICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgKyBzKSArIDIpO1xuICB9LFxuXG4gIGVhc2VJbkJvdW5jZTogKHQ6IG51bWJlcikgPT4gMSAtIGVmZmVjdHMuZWFzZU91dEJvdW5jZSgxIC0gdCksXG5cbiAgZWFzZU91dEJvdW5jZSh0OiBudW1iZXIpIHtcbiAgICBjb25zdCBtID0gNy41NjI1O1xuICAgIGNvbnN0IGQgPSAyLjc1O1xuICAgIGlmICh0IDwgKDEgLyBkKSkge1xuICAgICAgcmV0dXJuIG0gKiB0ICogdDtcbiAgICB9XG4gICAgaWYgKHQgPCAoMiAvIGQpKSB7XG4gICAgICByZXR1cm4gbSAqICh0IC09ICgxLjUgLyBkKSkgKiB0ICsgMC43NTtcbiAgICB9XG4gICAgaWYgKHQgPCAoMi41IC8gZCkpIHtcbiAgICAgIHJldHVybiBtICogKHQgLT0gKDIuMjUgLyBkKSkgKiB0ICsgMC45Mzc1O1xuICAgIH1cbiAgICByZXR1cm4gbSAqICh0IC09ICgyLjYyNSAvIGQpKSAqIHQgKyAwLjk4NDM3NTtcbiAgfSxcblxuICBlYXNlSW5PdXRCb3VuY2U6ICh0OiBudW1iZXIpID0+ICh0IDwgMC41KVxuICAgID8gZWZmZWN0cy5lYXNlSW5Cb3VuY2UodCAqIDIpICogMC41XG4gICAgOiBlZmZlY3RzLmVhc2VPdXRCb3VuY2UodCAqIDIgLSAxKSAqIDAuNSArIDAuNSxcbn0gYXMgY29uc3Q7XG5cbmV4cG9ydCB0eXBlIEVhc2luZ0Z1bmN0aW9uID0ga2V5b2YgdHlwZW9mIGVmZmVjdHNcblxuZXhwb3J0IGRlZmF1bHQgZWZmZWN0cztcbiIsImltcG9ydCB7Q29sb3J9IGZyb20gJ0BrdXJrbGUvY29sb3InO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNQYXR0ZXJuT3JHcmFkaWVudCh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIENhbnZhc1BhdHRlcm4gfCBDYW52YXNHcmFkaWVudCB7XG4gIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgY29uc3QgdHlwZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgcmV0dXJuIHR5cGUgPT09ICdbb2JqZWN0IENhbnZhc1BhdHRlcm5dJyB8fCB0eXBlID09PSAnW29iamVjdCBDYW52YXNHcmFkaWVudF0nO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29sb3IodmFsdWU6IENhbnZhc0dyYWRpZW50KTogQ2FudmFzR3JhZGllbnQ7XG5leHBvcnQgZnVuY3Rpb24gY29sb3IodmFsdWU6IENhbnZhc1BhdHRlcm4pOiBDYW52YXNQYXR0ZXJuO1xuZXhwb3J0IGZ1bmN0aW9uIGNvbG9yKFxuICB2YWx1ZTpcbiAgfCBzdHJpbmdcbiAgfCB7IHI6IG51bWJlcjsgZzogbnVtYmVyOyBiOiBudW1iZXI7IGE6IG51bWJlciB9XG4gIHwgW251bWJlciwgbnVtYmVyLCBudW1iZXJdXG4gIHwgW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl1cbik6IENvbG9yO1xuZXhwb3J0IGZ1bmN0aW9uIGNvbG9yKHZhbHVlKSB7XG4gIHJldHVybiBpc1BhdHRlcm5PckdyYWRpZW50KHZhbHVlKSA/IHZhbHVlIDogbmV3IENvbG9yKHZhbHVlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEhvdmVyQ29sb3IodmFsdWU6IENhbnZhc0dyYWRpZW50KTogQ2FudmFzR3JhZGllbnQ7XG5leHBvcnQgZnVuY3Rpb24gZ2V0SG92ZXJDb2xvcih2YWx1ZTogQ2FudmFzUGF0dGVybik6IENhbnZhc1BhdHRlcm47XG5leHBvcnQgZnVuY3Rpb24gZ2V0SG92ZXJDb2xvcih2YWx1ZTogc3RyaW5nKTogc3RyaW5nO1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhvdmVyQ29sb3IodmFsdWUpIHtcbiAgcmV0dXJuIGlzUGF0dGVybk9yR3JhZGllbnQodmFsdWUpXG4gICAgPyB2YWx1ZVxuICAgIDogbmV3IENvbG9yKHZhbHVlKS5zYXR1cmF0ZSgwLjUpLmRhcmtlbigwLjEpLmhleFN0cmluZygpO1xufVxuIiwiY29uc3QgbnVtYmVycyA9IFsneCcsICd5JywgJ2JvcmRlcldpZHRoJywgJ3JhZGl1cycsICd0ZW5zaW9uJ107XG5jb25zdCBjb2xvcnMgPSBbJ2NvbG9yJywgJ2JvcmRlckNvbG9yJywgJ2JhY2tncm91bmRDb2xvciddO1xuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlBbmltYXRpb25zRGVmYXVsdHMoZGVmYXVsdHMpIHtcbiAgZGVmYXVsdHMuc2V0KCdhbmltYXRpb24nLCB7XG4gICAgZGVsYXk6IHVuZGVmaW5lZCxcbiAgICBkdXJhdGlvbjogMTAwMCxcbiAgICBlYXNpbmc6ICdlYXNlT3V0UXVhcnQnLFxuICAgIGZuOiB1bmRlZmluZWQsXG4gICAgZnJvbTogdW5kZWZpbmVkLFxuICAgIGxvb3A6IHVuZGVmaW5lZCxcbiAgICB0bzogdW5kZWZpbmVkLFxuICAgIHR5cGU6IHVuZGVmaW5lZCxcbiAgfSk7XG5cbiAgZGVmYXVsdHMuZGVzY3JpYmUoJ2FuaW1hdGlvbicsIHtcbiAgICBfZmFsbGJhY2s6IGZhbHNlLFxuICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ29uUHJvZ3Jlc3MnICYmIG5hbWUgIT09ICdvbkNvbXBsZXRlJyAmJiBuYW1lICE9PSAnZm4nLFxuICB9KTtcblxuICBkZWZhdWx0cy5zZXQoJ2FuaW1hdGlvbnMnLCB7XG4gICAgY29sb3JzOiB7XG4gICAgICB0eXBlOiAnY29sb3InLFxuICAgICAgcHJvcGVydGllczogY29sb3JzXG4gICAgfSxcbiAgICBudW1iZXJzOiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIHByb3BlcnRpZXM6IG51bWJlcnNcbiAgICB9LFxuICB9KTtcblxuICBkZWZhdWx0cy5kZXNjcmliZSgnYW5pbWF0aW9ucycsIHtcbiAgICBfZmFsbGJhY2s6ICdhbmltYXRpb24nLFxuICB9KTtcblxuICBkZWZhdWx0cy5zZXQoJ3RyYW5zaXRpb25zJywge1xuICAgIGFjdGl2ZToge1xuICAgICAgYW5pbWF0aW9uOiB7XG4gICAgICAgIGR1cmF0aW9uOiA0MDBcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlc2l6ZToge1xuICAgICAgYW5pbWF0aW9uOiB7XG4gICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICB9XG4gICAgfSxcbiAgICBzaG93OiB7XG4gICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgIGNvbG9yczoge1xuICAgICAgICAgIGZyb206ICd0cmFuc3BhcmVudCdcbiAgICAgICAgfSxcbiAgICAgICAgdmlzaWJsZToge1xuICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICBkdXJhdGlvbjogMCAvLyBzaG93IGltbWVkaWF0ZWx5XG4gICAgICAgIH0sXG4gICAgICB9XG4gICAgfSxcbiAgICBoaWRlOiB7XG4gICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgIGNvbG9yczoge1xuICAgICAgICAgIHRvOiAndHJhbnNwYXJlbnQnXG4gICAgICAgIH0sXG4gICAgICAgIHZpc2libGU6IHtcbiAgICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgICAgZWFzaW5nOiAnbGluZWFyJyxcbiAgICAgICAgICBmbjogdiA9PiB2IHwgMCAvLyBmb3Iga2VlcGluZyB0aGUgZGF0YXNldCB2aXNpYmxlIGFsbCB0aGUgd2F5IHRocm91Z2ggdGhlIGFuaW1hdGlvblxuICAgICAgICB9LFxuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gYXBwbHlMYXlvdXRzRGVmYXVsdHMoZGVmYXVsdHMpIHtcbiAgZGVmYXVsdHMuc2V0KCdsYXlvdXQnLCB7XG4gICAgYXV0b1BhZGRpbmc6IHRydWUsXG4gICAgcGFkZGluZzoge1xuICAgICAgdG9wOiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICBib3R0b206IDAsXG4gICAgICBsZWZ0OiAwXG4gICAgfVxuICB9KTtcbn1cbiIsIlxuY29uc3QgaW50bENhY2hlID0gbmV3IE1hcDxzdHJpbmcsIEludGwuTnVtYmVyRm9ybWF0PigpO1xuXG5mdW5jdGlvbiBnZXROdW1iZXJGb3JtYXQobG9jYWxlOiBzdHJpbmcsIG9wdGlvbnM/OiBJbnRsLk51bWJlckZvcm1hdE9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IGNhY2hlS2V5ID0gbG9jYWxlICsgSlNPTi5zdHJpbmdpZnkob3B0aW9ucyk7XG4gIGxldCBmb3JtYXR0ZXIgPSBpbnRsQ2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgaWYgKCFmb3JtYXR0ZXIpIHtcbiAgICBmb3JtYXR0ZXIgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jYWxlLCBvcHRpb25zKTtcbiAgICBpbnRsQ2FjaGUuc2V0KGNhY2hlS2V5LCBmb3JtYXR0ZXIpO1xuICB9XG4gIHJldHVybiBmb3JtYXR0ZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXROdW1iZXIobnVtOiBudW1iZXIsIGxvY2FsZTogc3RyaW5nLCBvcHRpb25zPzogSW50bC5OdW1iZXJGb3JtYXRPcHRpb25zKSB7XG4gIHJldHVybiBnZXROdW1iZXJGb3JtYXQobG9jYWxlLCBvcHRpb25zKS5mb3JtYXQobnVtKTtcbn1cbiIsImltcG9ydCB7aXNBcnJheX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHtmb3JtYXROdW1iZXJ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5pbnRsLmpzJztcbmltcG9ydCB7bG9nMTB9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5tYXRoLmpzJztcblxuLyoqXG4gKiBOYW1lc3BhY2UgdG8gaG9sZCBmb3JtYXR0ZXJzIGZvciBkaWZmZXJlbnQgdHlwZXMgb2YgdGlja3NcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuVGlja3MuZm9ybWF0dGVyc1xuICovXG5jb25zdCBmb3JtYXR0ZXJzID0ge1xuICAvKipcbiAgICogRm9ybWF0dGVyIGZvciB2YWx1ZSBsYWJlbHNcbiAgICogQG1ldGhvZCBDaGFydC5UaWNrcy5mb3JtYXR0ZXJzLnZhbHVlc1xuICAgKiBAcGFyYW0gdmFsdWUgdGhlIHZhbHVlIHRvIGRpc3BsYXlcbiAgICogQHJldHVybiB7c3RyaW5nfHN0cmluZ1tdfSB0aGUgbGFiZWwgdG8gZGlzcGxheVxuICAgKi9cbiAgdmFsdWVzKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpID8gLyoqIEB0eXBlIHtzdHJpbmdbXX0gKi8gKHZhbHVlKSA6ICcnICsgdmFsdWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvcm1hdHRlciBmb3IgbnVtZXJpYyB0aWNrc1xuICAgKiBAbWV0aG9kIENoYXJ0LlRpY2tzLmZvcm1hdHRlcnMubnVtZXJpY1xuICAgKiBAcGFyYW0gdGlja1ZhbHVlIHtudW1iZXJ9IHRoZSB2YWx1ZSB0byBiZSBmb3JtYXR0ZWRcbiAgICogQHBhcmFtIGluZGV4IHtudW1iZXJ9IHRoZSBwb3NpdGlvbiBvZiB0aGUgdGlja1ZhbHVlIHBhcmFtZXRlciBpbiB0aGUgdGlja3MgYXJyYXlcbiAgICogQHBhcmFtIHRpY2tzIHtvYmplY3RbXX0gdGhlIGxpc3Qgb2YgdGlja3MgYmVpbmcgY29udmVydGVkXG4gICAqIEByZXR1cm4ge3N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0aWNrVmFsdWUgcGFyYW1ldGVyXG4gICAqL1xuICBudW1lcmljKHRpY2tWYWx1ZSwgaW5kZXgsIHRpY2tzKSB7XG4gICAgaWYgKHRpY2tWYWx1ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuICcwJzsgLy8gbmV2ZXIgc2hvdyBkZWNpbWFsIHBsYWNlcyBmb3IgMFxuICAgIH1cblxuICAgIGNvbnN0IGxvY2FsZSA9IHRoaXMuY2hhcnQub3B0aW9ucy5sb2NhbGU7XG4gICAgbGV0IG5vdGF0aW9uO1xuICAgIGxldCBkZWx0YSA9IHRpY2tWYWx1ZTsgLy8gVGhpcyBpcyB1c2VkIHdoZW4gdGhlcmUgYXJlIGxlc3MgdGhhbiAyIHRpY2tzIGFzIHRoZSB0aWNrIGludGVydmFsLlxuXG4gICAgaWYgKHRpY2tzLmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIGFsbCB0aWNrcyBhcmUgc21hbGwgb3IgdGhlcmUgaHVnZSBudW1iZXJzOyB1c2Ugc2NpZW50aWZpYyBub3RhdGlvblxuICAgICAgY29uc3QgbWF4VGljayA9IE1hdGgubWF4KE1hdGguYWJzKHRpY2tzWzBdLnZhbHVlKSwgTWF0aC5hYnModGlja3NbdGlja3MubGVuZ3RoIC0gMV0udmFsdWUpKTtcbiAgICAgIGlmIChtYXhUaWNrIDwgMWUtNCB8fCBtYXhUaWNrID4gMWUrMTUpIHtcbiAgICAgICAgbm90YXRpb24gPSAnc2NpZW50aWZpYyc7XG4gICAgICB9XG5cbiAgICAgIGRlbHRhID0gY2FsY3VsYXRlRGVsdGEodGlja1ZhbHVlLCB0aWNrcyk7XG4gICAgfVxuXG4gICAgY29uc3QgbG9nRGVsdGEgPSBsb2cxMChNYXRoLmFicyhkZWx0YSkpO1xuXG4gICAgLy8gV2hlbiBkYXRhc2V0cyBoYXZlIHZhbHVlcyBhcHByb2FjaGluZyBOdW1iZXIuTUFYX1ZBTFVFLCB0aGUgdGljayBjYWxjdWxhdGlvbnMgbWlnaHQgcmVzdWx0IGluXG4gICAgLy8gaW5maW5pdHkgYW5kIGV2ZW50dWFsbHkgTmFOLiBQYXNzaW5nIE5hTiBmb3IgbWluaW11bUZyYWN0aW9uRGlnaXRzIG9yIG1heGltdW1GcmFjdGlvbkRpZ2l0c1xuICAgIC8vIHdpbGwgbWFrZSB0aGUgbnVtYmVyIGZvcm1hdHRlciB0aHJvdy4gU28gaW5zdGVhZCB3ZSBjaGVjayBmb3IgaXNOYU4gYW5kIHVzZSBhIGZhbGxiYWNrIHZhbHVlLlxuICAgIC8vXG4gICAgLy8gdG9GaXhlZCBoYXMgYSBtYXggb2YgMjAgZGVjaW1hbCBwbGFjZXNcbiAgICBjb25zdCBudW1EZWNpbWFsID0gaXNOYU4obG9nRGVsdGEpID8gMSA6IE1hdGgubWF4KE1hdGgubWluKC0xICogTWF0aC5mbG9vcihsb2dEZWx0YSksIDIwKSwgMCk7XG5cbiAgICBjb25zdCBvcHRpb25zID0ge25vdGF0aW9uLCBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IG51bURlY2ltYWwsIG1heGltdW1GcmFjdGlvbkRpZ2l0czogbnVtRGVjaW1hbH07XG4gICAgT2JqZWN0LmFzc2lnbihvcHRpb25zLCB0aGlzLm9wdGlvbnMudGlja3MuZm9ybWF0KTtcblxuICAgIHJldHVybiBmb3JtYXROdW1iZXIodGlja1ZhbHVlLCBsb2NhbGUsIG9wdGlvbnMpO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIEZvcm1hdHRlciBmb3IgbG9nYXJpdGhtaWMgdGlja3NcbiAgICogQG1ldGhvZCBDaGFydC5UaWNrcy5mb3JtYXR0ZXJzLmxvZ2FyaXRobWljXG4gICAqIEBwYXJhbSB0aWNrVmFsdWUge251bWJlcn0gdGhlIHZhbHVlIHRvIGJlIGZvcm1hdHRlZFxuICAgKiBAcGFyYW0gaW5kZXgge251bWJlcn0gdGhlIHBvc2l0aW9uIG9mIHRoZSB0aWNrVmFsdWUgcGFyYW1ldGVyIGluIHRoZSB0aWNrcyBhcnJheVxuICAgKiBAcGFyYW0gdGlja3Mge29iamVjdFtdfSB0aGUgbGlzdCBvZiB0aWNrcyBiZWluZyBjb252ZXJ0ZWRcbiAgICogQHJldHVybiB7c3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRpY2tWYWx1ZSBwYXJhbWV0ZXJcbiAgICovXG4gIGxvZ2FyaXRobWljKHRpY2tWYWx1ZSwgaW5kZXgsIHRpY2tzKSB7XG4gICAgaWYgKHRpY2tWYWx1ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuICcwJztcbiAgICB9XG4gICAgY29uc3QgcmVtYWluID0gdGlja3NbaW5kZXhdLnNpZ25pZmljYW5kIHx8ICh0aWNrVmFsdWUgLyAoTWF0aC5wb3coMTAsIE1hdGguZmxvb3IobG9nMTAodGlja1ZhbHVlKSkpKSk7XG4gICAgaWYgKFsxLCAyLCAzLCA1LCAxMCwgMTVdLmluY2x1ZGVzKHJlbWFpbikgfHwgaW5kZXggPiAwLjggKiB0aWNrcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmb3JtYXR0ZXJzLm51bWVyaWMuY2FsbCh0aGlzLCB0aWNrVmFsdWUsIGluZGV4LCB0aWNrcyk7XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfVxuXG59O1xuXG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZURlbHRhKHRpY2tWYWx1ZSwgdGlja3MpIHtcbiAgLy8gRmlndXJlIG91dCBob3cgbWFueSBkaWdpdHMgdG8gc2hvd1xuICAvLyBUaGUgc3BhY2UgYmV0d2VlbiB0aGUgZmlyc3QgdHdvIHRpY2tzIG1pZ2h0IGJlIHNtYWxsZXIgdGhhbiBub3JtYWwgc3BhY2luZ1xuICBsZXQgZGVsdGEgPSB0aWNrcy5sZW5ndGggPiAzID8gdGlja3NbMl0udmFsdWUgLSB0aWNrc1sxXS52YWx1ZSA6IHRpY2tzWzFdLnZhbHVlIC0gdGlja3NbMF0udmFsdWU7XG5cbiAgLy8gSWYgd2UgaGF2ZSBhIG51bWJlciBsaWtlIDIuNSBhcyB0aGUgZGVsdGEsIGZpZ3VyZSBvdXQgaG93IG1hbnkgZGVjaW1hbCBwbGFjZXMgd2UgbmVlZFxuICBpZiAoTWF0aC5hYnMoZGVsdGEpID49IDEgJiYgdGlja1ZhbHVlICE9PSBNYXRoLmZsb29yKHRpY2tWYWx1ZSkpIHtcbiAgICAvLyBub3QgYW4gaW50ZWdlclxuICAgIGRlbHRhID0gdGlja1ZhbHVlIC0gTWF0aC5mbG9vcih0aWNrVmFsdWUpO1xuICB9XG4gIHJldHVybiBkZWx0YTtcbn1cblxuLyoqXG4gKiBOYW1lc3BhY2UgdG8gaG9sZCBzdGF0aWMgdGljayBnZW5lcmF0aW9uIGZ1bmN0aW9uc1xuICogQG5hbWVzcGFjZSBDaGFydC5UaWNrc1xuICovXG5leHBvcnQgZGVmYXVsdCB7Zm9ybWF0dGVyc307XG4iLCJpbXBvcnQgVGlja3MgZnJvbSAnLi9jb3JlLnRpY2tzLmpzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5U2NhbGVEZWZhdWx0cyhkZWZhdWx0cykge1xuICBkZWZhdWx0cy5zZXQoJ3NjYWxlJywge1xuICAgIGRpc3BsYXk6IHRydWUsXG4gICAgb2Zmc2V0OiBmYWxzZSxcbiAgICByZXZlcnNlOiBmYWxzZSxcbiAgICBiZWdpbkF0WmVybzogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBTY2FsZSBib3VuZGFyeSBzdHJhdGVneSAoYnlwYXNzZWQgYnkgbWluL21heCB0aW1lIG9wdGlvbnMpXG4gICAgICogLSBgZGF0YWA6IG1ha2Ugc3VyZSBkYXRhIGFyZSBmdWxseSB2aXNpYmxlLCB0aWNrcyBvdXRzaWRlIGFyZSByZW1vdmVkXG4gICAgICogLSBgdGlja3NgOiBtYWtlIHN1cmUgdGlja3MgYXJlIGZ1bGx5IHZpc2libGUsIGRhdGEgb3V0c2lkZSBhcmUgdHJ1bmNhdGVkXG4gICAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9wdWxsLzQ1NTZcbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKi9cbiAgICBib3VuZHM6ICd0aWNrcycsXG5cbiAgICBjbGlwOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQWRkaXRpb24gZ3JhY2UgYWRkZWQgdG8gbWF4IGFuZCByZWR1Y2VkIGZyb20gbWluIGRhdGEgdmFsdWUuXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICovXG4gICAgZ3JhY2U6IDAsXG5cbiAgICAvLyBncmlkIGxpbmUgc2V0dGluZ3NcbiAgICBncmlkOiB7XG4gICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgbGluZVdpZHRoOiAxLFxuICAgICAgZHJhd09uQ2hhcnRBcmVhOiB0cnVlLFxuICAgICAgZHJhd1RpY2tzOiB0cnVlLFxuICAgICAgdGlja0xlbmd0aDogOCxcbiAgICAgIHRpY2tXaWR0aDogKF9jdHgsIG9wdGlvbnMpID0+IG9wdGlvbnMubGluZVdpZHRoLFxuICAgICAgdGlja0NvbG9yOiAoX2N0eCwgb3B0aW9ucykgPT4gb3B0aW9ucy5jb2xvcixcbiAgICAgIG9mZnNldDogZmFsc2UsXG4gICAgfSxcblxuICAgIGJvcmRlcjoge1xuICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgIGRhc2g6IFtdLFxuICAgICAgZGFzaE9mZnNldDogMC4wLFxuICAgICAgd2lkdGg6IDFcbiAgICB9LFxuXG4gICAgLy8gc2NhbGUgdGl0bGVcbiAgICB0aXRsZToge1xuICAgICAgLy8gZGlzcGxheSBwcm9wZXJ0eVxuICAgICAgZGlzcGxheTogZmFsc2UsXG5cbiAgICAgIC8vIGFjdHVhbCBsYWJlbFxuICAgICAgdGV4dDogJycsXG5cbiAgICAgIC8vIHRvcC9ib3R0b20gcGFkZGluZ1xuICAgICAgcGFkZGluZzoge1xuICAgICAgICB0b3A6IDQsXG4gICAgICAgIGJvdHRvbTogNFxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBsYWJlbCBzZXR0aW5nc1xuICAgIHRpY2tzOiB7XG4gICAgICBtaW5Sb3RhdGlvbjogMCxcbiAgICAgIG1heFJvdGF0aW9uOiA1MCxcbiAgICAgIG1pcnJvcjogZmFsc2UsXG4gICAgICB0ZXh0U3Ryb2tlV2lkdGg6IDAsXG4gICAgICB0ZXh0U3Ryb2tlQ29sb3I6ICcnLFxuICAgICAgcGFkZGluZzogMyxcbiAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICBhdXRvU2tpcDogdHJ1ZSxcbiAgICAgIGF1dG9Ta2lwUGFkZGluZzogMyxcbiAgICAgIGxhYmVsT2Zmc2V0OiAwLFxuICAgICAgLy8gV2UgcGFzcyB0aHJvdWdoIGFycmF5cyB0byBiZSByZW5kZXJlZCBhcyBtdWx0aWxpbmUgbGFiZWxzLCB3ZSBjb252ZXJ0IE90aGVycyB0byBzdHJpbmdzIGhlcmUuXG4gICAgICBjYWxsYmFjazogVGlja3MuZm9ybWF0dGVycy52YWx1ZXMsXG4gICAgICBtaW5vcjoge30sXG4gICAgICBtYWpvcjoge30sXG4gICAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgICBjcm9zc0FsaWduOiAnbmVhcicsXG5cbiAgICAgIHNob3dMYWJlbEJhY2tkcm9wOiBmYWxzZSxcbiAgICAgIGJhY2tkcm9wQ29sb3I6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNzUpJyxcbiAgICAgIGJhY2tkcm9wUGFkZGluZzogMixcbiAgICB9XG4gIH0pO1xuXG4gIGRlZmF1bHRzLnJvdXRlKCdzY2FsZS50aWNrcycsICdjb2xvcicsICcnLCAnY29sb3InKTtcbiAgZGVmYXVsdHMucm91dGUoJ3NjYWxlLmdyaWQnLCAnY29sb3InLCAnJywgJ2JvcmRlckNvbG9yJyk7XG4gIGRlZmF1bHRzLnJvdXRlKCdzY2FsZS5ib3JkZXInLCAnY29sb3InLCAnJywgJ2JvcmRlckNvbG9yJyk7XG4gIGRlZmF1bHRzLnJvdXRlKCdzY2FsZS50aXRsZScsICdjb2xvcicsICcnLCAnY29sb3InKTtcblxuICBkZWZhdWx0cy5kZXNjcmliZSgnc2NhbGUnLCB7XG4gICAgX2ZhbGxiYWNrOiBmYWxzZSxcbiAgICBfc2NyaXB0YWJsZTogKG5hbWUpID0+ICFuYW1lLnN0YXJ0c1dpdGgoJ2JlZm9yZScpICYmICFuYW1lLnN0YXJ0c1dpdGgoJ2FmdGVyJykgJiYgbmFtZSAhPT0gJ2NhbGxiYWNrJyAmJiBuYW1lICE9PSAncGFyc2VyJyxcbiAgICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JvcmRlckRhc2gnICYmIG5hbWUgIT09ICd0aWNrQm9yZGVyRGFzaCcgJiYgbmFtZSAhPT0gJ2Rhc2gnLFxuICB9KTtcblxuICBkZWZhdWx0cy5kZXNjcmliZSgnc2NhbGVzJywge1xuICAgIF9mYWxsYmFjazogJ3NjYWxlJyxcbiAgfSk7XG5cbiAgZGVmYXVsdHMuZGVzY3JpYmUoJ3NjYWxlLnRpY2tzJywge1xuICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JhY2tkcm9wUGFkZGluZycgJiYgbmFtZSAhPT0gJ2NhbGxiYWNrJyxcbiAgICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JhY2tkcm9wUGFkZGluZycsXG4gIH0pO1xufVxuIiwiaW1wb3J0IHtnZXRIb3ZlckNvbG9yfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29sb3IuanMnO1xuaW1wb3J0IHtpc09iamVjdCwgbWVyZ2UsIHZhbHVlT3JEZWZhdWx0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge2FwcGx5QW5pbWF0aW9uc0RlZmF1bHRzfSBmcm9tICcuL2NvcmUuYW5pbWF0aW9ucy5kZWZhdWx0cy5qcyc7XG5pbXBvcnQge2FwcGx5TGF5b3V0c0RlZmF1bHRzfSBmcm9tICcuL2NvcmUubGF5b3V0cy5kZWZhdWx0cy5qcyc7XG5pbXBvcnQge2FwcGx5U2NhbGVEZWZhdWx0c30gZnJvbSAnLi9jb3JlLnNjYWxlLmRlZmF1bHRzLmpzJztcblxuZXhwb3J0IGNvbnN0IG92ZXJyaWRlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5leHBvcnQgY29uc3QgZGVzY3JpcHRvcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldFNjb3BlKG5vZGUsIGtleSkge1xuICBpZiAoIWtleSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGNvbnN0IGtleXMgPSBrZXkuc3BsaXQoJy4nKTtcbiAgZm9yIChsZXQgaSA9IDAsIG4gPSBrZXlzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIGNvbnN0IGsgPSBrZXlzW2ldO1xuICAgIG5vZGUgPSBub2RlW2tdIHx8IChub2RlW2tdID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIHNldChyb290LCBzY29wZSwgdmFsdWVzKSB7XG4gIGlmICh0eXBlb2Ygc2NvcGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG1lcmdlKGdldFNjb3BlKHJvb3QsIHNjb3BlKSwgdmFsdWVzKTtcbiAgfVxuICByZXR1cm4gbWVyZ2UoZ2V0U2NvcGUocm9vdCwgJycpLCBzY29wZSk7XG59XG5cbi8qKlxuICogUGxlYXNlIHVzZSB0aGUgbW9kdWxlJ3MgZGVmYXVsdCBleHBvcnQgd2hpY2ggcHJvdmlkZXMgYSBzaW5nbGV0b24gaW5zdGFuY2VcbiAqIE5vdGU6IGNsYXNzIGlzIGV4cG9ydGVkIGZvciB0eXBlZG9jXG4gKi9cbmV4cG9ydCBjbGFzcyBEZWZhdWx0cyB7XG4gIGNvbnN0cnVjdG9yKF9kZXNjcmlwdG9ycywgX2FwcGxpZXJzKSB7XG4gICAgdGhpcy5hbmltYXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSAncmdiYSgwLDAsMCwwLjEpJztcbiAgICB0aGlzLmJvcmRlckNvbG9yID0gJ3JnYmEoMCwwLDAsMC4xKSc7XG4gICAgdGhpcy5jb2xvciA9ICcjNjY2JztcbiAgICB0aGlzLmRhdGFzZXRzID0ge307XG4gICAgdGhpcy5kZXZpY2VQaXhlbFJhdGlvID0gKGNvbnRleHQpID0+IGNvbnRleHQuY2hhcnQucGxhdGZvcm0uZ2V0RGV2aWNlUGl4ZWxSYXRpbygpO1xuICAgIHRoaXMuZWxlbWVudHMgPSB7fTtcbiAgICB0aGlzLmV2ZW50cyA9IFtcbiAgICAgICdtb3VzZW1vdmUnLFxuICAgICAgJ21vdXNlb3V0JyxcbiAgICAgICdjbGljaycsXG4gICAgICAndG91Y2hzdGFydCcsXG4gICAgICAndG91Y2htb3ZlJ1xuICAgIF07XG4gICAgdGhpcy5mb250ID0ge1xuICAgICAgZmFtaWx5OiBcIidIZWx2ZXRpY2EgTmV1ZScsICdIZWx2ZXRpY2EnLCAnQXJpYWwnLCBzYW5zLXNlcmlmXCIsXG4gICAgICBzaXplOiAxMixcbiAgICAgIHN0eWxlOiAnbm9ybWFsJyxcbiAgICAgIGxpbmVIZWlnaHQ6IDEuMixcbiAgICAgIHdlaWdodDogbnVsbFxuICAgIH07XG4gICAgdGhpcy5ob3ZlciA9IHt9O1xuICAgIHRoaXMuaG92ZXJCYWNrZ3JvdW5kQ29sb3IgPSAoY3R4LCBvcHRpb25zKSA9PiBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yKTtcbiAgICB0aGlzLmhvdmVyQm9yZGVyQ29sb3IgPSAoY3R4LCBvcHRpb25zKSA9PiBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYm9yZGVyQ29sb3IpO1xuICAgIHRoaXMuaG92ZXJDb2xvciA9IChjdHgsIG9wdGlvbnMpID0+IGdldEhvdmVyQ29sb3Iob3B0aW9ucy5jb2xvcik7XG4gICAgdGhpcy5pbmRleEF4aXMgPSAneCc7XG4gICAgdGhpcy5pbnRlcmFjdGlvbiA9IHtcbiAgICAgIG1vZGU6ICduZWFyZXN0JyxcbiAgICAgIGludGVyc2VjdDogdHJ1ZSxcbiAgICAgIGluY2x1ZGVJbnZpc2libGU6IGZhbHNlXG4gICAgfTtcbiAgICB0aGlzLm1haW50YWluQXNwZWN0UmF0aW8gPSB0cnVlO1xuICAgIHRoaXMub25Ib3ZlciA9IG51bGw7XG4gICAgdGhpcy5vbkNsaWNrID0gbnVsbDtcbiAgICB0aGlzLnBhcnNpbmcgPSB0cnVlO1xuICAgIHRoaXMucGx1Z2lucyA9IHt9O1xuICAgIHRoaXMucmVzcG9uc2l2ZSA9IHRydWU7XG4gICAgdGhpcy5zY2FsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNjYWxlcyA9IHt9O1xuICAgIHRoaXMuc2hvd0xpbmUgPSB0cnVlO1xuICAgIHRoaXMuZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3AgPSB0cnVlO1xuXG4gICAgdGhpcy5kZXNjcmliZShfZGVzY3JpcHRvcnMpO1xuICAgIHRoaXMuYXBwbHkoX2FwcGxpZXJzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHNjb3BlXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbdmFsdWVzXVxuXHQgKi9cbiAgc2V0KHNjb3BlLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gc2V0KHRoaXMsIHNjb3BlLCB2YWx1ZXMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzY29wZVxuXHQgKi9cbiAgZ2V0KHNjb3BlKSB7XG4gICAgcmV0dXJuIGdldFNjb3BlKHRoaXMsIHNjb3BlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHNjb3BlXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbdmFsdWVzXVxuXHQgKi9cbiAgZGVzY3JpYmUoc2NvcGUsIHZhbHVlcykge1xuICAgIHJldHVybiBzZXQoZGVzY3JpcHRvcnMsIHNjb3BlLCB2YWx1ZXMpO1xuICB9XG5cbiAgb3ZlcnJpZGUoc2NvcGUsIHZhbHVlcykge1xuICAgIHJldHVybiBzZXQob3ZlcnJpZGVzLCBzY29wZSwgdmFsdWVzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSb3V0ZXMgdGhlIG5hbWVkIGRlZmF1bHRzIHRvIGZhbGxiYWNrIHRvIGFub3RoZXIgc2NvcGUvbmFtZS5cblx0ICogVGhpcyByb3V0aW5nIGlzIHVzZWZ1bCB3aGVuIHRob3NlIHRhcmdldCB2YWx1ZXMsIGxpa2UgZGVmYXVsdHMuY29sb3IsIGFyZSBjaGFuZ2VkIHJ1bnRpbWUuXG5cdCAqIElmIHRoZSB2YWx1ZXMgd291bGQgYmUgY29waWVkLCB0aGUgcnVudGltZSBjaGFuZ2Ugd291bGQgbm90IHRha2UgZWZmZWN0LiBCeSByb3V0aW5nLCB0aGVcblx0ICogZmFsbGJhY2sgaXMgZXZhbHVhdGVkIGF0IGVhY2ggYWNjZXNzLCBzbyBpdHMgYWx3YXlzIHVwIHRvIGRhdGUuXG5cdCAqXG5cdCAqIEV4YW1wbGU6XG5cdCAqXG5cdCAqIFx0ZGVmYXVsdHMucm91dGUoJ2VsZW1lbnRzLmFyYycsICdiYWNrZ3JvdW5kQ29sb3InLCAnJywgJ2NvbG9yJylcblx0ICogICAtIHJlYWRzIHRoZSBiYWNrZ3JvdW5kQ29sb3IgZnJvbSBkZWZhdWx0cy5jb2xvciB3aGVuIHVuZGVmaW5lZCBsb2NhbGx5XG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzY29wZSBTY29wZSB0aGlzIHJvdXRlIGFwcGxpZXMgdG8uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFByb3BlcnR5IG5hbWUgdGhhdCBzaG91bGQgYmUgcm91dGVkIHRvIGRpZmZlcmVudCBuYW1lc3BhY2Ugd2hlbiBub3QgZGVmaW5lZCBoZXJlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0U2NvcGUgVGhlIG5hbWVzcGFjZSB3aGVyZSB0aG9zZSBwcm9wZXJ0aWVzIHNob3VsZCBiZSByb3V0ZWQgdG8uXG5cdCAqIEVtcHR5IHN0cmluZyAoJycpIGlzIHRoZSByb290IG9mIGRlZmF1bHRzLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0TmFtZSBUaGUgdGFyZ2V0IG5hbWUgaW4gdGhlIHRhcmdldCBzY29wZSB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIHJvdXRlZCB0by5cblx0ICovXG4gIHJvdXRlKHNjb3BlLCBuYW1lLCB0YXJnZXRTY29wZSwgdGFyZ2V0TmFtZSkge1xuICAgIGNvbnN0IHNjb3BlT2JqZWN0ID0gZ2V0U2NvcGUodGhpcywgc2NvcGUpO1xuICAgIGNvbnN0IHRhcmdldFNjb3BlT2JqZWN0ID0gZ2V0U2NvcGUodGhpcywgdGFyZ2V0U2NvcGUpO1xuICAgIGNvbnN0IHByaXZhdGVOYW1lID0gJ18nICsgbmFtZTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHNjb3BlT2JqZWN0LCB7XG4gICAgICAvLyBBIHByaXZhdGUgcHJvcGVydHkgaXMgZGVmaW5lZCB0byBob2xkIHRoZSBhY3R1YWwgdmFsdWUsIHdoZW4gdGhpcyBwcm9wZXJ0eSBpcyBzZXQgaW4gaXRzIHNjb3BlIChzZXQgaW4gdGhlIHNldHRlcilcbiAgICAgIFtwcml2YXRlTmFtZV06IHtcbiAgICAgICAgdmFsdWU6IHNjb3BlT2JqZWN0W25hbWVdLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIC8vIFRoZSBhY3R1YWwgcHJvcGVydHkgaXMgZGVmaW5lZCBhcyBnZXR0ZXIvc2V0dGVyIHNvIHdlIGNhbiBkbyB0aGUgcm91dGluZyB3aGVuIHZhbHVlIGlzIG5vdCBsb2NhbGx5IHNldC5cbiAgICAgIFtuYW1lXToge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgY29uc3QgbG9jYWwgPSB0aGlzW3ByaXZhdGVOYW1lXTtcbiAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXRTY29wZU9iamVjdFt0YXJnZXROYW1lXTtcbiAgICAgICAgICBpZiAoaXNPYmplY3QobG9jYWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdGFyZ2V0LCBsb2NhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZU9yRGVmYXVsdChsb2NhbCwgdGFyZ2V0KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgdGhpc1twcml2YXRlTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgYXBwbHkoYXBwbGllcnMpIHtcbiAgICBhcHBsaWVycy5mb3JFYWNoKChhcHBseSkgPT4gYXBwbHkodGhpcykpO1xuICB9XG59XG5cbi8vIHNpbmdsZXRvbiBpbnN0YW5jZVxuZXhwb3J0IGRlZmF1bHQgLyogI19fUFVSRV9fICovIG5ldyBEZWZhdWx0cyh7XG4gIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gIW5hbWUuc3RhcnRzV2l0aCgnb24nKSxcbiAgX2luZGV4YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdldmVudHMnLFxuICBob3Zlcjoge1xuICAgIF9mYWxsYmFjazogJ2ludGVyYWN0aW9uJ1xuICB9LFxuICBpbnRlcmFjdGlvbjoge1xuICAgIF9zY3JpcHRhYmxlOiBmYWxzZSxcbiAgICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgfVxufSwgW2FwcGx5QW5pbWF0aW9uc0RlZmF1bHRzLCBhcHBseUxheW91dHNEZWZhdWx0cywgYXBwbHlTY2FsZURlZmF1bHRzXSk7XG4iLCJpbXBvcnQgdHlwZSB7XG4gIENoYXJ0LFxuICBQb2ludCxcbiAgRm9udFNwZWMsXG4gIENhbnZhc0ZvbnRTcGVjLFxuICBQb2ludFN0eWxlLFxuICBSZW5kZXJUZXh0T3B0cyxcbiAgQmFja2Ryb3BPcHRpb25zXG59IGZyb20gJy4uL3R5cGVzL2luZGV4LmpzJztcbmltcG9ydCB0eXBlIHtcbiAgVFJCTCxcbiAgU3BsaW5lUG9pbnQsXG4gIFJvdW5kZWRSZWN0LFxuICBUUkJMQ29ybmVyc1xufSBmcm9tICcuLi90eXBlcy9nZW9tZXRyaWMuanMnO1xuaW1wb3J0IHtpc0FycmF5LCBpc051bGxPclVuZGVmfSBmcm9tICcuL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge1BJLCBUQVUsIEhBTEZfUEksIFFVQVJURVJfUEksIFRXT19USElSRFNfUEksIFJBRF9QRVJfREVHfSBmcm9tICcuL2hlbHBlcnMubWF0aC5qcyc7XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGdpdmVuIGZvbnQgb2JqZWN0IGludG8gYSBDU1MgZm9udCBzdHJpbmcuXG4gKiBAcGFyYW0gZm9udCAtIEEgZm9udCBvYmplY3QuXG4gKiBAcmV0dXJuIFRoZSBDU1MgZm9udCBzdHJpbmcuIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvZm9udFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvRm9udFN0cmluZyhmb250OiBGb250U3BlYykge1xuICBpZiAoIWZvbnQgfHwgaXNOdWxsT3JVbmRlZihmb250LnNpemUpIHx8IGlzTnVsbE9yVW5kZWYoZm9udC5mYW1pbHkpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gKGZvbnQuc3R5bGUgPyBmb250LnN0eWxlICsgJyAnIDogJycpXG5cdFx0KyAoZm9udC53ZWlnaHQgPyBmb250LndlaWdodCArICcgJyA6ICcnKVxuXHRcdCsgZm9udC5zaXplICsgJ3B4ICdcblx0XHQrIGZvbnQuZmFtaWx5O1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfbWVhc3VyZVRleHQoXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICBkYXRhOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+LFxuICBnYzogc3RyaW5nW10sXG4gIGxvbmdlc3Q6IG51bWJlcixcbiAgc3RyaW5nOiBzdHJpbmdcbikge1xuICBsZXQgdGV4dFdpZHRoID0gZGF0YVtzdHJpbmddO1xuICBpZiAoIXRleHRXaWR0aCkge1xuICAgIHRleHRXaWR0aCA9IGRhdGFbc3RyaW5nXSA9IGN0eC5tZWFzdXJlVGV4dChzdHJpbmcpLndpZHRoO1xuICAgIGdjLnB1c2goc3RyaW5nKTtcbiAgfVxuICBpZiAodGV4dFdpZHRoID4gbG9uZ2VzdCkge1xuICAgIGxvbmdlc3QgPSB0ZXh0V2lkdGg7XG4gIH1cbiAgcmV0dXJuIGxvbmdlc3Q7XG59XG5cbnR5cGUgVGhpbmcgPSBzdHJpbmcgfCB1bmRlZmluZWQgfCBudWxsXG50eXBlIFRoaW5ncyA9IChUaGluZyB8IFRoaW5nW10pW11cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZXhwb3J0IGZ1bmN0aW9uIF9sb25nZXN0VGV4dChcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIGZvbnQ6IHN0cmluZyxcbiAgYXJyYXlPZlRoaW5nczogVGhpbmdzLFxuICBjYWNoZT86IHtkYXRhPzogUmVjb3JkPHN0cmluZywgbnVtYmVyPiwgZ2FyYmFnZUNvbGxlY3Q/OiBzdHJpbmdbXSwgZm9udD86IHN0cmluZ31cbikge1xuICBjYWNoZSA9IGNhY2hlIHx8IHt9O1xuICBsZXQgZGF0YSA9IGNhY2hlLmRhdGEgPSBjYWNoZS5kYXRhIHx8IHt9O1xuICBsZXQgZ2MgPSBjYWNoZS5nYXJiYWdlQ29sbGVjdCA9IGNhY2hlLmdhcmJhZ2VDb2xsZWN0IHx8IFtdO1xuXG4gIGlmIChjYWNoZS5mb250ICE9PSBmb250KSB7XG4gICAgZGF0YSA9IGNhY2hlLmRhdGEgPSB7fTtcbiAgICBnYyA9IGNhY2hlLmdhcmJhZ2VDb2xsZWN0ID0gW107XG4gICAgY2FjaGUuZm9udCA9IGZvbnQ7XG4gIH1cblxuICBjdHguc2F2ZSgpO1xuXG4gIGN0eC5mb250ID0gZm9udDtcbiAgbGV0IGxvbmdlc3QgPSAwO1xuICBjb25zdCBpbGVuID0gYXJyYXlPZlRoaW5ncy5sZW5ndGg7XG4gIGxldCBpOiBudW1iZXIsIGo6IG51bWJlciwgamxlbjogbnVtYmVyLCB0aGluZzogVGhpbmcgfCBUaGluZ1tdLCBuZXN0ZWRUaGluZzogVGhpbmcgfCBUaGluZ1tdO1xuICBmb3IgKGkgPSAwOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgdGhpbmcgPSBhcnJheU9mVGhpbmdzW2ldO1xuXG4gICAgLy8gVW5kZWZpbmVkIHN0cmluZ3MgYW5kIGFycmF5cyBzaG91bGQgbm90IGJlIG1lYXN1cmVkXG4gICAgaWYgKHRoaW5nICE9PSB1bmRlZmluZWQgJiYgdGhpbmcgIT09IG51bGwgJiYgIWlzQXJyYXkodGhpbmcpKSB7XG4gICAgICBsb25nZXN0ID0gX21lYXN1cmVUZXh0KGN0eCwgZGF0YSwgZ2MsIGxvbmdlc3QsIHRoaW5nKTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkodGhpbmcpKSB7XG4gICAgICAvLyBpZiBpdCBpcyBhbiBhcnJheSBsZXRzIG1lYXN1cmUgZWFjaCBlbGVtZW50XG4gICAgICAvLyB0byBkbyBtYXliZSBzaW1wbGlmeSB0aGlzIGZ1bmN0aW9uIGEgYml0IHNvIHdlIGNhbiBkbyB0aGlzIG1vcmUgcmVjdXJzaXZlbHk/XG4gICAgICBmb3IgKGogPSAwLCBqbGVuID0gdGhpbmcubGVuZ3RoOyBqIDwgamxlbjsgaisrKSB7XG4gICAgICAgIG5lc3RlZFRoaW5nID0gdGhpbmdbal07XG4gICAgICAgIC8vIFVuZGVmaW5lZCBzdHJpbmdzIGFuZCBhcnJheXMgc2hvdWxkIG5vdCBiZSBtZWFzdXJlZFxuICAgICAgICBpZiAobmVzdGVkVGhpbmcgIT09IHVuZGVmaW5lZCAmJiBuZXN0ZWRUaGluZyAhPT0gbnVsbCAmJiAhaXNBcnJheShuZXN0ZWRUaGluZykpIHtcbiAgICAgICAgICBsb25nZXN0ID0gX21lYXN1cmVUZXh0KGN0eCwgZGF0YSwgZ2MsIGxvbmdlc3QsIG5lc3RlZFRoaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGN0eC5yZXN0b3JlKCk7XG5cbiAgY29uc3QgZ2NMZW4gPSBnYy5sZW5ndGggLyAyO1xuICBpZiAoZ2NMZW4gPiBhcnJheU9mVGhpbmdzLmxlbmd0aCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBnY0xlbjsgaSsrKSB7XG4gICAgICBkZWxldGUgZGF0YVtnY1tpXV07XG4gICAgfVxuICAgIGdjLnNwbGljZSgwLCBnY0xlbik7XG4gIH1cbiAgcmV0dXJuIGxvbmdlc3Q7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYWxpZ25lZCBwaXhlbCB2YWx1ZSB0byBhdm9pZCBhbnRpLWFsaWFzaW5nIGJsdXJcbiAqIEBwYXJhbSBjaGFydCAtIFRoZSBjaGFydCBpbnN0YW5jZS5cbiAqIEBwYXJhbSBwaXhlbCAtIEEgcGl4ZWwgdmFsdWUuXG4gKiBAcGFyYW0gd2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIGVsZW1lbnQuXG4gKiBAcmV0dXJucyBUaGUgYWxpZ25lZCBwaXhlbCB2YWx1ZS5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYWxpZ25QaXhlbChjaGFydDogQ2hhcnQsIHBpeGVsOiBudW1iZXIsIHdpZHRoOiBudW1iZXIpIHtcbiAgY29uc3QgZGV2aWNlUGl4ZWxSYXRpbyA9IGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvO1xuICBjb25zdCBoYWxmV2lkdGggPSB3aWR0aCAhPT0gMCA/IE1hdGgubWF4KHdpZHRoIC8gMiwgMC41KSA6IDA7XG4gIHJldHVybiBNYXRoLnJvdW5kKChwaXhlbCAtIGhhbGZXaWR0aCkgKiBkZXZpY2VQaXhlbFJhdGlvKSAvIGRldmljZVBpeGVsUmF0aW8gKyBoYWxmV2lkdGg7XG59XG5cbi8qKlxuICogQ2xlYXJzIHRoZSBlbnRpcmUgY2FudmFzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJDYW52YXMoY2FudmFzPzogSFRNTENhbnZhc0VsZW1lbnQsIGN0eD86IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkge1xuICBpZiAoIWN0eCAmJiAhY2FudmFzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY3R4ID0gY3R4IHx8IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gIGN0eC5zYXZlKCk7XG4gIC8vIGNhbnZhcy53aWR0aCBhbmQgY2FudmFzLmhlaWdodCBkbyBub3QgY29uc2lkZXIgdGhlIGNhbnZhcyB0cmFuc2Zvcm0sXG4gIC8vIHdoaWxlIGNsZWFyUmVjdCBkb2VzXG4gIGN0eC5yZXNldFRyYW5zZm9ybSgpO1xuICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gIGN0eC5yZXN0b3JlKCk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRHJhd1BvaW50T3B0aW9ucyB7XG4gIHBvaW50U3R5bGU6IFBvaW50U3R5bGU7XG4gIHJvdGF0aW9uPzogbnVtYmVyO1xuICByYWRpdXM6IG51bWJlcjtcbiAgYm9yZGVyV2lkdGg6IG51bWJlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRyYXdQb2ludChcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIG9wdGlvbnM6IERyYXdQb2ludE9wdGlvbnMsXG4gIHg6IG51bWJlcixcbiAgeTogbnVtYmVyXG4pIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICBkcmF3UG9pbnRMZWdlbmQoY3R4LCBvcHRpb25zLCB4LCB5LCBudWxsKTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmV4cG9ydCBmdW5jdGlvbiBkcmF3UG9pbnRMZWdlbmQoXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICBvcHRpb25zOiBEcmF3UG9pbnRPcHRpb25zLFxuICB4OiBudW1iZXIsXG4gIHk6IG51bWJlcixcbiAgdzogbnVtYmVyXG4pIHtcbiAgbGV0IHR5cGU6IHN0cmluZywgeE9mZnNldDogbnVtYmVyLCB5T2Zmc2V0OiBudW1iZXIsIHNpemU6IG51bWJlciwgY29ybmVyUmFkaXVzOiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIHhPZmZzZXRXOiBudW1iZXIsIHlPZmZzZXRXOiBudW1iZXI7XG4gIGNvbnN0IHN0eWxlID0gb3B0aW9ucy5wb2ludFN0eWxlO1xuICBjb25zdCByb3RhdGlvbiA9IG9wdGlvbnMucm90YXRpb247XG4gIGNvbnN0IHJhZGl1cyA9IG9wdGlvbnMucmFkaXVzO1xuICBsZXQgcmFkID0gKHJvdGF0aW9uIHx8IDApICogUkFEX1BFUl9ERUc7XG5cbiAgaWYgKHN0eWxlICYmIHR5cGVvZiBzdHlsZSA9PT0gJ29iamVjdCcpIHtcbiAgICB0eXBlID0gc3R5bGUudG9TdHJpbmcoKTtcbiAgICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgSFRNTEltYWdlRWxlbWVudF0nIHx8IHR5cGUgPT09ICdbb2JqZWN0IEhUTUxDYW52YXNFbGVtZW50XScpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xuICAgICAgY3R4LnJvdGF0ZShyYWQpO1xuICAgICAgY3R4LmRyYXdJbWFnZShzdHlsZSwgLXN0eWxlLndpZHRoIC8gMiwgLXN0eWxlLmhlaWdodCAvIDIsIHN0eWxlLndpZHRoLCBzdHlsZS5oZWlnaHQpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNOYU4ocmFkaXVzKSB8fCByYWRpdXMgPD0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGN0eC5iZWdpblBhdGgoKTtcblxuICBzd2l0Y2ggKHN0eWxlKSB7XG4gIC8vIERlZmF1bHQgaW5jbHVkZXMgY2lyY2xlXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmICh3KSB7XG4gICAgICAgIGN0eC5lbGxpcHNlKHgsIHksIHcgLyAyLCByYWRpdXMsIDAsIDAsIFRBVSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHguYXJjKHgsIHksIHJhZGl1cywgMCwgVEFVKTtcbiAgICAgIH1cbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RyaWFuZ2xlJzpcbiAgICAgIHdpZHRoID0gdyA/IHcgLyAyIDogcmFkaXVzO1xuICAgICAgY3R4Lm1vdmVUbyh4ICsgTWF0aC5zaW4ocmFkKSAqIHdpZHRoLCB5IC0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cyk7XG4gICAgICByYWQgKz0gVFdPX1RISVJEU19QSTtcbiAgICAgIGN0eC5saW5lVG8oeCArIE1hdGguc2luKHJhZCkgKiB3aWR0aCwgeSAtIE1hdGguY29zKHJhZCkgKiByYWRpdXMpO1xuICAgICAgcmFkICs9IFRXT19USElSRFNfUEk7XG4gICAgICBjdHgubGluZVRvKHggKyBNYXRoLnNpbihyYWQpICogd2lkdGgsIHkgLSBNYXRoLmNvcyhyYWQpICogcmFkaXVzKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3JlY3RSb3VuZGVkJzpcbiAgICAvLyBOT1RFOiB0aGUgcm91bmRlZCByZWN0IGltcGxlbWVudGF0aW9uIGNoYW5nZWQgdG8gdXNlIGBhcmNgIGluc3RlYWQgb2ZcbiAgICAvLyBgcXVhZHJhdGljQ3VydmVUb2Agc2luY2UgaXQgZ2VuZXJhdGVzIGJldHRlciByZXN1bHRzIHdoZW4gcmVjdCBpc1xuICAgIC8vIGFsbW9zdCBhIGNpcmNsZS4gMC41MTYgKGluc3RlYWQgb2YgMC41KSBwcm9kdWNlcyByZXN1bHRzIHdpdGggdmlzdWFsbHlcbiAgICAvLyBjbG9zZXIgcHJvcG9ydGlvbiB0byB0aGUgcHJldmlvdXMgaW1wbCBhbmQgaXQgaXMgaW5zY3JpYmVkIGluIHRoZVxuICAgIC8vIGNpcmNsZSB3aXRoIGByYWRpdXNgLiBGb3IgbW9yZSBkZXRhaWxzLCBzZWUgdGhlIGZvbGxvd2luZyBQUnM6XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzU1OTdcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNTg1OFxuICAgICAgY29ybmVyUmFkaXVzID0gcmFkaXVzICogMC41MTY7XG4gICAgICBzaXplID0gcmFkaXVzIC0gY29ybmVyUmFkaXVzO1xuICAgICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCArIFFVQVJURVJfUEkpICogc2l6ZTtcbiAgICAgIHhPZmZzZXRXID0gTWF0aC5jb3MocmFkICsgUVVBUlRFUl9QSSkgKiAodyA/IHcgLyAyIC0gY29ybmVyUmFkaXVzIDogc2l6ZSk7XG4gICAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkICsgUVVBUlRFUl9QSSkgKiBzaXplO1xuICAgICAgeU9mZnNldFcgPSBNYXRoLnNpbihyYWQgKyBRVUFSVEVSX1BJKSAqICh3ID8gdyAvIDIgLSBjb3JuZXJSYWRpdXMgOiBzaXplKTtcbiAgICAgIGN0eC5hcmMoeCAtIHhPZmZzZXRXLCB5IC0geU9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQgLSBQSSwgcmFkIC0gSEFMRl9QSSk7XG4gICAgICBjdHguYXJjKHggKyB5T2Zmc2V0VywgeSAtIHhPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkIC0gSEFMRl9QSSwgcmFkKTtcbiAgICAgIGN0eC5hcmMoeCArIHhPZmZzZXRXLCB5ICsgeU9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQsIHJhZCArIEhBTEZfUEkpO1xuICAgICAgY3R4LmFyYyh4IC0geU9mZnNldFcsIHkgKyB4T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCArIEhBTEZfUEksIHJhZCArIFBJKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3JlY3QnOlxuICAgICAgaWYgKCFyb3RhdGlvbikge1xuICAgICAgICBzaXplID0gTWF0aC5TUVJUMV8yICogcmFkaXVzO1xuICAgICAgICB3aWR0aCA9IHcgPyB3IC8gMiA6IHNpemU7XG4gICAgICAgIGN0eC5yZWN0KHggLSB3aWR0aCwgeSAtIHNpemUsIDIgKiB3aWR0aCwgMiAqIHNpemUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJhZCArPSBRVUFSVEVSX1BJO1xuICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlICdyZWN0Um90JzpcbiAgICAgIHhPZmZzZXRXID0gTWF0aC5jb3MocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpO1xuICAgICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICAgIHlPZmZzZXRXID0gTWF0aC5zaW4ocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpO1xuICAgICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldFcsIHkgLSB5T2Zmc2V0KTtcbiAgICAgIGN0eC5saW5lVG8oeCArIHlPZmZzZXRXLCB5IC0geE9mZnNldCk7XG4gICAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0VywgeSArIHlPZmZzZXQpO1xuICAgICAgY3R4LmxpbmVUbyh4IC0geU9mZnNldFcsIHkgKyB4T2Zmc2V0KTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Nyb3NzUm90JzpcbiAgICAgIHJhZCArPSBRVUFSVEVSX1BJO1xuICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlICdjcm9zcyc6XG4gICAgICB4T2Zmc2V0VyA9IE1hdGguY29zKHJhZCkgKiAodyA/IHcgLyAyIDogcmFkaXVzKTtcbiAgICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgICB5T2Zmc2V0VyA9IE1hdGguc2luKHJhZCkgKiAodyA/IHcgLyAyIDogcmFkaXVzKTtcbiAgICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXRXLCB5IC0geU9mZnNldCk7XG4gICAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0VywgeSArIHlPZmZzZXQpO1xuICAgICAgY3R4Lm1vdmVUbyh4ICsgeU9mZnNldFcsIHkgLSB4T2Zmc2V0KTtcbiAgICAgIGN0eC5saW5lVG8oeCAtIHlPZmZzZXRXLCB5ICsgeE9mZnNldCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzdGFyJzpcbiAgICAgIHhPZmZzZXRXID0gTWF0aC5jb3MocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpO1xuICAgICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICAgIHlPZmZzZXRXID0gTWF0aC5zaW4ocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpO1xuICAgICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldFcsIHkgLSB5T2Zmc2V0KTtcbiAgICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXRXLCB5ICsgeU9mZnNldCk7XG4gICAgICBjdHgubW92ZVRvKHggKyB5T2Zmc2V0VywgeSAtIHhPZmZzZXQpO1xuICAgICAgY3R4LmxpbmVUbyh4IC0geU9mZnNldFcsIHkgKyB4T2Zmc2V0KTtcbiAgICAgIHJhZCArPSBRVUFSVEVSX1BJO1xuICAgICAgeE9mZnNldFcgPSBNYXRoLmNvcyhyYWQpICogKHcgPyB3IC8gMiA6IHJhZGl1cyk7XG4gICAgICB4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcbiAgICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgICAgeU9mZnNldFcgPSBNYXRoLnNpbihyYWQpICogKHcgPyB3IC8gMiA6IHJhZGl1cyk7XG4gICAgICBjdHgubW92ZVRvKHggLSB4T2Zmc2V0VywgeSAtIHlPZmZzZXQpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgeE9mZnNldFcsIHkgKyB5T2Zmc2V0KTtcbiAgICAgIGN0eC5tb3ZlVG8oeCArIHlPZmZzZXRXLCB5IC0geE9mZnNldCk7XG4gICAgICBjdHgubGluZVRvKHggLSB5T2Zmc2V0VywgeSArIHhPZmZzZXQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbGluZSc6XG4gICAgICB4T2Zmc2V0ID0gdyA/IHcgLyAyIDogTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcbiAgICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZGFzaCc6XG4gICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgTWF0aC5jb3MocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpLCB5ICsgTWF0aC5zaW4ocmFkKSAqIHJhZGl1cyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGZhbHNlOlxuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICBjdHguZmlsbCgpO1xuICBpZiAob3B0aW9ucy5ib3JkZXJXaWR0aCA+IDApIHtcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBvaW50IGlzIGluc2lkZSB0aGUgcmVjdGFuZ2xlXG4gKiBAcGFyYW0gcG9pbnQgLSBUaGUgcG9pbnQgdG8gdGVzdFxuICogQHBhcmFtIGFyZWEgLSBUaGUgcmVjdGFuZ2xlXG4gKiBAcGFyYW0gbWFyZ2luIC0gYWxsb3dlZCBtYXJnaW5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfaXNQb2ludEluQXJlYShcbiAgcG9pbnQ6IFBvaW50LFxuICBhcmVhOiBUUkJMLFxuICBtYXJnaW4/OiBudW1iZXJcbikge1xuICBtYXJnaW4gPSBtYXJnaW4gfHwgMC41OyAvLyBtYXJnaW4gLSBkZWZhdWx0IGlzIHRvIG1hdGNoIHJvdW5kZWQgZGVjaW1hbHNcblxuICByZXR1cm4gIWFyZWEgfHwgKHBvaW50ICYmIHBvaW50LnggPiBhcmVhLmxlZnQgLSBtYXJnaW4gJiYgcG9pbnQueCA8IGFyZWEucmlnaHQgKyBtYXJnaW4gJiZcblx0XHRwb2ludC55ID4gYXJlYS50b3AgLSBtYXJnaW4gJiYgcG9pbnQueSA8IGFyZWEuYm90dG9tICsgbWFyZ2luKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsaXBBcmVhKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBhcmVhOiBUUkJMKSB7XG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LnJlY3QoYXJlYS5sZWZ0LCBhcmVhLnRvcCwgYXJlYS5yaWdodCAtIGFyZWEubGVmdCwgYXJlYS5ib3R0b20gLSBhcmVhLnRvcCk7XG4gIGN0eC5jbGlwKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bmNsaXBBcmVhKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XG4gIGN0eC5yZXN0b3JlKCk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9zdGVwcGVkTGluZVRvKFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgcHJldmlvdXM6IFBvaW50LFxuICB0YXJnZXQ6IFBvaW50LFxuICBmbGlwPzogYm9vbGVhbixcbiAgbW9kZT86IHN0cmluZ1xuKSB7XG4gIGlmICghcHJldmlvdXMpIHtcbiAgICByZXR1cm4gY3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xuICB9XG4gIGlmIChtb2RlID09PSAnbWlkZGxlJykge1xuICAgIGNvbnN0IG1pZHBvaW50ID0gKHByZXZpb3VzLnggKyB0YXJnZXQueCkgLyAyLjA7XG4gICAgY3R4LmxpbmVUbyhtaWRwb2ludCwgcHJldmlvdXMueSk7XG4gICAgY3R4LmxpbmVUbyhtaWRwb2ludCwgdGFyZ2V0LnkpO1xuICB9IGVsc2UgaWYgKG1vZGUgPT09ICdhZnRlcicgIT09ICEhZmxpcCkge1xuICAgIGN0eC5saW5lVG8ocHJldmlvdXMueCwgdGFyZ2V0LnkpO1xuICB9IGVsc2Uge1xuICAgIGN0eC5saW5lVG8odGFyZ2V0LngsIHByZXZpb3VzLnkpO1xuICB9XG4gIGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2JlemllckN1cnZlVG8oXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICBwcmV2aW91czogU3BsaW5lUG9pbnQsXG4gIHRhcmdldDogU3BsaW5lUG9pbnQsXG4gIGZsaXA/OiBib29sZWFuXG4pIHtcbiAgaWYgKCFwcmV2aW91cykge1xuICAgIHJldHVybiBjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XG4gIH1cbiAgY3R4LmJlemllckN1cnZlVG8oXG4gICAgZmxpcCA/IHByZXZpb3VzLmNwMXggOiBwcmV2aW91cy5jcDJ4LFxuICAgIGZsaXAgPyBwcmV2aW91cy5jcDF5IDogcHJldmlvdXMuY3AyeSxcbiAgICBmbGlwID8gdGFyZ2V0LmNwMnggOiB0YXJnZXQuY3AxeCxcbiAgICBmbGlwID8gdGFyZ2V0LmNwMnkgOiB0YXJnZXQuY3AxeSxcbiAgICB0YXJnZXQueCxcbiAgICB0YXJnZXQueSk7XG59XG5cbmZ1bmN0aW9uIHNldFJlbmRlck9wdHMoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIG9wdHM6IFJlbmRlclRleHRPcHRzKSB7XG4gIGlmIChvcHRzLnRyYW5zbGF0aW9uKSB7XG4gICAgY3R4LnRyYW5zbGF0ZShvcHRzLnRyYW5zbGF0aW9uWzBdLCBvcHRzLnRyYW5zbGF0aW9uWzFdKTtcbiAgfVxuXG4gIGlmICghaXNOdWxsT3JVbmRlZihvcHRzLnJvdGF0aW9uKSkge1xuICAgIGN0eC5yb3RhdGUob3B0cy5yb3RhdGlvbik7XG4gIH1cblxuICBpZiAob3B0cy5jb2xvcikge1xuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRzLmNvbG9yO1xuICB9XG5cbiAgaWYgKG9wdHMudGV4dEFsaWduKSB7XG4gICAgY3R4LnRleHRBbGlnbiA9IG9wdHMudGV4dEFsaWduO1xuICB9XG5cbiAgaWYgKG9wdHMudGV4dEJhc2VsaW5lKSB7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9IG9wdHMudGV4dEJhc2VsaW5lO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlY29yYXRlVGV4dChcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIHg6IG51bWJlcixcbiAgeTogbnVtYmVyLFxuICBsaW5lOiBzdHJpbmcsXG4gIG9wdHM6IFJlbmRlclRleHRPcHRzXG4pIHtcbiAgaWYgKG9wdHMuc3RyaWtldGhyb3VnaCB8fCBvcHRzLnVuZGVybGluZSkge1xuICAgIC8qKlxuICAgICAqIE5vdyB0aGF0IElFMTEgc3VwcG9ydCBoYXMgYmVlbiBkcm9wcGVkLCB3ZSBjYW4gdXNlIG1vcmVcbiAgICAgKiBvZiB0aGUgVGV4dE1ldHJpY3Mgb2JqZWN0LiBUaGUgYWN0dWFsIGJvdW5kaW5nIGJveGVzXG4gICAgICogYXJlIHVuZmxhZ2dlZCBpbiBDaHJvbWUsIEZpcmVmb3gsIEVkZ2UsIGFuZCBTYWZhcmkgc28gdGhleVxuICAgICAqIGNhbiBiZSBzYWZlbHkgdXNlZC5cbiAgICAgKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1RleHRNZXRyaWNzI0Jyb3dzZXJfY29tcGF0aWJpbGl0eVxuICAgICAqL1xuICAgIGNvbnN0IG1ldHJpY3MgPSBjdHgubWVhc3VyZVRleHQobGluZSk7XG4gICAgY29uc3QgbGVmdCA9IHggLSBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94TGVmdDtcbiAgICBjb25zdCByaWdodCA9IHggKyBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94UmlnaHQ7XG4gICAgY29uc3QgdG9wID0geSAtIG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQ7XG4gICAgY29uc3QgYm90dG9tID0geSArIG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50O1xuICAgIGNvbnN0IHlEZWNvcmF0aW9uID0gb3B0cy5zdHJpa2V0aHJvdWdoID8gKHRvcCArIGJvdHRvbSkgLyAyIDogYm90dG9tO1xuXG4gICAgY3R4LnN0cm9rZVN0eWxlID0gY3R4LmZpbGxTdHlsZTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmxpbmVXaWR0aCA9IG9wdHMuZGVjb3JhdGlvbldpZHRoIHx8IDI7XG4gICAgY3R4Lm1vdmVUbyhsZWZ0LCB5RGVjb3JhdGlvbik7XG4gICAgY3R4LmxpbmVUbyhyaWdodCwgeURlY29yYXRpb24pO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkcmF3QmFja2Ryb3AoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIG9wdHM6IEJhY2tkcm9wT3B0aW9ucykge1xuICBjb25zdCBvbGRDb2xvciA9IGN0eC5maWxsU3R5bGU7XG5cbiAgY3R4LmZpbGxTdHlsZSA9IG9wdHMuY29sb3IgYXMgc3RyaW5nO1xuICBjdHguZmlsbFJlY3Qob3B0cy5sZWZ0LCBvcHRzLnRvcCwgb3B0cy53aWR0aCwgb3B0cy5oZWlnaHQpO1xuICBjdHguZmlsbFN0eWxlID0gb2xkQ29sb3I7XG59XG5cbi8qKlxuICogUmVuZGVyIHRleHQgb250byB0aGUgY2FudmFzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJUZXh0KFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgdGV4dDogc3RyaW5nIHwgc3RyaW5nW10sXG4gIHg6IG51bWJlcixcbiAgeTogbnVtYmVyLFxuICBmb250OiBDYW52YXNGb250U3BlYyxcbiAgb3B0czogUmVuZGVyVGV4dE9wdHMgPSB7fVxuKSB7XG4gIGNvbnN0IGxpbmVzID0gaXNBcnJheSh0ZXh0KSA/IHRleHQgOiBbdGV4dF07XG4gIGNvbnN0IHN0cm9rZSA9IG9wdHMuc3Ryb2tlV2lkdGggPiAwICYmIG9wdHMuc3Ryb2tlQ29sb3IgIT09ICcnO1xuICBsZXQgaTogbnVtYmVyLCBsaW5lOiBzdHJpbmc7XG5cbiAgY3R4LnNhdmUoKTtcbiAgY3R4LmZvbnQgPSBmb250LnN0cmluZztcbiAgc2V0UmVuZGVyT3B0cyhjdHgsIG9wdHMpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkge1xuICAgIGxpbmUgPSBsaW5lc1tpXTtcblxuICAgIGlmIChvcHRzLmJhY2tkcm9wKSB7XG4gICAgICBkcmF3QmFja2Ryb3AoY3R4LCBvcHRzLmJhY2tkcm9wKTtcbiAgICB9XG5cbiAgICBpZiAoc3Ryb2tlKSB7XG4gICAgICBpZiAob3B0cy5zdHJva2VDb2xvcikge1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRzLnN0cm9rZUNvbG9yO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTnVsbE9yVW5kZWYob3B0cy5zdHJva2VXaWR0aCkpIHtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IG9wdHMuc3Ryb2tlV2lkdGg7XG4gICAgICB9XG5cbiAgICAgIGN0eC5zdHJva2VUZXh0KGxpbmUsIHgsIHksIG9wdHMubWF4V2lkdGgpO1xuICAgIH1cblxuICAgIGN0eC5maWxsVGV4dChsaW5lLCB4LCB5LCBvcHRzLm1heFdpZHRoKTtcbiAgICBkZWNvcmF0ZVRleHQoY3R4LCB4LCB5LCBsaW5lLCBvcHRzKTtcblxuICAgIHkgKz0gTnVtYmVyKGZvbnQubGluZUhlaWdodCk7XG4gIH1cblxuICBjdHgucmVzdG9yZSgpO1xufVxuXG4vKipcbiAqIEFkZCBhIHBhdGggb2YgYSByZWN0YW5nbGUgd2l0aCByb3VuZGVkIGNvcm5lcnMgdG8gdGhlIGN1cnJlbnQgc3ViLXBhdGhcbiAqIEBwYXJhbSBjdHggLSBDb250ZXh0XG4gKiBAcGFyYW0gcmVjdCAtIEJvdW5kaW5nIHJlY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZFJvdW5kZWRSZWN0UGF0aChcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIHJlY3Q6IFJvdW5kZWRSZWN0ICYgeyByYWRpdXM6IFRSQkxDb3JuZXJzIH1cbikge1xuICBjb25zdCB7eCwgeSwgdywgaCwgcmFkaXVzfSA9IHJlY3Q7XG5cbiAgLy8gdG9wIGxlZnQgYXJjXG4gIGN0eC5hcmMoeCArIHJhZGl1cy50b3BMZWZ0LCB5ICsgcmFkaXVzLnRvcExlZnQsIHJhZGl1cy50b3BMZWZ0LCAxLjUgKiBQSSwgUEksIHRydWUpO1xuXG4gIC8vIGxpbmUgZnJvbSB0b3AgbGVmdCB0byBib3R0b20gbGVmdFxuICBjdHgubGluZVRvKHgsIHkgKyBoIC0gcmFkaXVzLmJvdHRvbUxlZnQpO1xuXG4gIC8vIGJvdHRvbSBsZWZ0IGFyY1xuICBjdHguYXJjKHggKyByYWRpdXMuYm90dG9tTGVmdCwgeSArIGggLSByYWRpdXMuYm90dG9tTGVmdCwgcmFkaXVzLmJvdHRvbUxlZnQsIFBJLCBIQUxGX1BJLCB0cnVlKTtcblxuICAvLyBsaW5lIGZyb20gYm90dG9tIGxlZnQgdG8gYm90dG9tIHJpZ2h0XG4gIGN0eC5saW5lVG8oeCArIHcgLSByYWRpdXMuYm90dG9tUmlnaHQsIHkgKyBoKTtcblxuICAvLyBib3R0b20gcmlnaHQgYXJjXG4gIGN0eC5hcmMoeCArIHcgLSByYWRpdXMuYm90dG9tUmlnaHQsIHkgKyBoIC0gcmFkaXVzLmJvdHRvbVJpZ2h0LCByYWRpdXMuYm90dG9tUmlnaHQsIEhBTEZfUEksIDAsIHRydWUpO1xuXG4gIC8vIGxpbmUgZnJvbSBib3R0b20gcmlnaHQgdG8gdG9wIHJpZ2h0XG4gIGN0eC5saW5lVG8oeCArIHcsIHkgKyByYWRpdXMudG9wUmlnaHQpO1xuXG4gIC8vIHRvcCByaWdodCBhcmNcbiAgY3R4LmFyYyh4ICsgdyAtIHJhZGl1cy50b3BSaWdodCwgeSArIHJhZGl1cy50b3BSaWdodCwgcmFkaXVzLnRvcFJpZ2h0LCAwLCAtSEFMRl9QSSwgdHJ1ZSk7XG5cbiAgLy8gbGluZSBmcm9tIHRvcCByaWdodCB0byB0b3AgbGVmdFxuICBjdHgubGluZVRvKHggKyByYWRpdXMudG9wTGVmdCwgeSk7XG59XG4iLCJpbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi4vY29yZS9jb3JlLmRlZmF1bHRzLmpzJztcbmltcG9ydCB7aXNBcnJheSwgaXNPYmplY3QsIHRvRGltZW5zaW9uLCB2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHt0b0ZvbnRTdHJpbmd9IGZyb20gJy4vaGVscGVycy5jYW52YXMuanMnO1xuaW1wb3J0IHR5cGUge0NoYXJ0QXJlYSwgRm9udFNwZWMsIFBvaW50fSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5pbXBvcnQgdHlwZSB7VFJCTCwgVFJCTENvcm5lcnN9IGZyb20gJy4uL3R5cGVzL2dlb21ldHJpYy5qcyc7XG5cbmNvbnN0IExJTkVfSEVJR0hUID0gL14obm9ybWFsfChcXGQrKD86XFwuXFxkKyk/KShweHxlbXwlKT8pJC87XG5jb25zdCBGT05UX1NUWUxFID0gL14obm9ybWFsfGl0YWxpY3xpbml0aWFsfGluaGVyaXR8dW5zZXR8KG9ibGlxdWUoIC0/WzAtOV0/WzAtOV1kZWcpPykpJC87XG5cbi8qKlxuICogQGFsaWFzIENoYXJ0LmhlbHBlcnMub3B0aW9uc1xuICogQG5hbWVzcGFjZVxuICovXG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiBsaW5lIGhlaWdodCBgdmFsdWVgIGluIHBpeGVscyBmb3IgYSBzcGVjaWZpYyBmb250IGBzaXplYC5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBsaW5lSGVpZ2h0IHRvIHBhcnNlIChlZy4gMS42LCAnMTRweCcsICc3NSUnLCAnMS42ZW0nKS5cbiAqIEBwYXJhbSBzaXplIC0gVGhlIGZvbnQgc2l6ZSAoaW4gcGl4ZWxzKSB1c2VkIHRvIHJlc29sdmUgcmVsYXRpdmUgYHZhbHVlYC5cbiAqIEByZXR1cm5zIFRoZSBlZmZlY3RpdmUgbGluZSBoZWlnaHQgaW4gcGl4ZWxzIChzaXplICogMS4yIGlmIHZhbHVlIGlzIGludmFsaWQpLlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvbGluZS1oZWlnaHRcbiAqIEBzaW5jZSAyLjcuMFxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9MaW5lSGVpZ2h0KHZhbHVlOiBudW1iZXIgfCBzdHJpbmcsIHNpemU6IG51bWJlcik6IG51bWJlciB7XG4gIGNvbnN0IG1hdGNoZXMgPSAoJycgKyB2YWx1ZSkubWF0Y2goTElORV9IRUlHSFQpO1xuICBpZiAoIW1hdGNoZXMgfHwgbWF0Y2hlc1sxXSA9PT0gJ25vcm1hbCcpIHtcbiAgICByZXR1cm4gc2l6ZSAqIDEuMjtcbiAgfVxuXG4gIHZhbHVlID0gK21hdGNoZXNbMl07XG5cbiAgc3dpdGNoIChtYXRjaGVzWzNdKSB7XG4gICAgY2FzZSAncHgnOlxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGNhc2UgJyUnOlxuICAgICAgdmFsdWUgLz0gMTAwO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHNpemUgKiB2YWx1ZTtcbn1cblxuY29uc3QgbnVtYmVyT3JaZXJvID0gKHY6IHVua25vd24pID0+ICt2IHx8IDA7XG5cbi8qKlxuICogQHBhcmFtIHZhbHVlXG4gKiBAcGFyYW0gcHJvcHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9yZWFkVmFsdWVUb1Byb3BzPEsgZXh0ZW5kcyBzdHJpbmc+KHZhbHVlOiBudW1iZXIgfCBSZWNvcmQ8SywgbnVtYmVyPiwgcHJvcHM6IEtbXSk6IFJlY29yZDxLLCBudW1iZXI+O1xuZXhwb3J0IGZ1bmN0aW9uIF9yZWFkVmFsdWVUb1Byb3BzPEsgZXh0ZW5kcyBzdHJpbmcsIFQgZXh0ZW5kcyBzdHJpbmc+KHZhbHVlOiBudW1iZXIgfCBSZWNvcmQ8SyAmIFQsIG51bWJlcj4sIHByb3BzOiBSZWNvcmQ8VCwgSz4pOiBSZWNvcmQ8VCwgbnVtYmVyPjtcbmV4cG9ydCBmdW5jdGlvbiBfcmVhZFZhbHVlVG9Qcm9wcyh2YWx1ZTogbnVtYmVyIHwgUmVjb3JkPHN0cmluZywgbnVtYmVyPiwgcHJvcHM6IHN0cmluZ1tdIHwgUmVjb3JkPHN0cmluZywgc3RyaW5nPikge1xuICBjb25zdCByZXQgPSB7fTtcbiAgY29uc3Qgb2JqUHJvcHMgPSBpc09iamVjdChwcm9wcyk7XG4gIGNvbnN0IGtleXMgPSBvYmpQcm9wcyA/IE9iamVjdC5rZXlzKHByb3BzKSA6IHByb3BzO1xuICBjb25zdCByZWFkID0gaXNPYmplY3QodmFsdWUpXG4gICAgPyBvYmpQcm9wc1xuICAgICAgPyBwcm9wID0+IHZhbHVlT3JEZWZhdWx0KHZhbHVlW3Byb3BdLCB2YWx1ZVtwcm9wc1twcm9wXV0pXG4gICAgICA6IHByb3AgPT4gdmFsdWVbcHJvcF1cbiAgICA6ICgpID0+IHZhbHVlO1xuXG4gIGZvciAoY29uc3QgcHJvcCBvZiBrZXlzKSB7XG4gICAgcmV0W3Byb3BdID0gbnVtYmVyT3JaZXJvKHJlYWQocHJvcCkpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGdpdmVuIHZhbHVlIGludG8gYSBUUkJMIG9iamVjdC5cbiAqIEBwYXJhbSB2YWx1ZSAtIElmIGEgbnVtYmVyLCBzZXQgdGhlIHZhbHVlIHRvIGFsbCBUUkJMIGNvbXBvbmVudCxcbiAqICBlbHNlLCBpZiBhbiBvYmplY3QsIHVzZSBkZWZpbmVkIHByb3BlcnRpZXMgYW5kIHNldHMgdW5kZWZpbmVkIG9uZXMgdG8gMC5cbiAqICB4IC8geSBhcmUgc2hvcnRoYW5kcyBmb3Igc2FtZSB2YWx1ZSBmb3IgbGVmdC9yaWdodCBhbmQgdG9wL2JvdHRvbS5cbiAqIEByZXR1cm5zIFRoZSBwYWRkaW5nIHZhbHVlcyAodG9wLCByaWdodCwgYm90dG9tLCBsZWZ0KVxuICogQHNpbmNlIDMuMC4wXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1RSQkwodmFsdWU6IG51bWJlciB8IFRSQkwgfCBQb2ludCkge1xuICByZXR1cm4gX3JlYWRWYWx1ZVRvUHJvcHModmFsdWUsIHt0b3A6ICd5JywgcmlnaHQ6ICd4JywgYm90dG9tOiAneScsIGxlZnQ6ICd4J30pO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiB2YWx1ZSBpbnRvIGEgVFJCTCBjb3JuZXJzIG9iamVjdCAoc2ltaWxhciB3aXRoIGNzcyBib3JkZXItcmFkaXVzKS5cbiAqIEBwYXJhbSB2YWx1ZSAtIElmIGEgbnVtYmVyLCBzZXQgdGhlIHZhbHVlIHRvIGFsbCBUUkJMIGNvcm5lciBjb21wb25lbnRzLFxuICogIGVsc2UsIGlmIGFuIG9iamVjdCwgdXNlIGRlZmluZWQgcHJvcGVydGllcyBhbmQgc2V0cyB1bmRlZmluZWQgb25lcyB0byAwLlxuICogQHJldHVybnMgVGhlIFRSQkwgY29ybmVyIHZhbHVlcyAodG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0KVxuICogQHNpbmNlIDMuMC4wXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1RSQkxDb3JuZXJzKHZhbHVlOiBudW1iZXIgfCBUUkJMQ29ybmVycykge1xuICByZXR1cm4gX3JlYWRWYWx1ZVRvUHJvcHModmFsdWUsIFsndG9wTGVmdCcsICd0b3BSaWdodCcsICdib3R0b21MZWZ0JywgJ2JvdHRvbVJpZ2h0J10pO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiB2YWx1ZSBpbnRvIGEgcGFkZGluZyBvYmplY3Qgd2l0aCBwcmUtY29tcHV0ZWQgd2lkdGgvaGVpZ2h0LlxuICogQHBhcmFtIHZhbHVlIC0gSWYgYSBudW1iZXIsIHNldCB0aGUgdmFsdWUgdG8gYWxsIFRSQkwgY29tcG9uZW50LFxuICogIGVsc2UsIGlmIGFuIG9iamVjdCwgdXNlIGRlZmluZWQgcHJvcGVydGllcyBhbmQgc2V0cyB1bmRlZmluZWQgb25lcyB0byAwLlxuICogIHggLyB5IGFyZSBzaG9ydGhhbmRzIGZvciBzYW1lIHZhbHVlIGZvciBsZWZ0L3JpZ2h0IGFuZCB0b3AvYm90dG9tLlxuICogQHJldHVybnMgVGhlIHBhZGRpbmcgdmFsdWVzICh0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQsIHdpZHRoLCBoZWlnaHQpXG4gKiBAc2luY2UgMi43LjBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvUGFkZGluZyh2YWx1ZT86IG51bWJlciB8IFRSQkwpOiBDaGFydEFyZWEge1xuICBjb25zdCBvYmogPSB0b1RSQkwodmFsdWUpIGFzIENoYXJ0QXJlYTtcblxuICBvYmoud2lkdGggPSBvYmoubGVmdCArIG9iai5yaWdodDtcbiAgb2JqLmhlaWdodCA9IG9iai50b3AgKyBvYmouYm90dG9tO1xuXG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogUGFyc2VzIGZvbnQgb3B0aW9ucyBhbmQgcmV0dXJucyB0aGUgZm9udCBvYmplY3QuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEEgb2JqZWN0IHRoYXQgY29udGFpbnMgZm9udCBvcHRpb25zIHRvIGJlIHBhcnNlZC5cbiAqIEBwYXJhbSBmYWxsYmFjayAtIEEgb2JqZWN0IHRoYXQgY29udGFpbnMgZmFsbGJhY2sgZm9udCBvcHRpb25zLlxuICogQHJldHVybiBUaGUgZm9udCBvYmplY3QuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0b0ZvbnQob3B0aW9uczogUGFydGlhbDxGb250U3BlYz4sIGZhbGxiYWNrPzogUGFydGlhbDxGb250U3BlYz4pIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGZhbGxiYWNrID0gZmFsbGJhY2sgfHwgZGVmYXVsdHMuZm9udCBhcyBGb250U3BlYztcblxuICBsZXQgc2l6ZSA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuc2l6ZSwgZmFsbGJhY2suc2l6ZSk7XG5cbiAgaWYgKHR5cGVvZiBzaXplID09PSAnc3RyaW5nJykge1xuICAgIHNpemUgPSBwYXJzZUludChzaXplLCAxMCk7XG4gIH1cbiAgbGV0IHN0eWxlID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5zdHlsZSwgZmFsbGJhY2suc3R5bGUpO1xuICBpZiAoc3R5bGUgJiYgISgnJyArIHN0eWxlKS5tYXRjaChGT05UX1NUWUxFKSkge1xuICAgIGNvbnNvbGUud2FybignSW52YWxpZCBmb250IHN0eWxlIHNwZWNpZmllZDogXCInICsgc3R5bGUgKyAnXCInKTtcbiAgICBzdHlsZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGNvbnN0IGZvbnQgPSB7XG4gICAgZmFtaWx5OiB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmZhbWlseSwgZmFsbGJhY2suZmFtaWx5KSxcbiAgICBsaW5lSGVpZ2h0OiB0b0xpbmVIZWlnaHQodmFsdWVPckRlZmF1bHQob3B0aW9ucy5saW5lSGVpZ2h0LCBmYWxsYmFjay5saW5lSGVpZ2h0KSwgc2l6ZSksXG4gICAgc2l6ZSxcbiAgICBzdHlsZSxcbiAgICB3ZWlnaHQ6IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMud2VpZ2h0LCBmYWxsYmFjay53ZWlnaHQpLFxuICAgIHN0cmluZzogJydcbiAgfTtcblxuICBmb250LnN0cmluZyA9IHRvRm9udFN0cmluZyhmb250KTtcbiAgcmV0dXJuIGZvbnQ7XG59XG5cbi8qKlxuICogRXZhbHVhdGVzIHRoZSBnaXZlbiBgaW5wdXRzYCBzZXF1ZW50aWFsbHkgYW5kIHJldHVybnMgdGhlIGZpcnN0IGRlZmluZWQgdmFsdWUuXG4gKiBAcGFyYW0gaW5wdXRzIC0gQW4gYXJyYXkgb2YgdmFsdWVzLCBmYWxsaW5nIGJhY2sgdG8gdGhlIGxhc3QgdmFsdWUuXG4gKiBAcGFyYW0gY29udGV4dCAtIElmIGRlZmluZWQgYW5kIHRoZSBjdXJyZW50IHZhbHVlIGlzIGEgZnVuY3Rpb24sIHRoZSB2YWx1ZVxuICogaXMgY2FsbGVkIHdpdGggYGNvbnRleHRgIGFzIGZpcnN0IGFyZ3VtZW50IGFuZCB0aGUgcmVzdWx0IGJlY29tZXMgdGhlIG5ldyBpbnB1dC5cbiAqIEBwYXJhbSBpbmRleCAtIElmIGRlZmluZWQgYW5kIHRoZSBjdXJyZW50IHZhbHVlIGlzIGFuIGFycmF5LCB0aGUgdmFsdWVcbiAqIGF0IGBpbmRleGAgYmVjb21lIHRoZSBuZXcgaW5wdXQuXG4gKiBAcGFyYW0gaW5mbyAtIG9iamVjdCB0byByZXR1cm4gaW5mb3JtYXRpb24gYWJvdXQgcmVzb2x1dGlvbiBpblxuICogQHBhcmFtIGluZm8uY2FjaGVhYmxlIC0gV2lsbCBiZSBzZXQgdG8gYGZhbHNlYCBpZiBvcHRpb24gaXMgbm90IGNhY2hlYWJsZS5cbiAqIEBzaW5jZSAyLjcuMFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZShpbnB1dHM6IEFycmF5PHVua25vd24+LCBjb250ZXh0Pzogb2JqZWN0LCBpbmRleD86IG51bWJlciwgaW5mbz86IHsgY2FjaGVhYmxlOiBib29sZWFuIH0pIHtcbiAgbGV0IGNhY2hlYWJsZSA9IHRydWU7XG4gIGxldCBpOiBudW1iZXIsIGlsZW46IG51bWJlciwgdmFsdWU6IHVua25vd247XG5cbiAgZm9yIChpID0gMCwgaWxlbiA9IGlucHV0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICB2YWx1ZSA9IGlucHV0c1tpXTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChjb250ZXh0ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlKGNvbnRleHQpO1xuICAgICAgY2FjaGVhYmxlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkICYmIGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlW2luZGV4ICUgdmFsdWUubGVuZ3RoXTtcbiAgICAgIGNhY2hlYWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGluZm8gJiYgIWNhY2hlYWJsZSkge1xuICAgICAgICBpbmZvLmNhY2hlYWJsZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSBtaW5tYXhcbiAqIEBwYXJhbSBncmFjZVxuICogQHBhcmFtIGJlZ2luQXRaZXJvXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2FkZEdyYWNlKG1pbm1heDogeyBtaW46IG51bWJlcjsgbWF4OiBudW1iZXI7IH0sIGdyYWNlOiBudW1iZXIgfCBzdHJpbmcsIGJlZ2luQXRaZXJvOiBib29sZWFuKSB7XG4gIGNvbnN0IHttaW4sIG1heH0gPSBtaW5tYXg7XG4gIGNvbnN0IGNoYW5nZSA9IHRvRGltZW5zaW9uKGdyYWNlLCAobWF4IC0gbWluKSAvIDIpO1xuICBjb25zdCBrZWVwWmVybyA9ICh2YWx1ZTogbnVtYmVyLCBhZGQ6IG51bWJlcikgPT4gYmVnaW5BdFplcm8gJiYgdmFsdWUgPT09IDAgPyAwIDogdmFsdWUgKyBhZGQ7XG4gIHJldHVybiB7XG4gICAgbWluOiBrZWVwWmVybyhtaW4sIC1NYXRoLmFicyhjaGFuZ2UpKSxcbiAgICBtYXg6IGtlZXBaZXJvKG1heCwgY2hhbmdlKVxuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGNvbnRleHQgaW5oZXJpdGluZyBwYXJlbnRDb250ZXh0XG4gKiBAcGFyYW0gcGFyZW50Q29udGV4dFxuICogQHBhcmFtIGNvbnRleHRcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb250ZXh0PFQgZXh0ZW5kcyBvYmplY3Q+KHBhcmVudENvbnRleHQ6IG51bGwsIGNvbnRleHQ6IFQpOiBUO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQ8VCBleHRlbmRzIG9iamVjdCwgUCBleHRlbmRzIFQ+KHBhcmVudENvbnRleHQ6IFAsIGNvbnRleHQ6IFQpOiBQICYgVDtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb250ZXh0KHBhcmVudENvbnRleHQ6IG9iamVjdCwgY29udGV4dDogb2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUocGFyZW50Q29udGV4dCksIGNvbnRleHQpO1xufVxuIiwiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lICovXG5pbXBvcnQgdHlwZSB7QW55T2JqZWN0fSBmcm9tICcuLi90eXBlcy9iYXNpYy5qcyc7XG5pbXBvcnQgdHlwZSB7Q2hhcnRNZXRhfSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5pbXBvcnQgdHlwZSB7XG4gIFJlc29sdmVyT2JqZWN0S2V5LFxuICBSZXNvbHZlckNhY2hlLFxuICBSZXNvbHZlclByb3h5LFxuICBEZXNjcmlwdG9yRGVmYXVsdHMsXG4gIERlc2NyaXB0b3IsXG4gIENvbnRleHRDYWNoZSxcbiAgQ29udGV4dFByb3h5XG59IGZyb20gJy4vaGVscGVycy5jb25maWcudHlwZXMuanMnO1xuaW1wb3J0IHtpc0FycmF5LCBpc0Z1bmN0aW9uLCBpc09iamVjdCwgcmVzb2x2ZU9iamVjdEtleSwgX2NhcGl0YWxpemV9IGZyb20gJy4vaGVscGVycy5jb3JlLmpzJztcblxuZXhwb3J0ICogZnJvbSAnLi9oZWxwZXJzLmNvbmZpZy50eXBlcy5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIFByb3h5IGZvciByZXNvbHZpbmcgcmF3IHZhbHVlcyBmb3Igb3B0aW9ucy5cbiAqIEBwYXJhbSBzY29wZXMgLSBUaGUgb3B0aW9uIHNjb3BlcyB0byBsb29rIGZvciB2YWx1ZXMsIGluIHJlc29sdXRpb24gb3JkZXJcbiAqIEBwYXJhbSBwcmVmaXhlcyAtIFRoZSBwcmVmaXhlcyBmb3IgdmFsdWVzLCBpbiByZXNvbHV0aW9uIG9yZGVyLlxuICogQHBhcmFtIHJvb3RTY29wZXMgLSBUaGUgcm9vdCBvcHRpb24gc2NvcGVzXG4gKiBAcGFyYW0gZmFsbGJhY2sgLSBQYXJlbnQgc2NvcGVzIGZhbGxiYWNrXG4gKiBAcGFyYW0gZ2V0VGFyZ2V0IC0gY2FsbGJhY2sgZm9yIGdldHRpbmcgdGhlIHRhcmdldCBmb3IgY2hhbmdlZCB2YWx1ZXNcbiAqIEByZXR1cm5zIFByb3h5XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2NyZWF0ZVJlc29sdmVyPFxuICBUIGV4dGVuZHMgQW55T2JqZWN0W10gPSBBbnlPYmplY3RbXSxcbiAgUiBleHRlbmRzIEFueU9iamVjdFtdID0gVFxuPihcbiAgc2NvcGVzOiBULFxuICBwcmVmaXhlcyA9IFsnJ10sXG4gIHJvb3RTY29wZXM/OiBSLFxuICBmYWxsYmFjaz86IFJlc29sdmVyT2JqZWN0S2V5LFxuICBnZXRUYXJnZXQgPSAoKSA9PiBzY29wZXNbMF1cbikge1xuICBjb25zdCBmaW5hbFJvb3RTY29wZXMgPSByb290U2NvcGVzIHx8IHNjb3BlcztcbiAgaWYgKHR5cGVvZiBmYWxsYmFjayA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBmYWxsYmFjayA9IF9yZXNvbHZlKCdfZmFsbGJhY2snLCBzY29wZXMpO1xuICB9XG4gIGNvbnN0IGNhY2hlOiBSZXNvbHZlckNhY2hlPFQsIFI+ID0ge1xuICAgIFtTeW1ib2wudG9TdHJpbmdUYWddOiAnT2JqZWN0JyxcbiAgICBfY2FjaGVhYmxlOiB0cnVlLFxuICAgIF9zY29wZXM6IHNjb3BlcyxcbiAgICBfcm9vdFNjb3BlczogZmluYWxSb290U2NvcGVzLFxuICAgIF9mYWxsYmFjazogZmFsbGJhY2ssXG4gICAgX2dldFRhcmdldDogZ2V0VGFyZ2V0LFxuICAgIG92ZXJyaWRlOiAoc2NvcGU6IEFueU9iamVjdCkgPT4gX2NyZWF0ZVJlc29sdmVyKFtzY29wZSwgLi4uc2NvcGVzXSwgcHJlZml4ZXMsIGZpbmFsUm9vdFNjb3BlcywgZmFsbGJhY2spLFxuICB9O1xuICByZXR1cm4gbmV3IFByb3h5KGNhY2hlLCB7XG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciB0aGUgZGVsZXRlIG9wZXJhdG9yLlxuICAgICAqL1xuICAgIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcDogc3RyaW5nKSB7XG4gICAgICBkZWxldGUgdGFyZ2V0W3Byb3BdOyAvLyByZW1vdmUgZnJvbSBjYWNoZVxuICAgICAgZGVsZXRlIHRhcmdldC5fa2V5czsgLy8gcmVtb3ZlIGNhY2hlZCBrZXlzXG4gICAgICBkZWxldGUgc2NvcGVzWzBdW3Byb3BdOyAvLyByZW1vdmUgZnJvbSB0b3AgbGV2ZWwgc2NvcGVcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIGdldHRpbmcgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqL1xuICAgIGdldCh0YXJnZXQsIHByb3A6IHN0cmluZykge1xuICAgICAgcmV0dXJuIF9jYWNoZWQodGFyZ2V0LCBwcm9wLFxuICAgICAgICAoKSA9PiBfcmVzb2x2ZVdpdGhQcmVmaXhlcyhwcm9wLCBwcmVmaXhlcywgc2NvcGVzLCB0YXJnZXQpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLlxuICAgICAqIEFsc28gdXNlZCBieSBPYmplY3QuaGFzT3duUHJvcGVydHkuXG4gICAgICovXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldC5fc2NvcGVzWzBdLCBwcm9wKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YuXG4gICAgICovXG4gICAgZ2V0UHJvdG90eXBlT2YoKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXRQcm90b3R5cGVPZihzY29wZXNbMF0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIHRoZSBpbiBvcGVyYXRvci5cbiAgICAgKi9cbiAgICBoYXModGFyZ2V0LCBwcm9wOiBzdHJpbmcpIHtcbiAgICAgIHJldHVybiBnZXRLZXlzRnJvbUFsbFNjb3Blcyh0YXJnZXQpLmluY2x1ZGVzKHByb3ApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIGFuZCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLlxuICAgICAqL1xuICAgIG93bktleXModGFyZ2V0KSB7XG4gICAgICByZXR1cm4gZ2V0S2V5c0Zyb21BbGxTY29wZXModGFyZ2V0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBzZXR0aW5nIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKi9cbiAgICBzZXQodGFyZ2V0LCBwcm9wOiBzdHJpbmcsIHZhbHVlKSB7XG4gICAgICBjb25zdCBzdG9yYWdlID0gdGFyZ2V0Ll9zdG9yYWdlIHx8ICh0YXJnZXQuX3N0b3JhZ2UgPSBnZXRUYXJnZXQoKSk7XG4gICAgICB0YXJnZXRbcHJvcF0gPSBzdG9yYWdlW3Byb3BdID0gdmFsdWU7IC8vIHNldCB0byB0b3AgbGV2ZWwgc2NvcGUgKyBjYWNoZVxuICAgICAgZGVsZXRlIHRhcmdldC5fa2V5czsgLy8gcmVtb3ZlIGNhY2hlZCBrZXlzXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pIGFzIFJlc29sdmVyUHJveHk8VCwgUj47XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBQcm94eSBmb3IgcmVzb2x2aW5nIG9wdGlvbiB2YWx1ZXMgd2l0aCBjb250ZXh0LlxuICogQHBhcmFtIHByb3h5IC0gVGhlIFByb3h5IHJldHVybmVkIGJ5IGBfY3JlYXRlUmVzb2x2ZXJgXG4gKiBAcGFyYW0gY29udGV4dCAtIENvbnRleHQgb2JqZWN0IGZvciBzY3JpcHRhYmxlL2luZGV4YWJsZSBvcHRpb25zXG4gKiBAcGFyYW0gc3ViUHJveHkgLSBUaGUgcHJveHkgcHJvdmlkZWQgZm9yIHNjcmlwdGFibGUgb3B0aW9uc1xuICogQHBhcmFtIGRlc2NyaXB0b3JEZWZhdWx0cyAtIERlZmF1bHRzIGZvciBkZXNjcmlwdG9yc1xuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9hdHRhY2hDb250ZXh0PFxuICBUIGV4dGVuZHMgQW55T2JqZWN0W10gPSBBbnlPYmplY3RbXSxcbiAgUiBleHRlbmRzIEFueU9iamVjdFtdID0gVFxuPihcbiAgcHJveHk6IFJlc29sdmVyUHJveHk8VCwgUj4sXG4gIGNvbnRleHQ6IEFueU9iamVjdCxcbiAgc3ViUHJveHk/OiBSZXNvbHZlclByb3h5PFQsIFI+LFxuICBkZXNjcmlwdG9yRGVmYXVsdHM/OiBEZXNjcmlwdG9yRGVmYXVsdHNcbikge1xuICBjb25zdCBjYWNoZTogQ29udGV4dENhY2hlPFQsIFI+ID0ge1xuICAgIF9jYWNoZWFibGU6IGZhbHNlLFxuICAgIF9wcm94eTogcHJveHksXG4gICAgX2NvbnRleHQ6IGNvbnRleHQsXG4gICAgX3N1YlByb3h5OiBzdWJQcm94eSxcbiAgICBfc3RhY2s6IG5ldyBTZXQoKSxcbiAgICBfZGVzY3JpcHRvcnM6IF9kZXNjcmlwdG9ycyhwcm94eSwgZGVzY3JpcHRvckRlZmF1bHRzKSxcbiAgICBzZXRDb250ZXh0OiAoY3R4OiBBbnlPYmplY3QpID0+IF9hdHRhY2hDb250ZXh0KHByb3h5LCBjdHgsIHN1YlByb3h5LCBkZXNjcmlwdG9yRGVmYXVsdHMpLFxuICAgIG92ZXJyaWRlOiAoc2NvcGU6IEFueU9iamVjdCkgPT4gX2F0dGFjaENvbnRleHQocHJveHkub3ZlcnJpZGUoc2NvcGUpLCBjb250ZXh0LCBzdWJQcm94eSwgZGVzY3JpcHRvckRlZmF1bHRzKVxuICB9O1xuICByZXR1cm4gbmV3IFByb3h5KGNhY2hlLCB7XG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciB0aGUgZGVsZXRlIG9wZXJhdG9yLlxuICAgICAqL1xuICAgIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcCkge1xuICAgICAgZGVsZXRlIHRhcmdldFtwcm9wXTsgLy8gcmVtb3ZlIGZyb20gY2FjaGVcbiAgICAgIGRlbGV0ZSBwcm94eVtwcm9wXTsgLy8gcmVtb3ZlIGZyb20gcHJveHlcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIGdldHRpbmcgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqL1xuICAgIGdldCh0YXJnZXQsIHByb3A6IHN0cmluZywgcmVjZWl2ZXIpIHtcbiAgICAgIHJldHVybiBfY2FjaGVkKHRhcmdldCwgcHJvcCxcbiAgICAgICAgKCkgPT4gX3Jlc29sdmVXaXRoQ29udGV4dCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvci5cbiAgICAgKiBBbHNvIHVzZWQgYnkgT2JqZWN0Lmhhc093blByb3BlcnR5LlxuICAgICAqL1xuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3ApIHtcbiAgICAgIHJldHVybiB0YXJnZXQuX2Rlc2NyaXB0b3JzLmFsbEtleXNcbiAgICAgICAgPyBSZWZsZWN0Lmhhcyhwcm94eSwgcHJvcCkgPyB7ZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSA6IHVuZGVmaW5lZFxuICAgICAgICA6IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3h5LCBwcm9wKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YuXG4gICAgICovXG4gICAgZ2V0UHJvdG90eXBlT2YoKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXRQcm90b3R5cGVPZihwcm94eSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgdGhlIGluIG9wZXJhdG9yLlxuICAgICAqL1xuICAgIGhhcyh0YXJnZXQsIHByb3ApIHtcbiAgICAgIHJldHVybiBSZWZsZWN0Lmhhcyhwcm94eSwgcHJvcCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgYW5kIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMuXG4gICAgICovXG4gICAgb3duS2V5cygpIHtcbiAgICAgIHJldHVybiBSZWZsZWN0Lm93bktleXMocHJveHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIHNldHRpbmcgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqL1xuICAgIHNldCh0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG4gICAgICBwcm94eVtwcm9wXSA9IHZhbHVlOyAvLyBzZXQgdG8gcHJveHlcbiAgICAgIGRlbGV0ZSB0YXJnZXRbcHJvcF07IC8vIHJlbW92ZSBmcm9tIGNhY2hlXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pIGFzIENvbnRleHRQcm94eTxULCBSPjtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2Rlc2NyaXB0b3JzKFxuICBwcm94eTogUmVzb2x2ZXJDYWNoZSxcbiAgZGVmYXVsdHM6IERlc2NyaXB0b3JEZWZhdWx0cyA9IHtzY3JpcHRhYmxlOiB0cnVlLCBpbmRleGFibGU6IHRydWV9XG4pOiBEZXNjcmlwdG9yIHtcbiAgY29uc3Qge19zY3JpcHRhYmxlID0gZGVmYXVsdHMuc2NyaXB0YWJsZSwgX2luZGV4YWJsZSA9IGRlZmF1bHRzLmluZGV4YWJsZSwgX2FsbEtleXMgPSBkZWZhdWx0cy5hbGxLZXlzfSA9IHByb3h5O1xuICByZXR1cm4ge1xuICAgIGFsbEtleXM6IF9hbGxLZXlzLFxuICAgIHNjcmlwdGFibGU6IF9zY3JpcHRhYmxlLFxuICAgIGluZGV4YWJsZTogX2luZGV4YWJsZSxcbiAgICBpc1NjcmlwdGFibGU6IGlzRnVuY3Rpb24oX3NjcmlwdGFibGUpID8gX3NjcmlwdGFibGUgOiAoKSA9PiBfc2NyaXB0YWJsZSxcbiAgICBpc0luZGV4YWJsZTogaXNGdW5jdGlvbihfaW5kZXhhYmxlKSA/IF9pbmRleGFibGUgOiAoKSA9PiBfaW5kZXhhYmxlXG4gIH07XG59XG5cbmNvbnN0IHJlYWRLZXkgPSAocHJlZml4OiBzdHJpbmcsIG5hbWU6IHN0cmluZykgPT4gcHJlZml4ID8gcHJlZml4ICsgX2NhcGl0YWxpemUobmFtZSkgOiBuYW1lO1xuY29uc3QgbmVlZHNTdWJSZXNvbHZlciA9IChwcm9wOiBzdHJpbmcsIHZhbHVlOiB1bmtub3duKSA9PiBpc09iamVjdCh2YWx1ZSkgJiYgcHJvcCAhPT0gJ2FkYXB0ZXJzJyAmJlxuICAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSA9PT0gbnVsbCB8fCB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KTtcblxuZnVuY3Rpb24gX2NhY2hlZChcbiAgdGFyZ2V0OiBBbnlPYmplY3QsXG4gIHByb3A6IHN0cmluZyxcbiAgcmVzb2x2ZTogKCkgPT4gdW5rbm93blxuKSB7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBwcm9wKSB8fCBwcm9wID09PSAnY29uc3RydWN0b3InKSB7XG4gICAgcmV0dXJuIHRhcmdldFtwcm9wXTtcbiAgfVxuXG4gIGNvbnN0IHZhbHVlID0gcmVzb2x2ZSgpO1xuICAvLyBjYWNoZSB0aGUgcmVzb2x2ZWQgdmFsdWVcbiAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gX3Jlc29sdmVXaXRoQ29udGV4dChcbiAgdGFyZ2V0OiBDb250ZXh0Q2FjaGUsXG4gIHByb3A6IHN0cmluZyxcbiAgcmVjZWl2ZXI6IEFueU9iamVjdFxuKSB7XG4gIGNvbnN0IHtfcHJveHksIF9jb250ZXh0LCBfc3ViUHJveHksIF9kZXNjcmlwdG9yczogZGVzY3JpcHRvcnN9ID0gdGFyZ2V0O1xuICBsZXQgdmFsdWUgPSBfcHJveHlbcHJvcF07IC8vIHJlc29sdmUgZnJvbSBwcm94eVxuXG4gIC8vIHJlc29sdmUgd2l0aCBjb250ZXh0XG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSAmJiBkZXNjcmlwdG9ycy5pc1NjcmlwdGFibGUocHJvcCkpIHtcbiAgICB2YWx1ZSA9IF9yZXNvbHZlU2NyaXB0YWJsZShwcm9wLCB2YWx1ZSwgdGFyZ2V0LCByZWNlaXZlcik7XG4gIH1cbiAgaWYgKGlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCkge1xuICAgIHZhbHVlID0gX3Jlc29sdmVBcnJheShwcm9wLCB2YWx1ZSwgdGFyZ2V0LCBkZXNjcmlwdG9ycy5pc0luZGV4YWJsZSk7XG4gIH1cbiAgaWYgKG5lZWRzU3ViUmVzb2x2ZXIocHJvcCwgdmFsdWUpKSB7XG4gICAgLy8gaWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzIGFuIG9iamVjdCwgY3JlYXRlIGEgc3ViIHJlc29sdmVyIGZvciBpdFxuICAgIHZhbHVlID0gX2F0dGFjaENvbnRleHQodmFsdWUsIF9jb250ZXh0LCBfc3ViUHJveHkgJiYgX3N1YlByb3h5W3Byb3BdLCBkZXNjcmlwdG9ycyk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBfcmVzb2x2ZVNjcmlwdGFibGUoXG4gIHByb3A6IHN0cmluZyxcbiAgZ2V0VmFsdWU6IChjdHg6IEFueU9iamVjdCwgc3ViOiBBbnlPYmplY3QpID0+IHVua25vd24sXG4gIHRhcmdldDogQ29udGV4dENhY2hlLFxuICByZWNlaXZlcjogQW55T2JqZWN0XG4pIHtcbiAgY29uc3Qge19wcm94eSwgX2NvbnRleHQsIF9zdWJQcm94eSwgX3N0YWNrfSA9IHRhcmdldDtcbiAgaWYgKF9zdGFjay5oYXMocHJvcCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlY3Vyc2lvbiBkZXRlY3RlZDogJyArIEFycmF5LmZyb20oX3N0YWNrKS5qb2luKCctPicpICsgJy0+JyArIHByb3ApO1xuICB9XG4gIF9zdGFjay5hZGQocHJvcCk7XG4gIGxldCB2YWx1ZSA9IGdldFZhbHVlKF9jb250ZXh0LCBfc3ViUHJveHkgfHwgcmVjZWl2ZXIpO1xuICBfc3RhY2suZGVsZXRlKHByb3ApO1xuICBpZiAobmVlZHNTdWJSZXNvbHZlcihwcm9wLCB2YWx1ZSkpIHtcbiAgICAvLyBXaGVuIHNjcmlwdGFibGUgb3B0aW9uIHJldHVybnMgYW4gb2JqZWN0LCBjcmVhdGUgYSByZXNvbHZlciBvbiB0aGF0LlxuICAgIHZhbHVlID0gY3JlYXRlU3ViUmVzb2x2ZXIoX3Byb3h5Ll9zY29wZXMsIF9wcm94eSwgcHJvcCwgdmFsdWUpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gX3Jlc29sdmVBcnJheShcbiAgcHJvcDogc3RyaW5nLFxuICB2YWx1ZTogdW5rbm93bltdLFxuICB0YXJnZXQ6IENvbnRleHRDYWNoZSxcbiAgaXNJbmRleGFibGU6IChrZXk6IHN0cmluZykgPT4gYm9vbGVhblxuKSB7XG4gIGNvbnN0IHtfcHJveHksIF9jb250ZXh0LCBfc3ViUHJveHksIF9kZXNjcmlwdG9yczogZGVzY3JpcHRvcnN9ID0gdGFyZ2V0O1xuXG4gIGlmICh0eXBlb2YgX2NvbnRleHQuaW5kZXggIT09ICd1bmRlZmluZWQnICYmIGlzSW5kZXhhYmxlKHByb3ApKSB7XG4gICAgcmV0dXJuIHZhbHVlW19jb250ZXh0LmluZGV4ICUgdmFsdWUubGVuZ3RoXTtcbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZVswXSkpIHtcbiAgICAvLyBBcnJheSBvZiBvYmplY3RzLCByZXR1cm4gYXJyYXkgb3IgcmVzb2x2ZXJzXG4gICAgY29uc3QgYXJyID0gdmFsdWU7XG4gICAgY29uc3Qgc2NvcGVzID0gX3Byb3h5Ll9zY29wZXMuZmlsdGVyKHMgPT4gcyAhPT0gYXJyKTtcbiAgICB2YWx1ZSA9IFtdO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBhcnIpIHtcbiAgICAgIGNvbnN0IHJlc29sdmVyID0gY3JlYXRlU3ViUmVzb2x2ZXIoc2NvcGVzLCBfcHJveHksIHByb3AsIGl0ZW0pO1xuICAgICAgdmFsdWUucHVzaChfYXR0YWNoQ29udGV4dChyZXNvbHZlciwgX2NvbnRleHQsIF9zdWJQcm94eSAmJiBfc3ViUHJveHlbcHJvcF0sIGRlc2NyaXB0b3JzKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUZhbGxiYWNrKFxuICBmYWxsYmFjazogUmVzb2x2ZXJPYmplY3RLZXkgfCAoKHByb3A6IFJlc29sdmVyT2JqZWN0S2V5LCB2YWx1ZTogdW5rbm93bikgPT4gUmVzb2x2ZXJPYmplY3RLZXkpLFxuICBwcm9wOiBSZXNvbHZlck9iamVjdEtleSxcbiAgdmFsdWU6IHVua25vd25cbikge1xuICByZXR1cm4gaXNGdW5jdGlvbihmYWxsYmFjaykgPyBmYWxsYmFjayhwcm9wLCB2YWx1ZSkgOiBmYWxsYmFjaztcbn1cblxuY29uc3QgZ2V0U2NvcGUgPSAoa2V5OiBSZXNvbHZlck9iamVjdEtleSwgcGFyZW50OiBBbnlPYmplY3QpID0+IGtleSA9PT0gdHJ1ZSA/IHBhcmVudFxuICA6IHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnID8gcmVzb2x2ZU9iamVjdEtleShwYXJlbnQsIGtleSkgOiB1bmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGFkZFNjb3BlcyhcbiAgc2V0OiBTZXQ8QW55T2JqZWN0PixcbiAgcGFyZW50U2NvcGVzOiBBbnlPYmplY3RbXSxcbiAga2V5OiBSZXNvbHZlck9iamVjdEtleSxcbiAgcGFyZW50RmFsbGJhY2s6IFJlc29sdmVyT2JqZWN0S2V5LFxuICB2YWx1ZTogdW5rbm93blxuKSB7XG4gIGZvciAoY29uc3QgcGFyZW50IG9mIHBhcmVudFNjb3Blcykge1xuICAgIGNvbnN0IHNjb3BlID0gZ2V0U2NvcGUoa2V5LCBwYXJlbnQpO1xuICAgIGlmIChzY29wZSkge1xuICAgICAgc2V0LmFkZChzY29wZSk7XG4gICAgICBjb25zdCBmYWxsYmFjayA9IHJlc29sdmVGYWxsYmFjayhzY29wZS5fZmFsbGJhY2ssIGtleSwgdmFsdWUpO1xuICAgICAgaWYgKHR5cGVvZiBmYWxsYmFjayAhPT0gJ3VuZGVmaW5lZCcgJiYgZmFsbGJhY2sgIT09IGtleSAmJiBmYWxsYmFjayAhPT0gcGFyZW50RmFsbGJhY2spIHtcbiAgICAgICAgLy8gV2hlbiB3ZSByZWFjaCB0aGUgZGVzY3JpcHRvciB0aGF0IGRlZmluZXMgYSBuZXcgX2ZhbGxiYWNrLCByZXR1cm4gdGhhdC5cbiAgICAgICAgLy8gVGhlIGZhbGxiYWNrIHdpbGwgcmVzdW1lIHRvIHRoYXQgbmV3IHNjb3BlLlxuICAgICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzY29wZSA9PT0gZmFsc2UgJiYgdHlwZW9mIHBhcmVudEZhbGxiYWNrICE9PSAndW5kZWZpbmVkJyAmJiBrZXkgIT09IHBhcmVudEZhbGxiYWNrKSB7XG4gICAgICAvLyBGYWxsYmFjayB0byBgZmFsc2VgIHJlc3VsdHMgdG8gYGZhbHNlYCwgd2hlbiBmYWxsaW5nIGJhY2sgdG8gZGlmZmVyZW50IGtleS5cbiAgICAgIC8vIEZvciBleGFtcGxlIGBpbnRlcmFjdGlvbmAgZnJvbSBgaG92ZXJgIG9yIGBwbHVnaW5zLnRvb2x0aXBgIGFuZCBgYW5pbWF0aW9uYCBmcm9tIGBhbmltYXRpb25zYFxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU3ViUmVzb2x2ZXIoXG4gIHBhcmVudFNjb3BlczogQW55T2JqZWN0W10sXG4gIHJlc29sdmVyOiBSZXNvbHZlckNhY2hlLFxuICBwcm9wOiBSZXNvbHZlck9iamVjdEtleSxcbiAgdmFsdWU6IHVua25vd25cbikge1xuICBjb25zdCByb290U2NvcGVzID0gcmVzb2x2ZXIuX3Jvb3RTY29wZXM7XG4gIGNvbnN0IGZhbGxiYWNrID0gcmVzb2x2ZUZhbGxiYWNrKHJlc29sdmVyLl9mYWxsYmFjaywgcHJvcCwgdmFsdWUpO1xuICBjb25zdCBhbGxTY29wZXMgPSBbLi4ucGFyZW50U2NvcGVzLCAuLi5yb290U2NvcGVzXTtcbiAgY29uc3Qgc2V0ID0gbmV3IFNldDxBbnlPYmplY3Q+KCk7XG4gIHNldC5hZGQodmFsdWUpO1xuICBsZXQga2V5ID0gYWRkU2NvcGVzRnJvbUtleShzZXQsIGFsbFNjb3BlcywgcHJvcCwgZmFsbGJhY2sgfHwgcHJvcCwgdmFsdWUpO1xuICBpZiAoa2V5ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgZmFsbGJhY2sgIT09ICd1bmRlZmluZWQnICYmIGZhbGxiYWNrICE9PSBwcm9wKSB7XG4gICAga2V5ID0gYWRkU2NvcGVzRnJvbUtleShzZXQsIGFsbFNjb3BlcywgZmFsbGJhY2ssIGtleSwgdmFsdWUpO1xuICAgIGlmIChrZXkgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVSZXNvbHZlcihBcnJheS5mcm9tKHNldCksIFsnJ10sIHJvb3RTY29wZXMsIGZhbGxiYWNrLFxuICAgICgpID0+IHN1YkdldFRhcmdldChyZXNvbHZlciwgcHJvcCBhcyBzdHJpbmcsIHZhbHVlKSk7XG59XG5cbmZ1bmN0aW9uIGFkZFNjb3Blc0Zyb21LZXkoXG4gIHNldDogU2V0PEFueU9iamVjdD4sXG4gIGFsbFNjb3BlczogQW55T2JqZWN0W10sXG4gIGtleTogUmVzb2x2ZXJPYmplY3RLZXksXG4gIGZhbGxiYWNrOiBSZXNvbHZlck9iamVjdEtleSxcbiAgaXRlbTogdW5rbm93blxuKSB7XG4gIHdoaWxlIChrZXkpIHtcbiAgICBrZXkgPSBhZGRTY29wZXMoc2V0LCBhbGxTY29wZXMsIGtleSwgZmFsbGJhY2ssIGl0ZW0pO1xuICB9XG4gIHJldHVybiBrZXk7XG59XG5cbmZ1bmN0aW9uIHN1YkdldFRhcmdldChcbiAgcmVzb2x2ZXI6IFJlc29sdmVyQ2FjaGUsXG4gIHByb3A6IHN0cmluZyxcbiAgdmFsdWU6IHVua25vd25cbikge1xuICBjb25zdCBwYXJlbnQgPSByZXNvbHZlci5fZ2V0VGFyZ2V0KCk7XG4gIGlmICghKHByb3AgaW4gcGFyZW50KSkge1xuICAgIHBhcmVudFtwcm9wXSA9IHt9O1xuICB9XG4gIGNvbnN0IHRhcmdldCA9IHBhcmVudFtwcm9wXTtcbiAgaWYgKGlzQXJyYXkodGFyZ2V0KSAmJiBpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAvLyBGb3IgYXJyYXkgb2Ygb2JqZWN0cywgdGhlIG9iamVjdCBpcyB1c2VkIHRvIHN0b3JlIHVwZGF0ZWQgdmFsdWVzXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiB0YXJnZXQgfHwge307XG59XG5cbmZ1bmN0aW9uIF9yZXNvbHZlV2l0aFByZWZpeGVzKFxuICBwcm9wOiBzdHJpbmcsXG4gIHByZWZpeGVzOiBzdHJpbmdbXSxcbiAgc2NvcGVzOiBBbnlPYmplY3RbXSxcbiAgcHJveHk6IFJlc29sdmVyUHJveHlcbikge1xuICBsZXQgdmFsdWU6IHVua25vd247XG4gIGZvciAoY29uc3QgcHJlZml4IG9mIHByZWZpeGVzKSB7XG4gICAgdmFsdWUgPSBfcmVzb2x2ZShyZWFkS2V5KHByZWZpeCwgcHJvcCksIHNjb3Blcyk7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBuZWVkc1N1YlJlc29sdmVyKHByb3AsIHZhbHVlKVxuICAgICAgICA/IGNyZWF0ZVN1YlJlc29sdmVyKHNjb3BlcywgcHJveHksIHByb3AsIHZhbHVlKVxuICAgICAgICA6IHZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBfcmVzb2x2ZShrZXk6IHN0cmluZywgc2NvcGVzOiBBbnlPYmplY3RbXSkge1xuICBmb3IgKGNvbnN0IHNjb3BlIG9mIHNjb3Blcykge1xuICAgIGlmICghc2NvcGUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHNjb3BlW2tleV07XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0S2V5c0Zyb21BbGxTY29wZXModGFyZ2V0OiBSZXNvbHZlckNhY2hlKSB7XG4gIGxldCBrZXlzID0gdGFyZ2V0Ll9rZXlzO1xuICBpZiAoIWtleXMpIHtcbiAgICBrZXlzID0gdGFyZ2V0Ll9rZXlzID0gcmVzb2x2ZUtleXNGcm9tQWxsU2NvcGVzKHRhcmdldC5fc2NvcGVzKTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUtleXNGcm9tQWxsU2NvcGVzKHNjb3BlczogQW55T2JqZWN0W10pIHtcbiAgY29uc3Qgc2V0ID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gIGZvciAoY29uc3Qgc2NvcGUgb2Ygc2NvcGVzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc2NvcGUpLmZpbHRlcihrID0+ICFrLnN0YXJ0c1dpdGgoJ18nKSkpIHtcbiAgICAgIHNldC5hZGQoa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIEFycmF5LmZyb20oc2V0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZShcbiAgbWV0YTogQ2hhcnRNZXRhPCdsaW5lJyB8ICdzY2F0dGVyJz4sXG4gIGRhdGE6IEFueU9iamVjdFtdLFxuICBzdGFydDogbnVtYmVyLFxuICBjb3VudDogbnVtYmVyXG4pIHtcbiAgY29uc3Qge2lTY2FsZX0gPSBtZXRhO1xuICBjb25zdCB7a2V5ID0gJ3InfSA9IHRoaXMuX3BhcnNpbmc7XG4gIGNvbnN0IHBhcnNlZCA9IG5ldyBBcnJheTx7cjogdW5rbm93bn0+KGNvdW50KTtcbiAgbGV0IGk6IG51bWJlciwgaWxlbjogbnVtYmVyLCBpbmRleDogbnVtYmVyLCBpdGVtOiBBbnlPYmplY3Q7XG5cbiAgZm9yIChpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgaW5kZXggPSBpICsgc3RhcnQ7XG4gICAgaXRlbSA9IGRhdGFbaW5kZXhdO1xuICAgIHBhcnNlZFtpXSA9IHtcbiAgICAgIHI6IGlTY2FsZS5wYXJzZShyZXNvbHZlT2JqZWN0S2V5KGl0ZW0sIGtleSksIGluZGV4KVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHBhcnNlZDtcbn1cbiIsImltcG9ydCB7YWxtb3N0RXF1YWxzLCBkaXN0YW5jZUJldHdlZW5Qb2ludHMsIHNpZ259IGZyb20gJy4vaGVscGVycy5tYXRoLmpzJztcbmltcG9ydCB7X2lzUG9pbnRJbkFyZWF9IGZyb20gJy4vaGVscGVycy5jYW52YXMuanMnO1xuaW1wb3J0IHR5cGUge0NoYXJ0QXJlYX0gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuaW1wb3J0IHR5cGUge1NwbGluZVBvaW50fSBmcm9tICcuLi90eXBlcy9nZW9tZXRyaWMuanMnO1xuXG5jb25zdCBFUFNJTE9OID0gTnVtYmVyLkVQU0lMT04gfHwgMWUtMTQ7XG5cbnR5cGUgT3B0aW9uYWxTcGxpbmVQb2ludCA9IFNwbGluZVBvaW50IHwgZmFsc2VcbmNvbnN0IGdldFBvaW50ID0gKHBvaW50czogU3BsaW5lUG9pbnRbXSwgaTogbnVtYmVyKTogT3B0aW9uYWxTcGxpbmVQb2ludCA9PiBpIDwgcG9pbnRzLmxlbmd0aCAmJiAhcG9pbnRzW2ldLnNraXAgJiYgcG9pbnRzW2ldO1xuY29uc3QgZ2V0VmFsdWVBeGlzID0gKGluZGV4QXhpczogJ3gnIHwgJ3knKSA9PiBpbmRleEF4aXMgPT09ICd4JyA/ICd5JyA6ICd4JztcblxuZXhwb3J0IGZ1bmN0aW9uIHNwbGluZUN1cnZlKFxuICBmaXJzdFBvaW50OiBTcGxpbmVQb2ludCxcbiAgbWlkZGxlUG9pbnQ6IFNwbGluZVBvaW50LFxuICBhZnRlclBvaW50OiBTcGxpbmVQb2ludCxcbiAgdDogbnVtYmVyXG4pOiB7XG4gICAgcHJldmlvdXM6IFNwbGluZVBvaW50XG4gICAgbmV4dDogU3BsaW5lUG9pbnRcbiAgfSB7XG4gIC8vIFByb3BzIHRvIFJvYiBTcGVuY2VyIGF0IHNjYWxlZCBpbm5vdmF0aW9uIGZvciBoaXMgcG9zdCBvbiBzcGxpbmluZyBiZXR3ZWVuIHBvaW50c1xuICAvLyBodHRwOi8vc2NhbGVkaW5ub3ZhdGlvbi5jb20vYW5hbHl0aWNzL3NwbGluZXMvYWJvdXRTcGxpbmVzLmh0bWxcblxuICAvLyBUaGlzIGZ1bmN0aW9uIG11c3QgYWxzbyByZXNwZWN0IFwic2tpcHBlZFwiIHBvaW50c1xuXG4gIGNvbnN0IHByZXZpb3VzID0gZmlyc3RQb2ludC5za2lwID8gbWlkZGxlUG9pbnQgOiBmaXJzdFBvaW50O1xuICBjb25zdCBjdXJyZW50ID0gbWlkZGxlUG9pbnQ7XG4gIGNvbnN0IG5leHQgPSBhZnRlclBvaW50LnNraXAgPyBtaWRkbGVQb2ludCA6IGFmdGVyUG9pbnQ7XG4gIGNvbnN0IGQwMSA9IGRpc3RhbmNlQmV0d2VlblBvaW50cyhjdXJyZW50LCBwcmV2aW91cyk7XG4gIGNvbnN0IGQxMiA9IGRpc3RhbmNlQmV0d2VlblBvaW50cyhuZXh0LCBjdXJyZW50KTtcblxuICBsZXQgczAxID0gZDAxIC8gKGQwMSArIGQxMik7XG4gIGxldCBzMTIgPSBkMTIgLyAoZDAxICsgZDEyKTtcblxuICAvLyBJZiBhbGwgcG9pbnRzIGFyZSB0aGUgc2FtZSwgczAxICYgczAyIHdpbGwgYmUgaW5mXG4gIHMwMSA9IGlzTmFOKHMwMSkgPyAwIDogczAxO1xuICBzMTIgPSBpc05hTihzMTIpID8gMCA6IHMxMjtcblxuICBjb25zdCBmYSA9IHQgKiBzMDE7IC8vIHNjYWxpbmcgZmFjdG9yIGZvciB0cmlhbmdsZSBUYVxuICBjb25zdCBmYiA9IHQgKiBzMTI7XG5cbiAgcmV0dXJuIHtcbiAgICBwcmV2aW91czoge1xuICAgICAgeDogY3VycmVudC54IC0gZmEgKiAobmV4dC54IC0gcHJldmlvdXMueCksXG4gICAgICB5OiBjdXJyZW50LnkgLSBmYSAqIChuZXh0LnkgLSBwcmV2aW91cy55KVxuICAgIH0sXG4gICAgbmV4dDoge1xuICAgICAgeDogY3VycmVudC54ICsgZmIgKiAobmV4dC54IC0gcHJldmlvdXMueCksXG4gICAgICB5OiBjdXJyZW50LnkgKyBmYiAqIChuZXh0LnkgLSBwcmV2aW91cy55KVxuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBBZGp1c3QgdGFuZ2VudHMgdG8gZW5zdXJlIG1vbm90b25pYyBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIG1vbm90b25lQWRqdXN0KHBvaW50czogU3BsaW5lUG9pbnRbXSwgZGVsdGFLOiBudW1iZXJbXSwgbUs6IG51bWJlcltdKSB7XG4gIGNvbnN0IHBvaW50c0xlbiA9IHBvaW50cy5sZW5ndGg7XG5cbiAgbGV0IGFscGhhSzogbnVtYmVyLCBiZXRhSzogbnVtYmVyLCB0YXVLOiBudW1iZXIsIHNxdWFyZWRNYWduaXR1ZGU6IG51bWJlciwgcG9pbnRDdXJyZW50OiBPcHRpb25hbFNwbGluZVBvaW50O1xuICBsZXQgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgMCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzTGVuIC0gMTsgKytpKSB7XG4gICAgcG9pbnRDdXJyZW50ID0gcG9pbnRBZnRlcjtcbiAgICBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCBpICsgMSk7XG4gICAgaWYgKCFwb2ludEN1cnJlbnQgfHwgIXBvaW50QWZ0ZXIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChhbG1vc3RFcXVhbHMoZGVsdGFLW2ldLCAwLCBFUFNJTE9OKSkge1xuICAgICAgbUtbaV0gPSBtS1tpICsgMV0gPSAwO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgYWxwaGFLID0gbUtbaV0gLyBkZWx0YUtbaV07XG4gICAgYmV0YUsgPSBtS1tpICsgMV0gLyBkZWx0YUtbaV07XG4gICAgc3F1YXJlZE1hZ25pdHVkZSA9IE1hdGgucG93KGFscGhhSywgMikgKyBNYXRoLnBvdyhiZXRhSywgMik7XG4gICAgaWYgKHNxdWFyZWRNYWduaXR1ZGUgPD0gOSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdGF1SyA9IDMgLyBNYXRoLnNxcnQoc3F1YXJlZE1hZ25pdHVkZSk7XG4gICAgbUtbaV0gPSBhbHBoYUsgKiB0YXVLICogZGVsdGFLW2ldO1xuICAgIG1LW2kgKyAxXSA9IGJldGFLICogdGF1SyAqIGRlbHRhS1tpXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtb25vdG9uZUNvbXB1dGUocG9pbnRzOiBTcGxpbmVQb2ludFtdLCBtSzogbnVtYmVyW10sIGluZGV4QXhpczogJ3gnIHwgJ3knID0gJ3gnKSB7XG4gIGNvbnN0IHZhbHVlQXhpcyA9IGdldFZhbHVlQXhpcyhpbmRleEF4aXMpO1xuICBjb25zdCBwb2ludHNMZW4gPSBwb2ludHMubGVuZ3RoO1xuICBsZXQgZGVsdGE6IG51bWJlciwgcG9pbnRCZWZvcmU6IE9wdGlvbmFsU3BsaW5lUG9pbnQsIHBvaW50Q3VycmVudDogT3B0aW9uYWxTcGxpbmVQb2ludDtcbiAgbGV0IHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIDApO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzTGVuOyArK2kpIHtcbiAgICBwb2ludEJlZm9yZSA9IHBvaW50Q3VycmVudDtcbiAgICBwb2ludEN1cnJlbnQgPSBwb2ludEFmdGVyO1xuICAgIHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIGkgKyAxKTtcbiAgICBpZiAoIXBvaW50Q3VycmVudCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgaVBpeGVsID0gcG9pbnRDdXJyZW50W2luZGV4QXhpc107XG4gICAgY29uc3QgdlBpeGVsID0gcG9pbnRDdXJyZW50W3ZhbHVlQXhpc107XG4gICAgaWYgKHBvaW50QmVmb3JlKSB7XG4gICAgICBkZWx0YSA9IChpUGl4ZWwgLSBwb2ludEJlZm9yZVtpbmRleEF4aXNdKSAvIDM7XG4gICAgICBwb2ludEN1cnJlbnRbYGNwMSR7aW5kZXhBeGlzfWBdID0gaVBpeGVsIC0gZGVsdGE7XG4gICAgICBwb2ludEN1cnJlbnRbYGNwMSR7dmFsdWVBeGlzfWBdID0gdlBpeGVsIC0gZGVsdGEgKiBtS1tpXTtcbiAgICB9XG4gICAgaWYgKHBvaW50QWZ0ZXIpIHtcbiAgICAgIGRlbHRhID0gKHBvaW50QWZ0ZXJbaW5kZXhBeGlzXSAtIGlQaXhlbCkgLyAzO1xuICAgICAgcG9pbnRDdXJyZW50W2BjcDIke2luZGV4QXhpc31gXSA9IGlQaXhlbCArIGRlbHRhO1xuICAgICAgcG9pbnRDdXJyZW50W2BjcDIke3ZhbHVlQXhpc31gXSA9IHZQaXhlbCArIGRlbHRhICogbUtbaV07XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjYWxjdWxhdGVzIELDqXppZXIgY29udHJvbCBwb2ludHMgaW4gYSBzaW1pbGFyIHdheSB0aGFuIHxzcGxpbmVDdXJ2ZXwsXG4gKiBidXQgcHJlc2VydmVzIG1vbm90b25pY2l0eSBvZiB0aGUgcHJvdmlkZWQgZGF0YSBhbmQgZW5zdXJlcyBubyBsb2NhbCBleHRyZW11bXMgYXJlIGFkZGVkXG4gKiBiZXR3ZWVuIHRoZSBkYXRhc2V0IGRpc2NyZXRlIHBvaW50cyBkdWUgdG8gdGhlIGludGVycG9sYXRpb24uXG4gKiBTZWUgOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Nb25vdG9uZV9jdWJpY19pbnRlcnBvbGF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcGxpbmVDdXJ2ZU1vbm90b25lKHBvaW50czogU3BsaW5lUG9pbnRbXSwgaW5kZXhBeGlzOiAneCcgfCAneScgPSAneCcpIHtcbiAgY29uc3QgdmFsdWVBeGlzID0gZ2V0VmFsdWVBeGlzKGluZGV4QXhpcyk7XG4gIGNvbnN0IHBvaW50c0xlbiA9IHBvaW50cy5sZW5ndGg7XG4gIGNvbnN0IGRlbHRhSzogbnVtYmVyW10gPSBBcnJheShwb2ludHNMZW4pLmZpbGwoMCk7XG4gIGNvbnN0IG1LOiBudW1iZXJbXSA9IEFycmF5KHBvaW50c0xlbik7XG5cbiAgLy8gQ2FsY3VsYXRlIHNsb3BlcyAoZGVsdGFLKSBhbmQgaW5pdGlhbGl6ZSB0YW5nZW50cyAobUspXG4gIGxldCBpLCBwb2ludEJlZm9yZTogT3B0aW9uYWxTcGxpbmVQb2ludCwgcG9pbnRDdXJyZW50OiBPcHRpb25hbFNwbGluZVBvaW50O1xuICBsZXQgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgMCk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHBvaW50c0xlbjsgKytpKSB7XG4gICAgcG9pbnRCZWZvcmUgPSBwb2ludEN1cnJlbnQ7XG4gICAgcG9pbnRDdXJyZW50ID0gcG9pbnRBZnRlcjtcbiAgICBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCBpICsgMSk7XG4gICAgaWYgKCFwb2ludEN1cnJlbnQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChwb2ludEFmdGVyKSB7XG4gICAgICBjb25zdCBzbG9wZURlbHRhID0gcG9pbnRBZnRlcltpbmRleEF4aXNdIC0gcG9pbnRDdXJyZW50W2luZGV4QXhpc107XG5cbiAgICAgIC8vIEluIHRoZSBjYXNlIG9mIHR3byBwb2ludHMgdGhhdCBhcHBlYXIgYXQgdGhlIHNhbWUgeCBwaXhlbCwgc2xvcGVEZWx0YVggaXMgMFxuICAgICAgZGVsdGFLW2ldID0gc2xvcGVEZWx0YSAhPT0gMCA/IChwb2ludEFmdGVyW3ZhbHVlQXhpc10gLSBwb2ludEN1cnJlbnRbdmFsdWVBeGlzXSkgLyBzbG9wZURlbHRhIDogMDtcbiAgICB9XG4gICAgbUtbaV0gPSAhcG9pbnRCZWZvcmUgPyBkZWx0YUtbaV1cbiAgICAgIDogIXBvaW50QWZ0ZXIgPyBkZWx0YUtbaSAtIDFdXG4gICAgICAgIDogKHNpZ24oZGVsdGFLW2kgLSAxXSkgIT09IHNpZ24oZGVsdGFLW2ldKSkgPyAwXG4gICAgICAgICAgOiAoZGVsdGFLW2kgLSAxXSArIGRlbHRhS1tpXSkgLyAyO1xuICB9XG5cbiAgbW9ub3RvbmVBZGp1c3QocG9pbnRzLCBkZWx0YUssIG1LKTtcblxuICBtb25vdG9uZUNvbXB1dGUocG9pbnRzLCBtSywgaW5kZXhBeGlzKTtcbn1cblxuZnVuY3Rpb24gY2FwQ29udHJvbFBvaW50KHB0OiBudW1iZXIsIG1pbjogbnVtYmVyLCBtYXg6IG51bWJlcikge1xuICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4ocHQsIG1heCksIG1pbik7XG59XG5cbmZ1bmN0aW9uIGNhcEJlemllclBvaW50cyhwb2ludHM6IFNwbGluZVBvaW50W10sIGFyZWE6IENoYXJ0QXJlYSkge1xuICBsZXQgaSwgaWxlbiwgcG9pbnQsIGluQXJlYSwgaW5BcmVhUHJldjtcbiAgbGV0IGluQXJlYU5leHQgPSBfaXNQb2ludEluQXJlYShwb2ludHNbMF0sIGFyZWEpO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGluQXJlYVByZXYgPSBpbkFyZWE7XG4gICAgaW5BcmVhID0gaW5BcmVhTmV4dDtcbiAgICBpbkFyZWFOZXh0ID0gaSA8IGlsZW4gLSAxICYmIF9pc1BvaW50SW5BcmVhKHBvaW50c1tpICsgMV0sIGFyZWEpO1xuICAgIGlmICghaW5BcmVhKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgaWYgKGluQXJlYVByZXYpIHtcbiAgICAgIHBvaW50LmNwMXggPSBjYXBDb250cm9sUG9pbnQocG9pbnQuY3AxeCwgYXJlYS5sZWZ0LCBhcmVhLnJpZ2h0KTtcbiAgICAgIHBvaW50LmNwMXkgPSBjYXBDb250cm9sUG9pbnQocG9pbnQuY3AxeSwgYXJlYS50b3AsIGFyZWEuYm90dG9tKTtcbiAgICB9XG4gICAgaWYgKGluQXJlYU5leHQpIHtcbiAgICAgIHBvaW50LmNwMnggPSBjYXBDb250cm9sUG9pbnQocG9pbnQuY3AyeCwgYXJlYS5sZWZ0LCBhcmVhLnJpZ2h0KTtcbiAgICAgIHBvaW50LmNwMnkgPSBjYXBDb250cm9sUG9pbnQocG9pbnQuY3AyeSwgYXJlYS50b3AsIGFyZWEuYm90dG9tKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX3VwZGF0ZUJlemllckNvbnRyb2xQb2ludHMoXG4gIHBvaW50czogU3BsaW5lUG9pbnRbXSxcbiAgb3B0aW9ucyxcbiAgYXJlYTogQ2hhcnRBcmVhLFxuICBsb29wOiBib29sZWFuLFxuICBpbmRleEF4aXM6ICd4JyB8ICd5J1xuKSB7XG4gIGxldCBpOiBudW1iZXIsIGlsZW46IG51bWJlciwgcG9pbnQ6IFNwbGluZVBvaW50LCBjb250cm9sUG9pbnRzOiBSZXR1cm5UeXBlPHR5cGVvZiBzcGxpbmVDdXJ2ZT47XG5cbiAgLy8gT25seSBjb25zaWRlciBwb2ludHMgdGhhdCBhcmUgZHJhd24gaW4gY2FzZSB0aGUgc3BhbkdhcHMgb3B0aW9uIGlzIHVzZWRcbiAgaWYgKG9wdGlvbnMuc3BhbkdhcHMpIHtcbiAgICBwb2ludHMgPSBwb2ludHMuZmlsdGVyKChwdCkgPT4gIXB0LnNraXApO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gJ21vbm90b25lJykge1xuICAgIHNwbGluZUN1cnZlTW9ub3RvbmUocG9pbnRzLCBpbmRleEF4aXMpO1xuICB9IGVsc2Uge1xuICAgIGxldCBwcmV2ID0gbG9vcCA/IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0gOiBwb2ludHNbMF07XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgY29udHJvbFBvaW50cyA9IHNwbGluZUN1cnZlKFxuICAgICAgICBwcmV2LFxuICAgICAgICBwb2ludCxcbiAgICAgICAgcG9pbnRzW01hdGgubWluKGkgKyAxLCBpbGVuIC0gKGxvb3AgPyAwIDogMSkpICUgaWxlbl0sXG4gICAgICAgIG9wdGlvbnMudGVuc2lvblxuICAgICAgKTtcbiAgICAgIHBvaW50LmNwMXggPSBjb250cm9sUG9pbnRzLnByZXZpb3VzLng7XG4gICAgICBwb2ludC5jcDF5ID0gY29udHJvbFBvaW50cy5wcmV2aW91cy55O1xuICAgICAgcG9pbnQuY3AyeCA9IGNvbnRyb2xQb2ludHMubmV4dC54O1xuICAgICAgcG9pbnQuY3AyeSA9IGNvbnRyb2xQb2ludHMubmV4dC55O1xuICAgICAgcHJldiA9IHBvaW50O1xuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRpb25zLmNhcEJlemllclBvaW50cykge1xuICAgIGNhcEJlemllclBvaW50cyhwb2ludHMsIGFyZWEpO1xuICB9XG59XG4iLCJpbXBvcnQgdHlwZSB7Q2hhcnRBcmVhLCBTY2FsZX0gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuaW1wb3J0IHR5cGUgUHJpdmF0ZUNoYXJ0IGZyb20gJy4uL2NvcmUvY29yZS5jb250cm9sbGVyLmpzJztcbmltcG9ydCB0eXBlIHtDaGFydCwgQ2hhcnRFdmVudH0gZnJvbSAnLi4vdHlwZXMuanMnO1xuaW1wb3J0IHtJTkZJTklUWX0gZnJvbSAnLi9oZWxwZXJzLm1hdGguanMnO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfaXNEb21TdXBwb3J0ZWQoKTogYm9vbGVhbiB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZ2V0UGFyZW50Tm9kZShkb21Ob2RlOiBIVE1MQ2FudmFzRWxlbWVudCk6IEhUTUxDYW52YXNFbGVtZW50IHtcbiAgbGV0IHBhcmVudCA9IGRvbU5vZGUucGFyZW50Tm9kZTtcbiAgaWYgKHBhcmVudCAmJiBwYXJlbnQudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgU2hhZG93Um9vdF0nKSB7XG4gICAgcGFyZW50ID0gKHBhcmVudCBhcyBTaGFkb3dSb290KS5ob3N0O1xuICB9XG4gIHJldHVybiBwYXJlbnQgYXMgSFRNTENhbnZhc0VsZW1lbnQ7XG59XG5cbi8qKlxuICogY29udmVydCBtYXgtd2lkdGgvbWF4LWhlaWdodCB2YWx1ZXMgdGhhdCBtYXkgYmUgcGVyY2VudGFnZXMgaW50byBhIG51bWJlclxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZU1heFN0eWxlKHN0eWxlVmFsdWU6IHN0cmluZyB8IG51bWJlciwgbm9kZTogSFRNTEVsZW1lbnQsIHBhcmVudFByb3BlcnR5OiBzdHJpbmcpIHtcbiAgbGV0IHZhbHVlSW5QaXhlbHM6IG51bWJlcjtcbiAgaWYgKHR5cGVvZiBzdHlsZVZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHZhbHVlSW5QaXhlbHMgPSBwYXJzZUludChzdHlsZVZhbHVlLCAxMCk7XG5cbiAgICBpZiAoc3R5bGVWYWx1ZS5pbmRleE9mKCclJykgIT09IC0xKSB7XG4gICAgICAvLyBwZXJjZW50YWdlICogc2l6ZSBpbiBkaW1lbnNpb25cbiAgICAgIHZhbHVlSW5QaXhlbHMgPSAodmFsdWVJblBpeGVscyAvIDEwMCkgKiBub2RlLnBhcmVudE5vZGVbcGFyZW50UHJvcGVydHldO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWx1ZUluUGl4ZWxzID0gc3R5bGVWYWx1ZTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZUluUGl4ZWxzO1xufVxuXG5jb25zdCBnZXRDb21wdXRlZFN0eWxlID0gKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogQ1NTU3R5bGVEZWNsYXJhdGlvbiA9PlxuICBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFN0eWxlKGVsOiBIVE1MRWxlbWVudCwgcHJvcGVydHk6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKGVsKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KTtcbn1cblxuY29uc3QgcG9zaXRpb25zID0gWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXTtcbmZ1bmN0aW9uIGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZXM6IENTU1N0eWxlRGVjbGFyYXRpb24sIHN0eWxlOiBzdHJpbmcsIHN1ZmZpeD86IHN0cmluZyk6IENoYXJ0QXJlYSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9IGFzIENoYXJ0QXJlYTtcbiAgc3VmZml4ID0gc3VmZml4ID8gJy0nICsgc3VmZml4IDogJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgY29uc3QgcG9zID0gcG9zaXRpb25zW2ldO1xuICAgIHJlc3VsdFtwb3NdID0gcGFyc2VGbG9hdChzdHlsZXNbc3R5bGUgKyAnLScgKyBwb3MgKyBzdWZmaXhdKSB8fCAwO1xuICB9XG4gIHJlc3VsdC53aWR0aCA9IHJlc3VsdC5sZWZ0ICsgcmVzdWx0LnJpZ2h0O1xuICByZXN1bHQuaGVpZ2h0ID0gcmVzdWx0LnRvcCArIHJlc3VsdC5ib3R0b207XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmNvbnN0IHVzZU9mZnNldFBvcyA9ICh4OiBudW1iZXIsIHk6IG51bWJlciwgdGFyZ2V0OiBIVE1MRWxlbWVudCB8IEV2ZW50VGFyZ2V0KSA9PlxuICAoeCA+IDAgfHwgeSA+IDApICYmICghdGFyZ2V0IHx8ICEodGFyZ2V0IGFzIEhUTUxFbGVtZW50KS5zaGFkb3dSb290KTtcblxuLyoqXG4gKiBAcGFyYW0gZVxuICogQHBhcmFtIGNhbnZhc1xuICogQHJldHVybnMgQ2FudmFzIHBvc2l0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldENhbnZhc1Bvc2l0aW9uKFxuICBlOiBFdmVudCB8IFRvdWNoRXZlbnQgfCBNb3VzZUV2ZW50LFxuICBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50XG4pOiB7XG4gICAgeDogbnVtYmVyO1xuICAgIHk6IG51bWJlcjtcbiAgICBib3g6IGJvb2xlYW47XG4gIH0ge1xuICBjb25zdCB0b3VjaGVzID0gKGUgYXMgVG91Y2hFdmVudCkudG91Y2hlcztcbiAgY29uc3Qgc291cmNlID0gKHRvdWNoZXMgJiYgdG91Y2hlcy5sZW5ndGggPyB0b3VjaGVzWzBdIDogZSkgYXMgTW91c2VFdmVudDtcbiAgY29uc3Qge29mZnNldFgsIG9mZnNldFl9ID0gc291cmNlIGFzIE1vdXNlRXZlbnQ7XG4gIGxldCBib3ggPSBmYWxzZTtcbiAgbGV0IHgsIHk7XG4gIGlmICh1c2VPZmZzZXRQb3Mob2Zmc2V0WCwgb2Zmc2V0WSwgZS50YXJnZXQpKSB7XG4gICAgeCA9IG9mZnNldFg7XG4gICAgeSA9IG9mZnNldFk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB4ID0gc291cmNlLmNsaWVudFggLSByZWN0LmxlZnQ7XG4gICAgeSA9IHNvdXJjZS5jbGllbnRZIC0gcmVjdC50b3A7XG4gICAgYm94ID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4ge3gsIHksIGJveH07XG59XG5cbi8qKlxuICogR2V0cyBhbiBldmVudCdzIHgsIHkgY29vcmRpbmF0ZXMsIHJlbGF0aXZlIHRvIHRoZSBjaGFydCBhcmVhXG4gKiBAcGFyYW0gZXZlbnRcbiAqIEBwYXJhbSBjaGFydFxuICogQHJldHVybnMgeCBhbmQgeSBjb29yZGluYXRlcyBvZiB0aGUgZXZlbnRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVsYXRpdmVQb3NpdGlvbihcbiAgZXZlbnQ6IEV2ZW50IHwgQ2hhcnRFdmVudCB8IFRvdWNoRXZlbnQgfCBNb3VzZUV2ZW50LFxuICBjaGFydDogQ2hhcnQgfCBQcml2YXRlQ2hhcnRcbik6IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfSB7XG4gIGlmICgnbmF0aXZlJyBpbiBldmVudCkge1xuICAgIHJldHVybiBldmVudDtcbiAgfVxuXG4gIGNvbnN0IHtjYW52YXMsIGN1cnJlbnREZXZpY2VQaXhlbFJhdGlvfSA9IGNoYXJ0O1xuICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoY2FudmFzKTtcbiAgY29uc3QgYm9yZGVyQm94ID0gc3R5bGUuYm94U2l6aW5nID09PSAnYm9yZGVyLWJveCc7XG4gIGNvbnN0IHBhZGRpbmdzID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAncGFkZGluZycpO1xuICBjb25zdCBib3JkZXJzID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAnYm9yZGVyJywgJ3dpZHRoJyk7XG4gIGNvbnN0IHt4LCB5LCBib3h9ID0gZ2V0Q2FudmFzUG9zaXRpb24oZXZlbnQsIGNhbnZhcyk7XG4gIGNvbnN0IHhPZmZzZXQgPSBwYWRkaW5ncy5sZWZ0ICsgKGJveCAmJiBib3JkZXJzLmxlZnQpO1xuICBjb25zdCB5T2Zmc2V0ID0gcGFkZGluZ3MudG9wICsgKGJveCAmJiBib3JkZXJzLnRvcCk7XG5cbiAgbGV0IHt3aWR0aCwgaGVpZ2h0fSA9IGNoYXJ0O1xuICBpZiAoYm9yZGVyQm94KSB7XG4gICAgd2lkdGggLT0gcGFkZGluZ3Mud2lkdGggKyBib3JkZXJzLndpZHRoO1xuICAgIGhlaWdodCAtPSBwYWRkaW5ncy5oZWlnaHQgKyBib3JkZXJzLmhlaWdodDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IE1hdGgucm91bmQoKHggLSB4T2Zmc2V0KSAvIHdpZHRoICogY2FudmFzLndpZHRoIC8gY3VycmVudERldmljZVBpeGVsUmF0aW8pLFxuICAgIHk6IE1hdGgucm91bmQoKHkgLSB5T2Zmc2V0KSAvIGhlaWdodCAqIGNhbnZhcy5oZWlnaHQgLyBjdXJyZW50RGV2aWNlUGl4ZWxSYXRpbylcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29udGFpbmVyU2l6ZShjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IFBhcnRpYWw8U2NhbGU+IHtcbiAgbGV0IG1heFdpZHRoOiBudW1iZXIsIG1heEhlaWdodDogbnVtYmVyO1xuXG4gIGlmICh3aWR0aCA9PT0gdW5kZWZpbmVkIHx8IGhlaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gY2FudmFzICYmIF9nZXRQYXJlbnROb2RlKGNhbnZhcyk7XG4gICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgIHdpZHRoID0gY2FudmFzLmNsaWVudFdpZHRoO1xuICAgICAgaGVpZ2h0ID0gY2FudmFzLmNsaWVudEhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgLy8gdGhpcyBpcyB0aGUgYm9yZGVyIGJveCBvZiB0aGUgY29udGFpbmVyXG4gICAgICBjb25zdCBjb250YWluZXJTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoY29udGFpbmVyKTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lckJvcmRlciA9IGdldFBvc2l0aW9uZWRTdHlsZShjb250YWluZXJTdHlsZSwgJ2JvcmRlcicsICd3aWR0aCcpO1xuICAgICAgY29uc3QgY29udGFpbmVyUGFkZGluZyA9IGdldFBvc2l0aW9uZWRTdHlsZShjb250YWluZXJTdHlsZSwgJ3BhZGRpbmcnKTtcbiAgICAgIHdpZHRoID0gcmVjdC53aWR0aCAtIGNvbnRhaW5lclBhZGRpbmcud2lkdGggLSBjb250YWluZXJCb3JkZXIud2lkdGg7XG4gICAgICBoZWlnaHQgPSByZWN0LmhlaWdodCAtIGNvbnRhaW5lclBhZGRpbmcuaGVpZ2h0IC0gY29udGFpbmVyQm9yZGVyLmhlaWdodDtcbiAgICAgIG1heFdpZHRoID0gcGFyc2VNYXhTdHlsZShjb250YWluZXJTdHlsZS5tYXhXaWR0aCwgY29udGFpbmVyLCAnY2xpZW50V2lkdGgnKTtcbiAgICAgIG1heEhlaWdodCA9IHBhcnNlTWF4U3R5bGUoY29udGFpbmVyU3R5bGUubWF4SGVpZ2h0LCBjb250YWluZXIsICdjbGllbnRIZWlnaHQnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgbWF4V2lkdGg6IG1heFdpZHRoIHx8IElORklOSVRZLFxuICAgIG1heEhlaWdodDogbWF4SGVpZ2h0IHx8IElORklOSVRZXG4gIH07XG59XG5cbmNvbnN0IHJvdW5kMSA9ICh2OiBudW1iZXIpID0+IE1hdGgucm91bmQodiAqIDEwKSAvIDEwO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZXhwb3J0IGZ1bmN0aW9uIGdldE1heGltdW1TaXplKFxuICBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LFxuICBiYldpZHRoPzogbnVtYmVyLFxuICBiYkhlaWdodD86IG51bWJlcixcbiAgYXNwZWN0UmF0aW8/OiBudW1iZXJcbik6IHsgd2lkdGg6IG51bWJlcjsgaGVpZ2h0OiBudW1iZXIgfSB7XG4gIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShjYW52YXMpO1xuICBjb25zdCBtYXJnaW5zID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAnbWFyZ2luJyk7XG4gIGNvbnN0IG1heFdpZHRoID0gcGFyc2VNYXhTdHlsZShzdHlsZS5tYXhXaWR0aCwgY2FudmFzLCAnY2xpZW50V2lkdGgnKSB8fCBJTkZJTklUWTtcbiAgY29uc3QgbWF4SGVpZ2h0ID0gcGFyc2VNYXhTdHlsZShzdHlsZS5tYXhIZWlnaHQsIGNhbnZhcywgJ2NsaWVudEhlaWdodCcpIHx8IElORklOSVRZO1xuICBjb25zdCBjb250YWluZXJTaXplID0gZ2V0Q29udGFpbmVyU2l6ZShjYW52YXMsIGJiV2lkdGgsIGJiSGVpZ2h0KTtcbiAgbGV0IHt3aWR0aCwgaGVpZ2h0fSA9IGNvbnRhaW5lclNpemU7XG5cbiAgaWYgKHN0eWxlLmJveFNpemluZyA9PT0gJ2NvbnRlbnQtYm94Jykge1xuICAgIGNvbnN0IGJvcmRlcnMgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdib3JkZXInLCAnd2lkdGgnKTtcbiAgICBjb25zdCBwYWRkaW5ncyA9IGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZSwgJ3BhZGRpbmcnKTtcbiAgICB3aWR0aCAtPSBwYWRkaW5ncy53aWR0aCArIGJvcmRlcnMud2lkdGg7XG4gICAgaGVpZ2h0IC09IHBhZGRpbmdzLmhlaWdodCArIGJvcmRlcnMuaGVpZ2h0O1xuICB9XG4gIHdpZHRoID0gTWF0aC5tYXgoMCwgd2lkdGggLSBtYXJnaW5zLndpZHRoKTtcbiAgaGVpZ2h0ID0gTWF0aC5tYXgoMCwgYXNwZWN0UmF0aW8gPyB3aWR0aCAvIGFzcGVjdFJhdGlvIDogaGVpZ2h0IC0gbWFyZ2lucy5oZWlnaHQpO1xuICB3aWR0aCA9IHJvdW5kMShNYXRoLm1pbih3aWR0aCwgbWF4V2lkdGgsIGNvbnRhaW5lclNpemUubWF4V2lkdGgpKTtcbiAgaGVpZ2h0ID0gcm91bmQxKE1hdGgubWluKGhlaWdodCwgbWF4SGVpZ2h0LCBjb250YWluZXJTaXplLm1heEhlaWdodCkpO1xuICBpZiAod2lkdGggJiYgIWhlaWdodCkge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy80NjU5XG4gICAgLy8gSWYgdGhlIGNhbnZhcyBoYXMgd2lkdGgsIGJ1dCBubyBoZWlnaHQsIGRlZmF1bHQgdG8gYXNwZWN0UmF0aW8gb2YgMiAoY2FudmFzIGRlZmF1bHQpXG4gICAgaGVpZ2h0ID0gcm91bmQxKHdpZHRoIC8gMik7XG4gIH1cblxuICBjb25zdCBtYWludGFpbkhlaWdodCA9IGJiV2lkdGggIT09IHVuZGVmaW5lZCB8fCBiYkhlaWdodCAhPT0gdW5kZWZpbmVkO1xuXG4gIGlmIChtYWludGFpbkhlaWdodCAmJiBhc3BlY3RSYXRpbyAmJiBjb250YWluZXJTaXplLmhlaWdodCAmJiBoZWlnaHQgPiBjb250YWluZXJTaXplLmhlaWdodCkge1xuICAgIGhlaWdodCA9IGNvbnRhaW5lclNpemUuaGVpZ2h0O1xuICAgIHdpZHRoID0gcm91bmQxKE1hdGguZmxvb3IoaGVpZ2h0ICogYXNwZWN0UmF0aW8pKTtcbiAgfVxuXG4gIHJldHVybiB7d2lkdGgsIGhlaWdodH07XG59XG5cbi8qKlxuICogQHBhcmFtIGNoYXJ0XG4gKiBAcGFyYW0gZm9yY2VSYXRpb1xuICogQHBhcmFtIGZvcmNlU3R5bGVcbiAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGNhbnZhcyBjb250ZXh0IHNpemUgb3IgdHJhbnNmb3JtYXRpb24gaGFzIGNoYW5nZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXRpbmFTY2FsZShcbiAgY2hhcnQ6IENoYXJ0IHwgUHJpdmF0ZUNoYXJ0LFxuICBmb3JjZVJhdGlvOiBudW1iZXIsXG4gIGZvcmNlU3R5bGU/OiBib29sZWFuXG4pOiBib29sZWFuIHwgdm9pZCB7XG4gIGNvbnN0IHBpeGVsUmF0aW8gPSBmb3JjZVJhdGlvIHx8IDE7XG4gIGNvbnN0IGRldmljZUhlaWdodCA9IHJvdW5kMShjaGFydC5oZWlnaHQgKiBwaXhlbFJhdGlvKTtcbiAgY29uc3QgZGV2aWNlV2lkdGggPSByb3VuZDEoY2hhcnQud2lkdGggKiBwaXhlbFJhdGlvKTtcblxuICAoY2hhcnQgYXMgUHJpdmF0ZUNoYXJ0KS5oZWlnaHQgPSByb3VuZDEoY2hhcnQuaGVpZ2h0KTtcbiAgKGNoYXJ0IGFzIFByaXZhdGVDaGFydCkud2lkdGggPSByb3VuZDEoY2hhcnQud2lkdGgpO1xuXG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcblxuICAvLyBJZiBubyBzdHlsZSBoYXMgYmVlbiBzZXQgb24gdGhlIGNhbnZhcywgdGhlIHJlbmRlciBzaXplIGlzIHVzZWQgYXMgZGlzcGxheSBzaXplLFxuICAvLyBtYWtpbmcgdGhlIGNoYXJ0IHZpc3VhbGx5IGJpZ2dlciwgc28gbGV0J3MgZW5mb3JjZSBpdCB0byB0aGUgXCJjb3JyZWN0XCIgdmFsdWVzLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzM1NzVcbiAgaWYgKGNhbnZhcy5zdHlsZSAmJiAoZm9yY2VTdHlsZSB8fCAoIWNhbnZhcy5zdHlsZS5oZWlnaHQgJiYgIWNhbnZhcy5zdHlsZS53aWR0aCkpKSB7XG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGAke2NoYXJ0LmhlaWdodH1weGA7XG4gICAgY2FudmFzLnN0eWxlLndpZHRoID0gYCR7Y2hhcnQud2lkdGh9cHhgO1xuICB9XG5cbiAgaWYgKGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvICE9PSBwaXhlbFJhdGlvXG4gICAgICB8fCBjYW52YXMuaGVpZ2h0ICE9PSBkZXZpY2VIZWlnaHRcbiAgICAgIHx8IGNhbnZhcy53aWR0aCAhPT0gZGV2aWNlV2lkdGgpIHtcbiAgICAoY2hhcnQgYXMgUHJpdmF0ZUNoYXJ0KS5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XG4gICAgY2FudmFzLmhlaWdodCA9IGRldmljZUhlaWdodDtcbiAgICBjYW52YXMud2lkdGggPSBkZXZpY2VXaWR0aDtcbiAgICBjaGFydC5jdHguc2V0VHJhbnNmb3JtKHBpeGVsUmF0aW8sIDAsIDAsIHBpeGVsUmF0aW8sIDAsIDApO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBEZXRlY3RzIHN1cHBvcnQgZm9yIG9wdGlvbnMgb2JqZWN0IGFyZ3VtZW50IGluIGFkZEV2ZW50TGlzdGVuZXIuXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRXZlbnRUYXJnZXQvYWRkRXZlbnRMaXN0ZW5lciNTYWZlbHlfZGV0ZWN0aW5nX29wdGlvbl9zdXBwb3J0XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3Qgc3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucyA9IChmdW5jdGlvbigpIHtcbiAgbGV0IHBhc3NpdmVTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgZ2V0IHBhc3NpdmUoKSB7IC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgYnJvd3NlciBhdHRlbXB0cyB0byBhY2Nlc3MgdGhlIHBhc3NpdmUgcHJvcGVydHkuXG4gICAgICAgIHBhc3NpdmVTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBhcyBFdmVudExpc3RlbmVyT3B0aW9ucztcblxuICAgIGlmIChfaXNEb21TdXBwb3J0ZWQoKSkge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBvcHRpb25zKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgb3B0aW9ucyk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gY29udGludWUgcmVnYXJkbGVzcyBvZiBlcnJvclxuICB9XG4gIHJldHVybiBwYXNzaXZlU3VwcG9ydGVkO1xufSgpKTtcblxuLyoqXG4gKiBUaGUgXCJ1c2VkXCIgc2l6ZSBpcyB0aGUgZmluYWwgdmFsdWUgb2YgYSBkaW1lbnNpb24gcHJvcGVydHkgYWZ0ZXIgYWxsIGNhbGN1bGF0aW9ucyBoYXZlXG4gKiBiZWVuIHBlcmZvcm1lZC4gVGhpcyBtZXRob2QgdXNlcyB0aGUgY29tcHV0ZWQgc3R5bGUgb2YgYGVsZW1lbnRgIGJ1dCByZXR1cm5zIHVuZGVmaW5lZFxuICogaWYgdGhlIGNvbXB1dGVkIHN0eWxlIGlzIG5vdCBleHByZXNzZWQgaW4gcGl4ZWxzLiBUaGF0IGNhbiBoYXBwZW4gaW4gc29tZSBjYXNlcyB3aGVyZVxuICogYGVsZW1lbnRgIGhhcyBhIHNpemUgcmVsYXRpdmUgdG8gaXRzIHBhcmVudCBhbmQgdGhpcyBsYXN0IG9uZSBpcyBub3QgeWV0IGRpc3BsYXllZCxcbiAqIGZvciBleGFtcGxlIGJlY2F1c2Ugb2YgYGRpc3BsYXk6IG5vbmVgIG9uIGEgcGFyZW50IG5vZGUuXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy91c2VkX3ZhbHVlXG4gKiBAcmV0dXJucyBTaXplIGluIHBpeGVscyBvciB1bmRlZmluZWQgaWYgdW5rbm93bi5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcmVhZFVzZWRTaXplKFxuICBlbGVtZW50OiBIVE1MRWxlbWVudCxcbiAgcHJvcGVydHk6ICd3aWR0aCcgfCAnaGVpZ2h0J1xuKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgY29uc3QgdmFsdWUgPSBnZXRTdHlsZShlbGVtZW50LCBwcm9wZXJ0eSk7XG4gIGNvbnN0IG1hdGNoZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCgvXihcXGQrKShcXC5cXGQrKT9weCQvKTtcbiAgcmV0dXJuIG1hdGNoZXMgPyArbWF0Y2hlc1sxXSA6IHVuZGVmaW5lZDtcbn1cbiIsImltcG9ydCB0eXBlIHtQb2ludCwgU3BsaW5lUG9pbnR9IGZyb20gJy4uL3R5cGVzL2dlb21ldHJpYy5qcyc7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9wb2ludEluTGluZShwMTogUG9pbnQsIHAyOiBQb2ludCwgdDogbnVtYmVyLCBtb2RlPykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICByZXR1cm4ge1xuICAgIHg6IHAxLnggKyB0ICogKHAyLnggLSBwMS54KSxcbiAgICB5OiBwMS55ICsgdCAqIChwMi55IC0gcDEueSlcbiAgfTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX3N0ZXBwZWRJbnRlcnBvbGF0aW9uKFxuICBwMTogUG9pbnQsXG4gIHAyOiBQb2ludCxcbiAgdDogbnVtYmVyLCBtb2RlOiAnbWlkZGxlJyB8ICdhZnRlcicgfCB1bmtub3duXG4pIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBwMS54ICsgdCAqIChwMi54IC0gcDEueCksXG4gICAgeTogbW9kZSA9PT0gJ21pZGRsZScgPyB0IDwgMC41ID8gcDEueSA6IHAyLnlcbiAgICAgIDogbW9kZSA9PT0gJ2FmdGVyJyA/IHQgPCAxID8gcDEueSA6IHAyLnlcbiAgICAgICAgOiB0ID4gMCA/IHAyLnkgOiBwMS55XG4gIH07XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9iZXppZXJJbnRlcnBvbGF0aW9uKHAxOiBTcGxpbmVQb2ludCwgcDI6IFNwbGluZVBvaW50LCB0OiBudW1iZXIsIG1vZGU/KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIGNvbnN0IGNwMSA9IHt4OiBwMS5jcDJ4LCB5OiBwMS5jcDJ5fTtcbiAgY29uc3QgY3AyID0ge3g6IHAyLmNwMXgsIHk6IHAyLmNwMXl9O1xuICBjb25zdCBhID0gX3BvaW50SW5MaW5lKHAxLCBjcDEsIHQpO1xuICBjb25zdCBiID0gX3BvaW50SW5MaW5lKGNwMSwgY3AyLCB0KTtcbiAgY29uc3QgYyA9IF9wb2ludEluTGluZShjcDIsIHAyLCB0KTtcbiAgY29uc3QgZCA9IF9wb2ludEluTGluZShhLCBiLCB0KTtcbiAgY29uc3QgZSA9IF9wb2ludEluTGluZShiLCBjLCB0KTtcbiAgcmV0dXJuIF9wb2ludEluTGluZShkLCBlLCB0KTtcbn1cbiIsImV4cG9ydCBpbnRlcmZhY2UgUlRMQWRhcHRlciB7XG4gIHgoeDogbnVtYmVyKTogbnVtYmVyO1xuICBzZXRXaWR0aCh3OiBudW1iZXIpOiB2b2lkO1xuICB0ZXh0QWxpZ24oYWxpZ246ICdjZW50ZXInIHwgJ2xlZnQnIHwgJ3JpZ2h0Jyk6ICdjZW50ZXInIHwgJ2xlZnQnIHwgJ3JpZ2h0JztcbiAgeFBsdXMoeDogbnVtYmVyLCB2YWx1ZTogbnVtYmVyKTogbnVtYmVyO1xuICBsZWZ0Rm9yTHRyKHg6IG51bWJlciwgaXRlbVdpZHRoOiBudW1iZXIpOiBudW1iZXI7XG59XG5cbmNvbnN0IGdldFJpZ2h0VG9MZWZ0QWRhcHRlciA9IGZ1bmN0aW9uKHJlY3RYOiBudW1iZXIsIHdpZHRoOiBudW1iZXIpOiBSVExBZGFwdGVyIHtcbiAgcmV0dXJuIHtcbiAgICB4KHgpIHtcbiAgICAgIHJldHVybiByZWN0WCArIHJlY3RYICsgd2lkdGggLSB4O1xuICAgIH0sXG4gICAgc2V0V2lkdGgodykge1xuICAgICAgd2lkdGggPSB3O1xuICAgIH0sXG4gICAgdGV4dEFsaWduKGFsaWduKSB7XG4gICAgICBpZiAoYWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHJldHVybiBhbGlnbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhbGlnbiA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgfSxcbiAgICB4UGx1cyh4LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHggLSB2YWx1ZTtcbiAgICB9LFxuICAgIGxlZnRGb3JMdHIoeCwgaXRlbVdpZHRoKSB7XG4gICAgICByZXR1cm4geCAtIGl0ZW1XaWR0aDtcbiAgICB9LFxuICB9O1xufTtcblxuY29uc3QgZ2V0TGVmdFRvUmlnaHRBZGFwdGVyID0gZnVuY3Rpb24oKTogUlRMQWRhcHRlciB7XG4gIHJldHVybiB7XG4gICAgeCh4KSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9LFxuICAgIHNldFdpZHRoKHcpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIH0sXG4gICAgdGV4dEFsaWduKGFsaWduKSB7XG4gICAgICByZXR1cm4gYWxpZ247XG4gICAgfSxcbiAgICB4UGx1cyh4LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHggKyB2YWx1ZTtcbiAgICB9LFxuICAgIGxlZnRGb3JMdHIoeCwgX2l0ZW1XaWR0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIHg7XG4gICAgfSxcbiAgfTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSdGxBZGFwdGVyKHJ0bDogYm9vbGVhbiwgcmVjdFg6IG51bWJlciwgd2lkdGg6IG51bWJlcikge1xuICByZXR1cm4gcnRsID8gZ2V0UmlnaHRUb0xlZnRBZGFwdGVyKHJlY3RYLCB3aWR0aCkgOiBnZXRMZWZ0VG9SaWdodEFkYXB0ZXIoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG92ZXJyaWRlVGV4dERpcmVjdGlvbihjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgZGlyZWN0aW9uOiAnbHRyJyB8ICdydGwnKSB7XG4gIGxldCBzdHlsZTogQ1NTU3R5bGVEZWNsYXJhdGlvbiwgb3JpZ2luYWw6IFtzdHJpbmcsIHN0cmluZ107XG4gIGlmIChkaXJlY3Rpb24gPT09ICdsdHInIHx8IGRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICBzdHlsZSA9IGN0eC5jYW52YXMuc3R5bGU7XG4gICAgb3JpZ2luYWwgPSBbXG4gICAgICBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdkaXJlY3Rpb24nKSxcbiAgICAgIHN0eWxlLmdldFByb3BlcnR5UHJpb3JpdHkoJ2RpcmVjdGlvbicpLFxuICAgIF07XG5cbiAgICBzdHlsZS5zZXRQcm9wZXJ0eSgnZGlyZWN0aW9uJywgZGlyZWN0aW9uLCAnaW1wb3J0YW50Jyk7XG4gICAgKGN0eCBhcyB7IHByZXZUZXh0RGlyZWN0aW9uPzogW3N0cmluZywgc3RyaW5nXSB9KS5wcmV2VGV4dERpcmVjdGlvbiA9IG9yaWdpbmFsO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXN0b3JlVGV4dERpcmVjdGlvbihjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgb3JpZ2luYWw/OiBbc3RyaW5nLCBzdHJpbmddKSB7XG4gIGlmIChvcmlnaW5hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZGVsZXRlIChjdHggYXMgeyBwcmV2VGV4dERpcmVjdGlvbj86IFtzdHJpbmcsIHN0cmluZ10gfSkucHJldlRleHREaXJlY3Rpb247XG4gICAgY3R4LmNhbnZhcy5zdHlsZS5zZXRQcm9wZXJ0eSgnZGlyZWN0aW9uJywgb3JpZ2luYWxbMF0sIG9yaWdpbmFsWzFdKTtcbiAgfVxufVxuIiwiaW1wb3J0IHtfYW5nbGVCZXR3ZWVuLCBfYW5nbGVEaWZmLCBfaXNCZXR3ZWVuLCBfbm9ybWFsaXplQW5nbGV9IGZyb20gJy4vaGVscGVycy5tYXRoLmpzJztcbmltcG9ydCB7Y3JlYXRlQ29udGV4dH0gZnJvbSAnLi9oZWxwZXJzLm9wdGlvbnMuanMnO1xuaW1wb3J0IHtpc1BhdHRlcm5PckdyYWRpZW50fSBmcm9tICcuL2hlbHBlcnMuY29sb3IuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9lbGVtZW50cy9lbGVtZW50LmxpbmUuanMnKS5kZWZhdWx0IH0gTGluZUVsZW1lbnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9lbGVtZW50cy9lbGVtZW50LnBvaW50LmpzJykuZGVmYXVsdCB9IFBvaW50RWxlbWVudFxuICogQHR5cGVkZWYge3tzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlciwgbG9vcDogYm9vbGVhbiwgc3R5bGU/OiBhbnl9fSBTZWdtZW50XG4gKi9cblxuZnVuY3Rpb24gcHJvcGVydHlGbihwcm9wZXJ0eSkge1xuICBpZiAocHJvcGVydHkgPT09ICdhbmdsZScpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYmV0d2VlbjogX2FuZ2xlQmV0d2VlbixcbiAgICAgIGNvbXBhcmU6IF9hbmdsZURpZmYsXG4gICAgICBub3JtYWxpemU6IF9ub3JtYWxpemVBbmdsZSxcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgYmV0d2VlbjogX2lzQmV0d2VlbixcbiAgICBjb21wYXJlOiAoYSwgYikgPT4gYSAtIGIsXG4gICAgbm9ybWFsaXplOiB4ID0+IHhcbiAgfTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplU2VnbWVudCh7c3RhcnQsIGVuZCwgY291bnQsIGxvb3AsIHN0eWxlfSkge1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBzdGFydCAlIGNvdW50LFxuICAgIGVuZDogZW5kICUgY291bnQsXG4gICAgbG9vcDogbG9vcCAmJiAoZW5kIC0gc3RhcnQgKyAxKSAlIGNvdW50ID09PSAwLFxuICAgIHN0eWxlXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFNlZ21lbnQoc2VnbWVudCwgcG9pbnRzLCBib3VuZHMpIHtcbiAgY29uc3Qge3Byb3BlcnR5LCBzdGFydDogc3RhcnRCb3VuZCwgZW5kOiBlbmRCb3VuZH0gPSBib3VuZHM7XG4gIGNvbnN0IHtiZXR3ZWVuLCBub3JtYWxpemV9ID0gcHJvcGVydHlGbihwcm9wZXJ0eSk7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICBsZXQge3N0YXJ0LCBlbmQsIGxvb3B9ID0gc2VnbWVudDtcbiAgbGV0IGksIGlsZW47XG5cbiAgaWYgKGxvb3ApIHtcbiAgICBzdGFydCArPSBjb3VudDtcbiAgICBlbmQgKz0gY291bnQ7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpZiAoIWJldHdlZW4obm9ybWFsaXplKHBvaW50c1tzdGFydCAlIGNvdW50XVtwcm9wZXJ0eV0pLCBzdGFydEJvdW5kLCBlbmRCb3VuZCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdGFydC0tO1xuICAgICAgZW5kLS07XG4gICAgfVxuICAgIHN0YXJ0ICU9IGNvdW50O1xuICAgIGVuZCAlPSBjb3VudDtcbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkge1xuICAgIGVuZCArPSBjb3VudDtcbiAgfVxuICByZXR1cm4ge3N0YXJ0LCBlbmQsIGxvb3AsIHN0eWxlOiBzZWdtZW50LnN0eWxlfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzdWItc2VnbWVudChzKSBvZiBhIGxpbmUgc2VnbWVudCB0aGF0IGZhbGwgaW4gdGhlIGdpdmVuIGJvdW5kc1xuICogQHBhcmFtIHtvYmplY3R9IHNlZ21lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50LnN0YXJ0IC0gc3RhcnQgaW5kZXggb2YgdGhlIHNlZ21lbnQsIHJlZmVycmluZyB0aGUgcG9pbnRzIGFycmF5XG4gKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudC5lbmQgLSBlbmQgaW5kZXggb2YgdGhlIHNlZ21lbnQsIHJlZmVycmluZyB0aGUgcG9pbnRzIGFycmF5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNlZ21lbnQubG9vcCAtIGluZGljYXRlcyB0aGF0IHRoZSBzZWdtZW50IGlzIGEgbG9vcFxuICogQHBhcmFtIHtvYmplY3R9IFtzZWdtZW50LnN0eWxlXSAtIHNlZ21lbnQgc3R5bGVcbiAqIEBwYXJhbSB7UG9pbnRFbGVtZW50W119IHBvaW50cyAtIHRoZSBwb2ludHMgdGhhdCB0aGlzIHNlZ21lbnQgcmVmZXJzIHRvXG4gKiBAcGFyYW0ge29iamVjdH0gW2JvdW5kc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBib3VuZHMucHJvcGVydHkgLSB0aGUgcHJvcGVydHkgb2YgYSBgUG9pbnRFbGVtZW50YCB3ZSBhcmUgYm91bmRpbmcuIGB4YCwgYHlgIG9yIGBhbmdsZWAuXG4gKiBAcGFyYW0ge251bWJlcn0gYm91bmRzLnN0YXJ0IC0gc3RhcnQgdmFsdWUgb2YgdGhlIHByb3BlcnR5XG4gKiBAcGFyYW0ge251bWJlcn0gYm91bmRzLmVuZCAtIGVuZCB2YWx1ZSBvZiB0aGUgcHJvcGVydHlcbiAqIEBwcml2YXRlXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gX2JvdW5kU2VnbWVudChzZWdtZW50LCBwb2ludHMsIGJvdW5kcykge1xuICBpZiAoIWJvdW5kcykge1xuICAgIHJldHVybiBbc2VnbWVudF07XG4gIH1cblxuICBjb25zdCB7cHJvcGVydHksIHN0YXJ0OiBzdGFydEJvdW5kLCBlbmQ6IGVuZEJvdW5kfSA9IGJvdW5kcztcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCB7Y29tcGFyZSwgYmV0d2Vlbiwgbm9ybWFsaXplfSA9IHByb3BlcnR5Rm4ocHJvcGVydHkpO1xuICBjb25zdCB7c3RhcnQsIGVuZCwgbG9vcCwgc3R5bGV9ID0gZ2V0U2VnbWVudChzZWdtZW50LCBwb2ludHMsIGJvdW5kcyk7XG5cbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBpbnNpZGUgPSBmYWxzZTtcbiAgbGV0IHN1YlN0YXJ0ID0gbnVsbDtcbiAgbGV0IHZhbHVlLCBwb2ludCwgcHJldlZhbHVlO1xuXG4gIGNvbnN0IHN0YXJ0SXNCZWZvcmUgPSAoKSA9PiBiZXR3ZWVuKHN0YXJ0Qm91bmQsIHByZXZWYWx1ZSwgdmFsdWUpICYmIGNvbXBhcmUoc3RhcnRCb3VuZCwgcHJldlZhbHVlKSAhPT0gMDtcbiAgY29uc3QgZW5kSXNCZWZvcmUgPSAoKSA9PiBjb21wYXJlKGVuZEJvdW5kLCB2YWx1ZSkgPT09IDAgfHwgYmV0d2VlbihlbmRCb3VuZCwgcHJldlZhbHVlLCB2YWx1ZSk7XG4gIGNvbnN0IHNob3VsZFN0YXJ0ID0gKCkgPT4gaW5zaWRlIHx8IHN0YXJ0SXNCZWZvcmUoKTtcbiAgY29uc3Qgc2hvdWxkU3RvcCA9ICgpID0+ICFpbnNpZGUgfHwgZW5kSXNCZWZvcmUoKTtcblxuICBmb3IgKGxldCBpID0gc3RhcnQsIHByZXYgPSBzdGFydDsgaSA8PSBlbmQ7ICsraSkge1xuICAgIHBvaW50ID0gcG9pbnRzW2kgJSBjb3VudF07XG5cbiAgICBpZiAocG9pbnQuc2tpcCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFsdWUgPSBub3JtYWxpemUocG9pbnRbcHJvcGVydHldKTtcblxuICAgIGlmICh2YWx1ZSA9PT0gcHJldlZhbHVlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpbnNpZGUgPSBiZXR3ZWVuKHZhbHVlLCBzdGFydEJvdW5kLCBlbmRCb3VuZCk7XG5cbiAgICBpZiAoc3ViU3RhcnQgPT09IG51bGwgJiYgc2hvdWxkU3RhcnQoKSkge1xuICAgICAgc3ViU3RhcnQgPSBjb21wYXJlKHZhbHVlLCBzdGFydEJvdW5kKSA9PT0gMCA/IGkgOiBwcmV2O1xuICAgIH1cblxuICAgIGlmIChzdWJTdGFydCAhPT0gbnVsbCAmJiBzaG91bGRTdG9wKCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKG5vcm1hbGl6ZVNlZ21lbnQoe3N0YXJ0OiBzdWJTdGFydCwgZW5kOiBpLCBsb29wLCBjb3VudCwgc3R5bGV9KSk7XG4gICAgICBzdWJTdGFydCA9IG51bGw7XG4gICAgfVxuICAgIHByZXYgPSBpO1xuICAgIHByZXZWYWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgaWYgKHN1YlN0YXJ0ICE9PSBudWxsKSB7XG4gICAgcmVzdWx0LnB1c2gobm9ybWFsaXplU2VnbWVudCh7c3RhcnQ6IHN1YlN0YXJ0LCBlbmQsIGxvb3AsIGNvdW50LCBzdHlsZX0pKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzZWdtZW50cyBvZiB0aGUgbGluZSB0aGF0IGFyZSBpbnNpZGUgZ2l2ZW4gYm91bmRzXG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lXG4gKiBAcGFyYW0ge29iamVjdH0gW2JvdW5kc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBib3VuZHMucHJvcGVydHkgLSB0aGUgcHJvcGVydHkgd2UgYXJlIGJvdW5kaW5nIHdpdGguIGB4YCwgYHlgIG9yIGBhbmdsZWAuXG4gKiBAcGFyYW0ge251bWJlcn0gYm91bmRzLnN0YXJ0IC0gc3RhcnQgdmFsdWUgb2YgdGhlIGBwcm9wZXJ0eWBcbiAqIEBwYXJhbSB7bnVtYmVyfSBib3VuZHMuZW5kIC0gZW5kIHZhbHVlIG9mIHRoZSBgcHJvcGVydHlgXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2JvdW5kU2VnbWVudHMobGluZSwgYm91bmRzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBzZWdtZW50cyA9IGxpbmUuc2VnbWVudHM7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHN1YiA9IF9ib3VuZFNlZ21lbnQoc2VnbWVudHNbaV0sIGxpbmUucG9pbnRzLCBib3VuZHMpO1xuICAgIGlmIChzdWIubGVuZ3RoKSB7XG4gICAgICByZXN1bHQucHVzaCguLi5zdWIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEZpbmQgc3RhcnQgYW5kIGVuZCBpbmRleCBvZiBhIGxpbmUuXG4gKi9cbmZ1bmN0aW9uIGZpbmRTdGFydEFuZEVuZChwb2ludHMsIGNvdW50LCBsb29wLCBzcGFuR2Fwcykge1xuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgZW5kID0gY291bnQgLSAxO1xuXG4gIGlmIChsb29wICYmICFzcGFuR2Fwcykge1xuICAgIC8vIGxvb3AgYW5kIG5vdCBzcGFubmluZyBnYXBzLCBmaXJzdCBmaW5kIGEgZ2FwIHRvIHN0YXJ0IGZyb21cbiAgICB3aGlsZSAoc3RhcnQgPCBjb3VudCAmJiAhcG9pbnRzW3N0YXJ0XS5za2lwKSB7XG4gICAgICBzdGFydCsrO1xuICAgIH1cbiAgfVxuXG4gIC8vIGZpbmQgZmlyc3Qgbm9uIHNraXBwZWQgcG9pbnQgKGFmdGVyIHRoZSBmaXJzdCBnYXAgcG9zc2libHkpXG4gIHdoaWxlIChzdGFydCA8IGNvdW50ICYmIHBvaW50c1tzdGFydF0uc2tpcCkge1xuICAgIHN0YXJ0Kys7XG4gIH1cblxuICAvLyBpZiB3ZSBsb29wZWQgdG8gY291bnQsIHN0YXJ0IG5lZWRzIHRvIGJlIDBcbiAgc3RhcnQgJT0gY291bnQ7XG5cbiAgaWYgKGxvb3ApIHtcbiAgICAvLyBsb29wIHdpbGwgZ28gcGFzdCBjb3VudCwgaWYgc3RhcnQgPiAwXG4gICAgZW5kICs9IHN0YXJ0O1xuICB9XG5cbiAgd2hpbGUgKGVuZCA+IHN0YXJ0ICYmIHBvaW50c1tlbmQgJSBjb3VudF0uc2tpcCkge1xuICAgIGVuZC0tO1xuICB9XG5cbiAgLy8gZW5kIGNvdWxkIGJlIG1vcmUgdGhhbiBjb3VudCwgbm9ybWFsaXplXG4gIGVuZCAlPSBjb3VudDtcblxuICByZXR1cm4ge3N0YXJ0LCBlbmR9O1xufVxuXG4vKipcbiAqIENvbXB1dGUgc29saWQgc2VnbWVudHMgZnJvbSBQb2ludHMsIHdoZW4gc3BhbkdhcHMgPT09IGZhbHNlXG4gKiBAcGFyYW0ge1BvaW50RWxlbWVudFtdfSBwb2ludHMgLSB0aGUgcG9pbnRzXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBzdGFydCBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IG1heCAtIG1heCBpbmRleCAoY2FuIGdvIHBhc3QgY291bnQgb24gYSBsb29wKVxuICogQHBhcmFtIHtib29sZWFufSBsb29wIC0gYm9vbGVhbiBpbmRpY2F0aW5nIHRoYXQgdGhpcyB3b3VsZCBiZSBhIGxvb3AgaWYgbm8gZ2FwcyBhcmUgZm91bmRcbiAqL1xuZnVuY3Rpb24gc29saWRTZWdtZW50cyhwb2ludHMsIHN0YXJ0LCBtYXgsIGxvb3ApIHtcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IGxhc3QgPSBzdGFydDtcbiAgbGV0IHByZXYgPSBwb2ludHNbc3RhcnRdO1xuICBsZXQgZW5kO1xuXG4gIGZvciAoZW5kID0gc3RhcnQgKyAxOyBlbmQgPD0gbWF4OyArK2VuZCkge1xuICAgIGNvbnN0IGN1ciA9IHBvaW50c1tlbmQgJSBjb3VudF07XG4gICAgaWYgKGN1ci5za2lwIHx8IGN1ci5zdG9wKSB7XG4gICAgICBpZiAoIXByZXYuc2tpcCkge1xuICAgICAgICBsb29wID0gZmFsc2U7XG4gICAgICAgIHJlc3VsdC5wdXNoKHtzdGFydDogc3RhcnQgJSBjb3VudCwgZW5kOiAoZW5kIC0gMSkgJSBjb3VudCwgbG9vcH0pO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHN0YXJ0ID0gbGFzdCA9IGN1ci5zdG9wID8gZW5kIDogbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdCA9IGVuZDtcbiAgICAgIGlmIChwcmV2LnNraXApIHtcbiAgICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgICB9XG4gICAgfVxuICAgIHByZXYgPSBjdXI7XG4gIH1cblxuICBpZiAobGFzdCAhPT0gbnVsbCkge1xuICAgIHJlc3VsdC5wdXNoKHtzdGFydDogc3RhcnQgJSBjb3VudCwgZW5kOiBsYXN0ICUgY291bnQsIGxvb3B9KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgY29udGludW91cyBzZWdtZW50cyB0aGF0IGRlZmluZSB0aGUgd2hvbGUgbGluZVxuICogVGhlcmUgY2FuIGJlIHNraXBwZWQgcG9pbnRzIHdpdGhpbiBhIHNlZ21lbnQsIGlmIHNwYW5HYXBzIGlzIHRydWUuXG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lXG4gKiBAcGFyYW0ge29iamVjdH0gW3NlZ21lbnRPcHRpb25zXVxuICogQHJldHVybiB7U2VnbWVudFtdfVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9jb21wdXRlU2VnbWVudHMobGluZSwgc2VnbWVudE9wdGlvbnMpIHtcbiAgY29uc3QgcG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGNvbnN0IHNwYW5HYXBzID0gbGluZS5vcHRpb25zLnNwYW5HYXBzO1xuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG5cbiAgaWYgKCFjb3VudCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGNvbnN0IGxvb3AgPSAhIWxpbmUuX2xvb3A7XG4gIGNvbnN0IHtzdGFydCwgZW5kfSA9IGZpbmRTdGFydEFuZEVuZChwb2ludHMsIGNvdW50LCBsb29wLCBzcGFuR2Fwcyk7XG5cbiAgaWYgKHNwYW5HYXBzID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHNwbGl0QnlTdHlsZXMobGluZSwgW3tzdGFydCwgZW5kLCBsb29wfV0sIHBvaW50cywgc2VnbWVudE9wdGlvbnMpO1xuICB9XG5cbiAgY29uc3QgbWF4ID0gZW5kIDwgc3RhcnQgPyBlbmQgKyBjb3VudCA6IGVuZDtcbiAgY29uc3QgY29tcGxldGVMb29wID0gISFsaW5lLl9mdWxsTG9vcCAmJiBzdGFydCA9PT0gMCAmJiBlbmQgPT09IGNvdW50IC0gMTtcbiAgcmV0dXJuIHNwbGl0QnlTdHlsZXMobGluZSwgc29saWRTZWdtZW50cyhwb2ludHMsIHN0YXJ0LCBtYXgsIGNvbXBsZXRlTG9vcCksIHBvaW50cywgc2VnbWVudE9wdGlvbnMpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U2VnbWVudFtdfSBzZWdtZW50c1xuICogQHBhcmFtIHtQb2ludEVsZW1lbnRbXX0gcG9pbnRzXG4gKiBAcGFyYW0ge29iamVjdH0gW3NlZ21lbnRPcHRpb25zXVxuICogQHJldHVybiB7U2VnbWVudFtdfVxuICovXG5mdW5jdGlvbiBzcGxpdEJ5U3R5bGVzKGxpbmUsIHNlZ21lbnRzLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKSB7XG4gIGlmICghc2VnbWVudE9wdGlvbnMgfHwgIXNlZ21lbnRPcHRpb25zLnNldENvbnRleHQgfHwgIXBvaW50cykge1xuICAgIHJldHVybiBzZWdtZW50cztcbiAgfVxuICByZXR1cm4gZG9TcGxpdEJ5U3R5bGVzKGxpbmUsIHNlZ21lbnRzLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lXG4gKiBAcGFyYW0ge1NlZ21lbnRbXX0gc2VnbWVudHNcbiAqIEBwYXJhbSB7UG9pbnRFbGVtZW50W119IHBvaW50c1xuICogQHBhcmFtIHtvYmplY3R9IFtzZWdtZW50T3B0aW9uc11cbiAqIEByZXR1cm4ge1NlZ21lbnRbXX1cbiAqL1xuZnVuY3Rpb24gZG9TcGxpdEJ5U3R5bGVzKGxpbmUsIHNlZ21lbnRzLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKSB7XG4gIGNvbnN0IGNoYXJ0Q29udGV4dCA9IGxpbmUuX2NoYXJ0LmdldENvbnRleHQoKTtcbiAgY29uc3QgYmFzZVN0eWxlID0gcmVhZFN0eWxlKGxpbmUub3B0aW9ucyk7XG4gIGNvbnN0IHtfZGF0YXNldEluZGV4OiBkYXRhc2V0SW5kZXgsIG9wdGlvbnM6IHtzcGFuR2Fwc319ID0gbGluZTtcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IHByZXZTdHlsZSA9IGJhc2VTdHlsZTtcbiAgbGV0IHN0YXJ0ID0gc2VnbWVudHNbMF0uc3RhcnQ7XG4gIGxldCBpID0gc3RhcnQ7XG5cbiAgZnVuY3Rpb24gYWRkU3R5bGUocywgZSwgbCwgc3QpIHtcbiAgICBjb25zdCBkaXIgPSBzcGFuR2FwcyA/IC0xIDogMTtcbiAgICBpZiAocyA9PT0gZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBTdHlsZSBjYW4gbm90IHN0YXJ0L2VuZCBvbiBhIHNraXBwZWQgcG9pbnQsIGFkanVzdCBpbmRpY2VzIGFjY29yZGluZ2x5XG4gICAgcyArPSBjb3VudDtcbiAgICB3aGlsZSAocG9pbnRzW3MgJSBjb3VudF0uc2tpcCkge1xuICAgICAgcyAtPSBkaXI7XG4gICAgfVxuICAgIHdoaWxlIChwb2ludHNbZSAlIGNvdW50XS5za2lwKSB7XG4gICAgICBlICs9IGRpcjtcbiAgICB9XG4gICAgaWYgKHMgJSBjb3VudCAhPT0gZSAlIGNvdW50KSB7XG4gICAgICByZXN1bHQucHVzaCh7c3RhcnQ6IHMgJSBjb3VudCwgZW5kOiBlICUgY291bnQsIGxvb3A6IGwsIHN0eWxlOiBzdH0pO1xuICAgICAgcHJldlN0eWxlID0gc3Q7XG4gICAgICBzdGFydCA9IGUgJSBjb3VudDtcbiAgICB9XG4gIH1cblxuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICBzdGFydCA9IHNwYW5HYXBzID8gc3RhcnQgOiBzZWdtZW50LnN0YXJ0O1xuICAgIGxldCBwcmV2ID0gcG9pbnRzW3N0YXJ0ICUgY291bnRdO1xuICAgIGxldCBzdHlsZTtcbiAgICBmb3IgKGkgPSBzdGFydCArIDE7IGkgPD0gc2VnbWVudC5lbmQ7IGkrKykge1xuICAgICAgY29uc3QgcHQgPSBwb2ludHNbaSAlIGNvdW50XTtcbiAgICAgIHN0eWxlID0gcmVhZFN0eWxlKHNlZ21lbnRPcHRpb25zLnNldENvbnRleHQoY3JlYXRlQ29udGV4dChjaGFydENvbnRleHQsIHtcbiAgICAgICAgdHlwZTogJ3NlZ21lbnQnLFxuICAgICAgICBwMDogcHJldixcbiAgICAgICAgcDE6IHB0LFxuICAgICAgICBwMERhdGFJbmRleDogKGkgLSAxKSAlIGNvdW50LFxuICAgICAgICBwMURhdGFJbmRleDogaSAlIGNvdW50LFxuICAgICAgICBkYXRhc2V0SW5kZXhcbiAgICAgIH0pKSk7XG4gICAgICBpZiAoc3R5bGVDaGFuZ2VkKHN0eWxlLCBwcmV2U3R5bGUpKSB7XG4gICAgICAgIGFkZFN0eWxlKHN0YXJ0LCBpIC0gMSwgc2VnbWVudC5sb29wLCBwcmV2U3R5bGUpO1xuICAgICAgfVxuICAgICAgcHJldiA9IHB0O1xuICAgICAgcHJldlN0eWxlID0gc3R5bGU7XG4gICAgfVxuICAgIGlmIChzdGFydCA8IGkgLSAxKSB7XG4gICAgICBhZGRTdHlsZShzdGFydCwgaSAtIDEsIHNlZ21lbnQubG9vcCwgcHJldlN0eWxlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiByZWFkU3R5bGUob3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgYm9yZGVyQ2FwU3R5bGU6IG9wdGlvbnMuYm9yZGVyQ2FwU3R5bGUsXG4gICAgYm9yZGVyRGFzaDogb3B0aW9ucy5ib3JkZXJEYXNoLFxuICAgIGJvcmRlckRhc2hPZmZzZXQ6IG9wdGlvbnMuYm9yZGVyRGFzaE9mZnNldCxcbiAgICBib3JkZXJKb2luU3R5bGU6IG9wdGlvbnMuYm9yZGVySm9pblN0eWxlLFxuICAgIGJvcmRlcldpZHRoOiBvcHRpb25zLmJvcmRlcldpZHRoLFxuICAgIGJvcmRlckNvbG9yOiBvcHRpb25zLmJvcmRlckNvbG9yXG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlQ2hhbmdlZChzdHlsZSwgcHJldlN0eWxlKSB7XG4gIGlmICghcHJldlN0eWxlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGNhY2hlID0gW107XG4gIGNvbnN0IHJlcGxhY2VyID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIGlmICghaXNQYXR0ZXJuT3JHcmFkaWVudCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKCFjYWNoZS5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICAgIGNhY2hlLnB1c2godmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGUuaW5kZXhPZih2YWx1ZSk7XG4gIH07XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShzdHlsZSwgcmVwbGFjZXIpICE9PSBKU09OLnN0cmluZ2lmeShwcmV2U3R5bGUsIHJlcGxhY2VyKTtcbn1cbiIsImltcG9ydCB0eXBlIHtDaGFydCwgQ2hhcnRBcmVhLCBDaGFydE1ldGEsIFNjYWxlLCBUUkJMfSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5cbmZ1bmN0aW9uIGdldFNpemVGb3JBcmVhKHNjYWxlOiBTY2FsZSwgY2hhcnRBcmVhOiBDaGFydEFyZWEsIGZpZWxkOiBrZXlvZiBDaGFydEFyZWEpIHtcbiAgcmV0dXJuIHNjYWxlLm9wdGlvbnMuY2xpcCA/IHNjYWxlW2ZpZWxkXSA6IGNoYXJ0QXJlYVtmaWVsZF07XG59XG5cbmZ1bmN0aW9uIGdldERhdGFzZXRBcmVhKG1ldGE6IENoYXJ0TWV0YSwgY2hhcnRBcmVhOiBDaGFydEFyZWEpOiBUUkJMIHtcbiAgY29uc3Qge3hTY2FsZSwgeVNjYWxlfSA9IG1ldGE7XG4gIGlmICh4U2NhbGUgJiYgeVNjYWxlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IGdldFNpemVGb3JBcmVhKHhTY2FsZSwgY2hhcnRBcmVhLCAnbGVmdCcpLFxuICAgICAgcmlnaHQ6IGdldFNpemVGb3JBcmVhKHhTY2FsZSwgY2hhcnRBcmVhLCAncmlnaHQnKSxcbiAgICAgIHRvcDogZ2V0U2l6ZUZvckFyZWEoeVNjYWxlLCBjaGFydEFyZWEsICd0b3AnKSxcbiAgICAgIGJvdHRvbTogZ2V0U2l6ZUZvckFyZWEoeVNjYWxlLCBjaGFydEFyZWEsICdib3R0b20nKVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGNoYXJ0QXJlYTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERhdGFzZXRDbGlwQXJlYShjaGFydDogQ2hhcnQsIG1ldGE6IENoYXJ0TWV0YSk6IFRSQkwgfCBmYWxzZSB7XG4gIGNvbnN0IGNsaXAgPSBtZXRhLl9jbGlwO1xuICBpZiAoY2xpcC5kaXNhYmxlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBhcmVhID0gZ2V0RGF0YXNldEFyZWEobWV0YSwgY2hhcnQuY2hhcnRBcmVhKTtcblxuICByZXR1cm4ge1xuICAgIGxlZnQ6IGNsaXAubGVmdCA9PT0gZmFsc2UgPyAwIDogYXJlYS5sZWZ0IC0gKGNsaXAubGVmdCA9PT0gdHJ1ZSA/IDAgOiBjbGlwLmxlZnQpLFxuICAgIHJpZ2h0OiBjbGlwLnJpZ2h0ID09PSBmYWxzZSA/IGNoYXJ0LndpZHRoIDogYXJlYS5yaWdodCArIChjbGlwLnJpZ2h0ID09PSB0cnVlID8gMCA6IGNsaXAucmlnaHQpLFxuICAgIHRvcDogY2xpcC50b3AgPT09IGZhbHNlID8gMCA6IGFyZWEudG9wIC0gKGNsaXAudG9wID09PSB0cnVlID8gMCA6IGNsaXAudG9wKSxcbiAgICBib3R0b206IGNsaXAuYm90dG9tID09PSBmYWxzZSA/IGNoYXJ0LmhlaWdodCA6IGFyZWEuYm90dG9tICsgKGNsaXAuYm90dG9tID09PSB0cnVlID8gMCA6IGNsaXAuYm90dG9tKVxuICB9O1xufVxuIl0sIm5hbWVzIjpbIm5vb3AiLCJ1aWQiLCJpZCIsImlzTnVsbE9yVW5kZWYiLCJ2YWx1ZSIsInVuZGVmaW5lZCIsImlzQXJyYXkiLCJBcnJheSIsInR5cGUiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJzbGljZSIsImlzT2JqZWN0IiwiaXNOdW1iZXJGaW5pdGUiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsImZpbml0ZU9yRGVmYXVsdCIsImRlZmF1bHRWYWx1ZSIsInZhbHVlT3JEZWZhdWx0IiwidG9QZXJjZW50YWdlIiwiZGltZW5zaW9uIiwiZW5kc1dpdGgiLCJwYXJzZUZsb2F0IiwidG9EaW1lbnNpb24iLCJjYWxsYmFjayIsImZuIiwiYXJncyIsInRoaXNBcmciLCJhcHBseSIsImVhY2giLCJsb29wYWJsZSIsInJldmVyc2UiLCJpIiwibGVuIiwia2V5cyIsImxlbmd0aCIsIl9lbGVtZW50c0VxdWFsIiwiYTAiLCJhMSIsImlsZW4iLCJ2MCIsInYxIiwiZGF0YXNldEluZGV4IiwiaW5kZXgiLCJjbG9uZSIsInNvdXJjZSIsIm1hcCIsInRhcmdldCIsImNyZWF0ZSIsImtsZW4iLCJrIiwiaXNWYWxpZEtleSIsImtleSIsImluZGV4T2YiLCJfbWVyZ2VyIiwib3B0aW9ucyIsInR2YWwiLCJzdmFsIiwibWVyZ2UiLCJzb3VyY2VzIiwibWVyZ2VyIiwiY3VycmVudCIsIm1lcmdlSWYiLCJfbWVyZ2VySWYiLCJoYXNPd25Qcm9wZXJ0eSIsIl9kZXByZWNhdGVkIiwic2NvcGUiLCJwcmV2aW91cyIsImNvbnNvbGUiLCJ3YXJuIiwia2V5UmVzb2x2ZXJzIiwidiIsIngiLCJvIiwieSIsIl9zcGxpdEtleSIsInBhcnRzIiwic3BsaXQiLCJ0bXAiLCJwYXJ0IiwicHVzaCIsIl9nZXRLZXlSZXNvbHZlciIsIm9iaiIsInJlc29sdmVPYmplY3RLZXkiLCJyZXNvbHZlciIsIl9jYXBpdGFsaXplIiwic3RyIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJkZWZpbmVkIiwiaXNGdW5jdGlvbiIsInNldHNFcXVhbCIsImEiLCJiIiwic2l6ZSIsIml0ZW0iLCJoYXMiLCJfaXNDbGlja0V2ZW50IiwiZSIsIlBJIiwiTWF0aCIsIlRBVSIsIlBJVEFVIiwiSU5GSU5JVFkiLCJQT1NJVElWRV9JTkZJTklUWSIsIlJBRF9QRVJfREVHIiwiSEFMRl9QSSIsIlFVQVJURVJfUEkiLCJUV09fVEhJUkRTX1BJIiwibG9nMTAiLCJzaWduIiwiYWxtb3N0RXF1YWxzIiwiZXBzaWxvbiIsImFicyIsIm5pY2VOdW0iLCJyYW5nZSIsInJvdW5kZWRSYW5nZSIsInJvdW5kIiwibmljZVJhbmdlIiwicG93IiwiZmxvb3IiLCJmcmFjdGlvbiIsIm5pY2VGcmFjdGlvbiIsIl9mYWN0b3JpemUiLCJyZXN1bHQiLCJzcXJ0Iiwic29ydCIsInBvcCIsImlzTm9uUHJpbWl0aXZlIiwibiIsIlN5bWJvbCIsInRvUHJpbWl0aXZlIiwiaXNOdW1iZXIiLCJpc05hTiIsImFsbW9zdFdob2xlIiwicm91bmRlZCIsIl9zZXRNaW5BbmRNYXhCeUtleSIsImFycmF5IiwicHJvcGVydHkiLCJtaW4iLCJtYXgiLCJ0b1JhZGlhbnMiLCJkZWdyZWVzIiwidG9EZWdyZWVzIiwicmFkaWFucyIsIl9kZWNpbWFsUGxhY2VzIiwiaXNGaW5pdGVOdW1iZXIiLCJwIiwiZ2V0QW5nbGVGcm9tUG9pbnQiLCJjZW50cmVQb2ludCIsImFuZ2xlUG9pbnQiLCJkaXN0YW5jZUZyb21YQ2VudGVyIiwiZGlzdGFuY2VGcm9tWUNlbnRlciIsInJhZGlhbERpc3RhbmNlRnJvbUNlbnRlciIsImFuZ2xlIiwiYXRhbjIiLCJkaXN0YW5jZSIsImRpc3RhbmNlQmV0d2VlblBvaW50cyIsInB0MSIsInB0MiIsIl9hbmdsZURpZmYiLCJfbm9ybWFsaXplQW5nbGUiLCJfYW5nbGVCZXR3ZWVuIiwic3RhcnQiLCJlbmQiLCJzYW1lQW5nbGVJc0Z1bGxDaXJjbGUiLCJzIiwiYW5nbGVUb1N0YXJ0IiwiYW5nbGVUb0VuZCIsInN0YXJ0VG9BbmdsZSIsImVuZFRvQW5nbGUiLCJfbGltaXRWYWx1ZSIsIl9pbnQxNlJhbmdlIiwiX2lzQmV0d2VlbiIsIl9sb29rdXAiLCJ0YWJsZSIsImNtcCIsImhpIiwibG8iLCJtaWQiLCJfbG9va3VwQnlLZXkiLCJsYXN0IiwidGkiLCJfcmxvb2t1cEJ5S2V5IiwiX2ZpbHRlckJldHdlZW4iLCJ2YWx1ZXMiLCJhcnJheUV2ZW50cyIsImxpc3RlbkFycmF5RXZlbnRzIiwibGlzdGVuZXIiLCJfY2hhcnRqcyIsImxpc3RlbmVycyIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImZvckVhY2giLCJtZXRob2QiLCJiYXNlIiwicmVzIiwib2JqZWN0IiwidW5saXN0ZW5BcnJheUV2ZW50cyIsInN0dWIiLCJzcGxpY2UiLCJfYXJyYXlVbmlxdWUiLCJpdGVtcyIsInNldCIsIlNldCIsImZyb20iLCJmb250U3RyaW5nIiwicGl4ZWxTaXplIiwiZm9udFN0eWxlIiwiZm9udEZhbWlseSIsInJlcXVlc3RBbmltRnJhbWUiLCJ3aW5kb3ciLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ0aHJvdHRsZWQiLCJhcmdzVG9Vc2UiLCJ0aWNraW5nIiwiZGVib3VuY2UiLCJkZWxheSIsInRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiX3RvTGVmdFJpZ2h0Q2VudGVyIiwiYWxpZ24iLCJfYWxpZ25TdGFydEVuZCIsIl90ZXh0WCIsImxlZnQiLCJyaWdodCIsInJ0bCIsImNoZWNrIiwiX2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMiLCJtZXRhIiwicG9pbnRzIiwiYW5pbWF0aW9uc0Rpc2FibGVkIiwicG9pbnRDb3VudCIsImNvdW50IiwiX3NvcnRlZCIsImlTY2FsZSIsInZTY2FsZSIsIl9wYXJzZWQiLCJzcGFuR2FwcyIsImRhdGFzZXQiLCJheGlzIiwibWluRGVmaW5lZCIsIm1heERlZmluZWQiLCJnZXRVc2VyQm91bmRzIiwiZ2V0UGl4ZWxGb3JWYWx1ZSIsImRpc3RhbmNlVG9EZWZpbmVkTG8iLCJmaW5kSW5kZXgiLCJwb2ludCIsImRpc3RhbmNlVG9EZWZpbmVkSGkiLCJfc2NhbGVSYW5nZXNDaGFuZ2VkIiwieFNjYWxlIiwieVNjYWxlIiwiX3NjYWxlUmFuZ2VzIiwibmV3UmFuZ2VzIiwieG1pbiIsInhtYXgiLCJ5bWluIiwieW1heCIsImNoYW5nZWQiLCJhc3NpZ24iLCJhdEVkZ2UiLCJ0IiwiZWxhc3RpY0luIiwic2luIiwiZWxhc3RpY091dCIsImVmZmVjdHMiLCJsaW5lYXIiLCJlYXNlSW5RdWFkIiwiZWFzZU91dFF1YWQiLCJlYXNlSW5PdXRRdWFkIiwiZWFzZUluQ3ViaWMiLCJlYXNlT3V0Q3ViaWMiLCJlYXNlSW5PdXRDdWJpYyIsImVhc2VJblF1YXJ0IiwiZWFzZU91dFF1YXJ0IiwiZWFzZUluT3V0UXVhcnQiLCJlYXNlSW5RdWludCIsImVhc2VPdXRRdWludCIsImVhc2VJbk91dFF1aW50IiwiZWFzZUluU2luZSIsImNvcyIsImVhc2VPdXRTaW5lIiwiZWFzZUluT3V0U2luZSIsImVhc2VJbkV4cG8iLCJlYXNlT3V0RXhwbyIsImVhc2VJbk91dEV4cG8iLCJlYXNlSW5DaXJjIiwiZWFzZU91dENpcmMiLCJlYXNlSW5PdXRDaXJjIiwiZWFzZUluRWxhc3RpYyIsImVhc2VPdXRFbGFzdGljIiwiZWFzZUluT3V0RWxhc3RpYyIsImVhc2VJbkJhY2siLCJlYXNlT3V0QmFjayIsImVhc2VJbk91dEJhY2siLCJlYXNlSW5Cb3VuY2UiLCJlYXNlT3V0Qm91bmNlIiwibSIsImQiLCJlYXNlSW5PdXRCb3VuY2UiLCJpc1BhdHRlcm5PckdyYWRpZW50IiwiY29sb3IiLCJDb2xvciIsImdldEhvdmVyQ29sb3IiLCJzYXR1cmF0ZSIsImRhcmtlbiIsImhleFN0cmluZyIsIm51bWJlcnMiLCJjb2xvcnMiLCJhcHBseUFuaW1hdGlvbnNEZWZhdWx0cyIsImRlZmF1bHRzIiwiZHVyYXRpb24iLCJlYXNpbmciLCJsb29wIiwidG8iLCJkZXNjcmliZSIsIl9mYWxsYmFjayIsIl9pbmRleGFibGUiLCJfc2NyaXB0YWJsZSIsIm5hbWUiLCJwcm9wZXJ0aWVzIiwiYWN0aXZlIiwiYW5pbWF0aW9uIiwicmVzaXplIiwic2hvdyIsImFuaW1hdGlvbnMiLCJ2aXNpYmxlIiwiaGlkZSIsImFwcGx5TGF5b3V0c0RlZmF1bHRzIiwiYXV0b1BhZGRpbmciLCJwYWRkaW5nIiwidG9wIiwiYm90dG9tIiwiaW50bENhY2hlIiwiTWFwIiwiZ2V0TnVtYmVyRm9ybWF0IiwibG9jYWxlIiwiY2FjaGVLZXkiLCJKU09OIiwic3RyaW5naWZ5IiwiZm9ybWF0dGVyIiwiZ2V0IiwiSW50bCIsIk51bWJlckZvcm1hdCIsImZvcm1hdE51bWJlciIsIm51bSIsImZvcm1hdCIsImZvcm1hdHRlcnMiLCJudW1lcmljIiwidGlja1ZhbHVlIiwidGlja3MiLCJjaGFydCIsIm5vdGF0aW9uIiwiZGVsdGEiLCJtYXhUaWNrIiwiY2FsY3VsYXRlRGVsdGEiLCJsb2dEZWx0YSIsIm51bURlY2ltYWwiLCJtaW5pbXVtRnJhY3Rpb25EaWdpdHMiLCJtYXhpbXVtRnJhY3Rpb25EaWdpdHMiLCJsb2dhcml0aG1pYyIsInJlbWFpbiIsInNpZ25pZmljYW5kIiwiaW5jbHVkZXMiLCJhcHBseVNjYWxlRGVmYXVsdHMiLCJkaXNwbGF5Iiwib2Zmc2V0IiwiYmVnaW5BdFplcm8iLCJib3VuZHMiLCJjbGlwIiwiZ3JhY2UiLCJncmlkIiwibGluZVdpZHRoIiwiZHJhd09uQ2hhcnRBcmVhIiwiZHJhd1RpY2tzIiwidGlja0xlbmd0aCIsInRpY2tXaWR0aCIsIl9jdHgiLCJ0aWNrQ29sb3IiLCJib3JkZXIiLCJkYXNoIiwiZGFzaE9mZnNldCIsIndpZHRoIiwidGl0bGUiLCJ0ZXh0IiwibWluUm90YXRpb24iLCJtYXhSb3RhdGlvbiIsIm1pcnJvciIsInRleHRTdHJva2VXaWR0aCIsInRleHRTdHJva2VDb2xvciIsImF1dG9Ta2lwIiwiYXV0b1NraXBQYWRkaW5nIiwibGFiZWxPZmZzZXQiLCJUaWNrcyIsIm1pbm9yIiwibWFqb3IiLCJjcm9zc0FsaWduIiwic2hvd0xhYmVsQmFja2Ryb3AiLCJiYWNrZHJvcENvbG9yIiwiYmFja2Ryb3BQYWRkaW5nIiwicm91dGUiLCJzdGFydHNXaXRoIiwib3ZlcnJpZGVzIiwiZGVzY3JpcHRvcnMiLCJnZXRTY29wZSIsIm5vZGUiLCJyb290IiwiRGVmYXVsdHMiLCJjb25zdHJ1Y3RvciIsIl9kZXNjcmlwdG9ycyIsIl9hcHBsaWVycyIsImJhY2tncm91bmRDb2xvciIsImJvcmRlckNvbG9yIiwiZGF0YXNldHMiLCJkZXZpY2VQaXhlbFJhdGlvIiwiY29udGV4dCIsInBsYXRmb3JtIiwiZ2V0RGV2aWNlUGl4ZWxSYXRpbyIsImVsZW1lbnRzIiwiZXZlbnRzIiwiZm9udCIsImZhbWlseSIsInN0eWxlIiwibGluZUhlaWdodCIsIndlaWdodCIsImhvdmVyIiwiaG92ZXJCYWNrZ3JvdW5kQ29sb3IiLCJjdHgiLCJob3ZlckJvcmRlckNvbG9yIiwiaG92ZXJDb2xvciIsImluZGV4QXhpcyIsImludGVyYWN0aW9uIiwibW9kZSIsImludGVyc2VjdCIsImluY2x1ZGVJbnZpc2libGUiLCJtYWludGFpbkFzcGVjdFJhdGlvIiwib25Ib3ZlciIsIm9uQ2xpY2siLCJwYXJzaW5nIiwicGx1Z2lucyIsInJlc3BvbnNpdmUiLCJzY2FsZSIsInNjYWxlcyIsInNob3dMaW5lIiwiZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3AiLCJvdmVycmlkZSIsInRhcmdldFNjb3BlIiwidGFyZ2V0TmFtZSIsInNjb3BlT2JqZWN0IiwidGFyZ2V0U2NvcGVPYmplY3QiLCJwcml2YXRlTmFtZSIsImRlZmluZVByb3BlcnRpZXMiLCJ3cml0YWJsZSIsImxvY2FsIiwiYXBwbGllcnMiLCJ0b0ZvbnRTdHJpbmciLCJfbWVhc3VyZVRleHQiLCJkYXRhIiwiZ2MiLCJsb25nZXN0Iiwic3RyaW5nIiwidGV4dFdpZHRoIiwibWVhc3VyZVRleHQiLCJfbG9uZ2VzdFRleHQiLCJhcnJheU9mVGhpbmdzIiwiY2FjaGUiLCJnYXJiYWdlQ29sbGVjdCIsInNhdmUiLCJqIiwiamxlbiIsInRoaW5nIiwibmVzdGVkVGhpbmciLCJyZXN0b3JlIiwiZ2NMZW4iLCJfYWxpZ25QaXhlbCIsInBpeGVsIiwiY3VycmVudERldmljZVBpeGVsUmF0aW8iLCJoYWxmV2lkdGgiLCJjbGVhckNhbnZhcyIsImNhbnZhcyIsImdldENvbnRleHQiLCJyZXNldFRyYW5zZm9ybSIsImNsZWFyUmVjdCIsImhlaWdodCIsImRyYXdQb2ludCIsImRyYXdQb2ludExlZ2VuZCIsInciLCJ4T2Zmc2V0IiwieU9mZnNldCIsImNvcm5lclJhZGl1cyIsInhPZmZzZXRXIiwieU9mZnNldFciLCJwb2ludFN0eWxlIiwicm90YXRpb24iLCJyYWRpdXMiLCJyYWQiLCJ0cmFuc2xhdGUiLCJyb3RhdGUiLCJkcmF3SW1hZ2UiLCJiZWdpblBhdGgiLCJlbGxpcHNlIiwiYXJjIiwiY2xvc2VQYXRoIiwibW92ZVRvIiwibGluZVRvIiwiU1FSVDFfMiIsInJlY3QiLCJmaWxsIiwiYm9yZGVyV2lkdGgiLCJzdHJva2UiLCJfaXNQb2ludEluQXJlYSIsImFyZWEiLCJtYXJnaW4iLCJjbGlwQXJlYSIsInVuY2xpcEFyZWEiLCJfc3RlcHBlZExpbmVUbyIsImZsaXAiLCJtaWRwb2ludCIsIl9iZXppZXJDdXJ2ZVRvIiwiYmV6aWVyQ3VydmVUbyIsImNwMXgiLCJjcDJ4IiwiY3AxeSIsImNwMnkiLCJzZXRSZW5kZXJPcHRzIiwib3B0cyIsInRyYW5zbGF0aW9uIiwiZmlsbFN0eWxlIiwidGV4dEFsaWduIiwidGV4dEJhc2VsaW5lIiwiZGVjb3JhdGVUZXh0IiwibGluZSIsInN0cmlrZXRocm91Z2giLCJ1bmRlcmxpbmUiLCJtZXRyaWNzIiwiYWN0dWFsQm91bmRpbmdCb3hMZWZ0IiwiYWN0dWFsQm91bmRpbmdCb3hSaWdodCIsImFjdHVhbEJvdW5kaW5nQm94QXNjZW50IiwiYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50IiwieURlY29yYXRpb24iLCJzdHJva2VTdHlsZSIsImRlY29yYXRpb25XaWR0aCIsImRyYXdCYWNrZHJvcCIsIm9sZENvbG9yIiwiZmlsbFJlY3QiLCJyZW5kZXJUZXh0IiwibGluZXMiLCJzdHJva2VXaWR0aCIsInN0cm9rZUNvbG9yIiwiYmFja2Ryb3AiLCJzdHJva2VUZXh0IiwibWF4V2lkdGgiLCJmaWxsVGV4dCIsImFkZFJvdW5kZWRSZWN0UGF0aCIsImgiLCJ0b3BMZWZ0IiwiYm90dG9tTGVmdCIsImJvdHRvbVJpZ2h0IiwidG9wUmlnaHQiLCJMSU5FX0hFSUdIVCIsIkZPTlRfU1RZTEUiLCJ0b0xpbmVIZWlnaHQiLCJtYXRjaGVzIiwibWF0Y2giLCJudW1iZXJPclplcm8iLCJfcmVhZFZhbHVlVG9Qcm9wcyIsInByb3BzIiwicmV0Iiwib2JqUHJvcHMiLCJyZWFkIiwicHJvcCIsInRvVFJCTCIsInRvVFJCTENvcm5lcnMiLCJ0b1BhZGRpbmciLCJ0b0ZvbnQiLCJmYWxsYmFjayIsInBhcnNlSW50IiwicmVzb2x2ZSIsImlucHV0cyIsImluZm8iLCJjYWNoZWFibGUiLCJfYWRkR3JhY2UiLCJtaW5tYXgiLCJjaGFuZ2UiLCJrZWVwWmVybyIsImFkZCIsImNyZWF0ZUNvbnRleHQiLCJwYXJlbnRDb250ZXh0IiwiX2NyZWF0ZVJlc29sdmVyIiwic2NvcGVzIiwicHJlZml4ZXMiLCJyb290U2NvcGVzIiwiZ2V0VGFyZ2V0IiwiZmluYWxSb290U2NvcGVzIiwiX3Jlc29sdmUiLCJ0b1N0cmluZ1RhZyIsIl9jYWNoZWFibGUiLCJfc2NvcGVzIiwiX3Jvb3RTY29wZXMiLCJfZ2V0VGFyZ2V0IiwiUHJveHkiLCJkZWxldGVQcm9wZXJ0eSIsIl9rZXlzIiwiX2NhY2hlZCIsIl9yZXNvbHZlV2l0aFByZWZpeGVzIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiUmVmbGVjdCIsImdldFByb3RvdHlwZU9mIiwiZ2V0S2V5c0Zyb21BbGxTY29wZXMiLCJvd25LZXlzIiwic3RvcmFnZSIsIl9zdG9yYWdlIiwiX2F0dGFjaENvbnRleHQiLCJwcm94eSIsInN1YlByb3h5IiwiZGVzY3JpcHRvckRlZmF1bHRzIiwiX3Byb3h5IiwiX2NvbnRleHQiLCJfc3ViUHJveHkiLCJfc3RhY2siLCJzZXRDb250ZXh0IiwicmVjZWl2ZXIiLCJfcmVzb2x2ZVdpdGhDb250ZXh0IiwiYWxsS2V5cyIsInNjcmlwdGFibGUiLCJpbmRleGFibGUiLCJfYWxsS2V5cyIsImlzU2NyaXB0YWJsZSIsImlzSW5kZXhhYmxlIiwicmVhZEtleSIsInByZWZpeCIsIm5lZWRzU3ViUmVzb2x2ZXIiLCJfcmVzb2x2ZVNjcmlwdGFibGUiLCJfcmVzb2x2ZUFycmF5IiwiZ2V0VmFsdWUiLCJFcnJvciIsImpvaW4iLCJkZWxldGUiLCJjcmVhdGVTdWJSZXNvbHZlciIsImFyciIsImZpbHRlciIsInJlc29sdmVGYWxsYmFjayIsInBhcmVudCIsImFkZFNjb3BlcyIsInBhcmVudFNjb3BlcyIsInBhcmVudEZhbGxiYWNrIiwiYWxsU2NvcGVzIiwiYWRkU2NvcGVzRnJvbUtleSIsInN1YkdldFRhcmdldCIsInJlc29sdmVLZXlzRnJvbUFsbFNjb3BlcyIsIl9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZSIsIl9wYXJzaW5nIiwicGFyc2VkIiwiciIsInBhcnNlIiwiRVBTSUxPTiIsImdldFBvaW50Iiwic2tpcCIsImdldFZhbHVlQXhpcyIsInNwbGluZUN1cnZlIiwiZmlyc3RQb2ludCIsIm1pZGRsZVBvaW50IiwiYWZ0ZXJQb2ludCIsIm5leHQiLCJkMDEiLCJkMTIiLCJzMDEiLCJzMTIiLCJmYSIsImZiIiwibW9ub3RvbmVBZGp1c3QiLCJkZWx0YUsiLCJtSyIsInBvaW50c0xlbiIsImFscGhhSyIsImJldGFLIiwidGF1SyIsInNxdWFyZWRNYWduaXR1ZGUiLCJwb2ludEN1cnJlbnQiLCJwb2ludEFmdGVyIiwibW9ub3RvbmVDb21wdXRlIiwidmFsdWVBeGlzIiwicG9pbnRCZWZvcmUiLCJpUGl4ZWwiLCJ2UGl4ZWwiLCJzcGxpbmVDdXJ2ZU1vbm90b25lIiwic2xvcGVEZWx0YSIsImNhcENvbnRyb2xQb2ludCIsInB0IiwiY2FwQmV6aWVyUG9pbnRzIiwiaW5BcmVhIiwiaW5BcmVhUHJldiIsImluQXJlYU5leHQiLCJfdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cyIsImNvbnRyb2xQb2ludHMiLCJjdWJpY0ludGVycG9sYXRpb25Nb2RlIiwicHJldiIsInRlbnNpb24iLCJfaXNEb21TdXBwb3J0ZWQiLCJkb2N1bWVudCIsIl9nZXRQYXJlbnROb2RlIiwiZG9tTm9kZSIsInBhcmVudE5vZGUiLCJob3N0IiwicGFyc2VNYXhTdHlsZSIsInN0eWxlVmFsdWUiLCJwYXJlbnRQcm9wZXJ0eSIsInZhbHVlSW5QaXhlbHMiLCJnZXRDb21wdXRlZFN0eWxlIiwiZWxlbWVudCIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsImdldFN0eWxlIiwiZWwiLCJnZXRQcm9wZXJ0eVZhbHVlIiwicG9zaXRpb25zIiwiZ2V0UG9zaXRpb25lZFN0eWxlIiwic3R5bGVzIiwic3VmZml4IiwicG9zIiwidXNlT2Zmc2V0UG9zIiwic2hhZG93Um9vdCIsImdldENhbnZhc1Bvc2l0aW9uIiwidG91Y2hlcyIsIm9mZnNldFgiLCJvZmZzZXRZIiwiYm94IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiY2xpZW50WCIsImNsaWVudFkiLCJnZXRSZWxhdGl2ZVBvc2l0aW9uIiwiZXZlbnQiLCJib3JkZXJCb3giLCJib3hTaXppbmciLCJwYWRkaW5ncyIsImJvcmRlcnMiLCJnZXRDb250YWluZXJTaXplIiwibWF4SGVpZ2h0IiwiY29udGFpbmVyIiwiY2xpZW50V2lkdGgiLCJjbGllbnRIZWlnaHQiLCJjb250YWluZXJTdHlsZSIsImNvbnRhaW5lckJvcmRlciIsImNvbnRhaW5lclBhZGRpbmciLCJyb3VuZDEiLCJnZXRNYXhpbXVtU2l6ZSIsImJiV2lkdGgiLCJiYkhlaWdodCIsImFzcGVjdFJhdGlvIiwibWFyZ2lucyIsImNvbnRhaW5lclNpemUiLCJtYWludGFpbkhlaWdodCIsInJldGluYVNjYWxlIiwiZm9yY2VSYXRpbyIsImZvcmNlU3R5bGUiLCJwaXhlbFJhdGlvIiwiZGV2aWNlSGVpZ2h0IiwiZGV2aWNlV2lkdGgiLCJzZXRUcmFuc2Zvcm0iLCJzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zIiwicGFzc2l2ZVN1cHBvcnRlZCIsInBhc3NpdmUiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInJlYWRVc2VkU2l6ZSIsIl9wb2ludEluTGluZSIsInAxIiwicDIiLCJfc3RlcHBlZEludGVycG9sYXRpb24iLCJfYmV6aWVySW50ZXJwb2xhdGlvbiIsImNwMSIsImNwMiIsImMiLCJnZXRSaWdodFRvTGVmdEFkYXB0ZXIiLCJyZWN0WCIsInNldFdpZHRoIiwieFBsdXMiLCJsZWZ0Rm9yTHRyIiwiaXRlbVdpZHRoIiwiZ2V0TGVmdFRvUmlnaHRBZGFwdGVyIiwiX2l0ZW1XaWR0aCIsImdldFJ0bEFkYXB0ZXIiLCJvdmVycmlkZVRleHREaXJlY3Rpb24iLCJkaXJlY3Rpb24iLCJvcmlnaW5hbCIsImdldFByb3BlcnR5UHJpb3JpdHkiLCJzZXRQcm9wZXJ0eSIsInByZXZUZXh0RGlyZWN0aW9uIiwicmVzdG9yZVRleHREaXJlY3Rpb24iLCJwcm9wZXJ0eUZuIiwiYmV0d2VlbiIsImNvbXBhcmUiLCJub3JtYWxpemUiLCJub3JtYWxpemVTZWdtZW50IiwiZ2V0U2VnbWVudCIsInNlZ21lbnQiLCJzdGFydEJvdW5kIiwiZW5kQm91bmQiLCJfYm91bmRTZWdtZW50IiwiaW5zaWRlIiwic3ViU3RhcnQiLCJwcmV2VmFsdWUiLCJzdGFydElzQmVmb3JlIiwiZW5kSXNCZWZvcmUiLCJzaG91bGRTdGFydCIsInNob3VsZFN0b3AiLCJfYm91bmRTZWdtZW50cyIsInNlZ21lbnRzIiwic3ViIiwiZmluZFN0YXJ0QW5kRW5kIiwic29saWRTZWdtZW50cyIsImN1ciIsInN0b3AiLCJfY29tcHV0ZVNlZ21lbnRzIiwic2VnbWVudE9wdGlvbnMiLCJfbG9vcCIsInNwbGl0QnlTdHlsZXMiLCJjb21wbGV0ZUxvb3AiLCJfZnVsbExvb3AiLCJkb1NwbGl0QnlTdHlsZXMiLCJjaGFydENvbnRleHQiLCJfY2hhcnQiLCJiYXNlU3R5bGUiLCJyZWFkU3R5bGUiLCJfZGF0YXNldEluZGV4IiwicHJldlN0eWxlIiwiYWRkU3R5bGUiLCJsIiwic3QiLCJkaXIiLCJwMCIsInAwRGF0YUluZGV4IiwicDFEYXRhSW5kZXgiLCJzdHlsZUNoYW5nZWQiLCJib3JkZXJDYXBTdHlsZSIsImJvcmRlckRhc2giLCJib3JkZXJEYXNoT2Zmc2V0IiwiYm9yZGVySm9pblN0eWxlIiwicmVwbGFjZXIiLCJnZXRTaXplRm9yQXJlYSIsImNoYXJ0QXJlYSIsImZpZWxkIiwiZ2V0RGF0YXNldEFyZWEiLCJnZXREYXRhc2V0Q2xpcEFyZWEiLCJfY2xpcCIsImRpc2FibGVkIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chart.js/dist/chunks/helpers.dataset.js\n");

/***/ })

};
;